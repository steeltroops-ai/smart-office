var __create = Object.create;
var __getProtoOf = Object.getPrototypeOf;
var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __toESM = (mod, isNodeMode, target) => {
  target = mod != null ? __create(__getProtoOf(mod)) : {};
  const to = isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target;
  for (let key of __getOwnPropNames(mod))
    if (!__hasOwnProp.call(to, key))
      __defProp(to, key, {
        get: () => mod[key],
        enumerable: true
      });
  return to;
};
var __commonJS = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {
      get: all[name],
      enumerable: true,
      configurable: true,
      set: (newValue) => all[name] = () => newValue
    });
};
var __esm = (fn, res) => () => (fn && (res = fn(fn = 0)), res);

// node_modules/@babel/runtime/helpers/esm/typeof.js
function _typeof(o) {
  "@babel/helpers - typeof";
  return _typeof = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && typeof Symbol == "function" && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof(o);
}
var init_typeof = () => {};

// node_modules/fflate/esm/browser.js
function zlibSync(data, opts) {
  if (!opts)
    opts = {};
  var a = adler();
  a.p(data);
  var d = dopt(data, opts, opts.dictionary ? 6 : 2, 4);
  return zlh(d, opts), wbytes(d, d.length - 4, a.d()), d;
}
function unzlibSync(data, opts) {
  return inflt(data.subarray(zls(data, opts && opts.dictionary), -4), { i: 2 }, opts && opts.out, opts && opts.dictionary);
}
var u8, u16, i32, fleb, fdeb, clim, freb = function(eb, start) {
  var b = new u16(31);
  for (var i2 = 0;i2 < 31; ++i2) {
    b[i2] = start += 1 << eb[i2 - 1];
  }
  var r = new i32(b[30]);
  for (var i2 = 1;i2 < 30; ++i2) {
    for (var j = b[i2];j < b[i2 + 1]; ++j) {
      r[j] = j - b[i2] << 5 | i2;
    }
  }
  return { b, r };
}, _a, fl, revfl, _b, fd, revfd, rev, x, i2, hMap = function(cd, mb, r) {
  var s = cd.length;
  var i3 = 0;
  var l = new u16(mb);
  for (;i3 < s; ++i3) {
    if (cd[i3])
      ++l[cd[i3] - 1];
  }
  var le = new u16(mb);
  for (i3 = 1;i3 < mb; ++i3) {
    le[i3] = le[i3 - 1] + l[i3 - 1] << 1;
  }
  var co;
  if (r) {
    co = new u16(1 << mb);
    var rvb = 15 - mb;
    for (i3 = 0;i3 < s; ++i3) {
      if (cd[i3]) {
        var sv = i3 << 4 | cd[i3];
        var r_1 = mb - cd[i3];
        var v = le[cd[i3] - 1]++ << r_1;
        for (var m = v | (1 << r_1) - 1;v <= m; ++v) {
          co[rev[v] >> rvb] = sv;
        }
      }
    }
  } else {
    co = new u16(s);
    for (i3 = 0;i3 < s; ++i3) {
      if (cd[i3]) {
        co[i3] = rev[le[cd[i3] - 1]++] >> 15 - cd[i3];
      }
    }
  }
  return co;
}, flt, i2, i2, i2, i2, fdt, i2, flm, flrm, fdm, fdrm, max = function(a) {
  var m = a[0];
  for (var i3 = 1;i3 < a.length; ++i3) {
    if (a[i3] > m)
      m = a[i3];
  }
  return m;
}, bits = function(d, p, m) {
  var o = p / 8 | 0;
  return (d[o] | d[o + 1] << 8) >> (p & 7) & m;
}, bits16 = function(d, p) {
  var o = p / 8 | 0;
  return (d[o] | d[o + 1] << 8 | d[o + 2] << 16) >> (p & 7);
}, shft = function(p) {
  return (p + 7) / 8 | 0;
}, slc = function(v, s, e) {
  if (s == null || s < 0)
    s = 0;
  if (e == null || e > v.length)
    e = v.length;
  return new u8(v.subarray(s, e));
}, ec, err = function(ind, msg, nt) {
  var e = new Error(msg || ec[ind]);
  e.code = ind;
  if (Error.captureStackTrace)
    Error.captureStackTrace(e, err);
  if (!nt)
    throw e;
  return e;
}, inflt = function(dat, st, buf, dict) {
  var sl = dat.length, dl = dict ? dict.length : 0;
  if (!sl || st.f && !st.l)
    return buf || new u8(0);
  var noBuf = !buf;
  var resize = noBuf || st.i != 2;
  var noSt = st.i;
  if (noBuf)
    buf = new u8(sl * 3);
  var cbuf = function(l2) {
    var bl = buf.length;
    if (l2 > bl) {
      var nbuf = new u8(Math.max(bl * 2, l2));
      nbuf.set(buf);
      buf = nbuf;
    }
  };
  var final = st.f || 0, pos = st.p || 0, bt = st.b || 0, lm = st.l, dm = st.d, lbt = st.m, dbt = st.n;
  var tbts = sl * 8;
  do {
    if (!lm) {
      final = bits(dat, pos, 1);
      var type = bits(dat, pos + 1, 3);
      pos += 3;
      if (!type) {
        var s = shft(pos) + 4, l = dat[s - 4] | dat[s - 3] << 8, t = s + l;
        if (t > sl) {
          if (noSt)
            err(0);
          break;
        }
        if (resize)
          cbuf(bt + l);
        buf.set(dat.subarray(s, t), bt);
        st.b = bt += l, st.p = pos = t * 8, st.f = final;
        continue;
      } else if (type == 1)
        lm = flrm, dm = fdrm, lbt = 9, dbt = 5;
      else if (type == 2) {
        var hLit = bits(dat, pos, 31) + 257, hcLen = bits(dat, pos + 10, 15) + 4;
        var tl = hLit + bits(dat, pos + 5, 31) + 1;
        pos += 14;
        var ldt = new u8(tl);
        var clt = new u8(19);
        for (var i3 = 0;i3 < hcLen; ++i3) {
          clt[clim[i3]] = bits(dat, pos + i3 * 3, 7);
        }
        pos += hcLen * 3;
        var clb = max(clt), clbmsk = (1 << clb) - 1;
        var clm = hMap(clt, clb, 1);
        for (var i3 = 0;i3 < tl; ) {
          var r = clm[bits(dat, pos, clbmsk)];
          pos += r & 15;
          var s = r >> 4;
          if (s < 16) {
            ldt[i3++] = s;
          } else {
            var c = 0, n = 0;
            if (s == 16)
              n = 3 + bits(dat, pos, 3), pos += 2, c = ldt[i3 - 1];
            else if (s == 17)
              n = 3 + bits(dat, pos, 7), pos += 3;
            else if (s == 18)
              n = 11 + bits(dat, pos, 127), pos += 7;
            while (n--)
              ldt[i3++] = c;
          }
        }
        var lt = ldt.subarray(0, hLit), dt = ldt.subarray(hLit);
        lbt = max(lt);
        dbt = max(dt);
        lm = hMap(lt, lbt, 1);
        dm = hMap(dt, dbt, 1);
      } else
        err(1);
      if (pos > tbts) {
        if (noSt)
          err(0);
        break;
      }
    }
    if (resize)
      cbuf(bt + 131072);
    var lms = (1 << lbt) - 1, dms = (1 << dbt) - 1;
    var lpos = pos;
    for (;; lpos = pos) {
      var c = lm[bits16(dat, pos) & lms], sym = c >> 4;
      pos += c & 15;
      if (pos > tbts) {
        if (noSt)
          err(0);
        break;
      }
      if (!c)
        err(2);
      if (sym < 256)
        buf[bt++] = sym;
      else if (sym == 256) {
        lpos = pos, lm = null;
        break;
      } else {
        var add = sym - 254;
        if (sym > 264) {
          var i3 = sym - 257, b = fleb[i3];
          add = bits(dat, pos, (1 << b) - 1) + fl[i3];
          pos += b;
        }
        var d = dm[bits16(dat, pos) & dms], dsym = d >> 4;
        if (!d)
          err(3);
        pos += d & 15;
        var dt = fd[dsym];
        if (dsym > 3) {
          var b = fdeb[dsym];
          dt += bits16(dat, pos) & (1 << b) - 1, pos += b;
        }
        if (pos > tbts) {
          if (noSt)
            err(0);
          break;
        }
        if (resize)
          cbuf(bt + 131072);
        var end = bt + add;
        if (bt < dt) {
          var shift2 = dl - dt, dend = Math.min(dt, end);
          if (shift2 + bt < 0)
            err(3);
          for (;bt < dend; ++bt)
            buf[bt] = dict[shift2 + bt];
        }
        for (;bt < end; ++bt)
          buf[bt] = buf[bt - dt];
      }
    }
    st.l = lm, st.p = lpos, st.b = bt, st.f = final;
    if (lm)
      final = 1, st.m = lbt, st.d = dm, st.n = dbt;
  } while (!final);
  return bt != buf.length && noBuf ? slc(buf, 0, bt) : buf.subarray(0, bt);
}, wbits = function(d, p, v) {
  v <<= p & 7;
  var o = p / 8 | 0;
  d[o] |= v;
  d[o + 1] |= v >> 8;
}, wbits16 = function(d, p, v) {
  v <<= p & 7;
  var o = p / 8 | 0;
  d[o] |= v;
  d[o + 1] |= v >> 8;
  d[o + 2] |= v >> 16;
}, hTree = function(d, mb) {
  var t = [];
  for (var i3 = 0;i3 < d.length; ++i3) {
    if (d[i3])
      t.push({ s: i3, f: d[i3] });
  }
  var s = t.length;
  var t2 = t.slice();
  if (!s)
    return { t: et, l: 0 };
  if (s == 1) {
    var v = new u8(t[0].s + 1);
    v[t[0].s] = 1;
    return { t: v, l: 1 };
  }
  t.sort(function(a, b) {
    return a.f - b.f;
  });
  t.push({ s: -1, f: 25001 });
  var l = t[0], r = t[1], i0 = 0, i1 = 1, i22 = 2;
  t[0] = { s: -1, f: l.f + r.f, l, r };
  while (i1 != s - 1) {
    l = t[t[i0].f < t[i22].f ? i0++ : i22++];
    r = t[i0 != i1 && t[i0].f < t[i22].f ? i0++ : i22++];
    t[i1++] = { s: -1, f: l.f + r.f, l, r };
  }
  var maxSym = t2[0].s;
  for (var i3 = 1;i3 < s; ++i3) {
    if (t2[i3].s > maxSym)
      maxSym = t2[i3].s;
  }
  var tr = new u16(maxSym + 1);
  var mbt = ln(t[i1 - 1], tr, 0);
  if (mbt > mb) {
    var i3 = 0, dt = 0;
    var lft = mbt - mb, cst = 1 << lft;
    t2.sort(function(a, b) {
      return tr[b.s] - tr[a.s] || a.f - b.f;
    });
    for (;i3 < s; ++i3) {
      var i2_1 = t2[i3].s;
      if (tr[i2_1] > mb) {
        dt += cst - (1 << mbt - tr[i2_1]);
        tr[i2_1] = mb;
      } else
        break;
    }
    dt >>= lft;
    while (dt > 0) {
      var i2_2 = t2[i3].s;
      if (tr[i2_2] < mb)
        dt -= 1 << mb - tr[i2_2]++ - 1;
      else
        ++i3;
    }
    for (;i3 >= 0 && dt; --i3) {
      var i2_3 = t2[i3].s;
      if (tr[i2_3] == mb) {
        --tr[i2_3];
        ++dt;
      }
    }
    mbt = mb;
  }
  return { t: new u8(tr), l: mbt };
}, ln = function(n, l, d) {
  return n.s == -1 ? Math.max(ln(n.l, l, d + 1), ln(n.r, l, d + 1)) : l[n.s] = d;
}, lc = function(c) {
  var s = c.length;
  while (s && !c[--s])
    ;
  var cl = new u16(++s);
  var cli = 0, cln = c[0], cls = 1;
  var w = function(v) {
    cl[cli++] = v;
  };
  for (var i3 = 1;i3 <= s; ++i3) {
    if (c[i3] == cln && i3 != s)
      ++cls;
    else {
      if (!cln && cls > 2) {
        for (;cls > 138; cls -= 138)
          w(32754);
        if (cls > 2) {
          w(cls > 10 ? cls - 11 << 5 | 28690 : cls - 3 << 5 | 12305);
          cls = 0;
        }
      } else if (cls > 3) {
        w(cln), --cls;
        for (;cls > 6; cls -= 6)
          w(8304);
        if (cls > 2)
          w(cls - 3 << 5 | 8208), cls = 0;
      }
      while (cls--)
        w(cln);
      cls = 1;
      cln = c[i3];
    }
  }
  return { c: cl.subarray(0, cli), n: s };
}, clen = function(cf, cl) {
  var l = 0;
  for (var i3 = 0;i3 < cl.length; ++i3)
    l += cf[i3] * cl[i3];
  return l;
}, wfblk = function(out, pos, dat) {
  var s = dat.length;
  var o = shft(pos + 2);
  out[o] = s & 255;
  out[o + 1] = s >> 8;
  out[o + 2] = out[o] ^ 255;
  out[o + 3] = out[o + 1] ^ 255;
  for (var i3 = 0;i3 < s; ++i3)
    out[o + i3 + 4] = dat[i3];
  return (o + 4 + s) * 8;
}, wblk = function(dat, out, final, syms, lf, df, eb, li, bs, bl, p) {
  wbits(out, p++, final);
  ++lf[256];
  var _a2 = hTree(lf, 15), dlt = _a2.t, mlb = _a2.l;
  var _b2 = hTree(df, 15), ddt = _b2.t, mdb = _b2.l;
  var _c = lc(dlt), lclt = _c.c, nlc = _c.n;
  var _d = lc(ddt), lcdt = _d.c, ndc = _d.n;
  var lcfreq = new u16(19);
  for (var i3 = 0;i3 < lclt.length; ++i3)
    ++lcfreq[lclt[i3] & 31];
  for (var i3 = 0;i3 < lcdt.length; ++i3)
    ++lcfreq[lcdt[i3] & 31];
  var _e = hTree(lcfreq, 7), lct = _e.t, mlcb = _e.l;
  var nlcc = 19;
  for (;nlcc > 4 && !lct[clim[nlcc - 1]]; --nlcc)
    ;
  var flen = bl + 5 << 3;
  var ftlen = clen(lf, flt) + clen(df, fdt) + eb;
  var dtlen = clen(lf, dlt) + clen(df, ddt) + eb + 14 + 3 * nlcc + clen(lcfreq, lct) + 2 * lcfreq[16] + 3 * lcfreq[17] + 7 * lcfreq[18];
  if (bs >= 0 && flen <= ftlen && flen <= dtlen)
    return wfblk(out, p, dat.subarray(bs, bs + bl));
  var lm, ll, dm, dl;
  wbits(out, p, 1 + (dtlen < ftlen)), p += 2;
  if (dtlen < ftlen) {
    lm = hMap(dlt, mlb, 0), ll = dlt, dm = hMap(ddt, mdb, 0), dl = ddt;
    var llm = hMap(lct, mlcb, 0);
    wbits(out, p, nlc - 257);
    wbits(out, p + 5, ndc - 1);
    wbits(out, p + 10, nlcc - 4);
    p += 14;
    for (var i3 = 0;i3 < nlcc; ++i3)
      wbits(out, p + 3 * i3, lct[clim[i3]]);
    p += 3 * nlcc;
    var lcts = [lclt, lcdt];
    for (var it = 0;it < 2; ++it) {
      var clct = lcts[it];
      for (var i3 = 0;i3 < clct.length; ++i3) {
        var len = clct[i3] & 31;
        wbits(out, p, llm[len]), p += lct[len];
        if (len > 15)
          wbits(out, p, clct[i3] >> 5 & 127), p += clct[i3] >> 12;
      }
    }
  } else {
    lm = flm, ll = flt, dm = fdm, dl = fdt;
  }
  for (var i3 = 0;i3 < li; ++i3) {
    var sym = syms[i3];
    if (sym > 255) {
      var len = sym >> 18 & 31;
      wbits16(out, p, lm[len + 257]), p += ll[len + 257];
      if (len > 7)
        wbits(out, p, sym >> 23 & 31), p += fleb[len];
      var dst = sym & 31;
      wbits16(out, p, dm[dst]), p += dl[dst];
      if (dst > 3)
        wbits16(out, p, sym >> 5 & 8191), p += fdeb[dst];
    } else {
      wbits16(out, p, lm[sym]), p += ll[sym];
    }
  }
  wbits16(out, p, lm[256]);
  return p + ll[256];
}, deo, et, dflt = function(dat, lvl, plvl, pre, post, st) {
  var s = st.z || dat.length;
  var o = new u8(pre + s + 5 * (1 + Math.ceil(s / 7000)) + post);
  var w = o.subarray(pre, o.length - post);
  var lst = st.l;
  var pos = (st.r || 0) & 7;
  if (lvl) {
    if (pos)
      w[0] = st.r >> 3;
    var opt = deo[lvl - 1];
    var n = opt >> 13, c = opt & 8191;
    var msk_1 = (1 << plvl) - 1;
    var prev = st.p || new u16(32768), head = st.h || new u16(msk_1 + 1);
    var bs1_1 = Math.ceil(plvl / 3), bs2_1 = 2 * bs1_1;
    var hsh = function(i4) {
      return (dat[i4] ^ dat[i4 + 1] << bs1_1 ^ dat[i4 + 2] << bs2_1) & msk_1;
    };
    var syms = new i32(25000);
    var lf = new u16(288), df = new u16(32);
    var lc_1 = 0, eb = 0, i3 = st.i || 0, li = 0, wi = st.w || 0, bs = 0;
    for (;i3 + 2 < s; ++i3) {
      var hv = hsh(i3);
      var imod = i3 & 32767, pimod = head[hv];
      prev[imod] = pimod;
      head[hv] = imod;
      if (wi <= i3) {
        var rem = s - i3;
        if ((lc_1 > 7000 || li > 24576) && (rem > 423 || !lst)) {
          pos = wblk(dat, w, 0, syms, lf, df, eb, li, bs, i3 - bs, pos);
          li = lc_1 = eb = 0, bs = i3;
          for (var j = 0;j < 286; ++j)
            lf[j] = 0;
          for (var j = 0;j < 30; ++j)
            df[j] = 0;
        }
        var l = 2, d = 0, ch_1 = c, dif = imod - pimod & 32767;
        if (rem > 2 && hv == hsh(i3 - dif)) {
          var maxn = Math.min(n, rem) - 1;
          var maxd = Math.min(32767, i3);
          var ml = Math.min(258, rem);
          while (dif <= maxd && --ch_1 && imod != pimod) {
            if (dat[i3 + l] == dat[i3 + l - dif]) {
              var nl = 0;
              for (;nl < ml && dat[i3 + nl] == dat[i3 + nl - dif]; ++nl)
                ;
              if (nl > l) {
                l = nl, d = dif;
                if (nl > maxn)
                  break;
                var mmd = Math.min(dif, nl - 2);
                var md = 0;
                for (var j = 0;j < mmd; ++j) {
                  var ti = i3 - dif + j & 32767;
                  var pti = prev[ti];
                  var cd = ti - pti & 32767;
                  if (cd > md)
                    md = cd, pimod = ti;
                }
              }
            }
            imod = pimod, pimod = prev[imod];
            dif += imod - pimod & 32767;
          }
        }
        if (d) {
          syms[li++] = 268435456 | revfl[l] << 18 | revfd[d];
          var lin = revfl[l] & 31, din = revfd[d] & 31;
          eb += fleb[lin] + fdeb[din];
          ++lf[257 + lin];
          ++df[din];
          wi = i3 + l;
          ++lc_1;
        } else {
          syms[li++] = dat[i3];
          ++lf[dat[i3]];
        }
      }
    }
    for (i3 = Math.max(i3, wi);i3 < s; ++i3) {
      syms[li++] = dat[i3];
      ++lf[dat[i3]];
    }
    pos = wblk(dat, w, lst, syms, lf, df, eb, li, bs, i3 - bs, pos);
    if (!lst) {
      st.r = pos & 7 | w[pos / 8 | 0] << 3;
      pos -= 7;
      st.h = head, st.p = prev, st.i = i3, st.w = wi;
    }
  } else {
    for (var i3 = st.w || 0;i3 < s + lst; i3 += 65535) {
      var e = i3 + 65535;
      if (e >= s) {
        w[pos / 8 | 0] = lst;
        e = s;
      }
      pos = wfblk(w, pos + 1, dat.subarray(i3, e));
    }
    st.i = s;
  }
  return slc(o, 0, pre + shft(pos) + post);
}, adler = function() {
  var a = 1, b = 0;
  return {
    p: function(d) {
      var n = a, m = b;
      var l = d.length | 0;
      for (var i3 = 0;i3 != l; ) {
        var e = Math.min(i3 + 2655, l);
        for (;i3 < e; ++i3)
          m += n += d[i3];
        n = (n & 65535) + 15 * (n >> 16), m = (m & 65535) + 15 * (m >> 16);
      }
      a = n, b = m;
    },
    d: function() {
      a %= 65521, b %= 65521;
      return (a & 255) << 24 | (a & 65280) << 8 | (b & 255) << 8 | b >> 8;
    }
  };
}, dopt = function(dat, opt, pre, post, st) {
  if (!st) {
    st = { l: 1 };
    if (opt.dictionary) {
      var dict = opt.dictionary.subarray(-32768);
      var newDat = new u8(dict.length + dat.length);
      newDat.set(dict);
      newDat.set(dat, dict.length);
      dat = newDat;
      st.w = dict.length;
    }
  }
  return dflt(dat, opt.level == null ? 6 : opt.level, opt.mem == null ? st.l ? Math.ceil(Math.max(8, Math.min(13, Math.log(dat.length))) * 1.5) : 20 : 12 + opt.mem, pre, post, st);
}, wbytes = function(d, b, v) {
  for (;v; ++b)
    d[b] = v, v >>>= 8;
}, zlh = function(c, o) {
  var lv = o.level, fl2 = lv == 0 ? 0 : lv < 6 ? 1 : lv == 9 ? 3 : 2;
  c[0] = 120, c[1] = fl2 << 6 | (o.dictionary && 32);
  c[1] |= 31 - (c[0] << 8 | c[1]) % 31;
  if (o.dictionary) {
    var h = adler();
    h.p(o.dictionary);
    wbytes(c, 2, h.d());
  }
}, zls = function(d, dict) {
  if ((d[0] & 15) != 8 || d[0] >> 4 > 7 || (d[0] << 8 | d[1]) % 31)
    err(6, "invalid zlib data");
  if ((d[1] >> 5 & 1) == +!dict)
    err(6, "invalid zlib data: " + (d[1] & 32 ? "need" : "unexpected") + " dictionary");
  return (d[1] >> 3 & 4) + 2;
}, td, tds = 0;
var init_browser = __esm(() => {
  u8 = Uint8Array;
  u16 = Uint16Array;
  i32 = Int32Array;
  fleb = new u8([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0]);
  fdeb = new u8([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0]);
  clim = new u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
  _a = freb(fleb, 2);
  fl = _a.b;
  revfl = _a.r;
  fl[28] = 258, revfl[258] = 28;
  _b = freb(fdeb, 0);
  fd = _b.b;
  revfd = _b.r;
  rev = new u16(32768);
  for (i2 = 0;i2 < 32768; ++i2) {
    x = (i2 & 43690) >> 1 | (i2 & 21845) << 1;
    x = (x & 52428) >> 2 | (x & 13107) << 2;
    x = (x & 61680) >> 4 | (x & 3855) << 4;
    rev[i2] = ((x & 65280) >> 8 | (x & 255) << 8) >> 1;
  }
  flt = new u8(288);
  for (i2 = 0;i2 < 144; ++i2)
    flt[i2] = 8;
  for (i2 = 144;i2 < 256; ++i2)
    flt[i2] = 9;
  for (i2 = 256;i2 < 280; ++i2)
    flt[i2] = 7;
  for (i2 = 280;i2 < 288; ++i2)
    flt[i2] = 8;
  fdt = new u8(32);
  for (i2 = 0;i2 < 32; ++i2)
    fdt[i2] = 5;
  flm = /* @__PURE__ */ hMap(flt, 9, 0);
  flrm = /* @__PURE__ */ hMap(flt, 9, 1);
  fdm = /* @__PURE__ */ hMap(fdt, 5, 0);
  fdrm = /* @__PURE__ */ hMap(fdt, 5, 1);
  ec = [
    "unexpected EOF",
    "invalid block type",
    "invalid length/literal",
    "invalid distance",
    "stream finished",
    "no stream handler",
    ,
    "no callback",
    "invalid UTF-8 data",
    "extra field too long",
    "date not in range 1980-2099",
    "filename too long",
    "stream finishing",
    "invalid zip data"
  ];
  deo = /* @__PURE__ */ new i32([65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632]);
  et = /* @__PURE__ */ new u8(0);
  td = typeof TextDecoder != "undefined" && /* @__PURE__ */ new TextDecoder;
  try {
    td.decode(et, { stream: true });
    tds = 1;
  } catch (e) {}
});

// node_modules/html2canvas/dist/html2canvas.js
var require_html2canvas = __commonJS((exports, module) => {
  /*!
   * html2canvas 1.4.1 <https://html2canvas.hertzen.com>
   * Copyright (c) 2022 Niklas von Hertzen <https://hertzen.com>
   * Released under MIT License
   */
  (function(global2, factory) {
    typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, global2.html2canvas = factory());
  })(exports, function() {
    /*! *****************************************************************************
        Copyright (c) Microsoft Corporation.
    
        Permission to use, copy, modify, and/or distribute this software for any
        purpose with or without fee is hereby granted.
    
        THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
        REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
        AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
        INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
        LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
        OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
        PERFORMANCE OF THIS SOFTWARE.
        ***************************************************************************** */
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (Object.prototype.hasOwnProperty.call(b2, p))
            d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    function __extends(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
    }
    var __assign = function() {
      __assign = Object.assign || function __assign(t) {
        for (var s, i4 = 1, n = arguments.length;i4 < n; i4++) {
          s = arguments[i4];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    function __awaiter(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e2) {
            reject(e2);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e2) {
            reject(e2);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    }
    function __generator(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f2, y, t, g;
      return g = { next: verb(0), throw: verb(1), return: verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f2)
          throw new TypeError("Generator is already executing.");
        while (_)
          try {
            if (f2 = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e2) {
            op = [6, e2];
            y = 0;
          } finally {
            f2 = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : undefined, done: true };
      }
    }
    function __spreadArray(to, from2, pack2) {
      if (pack2 || arguments.length === 2)
        for (var i4 = 0, l = from2.length, ar;i4 < l; i4++) {
          if (ar || !(i4 in from2)) {
            if (!ar)
              ar = Array.prototype.slice.call(from2, 0, i4);
            ar[i4] = from2[i4];
          }
        }
      return to.concat(ar || from2);
    }
    var Bounds = function() {
      function Bounds2(left, top, width, height) {
        this.left = left;
        this.top = top;
        this.width = width;
        this.height = height;
      }
      Bounds2.prototype.add = function(x2, y, w, h) {
        return new Bounds2(this.left + x2, this.top + y, this.width + w, this.height + h);
      };
      Bounds2.fromClientRect = function(context, clientRect2) {
        return new Bounds2(clientRect2.left + context.windowBounds.left, clientRect2.top + context.windowBounds.top, clientRect2.width, clientRect2.height);
      };
      Bounds2.fromDOMRectList = function(context, domRectList) {
        var domRect = Array.from(domRectList).find(function(rect) {
          return rect.width !== 0;
        });
        return domRect ? new Bounds2(domRect.left + context.windowBounds.left, domRect.top + context.windowBounds.top, domRect.width, domRect.height) : Bounds2.EMPTY;
      };
      Bounds2.EMPTY = new Bounds2(0, 0, 0, 0);
      return Bounds2;
    }();
    var parseBounds = function(context, node) {
      return Bounds.fromClientRect(context, node.getBoundingClientRect());
    };
    var parseDocumentSize = function(document2) {
      var body = document2.body;
      var documentElement = document2.documentElement;
      if (!body || !documentElement) {
        throw new Error("Unable to get document size");
      }
      var width = Math.max(Math.max(body.scrollWidth, documentElement.scrollWidth), Math.max(body.offsetWidth, documentElement.offsetWidth), Math.max(body.clientWidth, documentElement.clientWidth));
      var height = Math.max(Math.max(body.scrollHeight, documentElement.scrollHeight), Math.max(body.offsetHeight, documentElement.offsetHeight), Math.max(body.clientHeight, documentElement.clientHeight));
      return new Bounds(0, 0, width, height);
    };
    var toCodePoints$1 = function(str) {
      var codePoints = [];
      var i4 = 0;
      var length = str.length;
      while (i4 < length) {
        var value = str.charCodeAt(i4++);
        if (value >= 55296 && value <= 56319 && i4 < length) {
          var extra = str.charCodeAt(i4++);
          if ((extra & 64512) === 56320) {
            codePoints.push(((value & 1023) << 10) + (extra & 1023) + 65536);
          } else {
            codePoints.push(value);
            i4--;
          }
        } else {
          codePoints.push(value);
        }
      }
      return codePoints;
    };
    var fromCodePoint$1 = function() {
      var codePoints = [];
      for (var _i = 0;_i < arguments.length; _i++) {
        codePoints[_i] = arguments[_i];
      }
      if (String.fromCodePoint) {
        return String.fromCodePoint.apply(String, codePoints);
      }
      var length = codePoints.length;
      if (!length) {
        return "";
      }
      var codeUnits = [];
      var index = -1;
      var result = "";
      while (++index < length) {
        var codePoint = codePoints[index];
        if (codePoint <= 65535) {
          codeUnits.push(codePoint);
        } else {
          codePoint -= 65536;
          codeUnits.push((codePoint >> 10) + 55296, codePoint % 1024 + 56320);
        }
        if (index + 1 === length || codeUnits.length > 16384) {
          result += String.fromCharCode.apply(String, codeUnits);
          codeUnits.length = 0;
        }
      }
      return result;
    };
    var chars$2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    var lookup$2 = typeof Uint8Array === "undefined" ? [] : new Uint8Array(256);
    for (var i$2 = 0;i$2 < chars$2.length; i$2++) {
      lookup$2[chars$2.charCodeAt(i$2)] = i$2;
    }
    var chars$1$1 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    var lookup$1$1 = typeof Uint8Array === "undefined" ? [] : new Uint8Array(256);
    for (var i$1$1 = 0;i$1$1 < chars$1$1.length; i$1$1++) {
      lookup$1$1[chars$1$1.charCodeAt(i$1$1)] = i$1$1;
    }
    var decode$1 = function(base642) {
      var bufferLength = base642.length * 0.75, len = base642.length, i4, p = 0, encoded1, encoded2, encoded3, encoded4;
      if (base642[base642.length - 1] === "=") {
        bufferLength--;
        if (base642[base642.length - 2] === "=") {
          bufferLength--;
        }
      }
      var buffer = typeof ArrayBuffer !== "undefined" && typeof Uint8Array !== "undefined" && typeof Uint8Array.prototype.slice !== "undefined" ? new ArrayBuffer(bufferLength) : new Array(bufferLength);
      var bytes = Array.isArray(buffer) ? buffer : new Uint8Array(buffer);
      for (i4 = 0;i4 < len; i4 += 4) {
        encoded1 = lookup$1$1[base642.charCodeAt(i4)];
        encoded2 = lookup$1$1[base642.charCodeAt(i4 + 1)];
        encoded3 = lookup$1$1[base642.charCodeAt(i4 + 2)];
        encoded4 = lookup$1$1[base642.charCodeAt(i4 + 3)];
        bytes[p++] = encoded1 << 2 | encoded2 >> 4;
        bytes[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;
        bytes[p++] = (encoded3 & 3) << 6 | encoded4 & 63;
      }
      return buffer;
    };
    var polyUint16Array$1 = function(buffer) {
      var length = buffer.length;
      var bytes = [];
      for (var i4 = 0;i4 < length; i4 += 2) {
        bytes.push(buffer[i4 + 1] << 8 | buffer[i4]);
      }
      return bytes;
    };
    var polyUint32Array$1 = function(buffer) {
      var length = buffer.length;
      var bytes = [];
      for (var i4 = 0;i4 < length; i4 += 4) {
        bytes.push(buffer[i4 + 3] << 24 | buffer[i4 + 2] << 16 | buffer[i4 + 1] << 8 | buffer[i4]);
      }
      return bytes;
    };
    var UTRIE2_SHIFT_2$1 = 5;
    var UTRIE2_SHIFT_1$1 = 6 + 5;
    var UTRIE2_INDEX_SHIFT$1 = 2;
    var UTRIE2_SHIFT_1_2$1 = UTRIE2_SHIFT_1$1 - UTRIE2_SHIFT_2$1;
    var UTRIE2_LSCP_INDEX_2_OFFSET$1 = 65536 >> UTRIE2_SHIFT_2$1;
    var UTRIE2_DATA_BLOCK_LENGTH$1 = 1 << UTRIE2_SHIFT_2$1;
    var UTRIE2_DATA_MASK$1 = UTRIE2_DATA_BLOCK_LENGTH$1 - 1;
    var UTRIE2_LSCP_INDEX_2_LENGTH$1 = 1024 >> UTRIE2_SHIFT_2$1;
    var UTRIE2_INDEX_2_BMP_LENGTH$1 = UTRIE2_LSCP_INDEX_2_OFFSET$1 + UTRIE2_LSCP_INDEX_2_LENGTH$1;
    var UTRIE2_UTF8_2B_INDEX_2_OFFSET$1 = UTRIE2_INDEX_2_BMP_LENGTH$1;
    var UTRIE2_UTF8_2B_INDEX_2_LENGTH$1 = 2048 >> 6;
    var UTRIE2_INDEX_1_OFFSET$1 = UTRIE2_UTF8_2B_INDEX_2_OFFSET$1 + UTRIE2_UTF8_2B_INDEX_2_LENGTH$1;
    var UTRIE2_OMITTED_BMP_INDEX_1_LENGTH$1 = 65536 >> UTRIE2_SHIFT_1$1;
    var UTRIE2_INDEX_2_BLOCK_LENGTH$1 = 1 << UTRIE2_SHIFT_1_2$1;
    var UTRIE2_INDEX_2_MASK$1 = UTRIE2_INDEX_2_BLOCK_LENGTH$1 - 1;
    var slice16$1 = function(view, start, end) {
      if (view.slice) {
        return view.slice(start, end);
      }
      return new Uint16Array(Array.prototype.slice.call(view, start, end));
    };
    var slice32$1 = function(view, start, end) {
      if (view.slice) {
        return view.slice(start, end);
      }
      return new Uint32Array(Array.prototype.slice.call(view, start, end));
    };
    var createTrieFromBase64$1 = function(base642, _byteLength) {
      var buffer = decode$1(base642);
      var view32 = Array.isArray(buffer) ? polyUint32Array$1(buffer) : new Uint32Array(buffer);
      var view16 = Array.isArray(buffer) ? polyUint16Array$1(buffer) : new Uint16Array(buffer);
      var headerLength = 24;
      var index = slice16$1(view16, headerLength / 2, view32[4] / 2);
      var data = view32[5] === 2 ? slice16$1(view16, (headerLength + view32[4]) / 2) : slice32$1(view32, Math.ceil((headerLength + view32[4]) / 4));
      return new Trie$1(view32[0], view32[1], view32[2], view32[3], index, data);
    };
    var Trie$1 = function() {
      function Trie2(initialValue, errorValue, highStart, highValueIndex, index, data) {
        this.initialValue = initialValue;
        this.errorValue = errorValue;
        this.highStart = highStart;
        this.highValueIndex = highValueIndex;
        this.index = index;
        this.data = data;
      }
      Trie2.prototype.get = function(codePoint) {
        var ix;
        if (codePoint >= 0) {
          if (codePoint < 55296 || codePoint > 56319 && codePoint <= 65535) {
            ix = this.index[codePoint >> UTRIE2_SHIFT_2$1];
            ix = (ix << UTRIE2_INDEX_SHIFT$1) + (codePoint & UTRIE2_DATA_MASK$1);
            return this.data[ix];
          }
          if (codePoint <= 65535) {
            ix = this.index[UTRIE2_LSCP_INDEX_2_OFFSET$1 + (codePoint - 55296 >> UTRIE2_SHIFT_2$1)];
            ix = (ix << UTRIE2_INDEX_SHIFT$1) + (codePoint & UTRIE2_DATA_MASK$1);
            return this.data[ix];
          }
          if (codePoint < this.highStart) {
            ix = UTRIE2_INDEX_1_OFFSET$1 - UTRIE2_OMITTED_BMP_INDEX_1_LENGTH$1 + (codePoint >> UTRIE2_SHIFT_1$1);
            ix = this.index[ix];
            ix += codePoint >> UTRIE2_SHIFT_2$1 & UTRIE2_INDEX_2_MASK$1;
            ix = this.index[ix];
            ix = (ix << UTRIE2_INDEX_SHIFT$1) + (codePoint & UTRIE2_DATA_MASK$1);
            return this.data[ix];
          }
          if (codePoint <= 1114111) {
            return this.data[this.highValueIndex];
          }
        }
        return this.errorValue;
      };
      return Trie2;
    }();
    var chars$3 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    var lookup$3 = typeof Uint8Array === "undefined" ? [] : new Uint8Array(256);
    for (var i$3 = 0;i$3 < chars$3.length; i$3++) {
      lookup$3[chars$3.charCodeAt(i$3)] = i$3;
    }
    var base64$1 = "KwAAAAAAAAAACA4AUD0AADAgAAACAAAAAAAIABAAGABAAEgAUABYAGAAaABgAGgAYgBqAF8AZwBgAGgAcQB5AHUAfQCFAI0AlQCdAKIAqgCyALoAYABoAGAAaABgAGgAwgDKAGAAaADGAM4A0wDbAOEA6QDxAPkAAQEJAQ8BFwF1AH0AHAEkASwBNAE6AUIBQQFJAVEBWQFhAWgBcAF4ATAAgAGGAY4BlQGXAZ8BpwGvAbUBvQHFAc0B0wHbAeMB6wHxAfkBAQIJAvEBEQIZAiECKQIxAjgCQAJGAk4CVgJeAmQCbAJ0AnwCgQKJApECmQKgAqgCsAK4ArwCxAIwAMwC0wLbAjAA4wLrAvMC+AIAAwcDDwMwABcDHQMlAy0DNQN1AD0DQQNJA0kDSQNRA1EDVwNZA1kDdQB1AGEDdQBpA20DdQN1AHsDdQCBA4kDkQN1AHUAmQOhA3UAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AKYDrgN1AHUAtgO+A8YDzgPWAxcD3gPjA+sD8wN1AHUA+wMDBAkEdQANBBUEHQQlBCoEFwMyBDgEYABABBcDSARQBFgEYARoBDAAcAQzAXgEgASIBJAEdQCXBHUAnwSnBK4EtgS6BMIEyAR1AHUAdQB1AHUAdQCVANAEYABgAGAAYABgAGAAYABgANgEYADcBOQEYADsBPQE/AQEBQwFFAUcBSQFLAU0BWQEPAVEBUsFUwVbBWAAYgVgAGoFcgV6BYIFigWRBWAAmQWfBaYFYABgAGAAYABgAKoFYACxBbAFuQW6BcEFwQXHBcEFwQXPBdMF2wXjBeoF8gX6BQIGCgYSBhoGIgYqBjIGOgZgAD4GRgZMBmAAUwZaBmAAYABgAGAAYABgAGAAYABgAGAAYABgAGIGYABpBnAGYABgAGAAYABgAGAAYABgAGAAYAB4Bn8GhQZgAGAAYAB1AHcDFQSLBmAAYABgAJMGdQA9A3UAmwajBqsGqwaVALMGuwbDBjAAywbSBtIG1QbSBtIG0gbSBtIG0gbdBuMG6wbzBvsGAwcLBxMHAwcbByMHJwcsBywHMQcsB9IGOAdAB0gHTgfSBkgHVgfSBtIG0gbSBtIG0gbSBtIG0gbSBiwHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAdgAGAALAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAdbB2MHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsB2kH0gZwB64EdQB1AHUAdQB1AHUAdQB1AHUHfQdgAIUHjQd1AHUAlQedB2AAYAClB6sHYACzB7YHvgfGB3UAzgfWBzMB3gfmB1EB7gf1B/0HlQENAQUIDQh1ABUIHQglCBcDLQg1CD0IRQhNCEEDUwh1AHUAdQBbCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIcAh3CHoIMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIgggwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAALAcsBywHLAcsBywHLAcsBywHLAcsB4oILAcsB44I0gaWCJ4Ipgh1AHUAqgiyCHUAdQB1AHUAdQB1AHUAdQB1AHUAtwh8AXUAvwh1AMUIyQjRCNkI4AjoCHUAdQB1AO4I9gj+CAYJDgkTCS0HGwkjCYIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiAAIAAAAFAAYABgAGIAXwBgAHEAdQBFAJUAogCyAKAAYABgAEIA4ABGANMA4QDxAMEBDwE1AFwBLAE6AQEBUQF4QkhCmEKoQrhCgAHIQsAB0MLAAcABwAHAAeDC6ABoAHDCwMMAAcABwAHAAdDDGMMAAcAB6MM4wwjDWMNow3jDaABoAGgAaABoAGgAaABoAGgAaABoAGgAaABoAGgAaABoAGgAaABoAEjDqABWw6bDqABpg6gAaABoAHcDvwOPA+gAaABfA/8DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DpcPAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcAB9cPKwkyCToJMAB1AHUAdQBCCUoJTQl1AFUJXAljCWcJawkwADAAMAAwAHMJdQB2CX4JdQCECYoJjgmWCXUAngkwAGAAYABxAHUApgn3A64JtAl1ALkJdQDACTAAMAAwADAAdQB1AHUAdQB1AHUAdQB1AHUAowYNBMUIMAAwADAAMADICcsJ0wnZCRUE4QkwAOkJ8An4CTAAMAB1AAAKvwh1AAgKDwoXCh8KdQAwACcKLgp1ADYKqAmICT4KRgowADAAdQB1AE4KMAB1AFYKdQBeCnUAZQowADAAMAAwADAAMAAwADAAMAAVBHUAbQowADAAdQC5CXUKMAAwAHwBxAijBogEMgF9CoQKiASMCpQKmgqIBKIKqgquCogEDQG2Cr4KxgrLCjAAMADTCtsKCgHjCusK8Qr5CgELMAAwADAAMAB1AIsECQsRC3UANAEZCzAAMAAwADAAMAB1ACELKQswAHUANAExCzkLdQBBC0kLMABRC1kLMAAwADAAMAAwADAAdQBhCzAAMAAwAGAAYABpC3ELdwt/CzAAMACHC4sLkwubC58Lpwt1AK4Ltgt1APsDMAAwADAAMAAwADAAMAAwAL4LwwvLC9IL1wvdCzAAMADlC+kL8Qv5C/8LSQswADAAMAAwADAAMAAwADAAMAAHDDAAMAAwADAAMAAODBYMHgx1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1ACYMMAAwADAAdQB1AHUALgx1AHUAdQB1AHUAdQA2DDAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AD4MdQBGDHUAdQB1AHUAdQB1AEkMdQB1AHUAdQB1AFAMMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQBYDHUAdQB1AF8MMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUA+wMVBGcMMAAwAHwBbwx1AHcMfwyHDI8MMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAYABgAJcMMAAwADAAdQB1AJ8MlQClDDAAMACtDCwHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsB7UMLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AA0EMAC9DDAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAsBywHLAcsBywHLAcsBywHLQcwAMEMyAwsBywHLAcsBywHLAcsBywHLAcsBywHzAwwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAHUAdQB1ANQM2QzhDDAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMABgAGAAYABgAGAAYABgAOkMYADxDGAA+AwADQYNYABhCWAAYAAODTAAMAAwADAAFg1gAGAAHg37AzAAMAAwADAAYABgACYNYAAsDTQNPA1gAEMNPg1LDWAAYABgAGAAYABgAGAAYABgAGAAUg1aDYsGVglhDV0NcQBnDW0NdQ15DWAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAlQCBDZUAiA2PDZcNMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAnw2nDTAAMAAwADAAMAAwAHUArw23DTAAMAAwADAAMAAwADAAMAAwADAAMAB1AL8NMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAB1AHUAdQB1AHUAdQDHDTAAYABgAM8NMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAA1w11ANwNMAAwAD0B5A0wADAAMAAwADAAMADsDfQN/A0EDgwOFA4wABsOMAAwADAAMAAwADAAMAAwANIG0gbSBtIG0gbSBtIG0gYjDigOwQUuDsEFMw7SBjoO0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIGQg5KDlIOVg7SBtIGXg5lDm0OdQ7SBtIGfQ6EDooOjQ6UDtIGmg6hDtIG0gaoDqwO0ga0DrwO0gZgAGAAYADEDmAAYAAkBtIGzA5gANIOYADaDokO0gbSBt8O5w7SBu8O0gb1DvwO0gZgAGAAxA7SBtIG0gbSBtIGYABgAGAAYAAED2AAsAUMD9IG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIGFA8sBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAccD9IGLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHJA8sBywHLAcsBywHLAccDywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywPLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAc0D9IG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIGLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAccD9IG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIGFA8sBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHPA/SBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gYUD0QPlQCVAJUAMAAwADAAMACVAJUAlQCVAJUAlQCVAEwPMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAA//8EAAQABAAEAAQABAAEAAQABAANAAMAAQABAAIABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQACgATABcAHgAbABoAHgAXABYAEgAeABsAGAAPABgAHABLAEsASwBLAEsASwBLAEsASwBLABgAGAAeAB4AHgATAB4AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQABYAGwASAB4AHgAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAWAA0AEQAeAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAAQABAAEAAQABAAFAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAJABYAGgAbABsAGwAeAB0AHQAeAE8AFwAeAA0AHgAeABoAGwBPAE8ADgBQAB0AHQAdAE8ATwAXAE8ATwBPABYAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAFAAUABQAFAAUABQAFAAUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAB4AHgAeAFAATwBAAE8ATwBPAEAATwBQAFAATwBQAB4AHgAeAB4AHgAeAB0AHQAdAB0AHgAdAB4ADgBQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgBQAB4AUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAJAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAkACQAJAAkACQAJAAkABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAeAB4AHgAeAFAAHgAeAB4AKwArAFAAUABQAFAAGABQACsAKwArACsAHgAeAFAAHgBQAFAAUAArAFAAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQABAAEAAQABAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAUAAeAB4AHgAeAB4AHgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAYAA0AKwArAB4AHgAbACsABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQADQAEAB4ABAAEAB4ABAAEABMABAArACsAKwArACsAKwArACsAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAKwArACsAKwBWAFYAVgBWAB4AHgArACsAKwArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AGgAaABoAGAAYAB4AHgAEAAQABAAEAAQABAAEAAQABAAEAAQAEwAEACsAEwATAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABABLAEsASwBLAEsASwBLAEsASwBLABoAGQAZAB4AUABQAAQAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQABMAUAAEAAQABAAEAAQABAAEAB4AHgAEAAQABAAEAAQABABQAFAABAAEAB4ABAAEAAQABABQAFAASwBLAEsASwBLAEsASwBLAEsASwBQAFAAUAAeAB4AUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwAeAFAABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQAUABQAB4AHgAYABMAUAArACsABAAbABsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAFAABAAEAAQABAAEAFAABAAEAAQAUAAEAAQABAAEAAQAKwArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAArACsAHgArAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAB4ABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAUAAEAAQABAAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQAFAABAAEAA0ADQBLAEsASwBLAEsASwBLAEsASwBLAB4AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAArAFAAUABQAFAAUABQAFAAUAArACsAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUAArACsAKwBQAFAAUABQACsAKwAEAFAABAAEAAQABAAEAAQABAArACsABAAEACsAKwAEAAQABABQACsAKwArACsAKwArACsAKwAEACsAKwArACsAUABQACsAUABQAFAABAAEACsAKwBLAEsASwBLAEsASwBLAEsASwBLAFAAUAAaABoAUABQAFAAUABQAEwAHgAbAFAAHgAEACsAKwAEAAQABAArAFAAUABQAFAAUABQACsAKwArACsAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQACsAUABQACsAUABQACsAKwAEACsABAAEAAQABAAEACsAKwArACsABAAEACsAKwAEAAQABAArACsAKwAEACsAKwArACsAKwArACsAUABQAFAAUAArAFAAKwArACsAKwArACsAKwBLAEsASwBLAEsASwBLAEsASwBLAAQABABQAFAAUAAEAB4AKwArACsAKwArACsAKwArACsAKwAEAAQABAArAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQACsAUABQAFAAUABQACsAKwAEAFAABAAEAAQABAAEAAQABAAEACsABAAEAAQAKwAEAAQABAArACsAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAABAAEACsAKwBLAEsASwBLAEsASwBLAEsASwBLAB4AGwArACsAKwArACsAKwArAFAABAAEAAQABAAEAAQAKwAEAAQABAArAFAAUABQAFAAUABQAFAAUAArACsAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAArACsABAAEACsAKwAEAAQABAArACsAKwArACsAKwArAAQABAAEACsAKwArACsAUABQACsAUABQAFAABAAEACsAKwBLAEsASwBLAEsASwBLAEsASwBLAB4AUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArAAQAUAArAFAAUABQAFAAUABQACsAKwArAFAAUABQACsAUABQAFAAUAArACsAKwBQAFAAKwBQACsAUABQACsAKwArAFAAUAArACsAKwBQAFAAUAArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArAAQABAAEAAQABAArACsAKwAEAAQABAArAAQABAAEAAQAKwArAFAAKwArACsAKwArACsABAArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAUABQAFAAHgAeAB4AHgAeAB4AGwAeACsAKwArACsAKwAEAAQABAAEAAQAUABQAFAAUABQAFAAUABQACsAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAUAAEAAQABAAEAAQABAAEACsABAAEAAQAKwAEAAQABAAEACsAKwArACsAKwArACsABAAEACsAUABQAFAAKwArACsAKwArAFAAUAAEAAQAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAKwAOAFAAUABQAFAAUABQAFAAHgBQAAQABAAEAA4AUABQAFAAUABQAFAAUABQACsAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAKwArAAQAUAAEAAQABAAEAAQABAAEACsABAAEAAQAKwAEAAQABAAEACsAKwArACsAKwArACsABAAEACsAKwArACsAKwArACsAUAArAFAAUAAEAAQAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwBQAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAFAABAAEAAQABAAEAAQABAArAAQABAAEACsABAAEAAQABABQAB4AKwArACsAKwBQAFAAUAAEAFAAUABQAFAAUABQAFAAUABQAFAABAAEACsAKwBLAEsASwBLAEsASwBLAEsASwBLAFAAUABQAFAAUABQAFAAUABQABoAUABQAFAAUABQAFAAKwAEAAQABAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQACsAUAArACsAUABQAFAAUABQAFAAUAArACsAKwAEACsAKwArACsABAAEAAQABAAEAAQAKwAEACsABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArAAQABAAeACsAKwArACsAKwArACsAKwArACsAKwArAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAAqAFwAXAAqACoAKgAqACoAKgAqACsAKwArACsAGwBcAFwAXABcAFwAXABcACoAKgAqACoAKgAqACoAKgAeAEsASwBLAEsASwBLAEsASwBLAEsADQANACsAKwArACsAKwBcAFwAKwBcACsAXABcAFwAXABcACsAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACsAXAArAFwAXABcAFwAXABcAFwAXABcAFwAKgBcAFwAKgAqACoAKgAqACoAKgAqACoAXAArACsAXABcAFwAXABcACsAXAArACoAKgAqACoAKgAqACsAKwBLAEsASwBLAEsASwBLAEsASwBLACsAKwBcAFwAXABcAFAADgAOAA4ADgAeAA4ADgAJAA4ADgANAAkAEwATABMAEwATAAkAHgATAB4AHgAeAAQABAAeAB4AHgAeAB4AHgBLAEsASwBLAEsASwBLAEsASwBLAFAAUABQAFAAUABQAFAAUABQAFAADQAEAB4ABAAeAAQAFgARABYAEQAEAAQAUABQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQADQAEAAQABAAEAAQADQAEAAQAUABQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABAArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArAA0ADQAeAB4AHgAeAB4AHgAEAB4AHgAeAB4AHgAeACsAHgAeAA4ADgANAA4AHgAeAB4AHgAeAAkACQArACsAKwArACsAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgBcAEsASwBLAEsASwBLAEsASwBLAEsADQANAB4AHgAeAB4AXABcAFwAXABcAFwAKgAqACoAKgBcAFwAXABcACoAKgAqAFwAKgAqACoAXABcACoAKgAqACoAKgAqACoAXABcAFwAKgAqACoAKgBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACoAKgAqACoAKgAqACoAKgAqACoAKgAqAFwAKgBLAEsASwBLAEsASwBLAEsASwBLACoAKgAqACoAKgAqAFAAUABQAFAAUABQACsAUAArACsAKwArACsAUAArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgBQAFAAUABQAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAUAArACsAUABQAFAAUABQAFAAUAArAFAAKwBQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAKwArAFAAUABQAFAAUABQAFAAKwBQACsAUABQAFAAUAArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsABAAEAAQAHgANAB4AHgAeAB4AHgAeAB4AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUAArACsADQBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAANAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAWABEAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAA0ADQANAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAAQABAAEACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAANAA0AKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUAArAAQABAArACsAKwArACsAKwArACsAKwArACsAKwBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqAA0ADQAVAFwADQAeAA0AGwBcACoAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwAeAB4AEwATAA0ADQAOAB4AEwATAB4ABAAEAAQACQArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUAAEAAQAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQAUAArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAArACsAKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsAHgArACsAKwATABMASwBLAEsASwBLAEsASwBLAEsASwBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAArACsAXABcAFwAXABcACsAKwArACsAKwArACsAKwArACsAKwBcAFwAXABcAFwAXABcAFwAXABcAFwAXAArACsAKwArAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAXAArACsAKwAqACoAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAArACsAHgAeAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACoAKgAqACoAKgAqACoAKgAqACoAKwAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKwArAAQASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArACsAKwBLAEsASwBLAEsASwBLAEsASwBLACsAKwArACsAKwArACoAKgAqACoAKgAqACoAXAAqACoAKgAqACoAKgArACsABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsABAAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABABQAFAAUABQAFAAUABQACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwANAA0AHgANAA0ADQANAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQABAAEAAQABAAEAAQAHgAeAB4AHgAeAB4AHgAeAB4AKwArACsABAAEAAQAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABABQAFAASwBLAEsASwBLAEsASwBLAEsASwBQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwAeAB4AHgAeAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArAA0ADQANAA0ADQBLAEsASwBLAEsASwBLAEsASwBLACsAKwArAFAAUABQAEsASwBLAEsASwBLAEsASwBLAEsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAA0ADQBQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUAAeAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArAAQABAAEAB4ABAAEAAQABAAEAAQABAAEAAQABAAEAAQABABQAFAAUABQAAQAUABQAFAAUABQAFAABABQAFAABAAEAAQAUAArACsAKwArACsABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsABAAEAAQABAAEAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAKwBQACsAUAArAFAAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACsAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArAB4AHgAeAB4AHgAeAB4AHgBQAB4AHgAeAFAAUABQACsAHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAUABQACsAKwAeAB4AHgAeAB4AHgArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArAFAAUABQACsAHgAeAB4AHgAeAB4AHgAOAB4AKwANAA0ADQANAA0ADQANAAkADQANAA0ACAAEAAsABAAEAA0ACQANAA0ADAAdAB0AHgAXABcAFgAXABcAFwAWABcAHQAdAB4AHgAUABQAFAANAAEAAQAEAAQABAAEAAQACQAaABoAGgAaABoAGgAaABoAHgAXABcAHQAVABUAHgAeAB4AHgAeAB4AGAAWABEAFQAVABUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ADQAeAA0ADQANAA0AHgANAA0ADQAHAB4AHgAeAB4AKwAEAAQABAAEAAQABAAEAAQABAAEAFAAUAArACsATwBQAFAAUABQAFAAHgAeAB4AFgARAE8AUABPAE8ATwBPAFAAUABQAFAAUAAeAB4AHgAWABEAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArABsAGwAbABsAGwAbABsAGgAbABsAGwAbABsAGwAbABsAGwAbABsAGwAbABsAGgAbABsAGwAbABoAGwAbABoAGwAbABsAGwAbABsAGwAbABsAGwAbABsAGwAbABsAGwAbAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAHgAeAFAAGgAeAB0AHgBQAB4AGgAeAB4AHgAeAB4AHgAeAB4AHgBPAB4AUAAbAB4AHgBQAFAAUABQAFAAHgAeAB4AHQAdAB4AUAAeAFAAHgBQAB4AUABPAFAAUAAeAB4AHgAeAB4AHgAeAFAAUABQAFAAUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAFAAHgBQAFAAUABQAE8ATwBQAFAAUABQAFAATwBQAFAATwBQAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAFAAUABQAFAATwBPAE8ATwBPAE8ATwBPAE8ATwBQAFAAUABQAFAAUABQAFAAUAAeAB4AUABQAFAAUABPAB4AHgArACsAKwArAB0AHQAdAB0AHQAdAB0AHQAdAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHgAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB4AHQAdAB4AHgAeAB0AHQAeAB4AHQAeAB4AHgAdAB4AHQAbABsAHgAdAB4AHgAeAB4AHQAeAB4AHQAdAB0AHQAeAB4AHQAeAB0AHgAdAB0AHQAdAB0AHQAeAB0AHgAeAB4AHgAeAB0AHQAdAB0AHgAeAB4AHgAdAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB4AHgAeAB0AHgAeAB4AHgAeAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB0AHgAeAB0AHQAdAB0AHgAeAB0AHQAeAB4AHQAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHQAeAB4AHQAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHQAeAB4AHgAdAB4AHgAeAB4AHgAeAB4AHQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AFAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeABYAEQAWABEAHgAeAB4AHgAeAB4AHQAeAB4AHgAeAB4AHgAeACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAWABEAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAFAAHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHgAeAB4AHgAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAeAB4AHQAdAB0AHQAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHQAeAB0AHQAdAB0AHQAdAB0AHgAeAB4AHgAeAB4AHgAeAB0AHQAeAB4AHQAdAB4AHgAeAB4AHQAdAB4AHgAeAB4AHQAdAB0AHgAeAB0AHgAeAB0AHQAdAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB0AHQAdAB4AHgAeAB4AHgAeAB4AHgAeAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAlAB4AHQAdAB4AHgAdAB4AHgAeAB4AHQAdAB4AHgAeAB4AJQAlAB0AHQAlAB4AJQAlACUAIAAlACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAeAB4AHgAeAB0AHgAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB0AHgAdAB0AHQAeAB0AJQAdAB0AHgAdAB0AHgAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHQAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAlACUAJQAlACUAJQAlACUAJQAdAB0AHQAdACUAHgAlACUAJQAdACUAJQAdAB0AHQAlACUAHQAdACUAHQAdACUAJQAlAB4AHQAeAB4AHgAeAB0AHQAlAB0AHQAdAB0AHQAdACUAJQAlACUAJQAdACUAJQAgACUAHQAdACUAJQAlACUAJQAlACUAJQAeAB4AHgAlACUAIAAgACAAIAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHgAeAB4AFwAXABcAFwAXABcAHgATABMAJQAeAB4AHgAWABEAFgARABYAEQAWABEAFgARABYAEQAWABEATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeABYAEQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAWABEAFgARABYAEQAWABEAFgARAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AFgARABYAEQAWABEAFgARABYAEQAWABEAFgARABYAEQAWABEAFgARABYAEQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAWABEAFgARAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AFgARAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB0AHQAdAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AUABQAFAAUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAEAAQABAAeAB4AKwArACsAKwArABMADQANAA0AUAATAA0AUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAUAANACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAA0ADQANAA0ADQANAA0ADQAeAA0AFgANAB4AHgAXABcAHgAeABcAFwAWABEAFgARABYAEQAWABEADQANAA0ADQATAFAADQANAB4ADQANAB4AHgAeAB4AHgAMAAwADQANAA0AHgANAA0AFgANAA0ADQANAA0ADQANAA0AHgANAB4ADQANAB4AHgAeACsAKwArACsAKwArACsAKwArACsAKwArACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAKwArACsAKwArACsAKwArACsAKwArACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAlACUAJQAlACUAJQAlACUAJQAlACUAJQArACsAKwArAA0AEQARACUAJQBHAFcAVwAWABEAFgARABYAEQAWABEAFgARACUAJQAWABEAFgARABYAEQAWABEAFQAWABEAEQAlAFcAVwBXAFcAVwBXAFcAVwBXAAQABAAEAAQABAAEACUAVwBXAFcAVwA2ACUAJQBXAFcAVwBHAEcAJQAlACUAKwBRAFcAUQBXAFEAVwBRAFcAUQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFEAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBRAFcAUQBXAFEAVwBXAFcAVwBXAFcAUQBXAFcAVwBXAFcAVwBRAFEAKwArAAQABAAVABUARwBHAFcAFQBRAFcAUQBXAFEAVwBRAFcAUQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFEAVwBRAFcAUQBXAFcAVwBXAFcAVwBRAFcAVwBXAFcAVwBXAFEAUQBXAFcAVwBXABUAUQBHAEcAVwArACsAKwArACsAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAKwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAKwAlACUAVwBXAFcAVwAlACUAJQAlACUAJQAlACUAJQAlACsAKwArACsAKwArACsAKwArACsAKwArAFEAUQBRAFEAUQBRAFEAUQBRAFEAUQBRAFEAUQBRAFEAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQArAFcAVwBXAFcAVwBXAFcAVwBXAFcAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQBPAE8ATwBPAE8ATwBPAE8AJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACUAJQAlAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAEcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAKwArACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAADQATAA0AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABLAEsASwBLAEsASwBLAEsASwBLAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAFAABAAEAAQABAAeAAQABAAEAAQABAAEAAQABAAEAAQAHgBQAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AUABQAAQABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAeAA0ADQANAA0ADQArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAB4AHgAeAB4AHgAeAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAHgAeAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAeAB4AUABQAFAAUABQAFAAUABQAFAAUABQAAQAUABQAFAABABQAFAAUABQAAQAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAeAB4AHgAeAAQAKwArACsAUABQAFAAUABQAFAAHgAeABoAHgArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAADgAOABMAEwArACsAKwArACsAKwArACsABAAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwANAA0ASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArACsAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABABQAFAAUABQAFAAUAAeAB4AHgBQAA4AUABQAAQAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAA0ADQBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArACsAKwArACsAKwArACsAKwArAB4AWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYACsAKwArAAQAHgAeAB4AHgAeAB4ADQANAA0AHgAeAB4AHgArAFAASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArAB4AHgBcAFwAXABcAFwAKgBcAFwAXABcAFwAXABcAFwAXABcAEsASwBLAEsASwBLAEsASwBLAEsAXABcAFwAXABcACsAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwArAFAAUABQAAQAUABQAFAAUABQAFAAUABQAAQABAArACsASwBLAEsASwBLAEsASwBLAEsASwArACsAHgANAA0ADQBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAKgAqACoAXAAqACoAKgBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAAqAFwAKgAqACoAXABcACoAKgBcAFwAXABcAFwAKgAqAFwAKgBcACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFwAXABcACoAKgBQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAA0ADQBQAFAAUAAEAAQAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUAArACsAUABQAFAAUABQAFAAKwArAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQADQAEAAQAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAVABVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBUAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVACsAKwArACsAKwArACsAKwArACsAKwArAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAKwArACsAKwBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAKwArACsAKwAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACUAJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAJQAlACUAJQAlACUAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAKwArACsAKwArAFYABABWAFYAVgBWAFYAVgBWAFYAVgBWAB4AVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgArAFYAVgBWAFYAVgArAFYAKwBWAFYAKwBWAFYAKwBWAFYAVgBWAFYAVgBWAFYAVgBWAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAEQAWAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUAAaAB4AKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAGAARABEAGAAYABMAEwAWABEAFAArACsAKwArACsAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACUAJQAlACUAJQAWABEAFgARABYAEQAWABEAFgARABYAEQAlACUAFgARACUAJQAlACUAJQAlACUAEQAlABEAKwAVABUAEwATACUAFgARABYAEQAWABEAJQAlACUAJQAlACUAJQAlACsAJQAbABoAJQArACsAKwArAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAAcAKwATACUAJQAbABoAJQAlABYAEQAlACUAEQAlABEAJQBXAFcAVwBXAFcAVwBXAFcAVwBXABUAFQAlACUAJQATACUAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXABYAJQARACUAJQAlAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwAWACUAEQAlABYAEQARABYAEQARABUAVwBRAFEAUQBRAFEAUQBRAFEAUQBRAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAEcARwArACsAVwBXAFcAVwBXAFcAKwArAFcAVwBXAFcAVwBXACsAKwBXAFcAVwBXAFcAVwArACsAVwBXAFcAKwArACsAGgAbACUAJQAlABsAGwArAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwAEAAQABAAQAB0AKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsADQANAA0AKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArAB4AHgAeAB4AHgAeAB4AHgAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAHgAeAB4AKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAAQAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAA0AUABQAFAAUAArACsAKwArAFAAUABQAFAAUABQAFAAUAANAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwAeACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAKwArAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUAArACsAKwBQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwANAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAB4AUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUAArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArAA0AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAUABQAFAAUABQAAQABAAEACsABAAEACsAKwArACsAKwAEAAQABAAEAFAAUABQAFAAKwBQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAAQABAAEACsAKwArACsABABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAA0ADQANAA0ADQANAA0ADQAeACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAFAAUABQAFAAUABQAFAAUAAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAArACsAKwArAFAAUABQAFAAUAANAA0ADQANAA0ADQAUACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsADQANAA0ADQANAA0ADQBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAAQABAAEAAQAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUAArAAQABAANACsAKwBQAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABABQAFAAUABQAB4AHgAeAB4AHgArACsAKwArACsAKwAEAAQABAAEAAQABAAEAA0ADQAeAB4AHgAeAB4AKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABAAeAB4AHgANAA0ADQANACsAKwArACsAKwArACsAKwArACsAKwAeACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwBLAEsASwBLAEsASwBLAEsASwBLACsAKwArACsAKwArAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsASwBLAEsASwBLAEsASwBLAEsASwANAA0ADQANAFAABAAEAFAAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAeAA4AUAArACsAKwArACsAKwArACsAKwAEAFAAUABQAFAADQANAB4ADQAEAAQABAAEAB4ABAAEAEsASwBLAEsASwBLAEsASwBLAEsAUAAOAFAADQANAA0AKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAANAA0AHgANAA0AHgAEACsAUABQAFAAUABQAFAAUAArAFAAKwBQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAA0AKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsABAAEAAQABAArAFAAUABQAFAAUABQAFAAUAArACsAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQACsAUABQAFAAUABQACsABAAEAFAABAAEAAQABAAEAAQABAArACsABAAEACsAKwAEAAQABAArACsAUAArACsAKwArACsAKwAEACsAKwArACsAKwBQAFAAUABQAFAABAAEACsAKwAEAAQABAAEAAQABAAEACsAKwArAAQABAAEAAQABAArACsAKwArACsAKwArACsAKwArACsABAAEAAQABAAEAAQABABQAFAAUABQAA0ADQANAA0AHgBLAEsASwBLAEsASwBLAEsASwBLAA0ADQArAB4ABABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAAQABAAEAFAAUAAeAFAAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAArACsABAAEAAQABAAEAAQABAAEAAQADgANAA0AEwATAB4AHgAeAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAFAAUABQAFAABAAEACsAKwAEAA0ADQAeAFAAKwArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAFAAKwArACsAKwArACsAKwBLAEsASwBLAEsASwBLAEsASwBLACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAKwArACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwBcAFwADQANAA0AKgBQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAeACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwBQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAKwArAFAAKwArAFAAUABQAFAAUABQAFAAUAArAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQAKwAEAAQAKwArAAQABAAEAAQAUAAEAFAABAAEAA0ADQANACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAArACsABAAEAAQABAAEAAQABABQAA4AUAAEACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAABAAEAAQABAAEAAQABAAEAAQABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAFAABAAEAAQABAAOAB4ADQANAA0ADQAOAB4ABAArACsAKwArACsAKwArACsAUAAEAAQABAAEAAQABAAEAAQABAAEAAQAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAA0ADQANAFAADgAOAA4ADQANACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEACsABAAEAAQABAAEAAQABAAEAFAADQANAA0ADQANACsAKwArACsAKwArACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwAOABMAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQACsAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAArACsAKwAEACsABAAEACsABAAEAAQABAAEAAQABABQAAQAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAKwBQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQAKwAEAAQAKwAEAAQABAAEAAQAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAaABoAGgAaAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwArACsAKwArAA0AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsADQANAA0ADQANACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAASABIAEgAQwBDAEMAUABQAFAAUABDAFAAUABQAEgAQwBIAEMAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAASABDAEMAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwAJAAkACQAJAAkACQAJABYAEQArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABIAEMAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwANAA0AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAAQABAAEAAQABAANACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAA0ADQANAB4AHgAeAB4AHgAeAFAAUABQAFAADQAeACsAKwArACsAKwArACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwArAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAANAA0AHgAeACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwAEAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArACsAKwArACsAKwAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAARwBHABUARwAJACsAKwArACsAKwArACsAKwArACsAKwAEAAQAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACsAKwArACsAKwArACsAKwBXAFcAVwBXAFcAVwBXAFcAVwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUQBRAFEAKwArACsAKwArACsAKwArACsAKwArACsAKwBRAFEAUQBRACsAKwArACsAKwArACsAKwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUAArACsAHgAEAAQADQAEAAQABAAEACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwArAB4AHgAeAB4AHgAeAB4AKwArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAAQABAAEAAQABAAeAB4AHgAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAB4AHgAEAAQABAAEAAQABAAEAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQABAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQAHgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwBQAFAAKwArAFAAKwArAFAAUAArACsAUABQAFAAUAArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACsAUAArAFAAUABQAFAAUABQAFAAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwBQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAHgAeAFAAUABQAFAAUAArAFAAKwArACsAUABQAFAAUABQAFAAUAArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAeACsAKwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAeAB4AHgAeAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAeAB4AHgAeAB4AHgAeAB4ABAAeAB4AHgAeAB4AHgAeAB4AHgAeAAQAHgAeAA0ADQANAA0AHgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAAQABAAEAAQAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAAQABAAEAAQABAAEAAQAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArAAQABAAEAAQABAAEAAQAKwAEAAQAKwAEAAQABAAEAAQAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwAEAAQABAAEAAQABAAEAFAAUABQAFAAUABQAFAAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwBQAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArABsAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwArAB4AHgAeAB4ABAAEAAQABAAEAAQABABQACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArABYAFgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAGgBQAFAAUAAaAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAKwBQACsAKwBQACsAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAKwBQACsAUAArACsAKwArACsAKwBQACsAKwArACsAUAArAFAAKwBQACsAUABQAFAAKwBQAFAAKwBQACsAKwBQACsAUAArAFAAKwBQACsAUAArAFAAUAArAFAAKwArAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQAFAAUAArAFAAUABQAFAAKwBQACsAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAUABQAFAAKwBQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8AJQAlACUAHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHgAeAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB4AHgAeACUAJQAlAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQApACkAKQApACkAKQApACkAKQApACkAKQApACkAKQApACkAKQApACkAKQApACkAKQApACkAJQAlACUAJQAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAeAB4AJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlAB4AHgAlACUAJQAlACUAHgAlACUAJQAlACUAIAAgACAAJQAlACAAJQAlACAAIAAgACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACEAIQAhACEAIQAlACUAIAAgACUAJQAgACAAIAAgACAAIAAgACAAIAAgACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAJQAlACUAIAAlACUAJQAlACAAIAAgACUAIAAgACAAJQAlACUAJQAlACUAJQAgACUAIAAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAHgAlAB4AJQAeACUAJQAlACUAJQAgACUAJQAlACUAHgAlAB4AHgAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAIAAlACUAJQAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAJQAlACUAJQAgACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAHgAeAB4AHgAeAB4AHgAeACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAeAB4AHgAeAB4AHgAlACUAJQAlACUAJQAlACAAIAAgACUAJQAlACAAIAAgACAAIAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeABcAFwAXABUAFQAVAB4AHgAeAB4AJQAlACUAIAAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAIAAgACUAJQAlACUAJQAlACUAJQAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAlACUAJQAlACUAJQAlACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACUAJQAlACUAJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeACUAJQAlACUAJQAlAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAlACUAJQAlACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAgACUAJQAgACUAJQAlACUAJQAlACUAJQAgACAAIAAgACAAIAAgACAAJQAlACUAJQAlACUAIAAlACUAJQAlACUAJQAlACUAJQAgACAAIAAgACAAIAAgACAAIAAgACUAJQAgACAAIAAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAgACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAIAAlACAAIAAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAgACAAIAAlACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAJQAlAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAKwArAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACUAJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwAlACUAJQAlACUAJQAlACUAJQAlACUAVwBXACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAKwAEACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAA==";
    var LETTER_NUMBER_MODIFIER = 50;
    var BK = 1;
    var CR$1 = 2;
    var LF$1 = 3;
    var CM = 4;
    var NL = 5;
    var WJ = 7;
    var ZW = 8;
    var GL = 9;
    var SP = 10;
    var ZWJ$1 = 11;
    var B2 = 12;
    var BA = 13;
    var BB = 14;
    var HY = 15;
    var CB = 16;
    var CL = 17;
    var CP = 18;
    var EX = 19;
    var IN = 20;
    var NS = 21;
    var OP = 22;
    var QU = 23;
    var IS = 24;
    var NU = 25;
    var PO = 26;
    var PR = 27;
    var SY = 28;
    var AI = 29;
    var AL = 30;
    var CJ = 31;
    var EB = 32;
    var EM = 33;
    var H2 = 34;
    var H3 = 35;
    var HL = 36;
    var ID = 37;
    var JL = 38;
    var JV = 39;
    var JT = 40;
    var RI$1 = 41;
    var SA = 42;
    var XX = 43;
    var ea_OP = [9001, 65288];
    var BREAK_MANDATORY = "!";
    var BREAK_NOT_ALLOWED$1 = "";
    var BREAK_ALLOWED$1 = "";
    var UnicodeTrie$1 = createTrieFromBase64$1(base64$1);
    var ALPHABETICS = [AL, HL];
    var HARD_LINE_BREAKS = [BK, CR$1, LF$1, NL];
    var SPACE$1 = [SP, ZW];
    var PREFIX_POSTFIX = [PR, PO];
    var LINE_BREAKS = HARD_LINE_BREAKS.concat(SPACE$1);
    var KOREAN_SYLLABLE_BLOCK = [JL, JV, JT, H2, H3];
    var HYPHEN = [HY, BA];
    var codePointsToCharacterClasses = function(codePoints, lineBreak2) {
      if (lineBreak2 === undefined) {
        lineBreak2 = "strict";
      }
      var types = [];
      var indices = [];
      var categories = [];
      codePoints.forEach(function(codePoint, index) {
        var classType = UnicodeTrie$1.get(codePoint);
        if (classType > LETTER_NUMBER_MODIFIER) {
          categories.push(true);
          classType -= LETTER_NUMBER_MODIFIER;
        } else {
          categories.push(false);
        }
        if (["normal", "auto", "loose"].indexOf(lineBreak2) !== -1) {
          if ([8208, 8211, 12316, 12448].indexOf(codePoint) !== -1) {
            indices.push(index);
            return types.push(CB);
          }
        }
        if (classType === CM || classType === ZWJ$1) {
          if (index === 0) {
            indices.push(index);
            return types.push(AL);
          }
          var prev = types[index - 1];
          if (LINE_BREAKS.indexOf(prev) === -1) {
            indices.push(indices[index - 1]);
            return types.push(prev);
          }
          indices.push(index);
          return types.push(AL);
        }
        indices.push(index);
        if (classType === CJ) {
          return types.push(lineBreak2 === "strict" ? NS : ID);
        }
        if (classType === SA) {
          return types.push(AL);
        }
        if (classType === AI) {
          return types.push(AL);
        }
        if (classType === XX) {
          if (codePoint >= 131072 && codePoint <= 196605 || codePoint >= 196608 && codePoint <= 262141) {
            return types.push(ID);
          } else {
            return types.push(AL);
          }
        }
        types.push(classType);
      });
      return [indices, types, categories];
    };
    var isAdjacentWithSpaceIgnored = function(a2, b, currentIndex, classTypes) {
      var current = classTypes[currentIndex];
      if (Array.isArray(a2) ? a2.indexOf(current) !== -1 : a2 === current) {
        var i4 = currentIndex;
        while (i4 <= classTypes.length) {
          i4++;
          var next = classTypes[i4];
          if (next === b) {
            return true;
          }
          if (next !== SP) {
            break;
          }
        }
      }
      if (current === SP) {
        var i4 = currentIndex;
        while (i4 > 0) {
          i4--;
          var prev = classTypes[i4];
          if (Array.isArray(a2) ? a2.indexOf(prev) !== -1 : a2 === prev) {
            var n = currentIndex;
            while (n <= classTypes.length) {
              n++;
              var next = classTypes[n];
              if (next === b) {
                return true;
              }
              if (next !== SP) {
                break;
              }
            }
          }
          if (prev !== SP) {
            break;
          }
        }
      }
      return false;
    };
    var previousNonSpaceClassType = function(currentIndex, classTypes) {
      var i4 = currentIndex;
      while (i4 >= 0) {
        var type = classTypes[i4];
        if (type === SP) {
          i4--;
        } else {
          return type;
        }
      }
      return 0;
    };
    var _lineBreakAtIndex = function(codePoints, classTypes, indicies, index, forbiddenBreaks) {
      if (indicies[index] === 0) {
        return BREAK_NOT_ALLOWED$1;
      }
      var currentIndex = index - 1;
      if (Array.isArray(forbiddenBreaks) && forbiddenBreaks[currentIndex] === true) {
        return BREAK_NOT_ALLOWED$1;
      }
      var beforeIndex = currentIndex - 1;
      var afterIndex = currentIndex + 1;
      var current = classTypes[currentIndex];
      var before = beforeIndex >= 0 ? classTypes[beforeIndex] : 0;
      var next = classTypes[afterIndex];
      if (current === CR$1 && next === LF$1) {
        return BREAK_NOT_ALLOWED$1;
      }
      if (HARD_LINE_BREAKS.indexOf(current) !== -1) {
        return BREAK_MANDATORY;
      }
      if (HARD_LINE_BREAKS.indexOf(next) !== -1) {
        return BREAK_NOT_ALLOWED$1;
      }
      if (SPACE$1.indexOf(next) !== -1) {
        return BREAK_NOT_ALLOWED$1;
      }
      if (previousNonSpaceClassType(currentIndex, classTypes) === ZW) {
        return BREAK_ALLOWED$1;
      }
      if (UnicodeTrie$1.get(codePoints[currentIndex]) === ZWJ$1) {
        return BREAK_NOT_ALLOWED$1;
      }
      if ((current === EB || current === EM) && UnicodeTrie$1.get(codePoints[afterIndex]) === ZWJ$1) {
        return BREAK_NOT_ALLOWED$1;
      }
      if (current === WJ || next === WJ) {
        return BREAK_NOT_ALLOWED$1;
      }
      if (current === GL) {
        return BREAK_NOT_ALLOWED$1;
      }
      if ([SP, BA, HY].indexOf(current) === -1 && next === GL) {
        return BREAK_NOT_ALLOWED$1;
      }
      if ([CL, CP, EX, IS, SY].indexOf(next) !== -1) {
        return BREAK_NOT_ALLOWED$1;
      }
      if (previousNonSpaceClassType(currentIndex, classTypes) === OP) {
        return BREAK_NOT_ALLOWED$1;
      }
      if (isAdjacentWithSpaceIgnored(QU, OP, currentIndex, classTypes)) {
        return BREAK_NOT_ALLOWED$1;
      }
      if (isAdjacentWithSpaceIgnored([CL, CP], NS, currentIndex, classTypes)) {
        return BREAK_NOT_ALLOWED$1;
      }
      if (isAdjacentWithSpaceIgnored(B2, B2, currentIndex, classTypes)) {
        return BREAK_NOT_ALLOWED$1;
      }
      if (current === SP) {
        return BREAK_ALLOWED$1;
      }
      if (current === QU || next === QU) {
        return BREAK_NOT_ALLOWED$1;
      }
      if (next === CB || current === CB) {
        return BREAK_ALLOWED$1;
      }
      if ([BA, HY, NS].indexOf(next) !== -1 || current === BB) {
        return BREAK_NOT_ALLOWED$1;
      }
      if (before === HL && HYPHEN.indexOf(current) !== -1) {
        return BREAK_NOT_ALLOWED$1;
      }
      if (current === SY && next === HL) {
        return BREAK_NOT_ALLOWED$1;
      }
      if (next === IN) {
        return BREAK_NOT_ALLOWED$1;
      }
      if (ALPHABETICS.indexOf(next) !== -1 && current === NU || ALPHABETICS.indexOf(current) !== -1 && next === NU) {
        return BREAK_NOT_ALLOWED$1;
      }
      if (current === PR && [ID, EB, EM].indexOf(next) !== -1 || [ID, EB, EM].indexOf(current) !== -1 && next === PO) {
        return BREAK_NOT_ALLOWED$1;
      }
      if (ALPHABETICS.indexOf(current) !== -1 && PREFIX_POSTFIX.indexOf(next) !== -1 || PREFIX_POSTFIX.indexOf(current) !== -1 && ALPHABETICS.indexOf(next) !== -1) {
        return BREAK_NOT_ALLOWED$1;
      }
      if ([PR, PO].indexOf(current) !== -1 && (next === NU || [OP, HY].indexOf(next) !== -1 && classTypes[afterIndex + 1] === NU) || [OP, HY].indexOf(current) !== -1 && next === NU || current === NU && [NU, SY, IS].indexOf(next) !== -1) {
        return BREAK_NOT_ALLOWED$1;
      }
      if ([NU, SY, IS, CL, CP].indexOf(next) !== -1) {
        var prevIndex = currentIndex;
        while (prevIndex >= 0) {
          var type = classTypes[prevIndex];
          if (type === NU) {
            return BREAK_NOT_ALLOWED$1;
          } else if ([SY, IS].indexOf(type) !== -1) {
            prevIndex--;
          } else {
            break;
          }
        }
      }
      if ([PR, PO].indexOf(next) !== -1) {
        var prevIndex = [CL, CP].indexOf(current) !== -1 ? beforeIndex : currentIndex;
        while (prevIndex >= 0) {
          var type = classTypes[prevIndex];
          if (type === NU) {
            return BREAK_NOT_ALLOWED$1;
          } else if ([SY, IS].indexOf(type) !== -1) {
            prevIndex--;
          } else {
            break;
          }
        }
      }
      if (JL === current && [JL, JV, H2, H3].indexOf(next) !== -1 || [JV, H2].indexOf(current) !== -1 && [JV, JT].indexOf(next) !== -1 || [JT, H3].indexOf(current) !== -1 && next === JT) {
        return BREAK_NOT_ALLOWED$1;
      }
      if (KOREAN_SYLLABLE_BLOCK.indexOf(current) !== -1 && [IN, PO].indexOf(next) !== -1 || KOREAN_SYLLABLE_BLOCK.indexOf(next) !== -1 && current === PR) {
        return BREAK_NOT_ALLOWED$1;
      }
      if (ALPHABETICS.indexOf(current) !== -1 && ALPHABETICS.indexOf(next) !== -1) {
        return BREAK_NOT_ALLOWED$1;
      }
      if (current === IS && ALPHABETICS.indexOf(next) !== -1) {
        return BREAK_NOT_ALLOWED$1;
      }
      if (ALPHABETICS.concat(NU).indexOf(current) !== -1 && next === OP && ea_OP.indexOf(codePoints[afterIndex]) === -1 || ALPHABETICS.concat(NU).indexOf(next) !== -1 && current === CP) {
        return BREAK_NOT_ALLOWED$1;
      }
      if (current === RI$1 && next === RI$1) {
        var i4 = indicies[currentIndex];
        var count = 1;
        while (i4 > 0) {
          i4--;
          if (classTypes[i4] === RI$1) {
            count++;
          } else {
            break;
          }
        }
        if (count % 2 !== 0) {
          return BREAK_NOT_ALLOWED$1;
        }
      }
      if (current === EB && next === EM) {
        return BREAK_NOT_ALLOWED$1;
      }
      return BREAK_ALLOWED$1;
    };
    var cssFormattedClasses = function(codePoints, options) {
      if (!options) {
        options = { lineBreak: "normal", wordBreak: "normal" };
      }
      var _a2 = codePointsToCharacterClasses(codePoints, options.lineBreak), indicies = _a2[0], classTypes = _a2[1], isLetterNumber = _a2[2];
      if (options.wordBreak === "break-all" || options.wordBreak === "break-word") {
        classTypes = classTypes.map(function(type) {
          return [NU, AL, SA].indexOf(type) !== -1 ? ID : type;
        });
      }
      var forbiddenBreakpoints = options.wordBreak === "keep-all" ? isLetterNumber.map(function(letterNumber, i4) {
        return letterNumber && codePoints[i4] >= 19968 && codePoints[i4] <= 40959;
      }) : undefined;
      return [indicies, classTypes, forbiddenBreakpoints];
    };
    var Break = function() {
      function Break2(codePoints, lineBreak2, start, end) {
        this.codePoints = codePoints;
        this.required = lineBreak2 === BREAK_MANDATORY;
        this.start = start;
        this.end = end;
      }
      Break2.prototype.slice = function() {
        return fromCodePoint$1.apply(undefined, this.codePoints.slice(this.start, this.end));
      };
      return Break2;
    }();
    var LineBreaker = function(str, options) {
      var codePoints = toCodePoints$1(str);
      var _a2 = cssFormattedClasses(codePoints, options), indicies = _a2[0], classTypes = _a2[1], forbiddenBreakpoints = _a2[2];
      var length = codePoints.length;
      var lastEnd = 0;
      var nextIndex = 0;
      return {
        next: function() {
          if (nextIndex >= length) {
            return { done: true, value: null };
          }
          var lineBreak2 = BREAK_NOT_ALLOWED$1;
          while (nextIndex < length && (lineBreak2 = _lineBreakAtIndex(codePoints, classTypes, indicies, ++nextIndex, forbiddenBreakpoints)) === BREAK_NOT_ALLOWED$1) {}
          if (lineBreak2 !== BREAK_NOT_ALLOWED$1 || nextIndex === length) {
            var value = new Break(codePoints, lineBreak2, lastEnd, nextIndex);
            lastEnd = nextIndex;
            return { value, done: false };
          }
          return { done: true, value: null };
        }
      };
    };
    var FLAG_UNRESTRICTED = 1 << 0;
    var FLAG_ID = 1 << 1;
    var FLAG_INTEGER = 1 << 2;
    var FLAG_NUMBER = 1 << 3;
    var LINE_FEED = 10;
    var SOLIDUS = 47;
    var REVERSE_SOLIDUS = 92;
    var CHARACTER_TABULATION = 9;
    var SPACE = 32;
    var QUOTATION_MARK = 34;
    var EQUALS_SIGN = 61;
    var NUMBER_SIGN = 35;
    var DOLLAR_SIGN = 36;
    var PERCENTAGE_SIGN = 37;
    var APOSTROPHE = 39;
    var LEFT_PARENTHESIS = 40;
    var RIGHT_PARENTHESIS = 41;
    var LOW_LINE = 95;
    var HYPHEN_MINUS = 45;
    var EXCLAMATION_MARK = 33;
    var LESS_THAN_SIGN = 60;
    var GREATER_THAN_SIGN = 62;
    var COMMERCIAL_AT = 64;
    var LEFT_SQUARE_BRACKET = 91;
    var RIGHT_SQUARE_BRACKET = 93;
    var CIRCUMFLEX_ACCENT = 61;
    var LEFT_CURLY_BRACKET = 123;
    var QUESTION_MARK = 63;
    var RIGHT_CURLY_BRACKET = 125;
    var VERTICAL_LINE = 124;
    var TILDE = 126;
    var CONTROL = 128;
    var REPLACEMENT_CHARACTER = 65533;
    var ASTERISK = 42;
    var PLUS_SIGN = 43;
    var COMMA = 44;
    var COLON = 58;
    var SEMICOLON = 59;
    var FULL_STOP = 46;
    var NULL = 0;
    var BACKSPACE = 8;
    var LINE_TABULATION = 11;
    var SHIFT_OUT = 14;
    var INFORMATION_SEPARATOR_ONE = 31;
    var DELETE = 127;
    var EOF = -1;
    var ZERO = 48;
    var a = 97;
    var e = 101;
    var f = 102;
    var u = 117;
    var z = 122;
    var A = 65;
    var E = 69;
    var F = 70;
    var U = 85;
    var Z = 90;
    var isDigit = function(codePoint) {
      return codePoint >= ZERO && codePoint <= 57;
    };
    var isSurrogateCodePoint = function(codePoint) {
      return codePoint >= 55296 && codePoint <= 57343;
    };
    var isHex = function(codePoint) {
      return isDigit(codePoint) || codePoint >= A && codePoint <= F || codePoint >= a && codePoint <= f;
    };
    var isLowerCaseLetter = function(codePoint) {
      return codePoint >= a && codePoint <= z;
    };
    var isUpperCaseLetter = function(codePoint) {
      return codePoint >= A && codePoint <= Z;
    };
    var isLetter = function(codePoint) {
      return isLowerCaseLetter(codePoint) || isUpperCaseLetter(codePoint);
    };
    var isNonASCIICodePoint = function(codePoint) {
      return codePoint >= CONTROL;
    };
    var isWhiteSpace = function(codePoint) {
      return codePoint === LINE_FEED || codePoint === CHARACTER_TABULATION || codePoint === SPACE;
    };
    var isNameStartCodePoint = function(codePoint) {
      return isLetter(codePoint) || isNonASCIICodePoint(codePoint) || codePoint === LOW_LINE;
    };
    var isNameCodePoint = function(codePoint) {
      return isNameStartCodePoint(codePoint) || isDigit(codePoint) || codePoint === HYPHEN_MINUS;
    };
    var isNonPrintableCodePoint = function(codePoint) {
      return codePoint >= NULL && codePoint <= BACKSPACE || codePoint === LINE_TABULATION || codePoint >= SHIFT_OUT && codePoint <= INFORMATION_SEPARATOR_ONE || codePoint === DELETE;
    };
    var isValidEscape = function(c1, c2) {
      if (c1 !== REVERSE_SOLIDUS) {
        return false;
      }
      return c2 !== LINE_FEED;
    };
    var isIdentifierStart = function(c1, c2, c3) {
      if (c1 === HYPHEN_MINUS) {
        return isNameStartCodePoint(c2) || isValidEscape(c2, c3);
      } else if (isNameStartCodePoint(c1)) {
        return true;
      } else if (c1 === REVERSE_SOLIDUS && isValidEscape(c1, c2)) {
        return true;
      }
      return false;
    };
    var isNumberStart = function(c1, c2, c3) {
      if (c1 === PLUS_SIGN || c1 === HYPHEN_MINUS) {
        if (isDigit(c2)) {
          return true;
        }
        return c2 === FULL_STOP && isDigit(c3);
      }
      if (c1 === FULL_STOP) {
        return isDigit(c2);
      }
      return isDigit(c1);
    };
    var stringToNumber = function(codePoints) {
      var c = 0;
      var sign = 1;
      if (codePoints[c] === PLUS_SIGN || codePoints[c] === HYPHEN_MINUS) {
        if (codePoints[c] === HYPHEN_MINUS) {
          sign = -1;
        }
        c++;
      }
      var integers = [];
      while (isDigit(codePoints[c])) {
        integers.push(codePoints[c++]);
      }
      var int = integers.length ? parseInt(fromCodePoint$1.apply(undefined, integers), 10) : 0;
      if (codePoints[c] === FULL_STOP) {
        c++;
      }
      var fraction = [];
      while (isDigit(codePoints[c])) {
        fraction.push(codePoints[c++]);
      }
      var fracd = fraction.length;
      var frac = fracd ? parseInt(fromCodePoint$1.apply(undefined, fraction), 10) : 0;
      if (codePoints[c] === E || codePoints[c] === e) {
        c++;
      }
      var expsign = 1;
      if (codePoints[c] === PLUS_SIGN || codePoints[c] === HYPHEN_MINUS) {
        if (codePoints[c] === HYPHEN_MINUS) {
          expsign = -1;
        }
        c++;
      }
      var exponent = [];
      while (isDigit(codePoints[c])) {
        exponent.push(codePoints[c++]);
      }
      var exp = exponent.length ? parseInt(fromCodePoint$1.apply(undefined, exponent), 10) : 0;
      return sign * (int + frac * Math.pow(10, -fracd)) * Math.pow(10, expsign * exp);
    };
    var LEFT_PARENTHESIS_TOKEN = {
      type: 2
    };
    var RIGHT_PARENTHESIS_TOKEN = {
      type: 3
    };
    var COMMA_TOKEN = { type: 4 };
    var SUFFIX_MATCH_TOKEN = { type: 13 };
    var PREFIX_MATCH_TOKEN = { type: 8 };
    var COLUMN_TOKEN = { type: 21 };
    var DASH_MATCH_TOKEN = { type: 9 };
    var INCLUDE_MATCH_TOKEN = { type: 10 };
    var LEFT_CURLY_BRACKET_TOKEN = {
      type: 11
    };
    var RIGHT_CURLY_BRACKET_TOKEN = {
      type: 12
    };
    var SUBSTRING_MATCH_TOKEN = { type: 14 };
    var BAD_URL_TOKEN = { type: 23 };
    var BAD_STRING_TOKEN = { type: 1 };
    var CDO_TOKEN = { type: 25 };
    var CDC_TOKEN = { type: 24 };
    var COLON_TOKEN = { type: 26 };
    var SEMICOLON_TOKEN = { type: 27 };
    var LEFT_SQUARE_BRACKET_TOKEN = {
      type: 28
    };
    var RIGHT_SQUARE_BRACKET_TOKEN = {
      type: 29
    };
    var WHITESPACE_TOKEN = { type: 31 };
    var EOF_TOKEN = { type: 32 };
    var Tokenizer = function() {
      function Tokenizer2() {
        this._value = [];
      }
      Tokenizer2.prototype.write = function(chunk) {
        this._value = this._value.concat(toCodePoints$1(chunk));
      };
      Tokenizer2.prototype.read = function() {
        var tokens = [];
        var token = this.consumeToken();
        while (token !== EOF_TOKEN) {
          tokens.push(token);
          token = this.consumeToken();
        }
        return tokens;
      };
      Tokenizer2.prototype.consumeToken = function() {
        var codePoint = this.consumeCodePoint();
        switch (codePoint) {
          case QUOTATION_MARK:
            return this.consumeStringToken(QUOTATION_MARK);
          case NUMBER_SIGN:
            var c1 = this.peekCodePoint(0);
            var c2 = this.peekCodePoint(1);
            var c3 = this.peekCodePoint(2);
            if (isNameCodePoint(c1) || isValidEscape(c2, c3)) {
              var flags = isIdentifierStart(c1, c2, c3) ? FLAG_ID : FLAG_UNRESTRICTED;
              var value = this.consumeName();
              return { type: 5, value, flags };
            }
            break;
          case DOLLAR_SIGN:
            if (this.peekCodePoint(0) === EQUALS_SIGN) {
              this.consumeCodePoint();
              return SUFFIX_MATCH_TOKEN;
            }
            break;
          case APOSTROPHE:
            return this.consumeStringToken(APOSTROPHE);
          case LEFT_PARENTHESIS:
            return LEFT_PARENTHESIS_TOKEN;
          case RIGHT_PARENTHESIS:
            return RIGHT_PARENTHESIS_TOKEN;
          case ASTERISK:
            if (this.peekCodePoint(0) === EQUALS_SIGN) {
              this.consumeCodePoint();
              return SUBSTRING_MATCH_TOKEN;
            }
            break;
          case PLUS_SIGN:
            if (isNumberStart(codePoint, this.peekCodePoint(0), this.peekCodePoint(1))) {
              this.reconsumeCodePoint(codePoint);
              return this.consumeNumericToken();
            }
            break;
          case COMMA:
            return COMMA_TOKEN;
          case HYPHEN_MINUS:
            var e1 = codePoint;
            var e2 = this.peekCodePoint(0);
            var e3 = this.peekCodePoint(1);
            if (isNumberStart(e1, e2, e3)) {
              this.reconsumeCodePoint(codePoint);
              return this.consumeNumericToken();
            }
            if (isIdentifierStart(e1, e2, e3)) {
              this.reconsumeCodePoint(codePoint);
              return this.consumeIdentLikeToken();
            }
            if (e2 === HYPHEN_MINUS && e3 === GREATER_THAN_SIGN) {
              this.consumeCodePoint();
              this.consumeCodePoint();
              return CDC_TOKEN;
            }
            break;
          case FULL_STOP:
            if (isNumberStart(codePoint, this.peekCodePoint(0), this.peekCodePoint(1))) {
              this.reconsumeCodePoint(codePoint);
              return this.consumeNumericToken();
            }
            break;
          case SOLIDUS:
            if (this.peekCodePoint(0) === ASTERISK) {
              this.consumeCodePoint();
              while (true) {
                var c = this.consumeCodePoint();
                if (c === ASTERISK) {
                  c = this.consumeCodePoint();
                  if (c === SOLIDUS) {
                    return this.consumeToken();
                  }
                }
                if (c === EOF) {
                  return this.consumeToken();
                }
              }
            }
            break;
          case COLON:
            return COLON_TOKEN;
          case SEMICOLON:
            return SEMICOLON_TOKEN;
          case LESS_THAN_SIGN:
            if (this.peekCodePoint(0) === EXCLAMATION_MARK && this.peekCodePoint(1) === HYPHEN_MINUS && this.peekCodePoint(2) === HYPHEN_MINUS) {
              this.consumeCodePoint();
              this.consumeCodePoint();
              return CDO_TOKEN;
            }
            break;
          case COMMERCIAL_AT:
            var a1 = this.peekCodePoint(0);
            var a2 = this.peekCodePoint(1);
            var a3 = this.peekCodePoint(2);
            if (isIdentifierStart(a1, a2, a3)) {
              var value = this.consumeName();
              return { type: 7, value };
            }
            break;
          case LEFT_SQUARE_BRACKET:
            return LEFT_SQUARE_BRACKET_TOKEN;
          case REVERSE_SOLIDUS:
            if (isValidEscape(codePoint, this.peekCodePoint(0))) {
              this.reconsumeCodePoint(codePoint);
              return this.consumeIdentLikeToken();
            }
            break;
          case RIGHT_SQUARE_BRACKET:
            return RIGHT_SQUARE_BRACKET_TOKEN;
          case CIRCUMFLEX_ACCENT:
            if (this.peekCodePoint(0) === EQUALS_SIGN) {
              this.consumeCodePoint();
              return PREFIX_MATCH_TOKEN;
            }
            break;
          case LEFT_CURLY_BRACKET:
            return LEFT_CURLY_BRACKET_TOKEN;
          case RIGHT_CURLY_BRACKET:
            return RIGHT_CURLY_BRACKET_TOKEN;
          case u:
          case U:
            var u1 = this.peekCodePoint(0);
            var u2 = this.peekCodePoint(1);
            if (u1 === PLUS_SIGN && (isHex(u2) || u2 === QUESTION_MARK)) {
              this.consumeCodePoint();
              this.consumeUnicodeRangeToken();
            }
            this.reconsumeCodePoint(codePoint);
            return this.consumeIdentLikeToken();
          case VERTICAL_LINE:
            if (this.peekCodePoint(0) === EQUALS_SIGN) {
              this.consumeCodePoint();
              return DASH_MATCH_TOKEN;
            }
            if (this.peekCodePoint(0) === VERTICAL_LINE) {
              this.consumeCodePoint();
              return COLUMN_TOKEN;
            }
            break;
          case TILDE:
            if (this.peekCodePoint(0) === EQUALS_SIGN) {
              this.consumeCodePoint();
              return INCLUDE_MATCH_TOKEN;
            }
            break;
          case EOF:
            return EOF_TOKEN;
        }
        if (isWhiteSpace(codePoint)) {
          this.consumeWhiteSpace();
          return WHITESPACE_TOKEN;
        }
        if (isDigit(codePoint)) {
          this.reconsumeCodePoint(codePoint);
          return this.consumeNumericToken();
        }
        if (isNameStartCodePoint(codePoint)) {
          this.reconsumeCodePoint(codePoint);
          return this.consumeIdentLikeToken();
        }
        return { type: 6, value: fromCodePoint$1(codePoint) };
      };
      Tokenizer2.prototype.consumeCodePoint = function() {
        var value = this._value.shift();
        return typeof value === "undefined" ? -1 : value;
      };
      Tokenizer2.prototype.reconsumeCodePoint = function(codePoint) {
        this._value.unshift(codePoint);
      };
      Tokenizer2.prototype.peekCodePoint = function(delta) {
        if (delta >= this._value.length) {
          return -1;
        }
        return this._value[delta];
      };
      Tokenizer2.prototype.consumeUnicodeRangeToken = function() {
        var digits = [];
        var codePoint = this.consumeCodePoint();
        while (isHex(codePoint) && digits.length < 6) {
          digits.push(codePoint);
          codePoint = this.consumeCodePoint();
        }
        var questionMarks = false;
        while (codePoint === QUESTION_MARK && digits.length < 6) {
          digits.push(codePoint);
          codePoint = this.consumeCodePoint();
          questionMarks = true;
        }
        if (questionMarks) {
          var start_1 = parseInt(fromCodePoint$1.apply(undefined, digits.map(function(digit) {
            return digit === QUESTION_MARK ? ZERO : digit;
          })), 16);
          var end = parseInt(fromCodePoint$1.apply(undefined, digits.map(function(digit) {
            return digit === QUESTION_MARK ? F : digit;
          })), 16);
          return { type: 30, start: start_1, end };
        }
        var start = parseInt(fromCodePoint$1.apply(undefined, digits), 16);
        if (this.peekCodePoint(0) === HYPHEN_MINUS && isHex(this.peekCodePoint(1))) {
          this.consumeCodePoint();
          codePoint = this.consumeCodePoint();
          var endDigits = [];
          while (isHex(codePoint) && endDigits.length < 6) {
            endDigits.push(codePoint);
            codePoint = this.consumeCodePoint();
          }
          var end = parseInt(fromCodePoint$1.apply(undefined, endDigits), 16);
          return { type: 30, start, end };
        } else {
          return { type: 30, start, end: start };
        }
      };
      Tokenizer2.prototype.consumeIdentLikeToken = function() {
        var value = this.consumeName();
        if (value.toLowerCase() === "url" && this.peekCodePoint(0) === LEFT_PARENTHESIS) {
          this.consumeCodePoint();
          return this.consumeUrlToken();
        } else if (this.peekCodePoint(0) === LEFT_PARENTHESIS) {
          this.consumeCodePoint();
          return { type: 19, value };
        }
        return { type: 20, value };
      };
      Tokenizer2.prototype.consumeUrlToken = function() {
        var value = [];
        this.consumeWhiteSpace();
        if (this.peekCodePoint(0) === EOF) {
          return { type: 22, value: "" };
        }
        var next = this.peekCodePoint(0);
        if (next === APOSTROPHE || next === QUOTATION_MARK) {
          var stringToken = this.consumeStringToken(this.consumeCodePoint());
          if (stringToken.type === 0) {
            this.consumeWhiteSpace();
            if (this.peekCodePoint(0) === EOF || this.peekCodePoint(0) === RIGHT_PARENTHESIS) {
              this.consumeCodePoint();
              return { type: 22, value: stringToken.value };
            }
          }
          this.consumeBadUrlRemnants();
          return BAD_URL_TOKEN;
        }
        while (true) {
          var codePoint = this.consumeCodePoint();
          if (codePoint === EOF || codePoint === RIGHT_PARENTHESIS) {
            return { type: 22, value: fromCodePoint$1.apply(undefined, value) };
          } else if (isWhiteSpace(codePoint)) {
            this.consumeWhiteSpace();
            if (this.peekCodePoint(0) === EOF || this.peekCodePoint(0) === RIGHT_PARENTHESIS) {
              this.consumeCodePoint();
              return { type: 22, value: fromCodePoint$1.apply(undefined, value) };
            }
            this.consumeBadUrlRemnants();
            return BAD_URL_TOKEN;
          } else if (codePoint === QUOTATION_MARK || codePoint === APOSTROPHE || codePoint === LEFT_PARENTHESIS || isNonPrintableCodePoint(codePoint)) {
            this.consumeBadUrlRemnants();
            return BAD_URL_TOKEN;
          } else if (codePoint === REVERSE_SOLIDUS) {
            if (isValidEscape(codePoint, this.peekCodePoint(0))) {
              value.push(this.consumeEscapedCodePoint());
            } else {
              this.consumeBadUrlRemnants();
              return BAD_URL_TOKEN;
            }
          } else {
            value.push(codePoint);
          }
        }
      };
      Tokenizer2.prototype.consumeWhiteSpace = function() {
        while (isWhiteSpace(this.peekCodePoint(0))) {
          this.consumeCodePoint();
        }
      };
      Tokenizer2.prototype.consumeBadUrlRemnants = function() {
        while (true) {
          var codePoint = this.consumeCodePoint();
          if (codePoint === RIGHT_PARENTHESIS || codePoint === EOF) {
            return;
          }
          if (isValidEscape(codePoint, this.peekCodePoint(0))) {
            this.consumeEscapedCodePoint();
          }
        }
      };
      Tokenizer2.prototype.consumeStringSlice = function(count) {
        var SLICE_STACK_SIZE = 50000;
        var value = "";
        while (count > 0) {
          var amount = Math.min(SLICE_STACK_SIZE, count);
          value += fromCodePoint$1.apply(undefined, this._value.splice(0, amount));
          count -= amount;
        }
        this._value.shift();
        return value;
      };
      Tokenizer2.prototype.consumeStringToken = function(endingCodePoint) {
        var value = "";
        var i4 = 0;
        do {
          var codePoint = this._value[i4];
          if (codePoint === EOF || codePoint === undefined || codePoint === endingCodePoint) {
            value += this.consumeStringSlice(i4);
            return { type: 0, value };
          }
          if (codePoint === LINE_FEED) {
            this._value.splice(0, i4);
            return BAD_STRING_TOKEN;
          }
          if (codePoint === REVERSE_SOLIDUS) {
            var next = this._value[i4 + 1];
            if (next !== EOF && next !== undefined) {
              if (next === LINE_FEED) {
                value += this.consumeStringSlice(i4);
                i4 = -1;
                this._value.shift();
              } else if (isValidEscape(codePoint, next)) {
                value += this.consumeStringSlice(i4);
                value += fromCodePoint$1(this.consumeEscapedCodePoint());
                i4 = -1;
              }
            }
          }
          i4++;
        } while (true);
      };
      Tokenizer2.prototype.consumeNumber = function() {
        var repr = [];
        var type = FLAG_INTEGER;
        var c1 = this.peekCodePoint(0);
        if (c1 === PLUS_SIGN || c1 === HYPHEN_MINUS) {
          repr.push(this.consumeCodePoint());
        }
        while (isDigit(this.peekCodePoint(0))) {
          repr.push(this.consumeCodePoint());
        }
        c1 = this.peekCodePoint(0);
        var c2 = this.peekCodePoint(1);
        if (c1 === FULL_STOP && isDigit(c2)) {
          repr.push(this.consumeCodePoint(), this.consumeCodePoint());
          type = FLAG_NUMBER;
          while (isDigit(this.peekCodePoint(0))) {
            repr.push(this.consumeCodePoint());
          }
        }
        c1 = this.peekCodePoint(0);
        c2 = this.peekCodePoint(1);
        var c3 = this.peekCodePoint(2);
        if ((c1 === E || c1 === e) && ((c2 === PLUS_SIGN || c2 === HYPHEN_MINUS) && isDigit(c3) || isDigit(c2))) {
          repr.push(this.consumeCodePoint(), this.consumeCodePoint());
          type = FLAG_NUMBER;
          while (isDigit(this.peekCodePoint(0))) {
            repr.push(this.consumeCodePoint());
          }
        }
        return [stringToNumber(repr), type];
      };
      Tokenizer2.prototype.consumeNumericToken = function() {
        var _a2 = this.consumeNumber(), number = _a2[0], flags = _a2[1];
        var c1 = this.peekCodePoint(0);
        var c2 = this.peekCodePoint(1);
        var c3 = this.peekCodePoint(2);
        if (isIdentifierStart(c1, c2, c3)) {
          var unit = this.consumeName();
          return { type: 15, number, flags, unit };
        }
        if (c1 === PERCENTAGE_SIGN) {
          this.consumeCodePoint();
          return { type: 16, number, flags };
        }
        return { type: 17, number, flags };
      };
      Tokenizer2.prototype.consumeEscapedCodePoint = function() {
        var codePoint = this.consumeCodePoint();
        if (isHex(codePoint)) {
          var hex = fromCodePoint$1(codePoint);
          while (isHex(this.peekCodePoint(0)) && hex.length < 6) {
            hex += fromCodePoint$1(this.consumeCodePoint());
          }
          if (isWhiteSpace(this.peekCodePoint(0))) {
            this.consumeCodePoint();
          }
          var hexCodePoint = parseInt(hex, 16);
          if (hexCodePoint === 0 || isSurrogateCodePoint(hexCodePoint) || hexCodePoint > 1114111) {
            return REPLACEMENT_CHARACTER;
          }
          return hexCodePoint;
        }
        if (codePoint === EOF) {
          return REPLACEMENT_CHARACTER;
        }
        return codePoint;
      };
      Tokenizer2.prototype.consumeName = function() {
        var result = "";
        while (true) {
          var codePoint = this.consumeCodePoint();
          if (isNameCodePoint(codePoint)) {
            result += fromCodePoint$1(codePoint);
          } else if (isValidEscape(codePoint, this.peekCodePoint(0))) {
            result += fromCodePoint$1(this.consumeEscapedCodePoint());
          } else {
            this.reconsumeCodePoint(codePoint);
            return result;
          }
        }
      };
      return Tokenizer2;
    }();
    var Parser = function() {
      function Parser2(tokens) {
        this._tokens = tokens;
      }
      Parser2.create = function(value) {
        var tokenizer = new Tokenizer;
        tokenizer.write(value);
        return new Parser2(tokenizer.read());
      };
      Parser2.parseValue = function(value) {
        return Parser2.create(value).parseComponentValue();
      };
      Parser2.parseValues = function(value) {
        return Parser2.create(value).parseComponentValues();
      };
      Parser2.prototype.parseComponentValue = function() {
        var token = this.consumeToken();
        while (token.type === 31) {
          token = this.consumeToken();
        }
        if (token.type === 32) {
          throw new SyntaxError("Error parsing CSS component value, unexpected EOF");
        }
        this.reconsumeToken(token);
        var value = this.consumeComponentValue();
        do {
          token = this.consumeToken();
        } while (token.type === 31);
        if (token.type === 32) {
          return value;
        }
        throw new SyntaxError("Error parsing CSS component value, multiple values found when expecting only one");
      };
      Parser2.prototype.parseComponentValues = function() {
        var values = [];
        while (true) {
          var value = this.consumeComponentValue();
          if (value.type === 32) {
            return values;
          }
          values.push(value);
          values.push();
        }
      };
      Parser2.prototype.consumeComponentValue = function() {
        var token = this.consumeToken();
        switch (token.type) {
          case 11:
          case 28:
          case 2:
            return this.consumeSimpleBlock(token.type);
          case 19:
            return this.consumeFunction(token);
        }
        return token;
      };
      Parser2.prototype.consumeSimpleBlock = function(type) {
        var block = { type, values: [] };
        var token = this.consumeToken();
        while (true) {
          if (token.type === 32 || isEndingTokenFor(token, type)) {
            return block;
          }
          this.reconsumeToken(token);
          block.values.push(this.consumeComponentValue());
          token = this.consumeToken();
        }
      };
      Parser2.prototype.consumeFunction = function(functionToken) {
        var cssFunction = {
          name: functionToken.value,
          values: [],
          type: 18
        };
        while (true) {
          var token = this.consumeToken();
          if (token.type === 32 || token.type === 3) {
            return cssFunction;
          }
          this.reconsumeToken(token);
          cssFunction.values.push(this.consumeComponentValue());
        }
      };
      Parser2.prototype.consumeToken = function() {
        var token = this._tokens.shift();
        return typeof token === "undefined" ? EOF_TOKEN : token;
      };
      Parser2.prototype.reconsumeToken = function(token) {
        this._tokens.unshift(token);
      };
      return Parser2;
    }();
    var isDimensionToken = function(token) {
      return token.type === 15;
    };
    var isNumberToken = function(token) {
      return token.type === 17;
    };
    var isIdentToken = function(token) {
      return token.type === 20;
    };
    var isStringToken = function(token) {
      return token.type === 0;
    };
    var isIdentWithValue = function(token, value) {
      return isIdentToken(token) && token.value === value;
    };
    var nonWhiteSpace = function(token) {
      return token.type !== 31;
    };
    var nonFunctionArgSeparator = function(token) {
      return token.type !== 31 && token.type !== 4;
    };
    var parseFunctionArgs = function(tokens) {
      var args = [];
      var arg = [];
      tokens.forEach(function(token) {
        if (token.type === 4) {
          if (arg.length === 0) {
            throw new Error("Error parsing function args, zero tokens for arg");
          }
          args.push(arg);
          arg = [];
          return;
        }
        if (token.type !== 31) {
          arg.push(token);
        }
      });
      if (arg.length) {
        args.push(arg);
      }
      return args;
    };
    var isEndingTokenFor = function(token, type) {
      if (type === 11 && token.type === 12) {
        return true;
      }
      if (type === 28 && token.type === 29) {
        return true;
      }
      return type === 2 && token.type === 3;
    };
    var isLength = function(token) {
      return token.type === 17 || token.type === 15;
    };
    var isLengthPercentage = function(token) {
      return token.type === 16 || isLength(token);
    };
    var parseLengthPercentageTuple = function(tokens) {
      return tokens.length > 1 ? [tokens[0], tokens[1]] : [tokens[0]];
    };
    var ZERO_LENGTH = {
      type: 17,
      number: 0,
      flags: FLAG_INTEGER
    };
    var FIFTY_PERCENT = {
      type: 16,
      number: 50,
      flags: FLAG_INTEGER
    };
    var HUNDRED_PERCENT = {
      type: 16,
      number: 100,
      flags: FLAG_INTEGER
    };
    var getAbsoluteValueForTuple = function(tuple, width, height) {
      var x2 = tuple[0], y = tuple[1];
      return [getAbsoluteValue(x2, width), getAbsoluteValue(typeof y !== "undefined" ? y : x2, height)];
    };
    var getAbsoluteValue = function(token, parent) {
      if (token.type === 16) {
        return token.number / 100 * parent;
      }
      if (isDimensionToken(token)) {
        switch (token.unit) {
          case "rem":
          case "em":
            return 16 * token.number;
          case "px":
          default:
            return token.number;
        }
      }
      return token.number;
    };
    var DEG = "deg";
    var GRAD = "grad";
    var RAD = "rad";
    var TURN = "turn";
    var angle = {
      name: "angle",
      parse: function(_context, value) {
        if (value.type === 15) {
          switch (value.unit) {
            case DEG:
              return Math.PI * value.number / 180;
            case GRAD:
              return Math.PI / 200 * value.number;
            case RAD:
              return value.number;
            case TURN:
              return Math.PI * 2 * value.number;
          }
        }
        throw new Error("Unsupported angle type");
      }
    };
    var isAngle = function(value) {
      if (value.type === 15) {
        if (value.unit === DEG || value.unit === GRAD || value.unit === RAD || value.unit === TURN) {
          return true;
        }
      }
      return false;
    };
    var parseNamedSide = function(tokens) {
      var sideOrCorner = tokens.filter(isIdentToken).map(function(ident) {
        return ident.value;
      }).join(" ");
      switch (sideOrCorner) {
        case "to bottom right":
        case "to right bottom":
        case "left top":
        case "top left":
          return [ZERO_LENGTH, ZERO_LENGTH];
        case "to top":
        case "bottom":
          return deg(0);
        case "to bottom left":
        case "to left bottom":
        case "right top":
        case "top right":
          return [ZERO_LENGTH, HUNDRED_PERCENT];
        case "to right":
        case "left":
          return deg(90);
        case "to top left":
        case "to left top":
        case "right bottom":
        case "bottom right":
          return [HUNDRED_PERCENT, HUNDRED_PERCENT];
        case "to bottom":
        case "top":
          return deg(180);
        case "to top right":
        case "to right top":
        case "left bottom":
        case "bottom left":
          return [HUNDRED_PERCENT, ZERO_LENGTH];
        case "to left":
        case "right":
          return deg(270);
      }
      return 0;
    };
    var deg = function(deg2) {
      return Math.PI * deg2 / 180;
    };
    var color$1 = {
      name: "color",
      parse: function(context, value) {
        if (value.type === 18) {
          var colorFunction = SUPPORTED_COLOR_FUNCTIONS[value.name];
          if (typeof colorFunction === "undefined") {
            throw new Error('Attempting to parse an unsupported color function "' + value.name + '"');
          }
          return colorFunction(context, value.values);
        }
        if (value.type === 5) {
          if (value.value.length === 3) {
            var r = value.value.substring(0, 1);
            var g = value.value.substring(1, 2);
            var b = value.value.substring(2, 3);
            return pack(parseInt(r + r, 16), parseInt(g + g, 16), parseInt(b + b, 16), 1);
          }
          if (value.value.length === 4) {
            var r = value.value.substring(0, 1);
            var g = value.value.substring(1, 2);
            var b = value.value.substring(2, 3);
            var a2 = value.value.substring(3, 4);
            return pack(parseInt(r + r, 16), parseInt(g + g, 16), parseInt(b + b, 16), parseInt(a2 + a2, 16) / 255);
          }
          if (value.value.length === 6) {
            var r = value.value.substring(0, 2);
            var g = value.value.substring(2, 4);
            var b = value.value.substring(4, 6);
            return pack(parseInt(r, 16), parseInt(g, 16), parseInt(b, 16), 1);
          }
          if (value.value.length === 8) {
            var r = value.value.substring(0, 2);
            var g = value.value.substring(2, 4);
            var b = value.value.substring(4, 6);
            var a2 = value.value.substring(6, 8);
            return pack(parseInt(r, 16), parseInt(g, 16), parseInt(b, 16), parseInt(a2, 16) / 255);
          }
        }
        if (value.type === 20) {
          var namedColor = COLORS[value.value.toUpperCase()];
          if (typeof namedColor !== "undefined") {
            return namedColor;
          }
        }
        return COLORS.TRANSPARENT;
      }
    };
    var isTransparent = function(color2) {
      return (255 & color2) === 0;
    };
    var asString = function(color2) {
      var alpha = 255 & color2;
      var blue = 255 & color2 >> 8;
      var green = 255 & color2 >> 16;
      var red = 255 & color2 >> 24;
      return alpha < 255 ? "rgba(" + red + "," + green + "," + blue + "," + alpha / 255 + ")" : "rgb(" + red + "," + green + "," + blue + ")";
    };
    var pack = function(r, g, b, a2) {
      return (r << 24 | g << 16 | b << 8 | Math.round(a2 * 255) << 0) >>> 0;
    };
    var getTokenColorValue = function(token, i4) {
      if (token.type === 17) {
        return token.number;
      }
      if (token.type === 16) {
        var max2 = i4 === 3 ? 1 : 255;
        return i4 === 3 ? token.number / 100 * max2 : Math.round(token.number / 100 * max2);
      }
      return 0;
    };
    var rgb = function(_context, args) {
      var tokens = args.filter(nonFunctionArgSeparator);
      if (tokens.length === 3) {
        var _a2 = tokens.map(getTokenColorValue), r = _a2[0], g = _a2[1], b = _a2[2];
        return pack(r, g, b, 1);
      }
      if (tokens.length === 4) {
        var _b2 = tokens.map(getTokenColorValue), r = _b2[0], g = _b2[1], b = _b2[2], a2 = _b2[3];
        return pack(r, g, b, a2);
      }
      return 0;
    };
    function hue2rgb(t1, t2, hue) {
      if (hue < 0) {
        hue += 1;
      }
      if (hue >= 1) {
        hue -= 1;
      }
      if (hue < 1 / 6) {
        return (t2 - t1) * hue * 6 + t1;
      } else if (hue < 1 / 2) {
        return t2;
      } else if (hue < 2 / 3) {
        return (t2 - t1) * 6 * (2 / 3 - hue) + t1;
      } else {
        return t1;
      }
    }
    var hsl = function(context, args) {
      var tokens = args.filter(nonFunctionArgSeparator);
      var hue = tokens[0], saturation = tokens[1], lightness = tokens[2], alpha = tokens[3];
      var h = (hue.type === 17 ? deg(hue.number) : angle.parse(context, hue)) / (Math.PI * 2);
      var s = isLengthPercentage(saturation) ? saturation.number / 100 : 0;
      var l = isLengthPercentage(lightness) ? lightness.number / 100 : 0;
      var a2 = typeof alpha !== "undefined" && isLengthPercentage(alpha) ? getAbsoluteValue(alpha, 1) : 1;
      if (s === 0) {
        return pack(l * 255, l * 255, l * 255, 1);
      }
      var t2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;
      var t1 = l * 2 - t2;
      var r = hue2rgb(t1, t2, h + 1 / 3);
      var g = hue2rgb(t1, t2, h);
      var b = hue2rgb(t1, t2, h - 1 / 3);
      return pack(r * 255, g * 255, b * 255, a2);
    };
    var SUPPORTED_COLOR_FUNCTIONS = {
      hsl,
      hsla: hsl,
      rgb,
      rgba: rgb
    };
    var parseColor = function(context, value) {
      return color$1.parse(context, Parser.create(value).parseComponentValue());
    };
    var COLORS = {
      ALICEBLUE: 4042850303,
      ANTIQUEWHITE: 4209760255,
      AQUA: 16777215,
      AQUAMARINE: 2147472639,
      AZURE: 4043309055,
      BEIGE: 4126530815,
      BISQUE: 4293182719,
      BLACK: 255,
      BLANCHEDALMOND: 4293643775,
      BLUE: 65535,
      BLUEVIOLET: 2318131967,
      BROWN: 2771004159,
      BURLYWOOD: 3736635391,
      CADETBLUE: 1604231423,
      CHARTREUSE: 2147418367,
      CHOCOLATE: 3530104575,
      CORAL: 4286533887,
      CORNFLOWERBLUE: 1687547391,
      CORNSILK: 4294499583,
      CRIMSON: 3692313855,
      CYAN: 16777215,
      DARKBLUE: 35839,
      DARKCYAN: 9145343,
      DARKGOLDENROD: 3095837695,
      DARKGRAY: 2846468607,
      DARKGREEN: 6553855,
      DARKGREY: 2846468607,
      DARKKHAKI: 3182914559,
      DARKMAGENTA: 2332068863,
      DARKOLIVEGREEN: 1433087999,
      DARKORANGE: 4287365375,
      DARKORCHID: 2570243327,
      DARKRED: 2332033279,
      DARKSALMON: 3918953215,
      DARKSEAGREEN: 2411499519,
      DARKSLATEBLUE: 1211993087,
      DARKSLATEGRAY: 793726975,
      DARKSLATEGREY: 793726975,
      DARKTURQUOISE: 13554175,
      DARKVIOLET: 2483082239,
      DEEPPINK: 4279538687,
      DEEPSKYBLUE: 12582911,
      DIMGRAY: 1768516095,
      DIMGREY: 1768516095,
      DODGERBLUE: 512819199,
      FIREBRICK: 2988581631,
      FLORALWHITE: 4294635775,
      FORESTGREEN: 579543807,
      FUCHSIA: 4278255615,
      GAINSBORO: 3705462015,
      GHOSTWHITE: 4177068031,
      GOLD: 4292280575,
      GOLDENROD: 3668254975,
      GRAY: 2155905279,
      GREEN: 8388863,
      GREENYELLOW: 2919182335,
      GREY: 2155905279,
      HONEYDEW: 4043305215,
      HOTPINK: 4285117695,
      INDIANRED: 3445382399,
      INDIGO: 1258324735,
      IVORY: 4294963455,
      KHAKI: 4041641215,
      LAVENDER: 3873897215,
      LAVENDERBLUSH: 4293981695,
      LAWNGREEN: 2096890111,
      LEMONCHIFFON: 4294626815,
      LIGHTBLUE: 2916673279,
      LIGHTCORAL: 4034953471,
      LIGHTCYAN: 3774873599,
      LIGHTGOLDENRODYELLOW: 4210742015,
      LIGHTGRAY: 3553874943,
      LIGHTGREEN: 2431553791,
      LIGHTGREY: 3553874943,
      LIGHTPINK: 4290167295,
      LIGHTSALMON: 4288707327,
      LIGHTSEAGREEN: 548580095,
      LIGHTSKYBLUE: 2278488831,
      LIGHTSLATEGRAY: 2005441023,
      LIGHTSLATEGREY: 2005441023,
      LIGHTSTEELBLUE: 2965692159,
      LIGHTYELLOW: 4294959359,
      LIME: 16711935,
      LIMEGREEN: 852308735,
      LINEN: 4210091775,
      MAGENTA: 4278255615,
      MAROON: 2147483903,
      MEDIUMAQUAMARINE: 1724754687,
      MEDIUMBLUE: 52735,
      MEDIUMORCHID: 3126187007,
      MEDIUMPURPLE: 2473647103,
      MEDIUMSEAGREEN: 1018393087,
      MEDIUMSLATEBLUE: 2070474495,
      MEDIUMSPRINGGREEN: 16423679,
      MEDIUMTURQUOISE: 1221709055,
      MEDIUMVIOLETRED: 3340076543,
      MIDNIGHTBLUE: 421097727,
      MINTCREAM: 4127193855,
      MISTYROSE: 4293190143,
      MOCCASIN: 4293178879,
      NAVAJOWHITE: 4292783615,
      NAVY: 33023,
      OLDLACE: 4260751103,
      OLIVE: 2155872511,
      OLIVEDRAB: 1804477439,
      ORANGE: 4289003775,
      ORANGERED: 4282712319,
      ORCHID: 3664828159,
      PALEGOLDENROD: 4008225535,
      PALEGREEN: 2566625535,
      PALETURQUOISE: 2951671551,
      PALEVIOLETRED: 3681588223,
      PAPAYAWHIP: 4293907967,
      PEACHPUFF: 4292524543,
      PERU: 3448061951,
      PINK: 4290825215,
      PLUM: 3718307327,
      POWDERBLUE: 2967529215,
      PURPLE: 2147516671,
      REBECCAPURPLE: 1714657791,
      RED: 4278190335,
      ROSYBROWN: 3163525119,
      ROYALBLUE: 1097458175,
      SADDLEBROWN: 2336560127,
      SALMON: 4202722047,
      SANDYBROWN: 4104413439,
      SEAGREEN: 780883967,
      SEASHELL: 4294307583,
      SIENNA: 2689740287,
      SILVER: 3233857791,
      SKYBLUE: 2278484991,
      SLATEBLUE: 1784335871,
      SLATEGRAY: 1887473919,
      SLATEGREY: 1887473919,
      SNOW: 4294638335,
      SPRINGGREEN: 16744447,
      STEELBLUE: 1182971135,
      TAN: 3535047935,
      TEAL: 8421631,
      THISTLE: 3636451583,
      TOMATO: 4284696575,
      TRANSPARENT: 0,
      TURQUOISE: 1088475391,
      VIOLET: 4001558271,
      WHEAT: 4125012991,
      WHITE: 4294967295,
      WHITESMOKE: 4126537215,
      YELLOW: 4294902015,
      YELLOWGREEN: 2597139199
    };
    var backgroundClip = {
      name: "background-clip",
      initialValue: "border-box",
      prefix: false,
      type: 1,
      parse: function(_context, tokens) {
        return tokens.map(function(token) {
          if (isIdentToken(token)) {
            switch (token.value) {
              case "padding-box":
                return 1;
              case "content-box":
                return 2;
            }
          }
          return 0;
        });
      }
    };
    var backgroundColor = {
      name: "background-color",
      initialValue: "transparent",
      prefix: false,
      type: 3,
      format: "color"
    };
    var parseColorStop = function(context, args) {
      var color2 = color$1.parse(context, args[0]);
      var stop = args[1];
      return stop && isLengthPercentage(stop) ? { color: color2, stop } : { color: color2, stop: null };
    };
    var processColorStops = function(stops, lineLength) {
      var first2 = stops[0];
      var last = stops[stops.length - 1];
      if (first2.stop === null) {
        first2.stop = ZERO_LENGTH;
      }
      if (last.stop === null) {
        last.stop = HUNDRED_PERCENT;
      }
      var processStops = [];
      var previous = 0;
      for (var i4 = 0;i4 < stops.length; i4++) {
        var stop_1 = stops[i4].stop;
        if (stop_1 !== null) {
          var absoluteValue = getAbsoluteValue(stop_1, lineLength);
          if (absoluteValue > previous) {
            processStops.push(absoluteValue);
          } else {
            processStops.push(previous);
          }
          previous = absoluteValue;
        } else {
          processStops.push(null);
        }
      }
      var gapBegin = null;
      for (var i4 = 0;i4 < processStops.length; i4++) {
        var stop_2 = processStops[i4];
        if (stop_2 === null) {
          if (gapBegin === null) {
            gapBegin = i4;
          }
        } else if (gapBegin !== null) {
          var gapLength = i4 - gapBegin;
          var beforeGap = processStops[gapBegin - 1];
          var gapValue = (stop_2 - beforeGap) / (gapLength + 1);
          for (var g = 1;g <= gapLength; g++) {
            processStops[gapBegin + g - 1] = gapValue * g;
          }
          gapBegin = null;
        }
      }
      return stops.map(function(_a2, i5) {
        var color2 = _a2.color;
        return { color: color2, stop: Math.max(Math.min(1, processStops[i5] / lineLength), 0) };
      });
    };
    var getAngleFromCorner = function(corner, width, height) {
      var centerX = width / 2;
      var centerY = height / 2;
      var x2 = getAbsoluteValue(corner[0], width) - centerX;
      var y = centerY - getAbsoluteValue(corner[1], height);
      return (Math.atan2(y, x2) + Math.PI * 2) % (Math.PI * 2);
    };
    var calculateGradientDirection = function(angle2, width, height) {
      var radian = typeof angle2 === "number" ? angle2 : getAngleFromCorner(angle2, width, height);
      var lineLength = Math.abs(width * Math.sin(radian)) + Math.abs(height * Math.cos(radian));
      var halfWidth = width / 2;
      var halfHeight = height / 2;
      var halfLineLength = lineLength / 2;
      var yDiff = Math.sin(radian - Math.PI / 2) * halfLineLength;
      var xDiff = Math.cos(radian - Math.PI / 2) * halfLineLength;
      return [lineLength, halfWidth - xDiff, halfWidth + xDiff, halfHeight - yDiff, halfHeight + yDiff];
    };
    var distance = function(a2, b) {
      return Math.sqrt(a2 * a2 + b * b);
    };
    var findCorner = function(width, height, x2, y, closest) {
      var corners = [
        [0, 0],
        [0, height],
        [width, 0],
        [width, height]
      ];
      return corners.reduce(function(stat, corner) {
        var cx = corner[0], cy = corner[1];
        var d = distance(x2 - cx, y - cy);
        if (closest ? d < stat.optimumDistance : d > stat.optimumDistance) {
          return {
            optimumCorner: corner,
            optimumDistance: d
          };
        }
        return stat;
      }, {
        optimumDistance: closest ? Infinity : -Infinity,
        optimumCorner: null
      }).optimumCorner;
    };
    var calculateRadius = function(gradient, x2, y, width, height) {
      var rx = 0;
      var ry = 0;
      switch (gradient.size) {
        case 0:
          if (gradient.shape === 0) {
            rx = ry = Math.min(Math.abs(x2), Math.abs(x2 - width), Math.abs(y), Math.abs(y - height));
          } else if (gradient.shape === 1) {
            rx = Math.min(Math.abs(x2), Math.abs(x2 - width));
            ry = Math.min(Math.abs(y), Math.abs(y - height));
          }
          break;
        case 2:
          if (gradient.shape === 0) {
            rx = ry = Math.min(distance(x2, y), distance(x2, y - height), distance(x2 - width, y), distance(x2 - width, y - height));
          } else if (gradient.shape === 1) {
            var c = Math.min(Math.abs(y), Math.abs(y - height)) / Math.min(Math.abs(x2), Math.abs(x2 - width));
            var _a2 = findCorner(width, height, x2, y, true), cx = _a2[0], cy = _a2[1];
            rx = distance(cx - x2, (cy - y) / c);
            ry = c * rx;
          }
          break;
        case 1:
          if (gradient.shape === 0) {
            rx = ry = Math.max(Math.abs(x2), Math.abs(x2 - width), Math.abs(y), Math.abs(y - height));
          } else if (gradient.shape === 1) {
            rx = Math.max(Math.abs(x2), Math.abs(x2 - width));
            ry = Math.max(Math.abs(y), Math.abs(y - height));
          }
          break;
        case 3:
          if (gradient.shape === 0) {
            rx = ry = Math.max(distance(x2, y), distance(x2, y - height), distance(x2 - width, y), distance(x2 - width, y - height));
          } else if (gradient.shape === 1) {
            var c = Math.max(Math.abs(y), Math.abs(y - height)) / Math.max(Math.abs(x2), Math.abs(x2 - width));
            var _b2 = findCorner(width, height, x2, y, false), cx = _b2[0], cy = _b2[1];
            rx = distance(cx - x2, (cy - y) / c);
            ry = c * rx;
          }
          break;
      }
      if (Array.isArray(gradient.size)) {
        rx = getAbsoluteValue(gradient.size[0], width);
        ry = gradient.size.length === 2 ? getAbsoluteValue(gradient.size[1], height) : rx;
      }
      return [rx, ry];
    };
    var linearGradient = function(context, tokens) {
      var angle$1 = deg(180);
      var stops = [];
      parseFunctionArgs(tokens).forEach(function(arg, i4) {
        if (i4 === 0) {
          var firstToken = arg[0];
          if (firstToken.type === 20 && firstToken.value === "to") {
            angle$1 = parseNamedSide(arg);
            return;
          } else if (isAngle(firstToken)) {
            angle$1 = angle.parse(context, firstToken);
            return;
          }
        }
        var colorStop = parseColorStop(context, arg);
        stops.push(colorStop);
      });
      return { angle: angle$1, stops, type: 1 };
    };
    var prefixLinearGradient = function(context, tokens) {
      var angle$1 = deg(180);
      var stops = [];
      parseFunctionArgs(tokens).forEach(function(arg, i4) {
        if (i4 === 0) {
          var firstToken = arg[0];
          if (firstToken.type === 20 && ["top", "left", "right", "bottom"].indexOf(firstToken.value) !== -1) {
            angle$1 = parseNamedSide(arg);
            return;
          } else if (isAngle(firstToken)) {
            angle$1 = (angle.parse(context, firstToken) + deg(270)) % deg(360);
            return;
          }
        }
        var colorStop = parseColorStop(context, arg);
        stops.push(colorStop);
      });
      return {
        angle: angle$1,
        stops,
        type: 1
      };
    };
    var webkitGradient = function(context, tokens) {
      var angle2 = deg(180);
      var stops = [];
      var type = 1;
      var shape = 0;
      var size = 3;
      var position2 = [];
      parseFunctionArgs(tokens).forEach(function(arg, i4) {
        var firstToken = arg[0];
        if (i4 === 0) {
          if (isIdentToken(firstToken) && firstToken.value === "linear") {
            type = 1;
            return;
          } else if (isIdentToken(firstToken) && firstToken.value === "radial") {
            type = 2;
            return;
          }
        }
        if (firstToken.type === 18) {
          if (firstToken.name === "from") {
            var color2 = color$1.parse(context, firstToken.values[0]);
            stops.push({ stop: ZERO_LENGTH, color: color2 });
          } else if (firstToken.name === "to") {
            var color2 = color$1.parse(context, firstToken.values[0]);
            stops.push({ stop: HUNDRED_PERCENT, color: color2 });
          } else if (firstToken.name === "color-stop") {
            var values = firstToken.values.filter(nonFunctionArgSeparator);
            if (values.length === 2) {
              var color2 = color$1.parse(context, values[1]);
              var stop_1 = values[0];
              if (isNumberToken(stop_1)) {
                stops.push({
                  stop: { type: 16, number: stop_1.number * 100, flags: stop_1.flags },
                  color: color2
                });
              }
            }
          }
        }
      });
      return type === 1 ? {
        angle: (angle2 + deg(180)) % deg(360),
        stops,
        type
      } : { size, shape, stops, position: position2, type };
    };
    var CLOSEST_SIDE = "closest-side";
    var FARTHEST_SIDE = "farthest-side";
    var CLOSEST_CORNER = "closest-corner";
    var FARTHEST_CORNER = "farthest-corner";
    var CIRCLE = "circle";
    var ELLIPSE = "ellipse";
    var COVER = "cover";
    var CONTAIN = "contain";
    var radialGradient = function(context, tokens) {
      var shape = 0;
      var size = 3;
      var stops = [];
      var position2 = [];
      parseFunctionArgs(tokens).forEach(function(arg, i4) {
        var isColorStop = true;
        if (i4 === 0) {
          var isAtPosition_1 = false;
          isColorStop = arg.reduce(function(acc, token) {
            if (isAtPosition_1) {
              if (isIdentToken(token)) {
                switch (token.value) {
                  case "center":
                    position2.push(FIFTY_PERCENT);
                    return acc;
                  case "top":
                  case "left":
                    position2.push(ZERO_LENGTH);
                    return acc;
                  case "right":
                  case "bottom":
                    position2.push(HUNDRED_PERCENT);
                    return acc;
                }
              } else if (isLengthPercentage(token) || isLength(token)) {
                position2.push(token);
              }
            } else if (isIdentToken(token)) {
              switch (token.value) {
                case CIRCLE:
                  shape = 0;
                  return false;
                case ELLIPSE:
                  shape = 1;
                  return false;
                case "at":
                  isAtPosition_1 = true;
                  return false;
                case CLOSEST_SIDE:
                  size = 0;
                  return false;
                case COVER:
                case FARTHEST_SIDE:
                  size = 1;
                  return false;
                case CONTAIN:
                case CLOSEST_CORNER:
                  size = 2;
                  return false;
                case FARTHEST_CORNER:
                  size = 3;
                  return false;
              }
            } else if (isLength(token) || isLengthPercentage(token)) {
              if (!Array.isArray(size)) {
                size = [];
              }
              size.push(token);
              return false;
            }
            return acc;
          }, isColorStop);
        }
        if (isColorStop) {
          var colorStop = parseColorStop(context, arg);
          stops.push(colorStop);
        }
      });
      return { size, shape, stops, position: position2, type: 2 };
    };
    var prefixRadialGradient = function(context, tokens) {
      var shape = 0;
      var size = 3;
      var stops = [];
      var position2 = [];
      parseFunctionArgs(tokens).forEach(function(arg, i4) {
        var isColorStop = true;
        if (i4 === 0) {
          isColorStop = arg.reduce(function(acc, token) {
            if (isIdentToken(token)) {
              switch (token.value) {
                case "center":
                  position2.push(FIFTY_PERCENT);
                  return false;
                case "top":
                case "left":
                  position2.push(ZERO_LENGTH);
                  return false;
                case "right":
                case "bottom":
                  position2.push(HUNDRED_PERCENT);
                  return false;
              }
            } else if (isLengthPercentage(token) || isLength(token)) {
              position2.push(token);
              return false;
            }
            return acc;
          }, isColorStop);
        } else if (i4 === 1) {
          isColorStop = arg.reduce(function(acc, token) {
            if (isIdentToken(token)) {
              switch (token.value) {
                case CIRCLE:
                  shape = 0;
                  return false;
                case ELLIPSE:
                  shape = 1;
                  return false;
                case CONTAIN:
                case CLOSEST_SIDE:
                  size = 0;
                  return false;
                case FARTHEST_SIDE:
                  size = 1;
                  return false;
                case CLOSEST_CORNER:
                  size = 2;
                  return false;
                case COVER:
                case FARTHEST_CORNER:
                  size = 3;
                  return false;
              }
            } else if (isLength(token) || isLengthPercentage(token)) {
              if (!Array.isArray(size)) {
                size = [];
              }
              size.push(token);
              return false;
            }
            return acc;
          }, isColorStop);
        }
        if (isColorStop) {
          var colorStop = parseColorStop(context, arg);
          stops.push(colorStop);
        }
      });
      return { size, shape, stops, position: position2, type: 2 };
    };
    var isLinearGradient = function(background) {
      return background.type === 1;
    };
    var isRadialGradient = function(background) {
      return background.type === 2;
    };
    var image = {
      name: "image",
      parse: function(context, value) {
        if (value.type === 22) {
          var image_1 = { url: value.value, type: 0 };
          context.cache.addImage(value.value);
          return image_1;
        }
        if (value.type === 18) {
          var imageFunction = SUPPORTED_IMAGE_FUNCTIONS[value.name];
          if (typeof imageFunction === "undefined") {
            throw new Error('Attempting to parse an unsupported image function "' + value.name + '"');
          }
          return imageFunction(context, value.values);
        }
        throw new Error("Unsupported image type " + value.type);
      }
    };
    function isSupportedImage(value) {
      return !(value.type === 20 && value.value === "none") && (value.type !== 18 || !!SUPPORTED_IMAGE_FUNCTIONS[value.name]);
    }
    var SUPPORTED_IMAGE_FUNCTIONS = {
      "linear-gradient": linearGradient,
      "-moz-linear-gradient": prefixLinearGradient,
      "-ms-linear-gradient": prefixLinearGradient,
      "-o-linear-gradient": prefixLinearGradient,
      "-webkit-linear-gradient": prefixLinearGradient,
      "radial-gradient": radialGradient,
      "-moz-radial-gradient": prefixRadialGradient,
      "-ms-radial-gradient": prefixRadialGradient,
      "-o-radial-gradient": prefixRadialGradient,
      "-webkit-radial-gradient": prefixRadialGradient,
      "-webkit-gradient": webkitGradient
    };
    var backgroundImage = {
      name: "background-image",
      initialValue: "none",
      type: 1,
      prefix: false,
      parse: function(context, tokens) {
        if (tokens.length === 0) {
          return [];
        }
        var first2 = tokens[0];
        if (first2.type === 20 && first2.value === "none") {
          return [];
        }
        return tokens.filter(function(value) {
          return nonFunctionArgSeparator(value) && isSupportedImage(value);
        }).map(function(value) {
          return image.parse(context, value);
        });
      }
    };
    var backgroundOrigin = {
      name: "background-origin",
      initialValue: "border-box",
      prefix: false,
      type: 1,
      parse: function(_context, tokens) {
        return tokens.map(function(token) {
          if (isIdentToken(token)) {
            switch (token.value) {
              case "padding-box":
                return 1;
              case "content-box":
                return 2;
            }
          }
          return 0;
        });
      }
    };
    var backgroundPosition = {
      name: "background-position",
      initialValue: "0% 0%",
      type: 1,
      prefix: false,
      parse: function(_context, tokens) {
        return parseFunctionArgs(tokens).map(function(values) {
          return values.filter(isLengthPercentage);
        }).map(parseLengthPercentageTuple);
      }
    };
    var backgroundRepeat = {
      name: "background-repeat",
      initialValue: "repeat",
      prefix: false,
      type: 1,
      parse: function(_context, tokens) {
        return parseFunctionArgs(tokens).map(function(values) {
          return values.filter(isIdentToken).map(function(token) {
            return token.value;
          }).join(" ");
        }).map(parseBackgroundRepeat);
      }
    };
    var parseBackgroundRepeat = function(value) {
      switch (value) {
        case "no-repeat":
          return 1;
        case "repeat-x":
        case "repeat no-repeat":
          return 2;
        case "repeat-y":
        case "no-repeat repeat":
          return 3;
        case "repeat":
        default:
          return 0;
      }
    };
    var BACKGROUND_SIZE;
    (function(BACKGROUND_SIZE2) {
      BACKGROUND_SIZE2["AUTO"] = "auto";
      BACKGROUND_SIZE2["CONTAIN"] = "contain";
      BACKGROUND_SIZE2["COVER"] = "cover";
    })(BACKGROUND_SIZE || (BACKGROUND_SIZE = {}));
    var backgroundSize = {
      name: "background-size",
      initialValue: "0",
      prefix: false,
      type: 1,
      parse: function(_context, tokens) {
        return parseFunctionArgs(tokens).map(function(values) {
          return values.filter(isBackgroundSizeInfoToken);
        });
      }
    };
    var isBackgroundSizeInfoToken = function(value) {
      return isIdentToken(value) || isLengthPercentage(value);
    };
    var borderColorForSide = function(side) {
      return {
        name: "border-" + side + "-color",
        initialValue: "transparent",
        prefix: false,
        type: 3,
        format: "color"
      };
    };
    var borderTopColor = borderColorForSide("top");
    var borderRightColor = borderColorForSide("right");
    var borderBottomColor = borderColorForSide("bottom");
    var borderLeftColor = borderColorForSide("left");
    var borderRadiusForSide = function(side) {
      return {
        name: "border-radius-" + side,
        initialValue: "0 0",
        prefix: false,
        type: 1,
        parse: function(_context, tokens) {
          return parseLengthPercentageTuple(tokens.filter(isLengthPercentage));
        }
      };
    };
    var borderTopLeftRadius = borderRadiusForSide("top-left");
    var borderTopRightRadius = borderRadiusForSide("top-right");
    var borderBottomRightRadius = borderRadiusForSide("bottom-right");
    var borderBottomLeftRadius = borderRadiusForSide("bottom-left");
    var borderStyleForSide = function(side) {
      return {
        name: "border-" + side + "-style",
        initialValue: "solid",
        prefix: false,
        type: 2,
        parse: function(_context, style2) {
          switch (style2) {
            case "none":
              return 0;
            case "dashed":
              return 2;
            case "dotted":
              return 3;
            case "double":
              return 4;
          }
          return 1;
        }
      };
    };
    var borderTopStyle = borderStyleForSide("top");
    var borderRightStyle = borderStyleForSide("right");
    var borderBottomStyle = borderStyleForSide("bottom");
    var borderLeftStyle = borderStyleForSide("left");
    var borderWidthForSide = function(side) {
      return {
        name: "border-" + side + "-width",
        initialValue: "0",
        type: 0,
        prefix: false,
        parse: function(_context, token) {
          if (isDimensionToken(token)) {
            return token.number;
          }
          return 0;
        }
      };
    };
    var borderTopWidth = borderWidthForSide("top");
    var borderRightWidth = borderWidthForSide("right");
    var borderBottomWidth = borderWidthForSide("bottom");
    var borderLeftWidth = borderWidthForSide("left");
    var color = {
      name: "color",
      initialValue: "transparent",
      prefix: false,
      type: 3,
      format: "color"
    };
    var direction = {
      name: "direction",
      initialValue: "ltr",
      prefix: false,
      type: 2,
      parse: function(_context, direction2) {
        switch (direction2) {
          case "rtl":
            return 1;
          case "ltr":
          default:
            return 0;
        }
      }
    };
    var display = {
      name: "display",
      initialValue: "inline-block",
      prefix: false,
      type: 1,
      parse: function(_context, tokens) {
        return tokens.filter(isIdentToken).reduce(function(bit, token) {
          return bit | parseDisplayValue(token.value);
        }, 0);
      }
    };
    var parseDisplayValue = function(display2) {
      switch (display2) {
        case "block":
        case "-webkit-box":
          return 2;
        case "inline":
          return 4;
        case "run-in":
          return 8;
        case "flow":
          return 16;
        case "flow-root":
          return 32;
        case "table":
          return 64;
        case "flex":
        case "-webkit-flex":
          return 128;
        case "grid":
        case "-ms-grid":
          return 256;
        case "ruby":
          return 512;
        case "subgrid":
          return 1024;
        case "list-item":
          return 2048;
        case "table-row-group":
          return 4096;
        case "table-header-group":
          return 8192;
        case "table-footer-group":
          return 16384;
        case "table-row":
          return 32768;
        case "table-cell":
          return 65536;
        case "table-column-group":
          return 131072;
        case "table-column":
          return 262144;
        case "table-caption":
          return 524288;
        case "ruby-base":
          return 1048576;
        case "ruby-text":
          return 2097152;
        case "ruby-base-container":
          return 4194304;
        case "ruby-text-container":
          return 8388608;
        case "contents":
          return 16777216;
        case "inline-block":
          return 33554432;
        case "inline-list-item":
          return 67108864;
        case "inline-table":
          return 134217728;
        case "inline-flex":
          return 268435456;
        case "inline-grid":
          return 536870912;
      }
      return 0;
    };
    var float = {
      name: "float",
      initialValue: "none",
      prefix: false,
      type: 2,
      parse: function(_context, float2) {
        switch (float2) {
          case "left":
            return 1;
          case "right":
            return 2;
          case "inline-start":
            return 3;
          case "inline-end":
            return 4;
        }
        return 0;
      }
    };
    var letterSpacing = {
      name: "letter-spacing",
      initialValue: "0",
      prefix: false,
      type: 0,
      parse: function(_context, token) {
        if (token.type === 20 && token.value === "normal") {
          return 0;
        }
        if (token.type === 17) {
          return token.number;
        }
        if (token.type === 15) {
          return token.number;
        }
        return 0;
      }
    };
    var LINE_BREAK;
    (function(LINE_BREAK2) {
      LINE_BREAK2["NORMAL"] = "normal";
      LINE_BREAK2["STRICT"] = "strict";
    })(LINE_BREAK || (LINE_BREAK = {}));
    var lineBreak = {
      name: "line-break",
      initialValue: "normal",
      prefix: false,
      type: 2,
      parse: function(_context, lineBreak2) {
        switch (lineBreak2) {
          case "strict":
            return LINE_BREAK.STRICT;
          case "normal":
          default:
            return LINE_BREAK.NORMAL;
        }
      }
    };
    var lineHeight = {
      name: "line-height",
      initialValue: "normal",
      prefix: false,
      type: 4
    };
    var computeLineHeight = function(token, fontSize2) {
      if (isIdentToken(token) && token.value === "normal") {
        return 1.2 * fontSize2;
      } else if (token.type === 17) {
        return fontSize2 * token.number;
      } else if (isLengthPercentage(token)) {
        return getAbsoluteValue(token, fontSize2);
      }
      return fontSize2;
    };
    var listStyleImage = {
      name: "list-style-image",
      initialValue: "none",
      type: 0,
      prefix: false,
      parse: function(context, token) {
        if (token.type === 20 && token.value === "none") {
          return null;
        }
        return image.parse(context, token);
      }
    };
    var listStylePosition = {
      name: "list-style-position",
      initialValue: "outside",
      prefix: false,
      type: 2,
      parse: function(_context, position2) {
        switch (position2) {
          case "inside":
            return 0;
          case "outside":
          default:
            return 1;
        }
      }
    };
    var listStyleType = {
      name: "list-style-type",
      initialValue: "none",
      prefix: false,
      type: 2,
      parse: function(_context, type) {
        switch (type) {
          case "disc":
            return 0;
          case "circle":
            return 1;
          case "square":
            return 2;
          case "decimal":
            return 3;
          case "cjk-decimal":
            return 4;
          case "decimal-leading-zero":
            return 5;
          case "lower-roman":
            return 6;
          case "upper-roman":
            return 7;
          case "lower-greek":
            return 8;
          case "lower-alpha":
            return 9;
          case "upper-alpha":
            return 10;
          case "arabic-indic":
            return 11;
          case "armenian":
            return 12;
          case "bengali":
            return 13;
          case "cambodian":
            return 14;
          case "cjk-earthly-branch":
            return 15;
          case "cjk-heavenly-stem":
            return 16;
          case "cjk-ideographic":
            return 17;
          case "devanagari":
            return 18;
          case "ethiopic-numeric":
            return 19;
          case "georgian":
            return 20;
          case "gujarati":
            return 21;
          case "gurmukhi":
            return 22;
          case "hebrew":
            return 22;
          case "hiragana":
            return 23;
          case "hiragana-iroha":
            return 24;
          case "japanese-formal":
            return 25;
          case "japanese-informal":
            return 26;
          case "kannada":
            return 27;
          case "katakana":
            return 28;
          case "katakana-iroha":
            return 29;
          case "khmer":
            return 30;
          case "korean-hangul-formal":
            return 31;
          case "korean-hanja-formal":
            return 32;
          case "korean-hanja-informal":
            return 33;
          case "lao":
            return 34;
          case "lower-armenian":
            return 35;
          case "malayalam":
            return 36;
          case "mongolian":
            return 37;
          case "myanmar":
            return 38;
          case "oriya":
            return 39;
          case "persian":
            return 40;
          case "simp-chinese-formal":
            return 41;
          case "simp-chinese-informal":
            return 42;
          case "tamil":
            return 43;
          case "telugu":
            return 44;
          case "thai":
            return 45;
          case "tibetan":
            return 46;
          case "trad-chinese-formal":
            return 47;
          case "trad-chinese-informal":
            return 48;
          case "upper-armenian":
            return 49;
          case "disclosure-open":
            return 50;
          case "disclosure-closed":
            return 51;
          case "none":
          default:
            return -1;
        }
      }
    };
    var marginForSide = function(side) {
      return {
        name: "margin-" + side,
        initialValue: "0",
        prefix: false,
        type: 4
      };
    };
    var marginTop = marginForSide("top");
    var marginRight = marginForSide("right");
    var marginBottom = marginForSide("bottom");
    var marginLeft = marginForSide("left");
    var overflow = {
      name: "overflow",
      initialValue: "visible",
      prefix: false,
      type: 1,
      parse: function(_context, tokens) {
        return tokens.filter(isIdentToken).map(function(overflow2) {
          switch (overflow2.value) {
            case "hidden":
              return 1;
            case "scroll":
              return 2;
            case "clip":
              return 3;
            case "auto":
              return 4;
            case "visible":
            default:
              return 0;
          }
        });
      }
    };
    var overflowWrap = {
      name: "overflow-wrap",
      initialValue: "normal",
      prefix: false,
      type: 2,
      parse: function(_context, overflow2) {
        switch (overflow2) {
          case "break-word":
            return "break-word";
          case "normal":
          default:
            return "normal";
        }
      }
    };
    var paddingForSide = function(side) {
      return {
        name: "padding-" + side,
        initialValue: "0",
        prefix: false,
        type: 3,
        format: "length-percentage"
      };
    };
    var paddingTop = paddingForSide("top");
    var paddingRight = paddingForSide("right");
    var paddingBottom = paddingForSide("bottom");
    var paddingLeft = paddingForSide("left");
    var textAlign = {
      name: "text-align",
      initialValue: "left",
      prefix: false,
      type: 2,
      parse: function(_context, textAlign2) {
        switch (textAlign2) {
          case "right":
            return 2;
          case "center":
          case "justify":
            return 1;
          case "left":
          default:
            return 0;
        }
      }
    };
    var position = {
      name: "position",
      initialValue: "static",
      prefix: false,
      type: 2,
      parse: function(_context, position2) {
        switch (position2) {
          case "relative":
            return 1;
          case "absolute":
            return 2;
          case "fixed":
            return 3;
          case "sticky":
            return 4;
        }
        return 0;
      }
    };
    var textShadow = {
      name: "text-shadow",
      initialValue: "none",
      type: 1,
      prefix: false,
      parse: function(context, tokens) {
        if (tokens.length === 1 && isIdentWithValue(tokens[0], "none")) {
          return [];
        }
        return parseFunctionArgs(tokens).map(function(values) {
          var shadow = {
            color: COLORS.TRANSPARENT,
            offsetX: ZERO_LENGTH,
            offsetY: ZERO_LENGTH,
            blur: ZERO_LENGTH
          };
          var c = 0;
          for (var i4 = 0;i4 < values.length; i4++) {
            var token = values[i4];
            if (isLength(token)) {
              if (c === 0) {
                shadow.offsetX = token;
              } else if (c === 1) {
                shadow.offsetY = token;
              } else {
                shadow.blur = token;
              }
              c++;
            } else {
              shadow.color = color$1.parse(context, token);
            }
          }
          return shadow;
        });
      }
    };
    var textTransform = {
      name: "text-transform",
      initialValue: "none",
      prefix: false,
      type: 2,
      parse: function(_context, textTransform2) {
        switch (textTransform2) {
          case "uppercase":
            return 2;
          case "lowercase":
            return 1;
          case "capitalize":
            return 3;
        }
        return 0;
      }
    };
    var transform$1 = {
      name: "transform",
      initialValue: "none",
      prefix: true,
      type: 0,
      parse: function(_context, token) {
        if (token.type === 20 && token.value === "none") {
          return null;
        }
        if (token.type === 18) {
          var transformFunction = SUPPORTED_TRANSFORM_FUNCTIONS[token.name];
          if (typeof transformFunction === "undefined") {
            throw new Error('Attempting to parse an unsupported transform function "' + token.name + '"');
          }
          return transformFunction(token.values);
        }
        return null;
      }
    };
    var matrix = function(args) {
      var values = args.filter(function(arg) {
        return arg.type === 17;
      }).map(function(arg) {
        return arg.number;
      });
      return values.length === 6 ? values : null;
    };
    var matrix3d = function(args) {
      var values = args.filter(function(arg) {
        return arg.type === 17;
      }).map(function(arg) {
        return arg.number;
      });
      var a1 = values[0], b1 = values[1];
      values[2];
      values[3];
      var a2 = values[4], b2 = values[5];
      values[6];
      values[7];
      values[8];
      values[9];
      values[10];
      values[11];
      var a4 = values[12], b4 = values[13];
      values[14];
      values[15];
      return values.length === 16 ? [a1, b1, a2, b2, a4, b4] : null;
    };
    var SUPPORTED_TRANSFORM_FUNCTIONS = {
      matrix,
      matrix3d
    };
    var DEFAULT_VALUE = {
      type: 16,
      number: 50,
      flags: FLAG_INTEGER
    };
    var DEFAULT = [DEFAULT_VALUE, DEFAULT_VALUE];
    var transformOrigin = {
      name: "transform-origin",
      initialValue: "50% 50%",
      prefix: true,
      type: 1,
      parse: function(_context, tokens) {
        var origins = tokens.filter(isLengthPercentage);
        if (origins.length !== 2) {
          return DEFAULT;
        }
        return [origins[0], origins[1]];
      }
    };
    var visibility = {
      name: "visible",
      initialValue: "none",
      prefix: false,
      type: 2,
      parse: function(_context, visibility2) {
        switch (visibility2) {
          case "hidden":
            return 1;
          case "collapse":
            return 2;
          case "visible":
          default:
            return 0;
        }
      }
    };
    var WORD_BREAK;
    (function(WORD_BREAK2) {
      WORD_BREAK2["NORMAL"] = "normal";
      WORD_BREAK2["BREAK_ALL"] = "break-all";
      WORD_BREAK2["KEEP_ALL"] = "keep-all";
    })(WORD_BREAK || (WORD_BREAK = {}));
    var wordBreak = {
      name: "word-break",
      initialValue: "normal",
      prefix: false,
      type: 2,
      parse: function(_context, wordBreak2) {
        switch (wordBreak2) {
          case "break-all":
            return WORD_BREAK.BREAK_ALL;
          case "keep-all":
            return WORD_BREAK.KEEP_ALL;
          case "normal":
          default:
            return WORD_BREAK.NORMAL;
        }
      }
    };
    var zIndex = {
      name: "z-index",
      initialValue: "auto",
      prefix: false,
      type: 0,
      parse: function(_context, token) {
        if (token.type === 20) {
          return { auto: true, order: 0 };
        }
        if (isNumberToken(token)) {
          return { auto: false, order: token.number };
        }
        throw new Error("Invalid z-index number parsed");
      }
    };
    var time = {
      name: "time",
      parse: function(_context, value) {
        if (value.type === 15) {
          switch (value.unit.toLowerCase()) {
            case "s":
              return 1000 * value.number;
            case "ms":
              return value.number;
          }
        }
        throw new Error("Unsupported time type");
      }
    };
    var opacity = {
      name: "opacity",
      initialValue: "1",
      type: 0,
      prefix: false,
      parse: function(_context, token) {
        if (isNumberToken(token)) {
          return token.number;
        }
        return 1;
      }
    };
    var textDecorationColor = {
      name: "text-decoration-color",
      initialValue: "transparent",
      prefix: false,
      type: 3,
      format: "color"
    };
    var textDecorationLine = {
      name: "text-decoration-line",
      initialValue: "none",
      prefix: false,
      type: 1,
      parse: function(_context, tokens) {
        return tokens.filter(isIdentToken).map(function(token) {
          switch (token.value) {
            case "underline":
              return 1;
            case "overline":
              return 2;
            case "line-through":
              return 3;
            case "none":
              return 4;
          }
          return 0;
        }).filter(function(line) {
          return line !== 0;
        });
      }
    };
    var fontFamily = {
      name: "font-family",
      initialValue: "",
      prefix: false,
      type: 1,
      parse: function(_context, tokens) {
        var accumulator = [];
        var results = [];
        tokens.forEach(function(token) {
          switch (token.type) {
            case 20:
            case 0:
              accumulator.push(token.value);
              break;
            case 17:
              accumulator.push(token.number.toString());
              break;
            case 4:
              results.push(accumulator.join(" "));
              accumulator.length = 0;
              break;
          }
        });
        if (accumulator.length) {
          results.push(accumulator.join(" "));
        }
        return results.map(function(result) {
          return result.indexOf(" ") === -1 ? result : "'" + result + "'";
        });
      }
    };
    var fontSize = {
      name: "font-size",
      initialValue: "0",
      prefix: false,
      type: 3,
      format: "length"
    };
    var fontWeight = {
      name: "font-weight",
      initialValue: "normal",
      type: 0,
      prefix: false,
      parse: function(_context, token) {
        if (isNumberToken(token)) {
          return token.number;
        }
        if (isIdentToken(token)) {
          switch (token.value) {
            case "bold":
              return 700;
            case "normal":
            default:
              return 400;
          }
        }
        return 400;
      }
    };
    var fontVariant = {
      name: "font-variant",
      initialValue: "none",
      type: 1,
      prefix: false,
      parse: function(_context, tokens) {
        return tokens.filter(isIdentToken).map(function(token) {
          return token.value;
        });
      }
    };
    var fontStyle = {
      name: "font-style",
      initialValue: "normal",
      prefix: false,
      type: 2,
      parse: function(_context, overflow2) {
        switch (overflow2) {
          case "oblique":
            return "oblique";
          case "italic":
            return "italic";
          case "normal":
          default:
            return "normal";
        }
      }
    };
    var contains = function(bit, value) {
      return (bit & value) !== 0;
    };
    var content = {
      name: "content",
      initialValue: "none",
      type: 1,
      prefix: false,
      parse: function(_context, tokens) {
        if (tokens.length === 0) {
          return [];
        }
        var first2 = tokens[0];
        if (first2.type === 20 && first2.value === "none") {
          return [];
        }
        return tokens;
      }
    };
    var counterIncrement = {
      name: "counter-increment",
      initialValue: "none",
      prefix: true,
      type: 1,
      parse: function(_context, tokens) {
        if (tokens.length === 0) {
          return null;
        }
        var first2 = tokens[0];
        if (first2.type === 20 && first2.value === "none") {
          return null;
        }
        var increments = [];
        var filtered = tokens.filter(nonWhiteSpace);
        for (var i4 = 0;i4 < filtered.length; i4++) {
          var counter = filtered[i4];
          var next = filtered[i4 + 1];
          if (counter.type === 20) {
            var increment = next && isNumberToken(next) ? next.number : 1;
            increments.push({ counter: counter.value, increment });
          }
        }
        return increments;
      }
    };
    var counterReset = {
      name: "counter-reset",
      initialValue: "none",
      prefix: true,
      type: 1,
      parse: function(_context, tokens) {
        if (tokens.length === 0) {
          return [];
        }
        var resets = [];
        var filtered = tokens.filter(nonWhiteSpace);
        for (var i4 = 0;i4 < filtered.length; i4++) {
          var counter = filtered[i4];
          var next = filtered[i4 + 1];
          if (isIdentToken(counter) && counter.value !== "none") {
            var reset = next && isNumberToken(next) ? next.number : 0;
            resets.push({ counter: counter.value, reset });
          }
        }
        return resets;
      }
    };
    var duration = {
      name: "duration",
      initialValue: "0s",
      prefix: false,
      type: 1,
      parse: function(context, tokens) {
        return tokens.filter(isDimensionToken).map(function(token) {
          return time.parse(context, token);
        });
      }
    };
    var quotes = {
      name: "quotes",
      initialValue: "none",
      prefix: true,
      type: 1,
      parse: function(_context, tokens) {
        if (tokens.length === 0) {
          return null;
        }
        var first2 = tokens[0];
        if (first2.type === 20 && first2.value === "none") {
          return null;
        }
        var quotes2 = [];
        var filtered = tokens.filter(isStringToken);
        if (filtered.length % 2 !== 0) {
          return null;
        }
        for (var i4 = 0;i4 < filtered.length; i4 += 2) {
          var open_1 = filtered[i4].value;
          var close_1 = filtered[i4 + 1].value;
          quotes2.push({ open: open_1, close: close_1 });
        }
        return quotes2;
      }
    };
    var getQuote = function(quotes2, depth, open2) {
      if (!quotes2) {
        return "";
      }
      var quote = quotes2[Math.min(depth, quotes2.length - 1)];
      if (!quote) {
        return "";
      }
      return open2 ? quote.open : quote.close;
    };
    var boxShadow = {
      name: "box-shadow",
      initialValue: "none",
      type: 1,
      prefix: false,
      parse: function(context, tokens) {
        if (tokens.length === 1 && isIdentWithValue(tokens[0], "none")) {
          return [];
        }
        return parseFunctionArgs(tokens).map(function(values) {
          var shadow = {
            color: 255,
            offsetX: ZERO_LENGTH,
            offsetY: ZERO_LENGTH,
            blur: ZERO_LENGTH,
            spread: ZERO_LENGTH,
            inset: false
          };
          var c = 0;
          for (var i4 = 0;i4 < values.length; i4++) {
            var token = values[i4];
            if (isIdentWithValue(token, "inset")) {
              shadow.inset = true;
            } else if (isLength(token)) {
              if (c === 0) {
                shadow.offsetX = token;
              } else if (c === 1) {
                shadow.offsetY = token;
              } else if (c === 2) {
                shadow.blur = token;
              } else {
                shadow.spread = token;
              }
              c++;
            } else {
              shadow.color = color$1.parse(context, token);
            }
          }
          return shadow;
        });
      }
    };
    var paintOrder = {
      name: "paint-order",
      initialValue: "normal",
      prefix: false,
      type: 1,
      parse: function(_context, tokens) {
        var DEFAULT_VALUE2 = [0, 1, 2];
        var layers = [];
        tokens.filter(isIdentToken).forEach(function(token) {
          switch (token.value) {
            case "stroke":
              layers.push(1);
              break;
            case "fill":
              layers.push(0);
              break;
            case "markers":
              layers.push(2);
              break;
          }
        });
        DEFAULT_VALUE2.forEach(function(value) {
          if (layers.indexOf(value) === -1) {
            layers.push(value);
          }
        });
        return layers;
      }
    };
    var webkitTextStrokeColor = {
      name: "-webkit-text-stroke-color",
      initialValue: "currentcolor",
      prefix: false,
      type: 3,
      format: "color"
    };
    var webkitTextStrokeWidth = {
      name: "-webkit-text-stroke-width",
      initialValue: "0",
      type: 0,
      prefix: false,
      parse: function(_context, token) {
        if (isDimensionToken(token)) {
          return token.number;
        }
        return 0;
      }
    };
    var CSSParsedDeclaration = function() {
      function CSSParsedDeclaration2(context, declaration) {
        var _a2, _b2;
        this.animationDuration = parse(context, duration, declaration.animationDuration);
        this.backgroundClip = parse(context, backgroundClip, declaration.backgroundClip);
        this.backgroundColor = parse(context, backgroundColor, declaration.backgroundColor);
        this.backgroundImage = parse(context, backgroundImage, declaration.backgroundImage);
        this.backgroundOrigin = parse(context, backgroundOrigin, declaration.backgroundOrigin);
        this.backgroundPosition = parse(context, backgroundPosition, declaration.backgroundPosition);
        this.backgroundRepeat = parse(context, backgroundRepeat, declaration.backgroundRepeat);
        this.backgroundSize = parse(context, backgroundSize, declaration.backgroundSize);
        this.borderTopColor = parse(context, borderTopColor, declaration.borderTopColor);
        this.borderRightColor = parse(context, borderRightColor, declaration.borderRightColor);
        this.borderBottomColor = parse(context, borderBottomColor, declaration.borderBottomColor);
        this.borderLeftColor = parse(context, borderLeftColor, declaration.borderLeftColor);
        this.borderTopLeftRadius = parse(context, borderTopLeftRadius, declaration.borderTopLeftRadius);
        this.borderTopRightRadius = parse(context, borderTopRightRadius, declaration.borderTopRightRadius);
        this.borderBottomRightRadius = parse(context, borderBottomRightRadius, declaration.borderBottomRightRadius);
        this.borderBottomLeftRadius = parse(context, borderBottomLeftRadius, declaration.borderBottomLeftRadius);
        this.borderTopStyle = parse(context, borderTopStyle, declaration.borderTopStyle);
        this.borderRightStyle = parse(context, borderRightStyle, declaration.borderRightStyle);
        this.borderBottomStyle = parse(context, borderBottomStyle, declaration.borderBottomStyle);
        this.borderLeftStyle = parse(context, borderLeftStyle, declaration.borderLeftStyle);
        this.borderTopWidth = parse(context, borderTopWidth, declaration.borderTopWidth);
        this.borderRightWidth = parse(context, borderRightWidth, declaration.borderRightWidth);
        this.borderBottomWidth = parse(context, borderBottomWidth, declaration.borderBottomWidth);
        this.borderLeftWidth = parse(context, borderLeftWidth, declaration.borderLeftWidth);
        this.boxShadow = parse(context, boxShadow, declaration.boxShadow);
        this.color = parse(context, color, declaration.color);
        this.direction = parse(context, direction, declaration.direction);
        this.display = parse(context, display, declaration.display);
        this.float = parse(context, float, declaration.cssFloat);
        this.fontFamily = parse(context, fontFamily, declaration.fontFamily);
        this.fontSize = parse(context, fontSize, declaration.fontSize);
        this.fontStyle = parse(context, fontStyle, declaration.fontStyle);
        this.fontVariant = parse(context, fontVariant, declaration.fontVariant);
        this.fontWeight = parse(context, fontWeight, declaration.fontWeight);
        this.letterSpacing = parse(context, letterSpacing, declaration.letterSpacing);
        this.lineBreak = parse(context, lineBreak, declaration.lineBreak);
        this.lineHeight = parse(context, lineHeight, declaration.lineHeight);
        this.listStyleImage = parse(context, listStyleImage, declaration.listStyleImage);
        this.listStylePosition = parse(context, listStylePosition, declaration.listStylePosition);
        this.listStyleType = parse(context, listStyleType, declaration.listStyleType);
        this.marginTop = parse(context, marginTop, declaration.marginTop);
        this.marginRight = parse(context, marginRight, declaration.marginRight);
        this.marginBottom = parse(context, marginBottom, declaration.marginBottom);
        this.marginLeft = parse(context, marginLeft, declaration.marginLeft);
        this.opacity = parse(context, opacity, declaration.opacity);
        var overflowTuple = parse(context, overflow, declaration.overflow);
        this.overflowX = overflowTuple[0];
        this.overflowY = overflowTuple[overflowTuple.length > 1 ? 1 : 0];
        this.overflowWrap = parse(context, overflowWrap, declaration.overflowWrap);
        this.paddingTop = parse(context, paddingTop, declaration.paddingTop);
        this.paddingRight = parse(context, paddingRight, declaration.paddingRight);
        this.paddingBottom = parse(context, paddingBottom, declaration.paddingBottom);
        this.paddingLeft = parse(context, paddingLeft, declaration.paddingLeft);
        this.paintOrder = parse(context, paintOrder, declaration.paintOrder);
        this.position = parse(context, position, declaration.position);
        this.textAlign = parse(context, textAlign, declaration.textAlign);
        this.textDecorationColor = parse(context, textDecorationColor, (_a2 = declaration.textDecorationColor) !== null && _a2 !== undefined ? _a2 : declaration.color);
        this.textDecorationLine = parse(context, textDecorationLine, (_b2 = declaration.textDecorationLine) !== null && _b2 !== undefined ? _b2 : declaration.textDecoration);
        this.textShadow = parse(context, textShadow, declaration.textShadow);
        this.textTransform = parse(context, textTransform, declaration.textTransform);
        this.transform = parse(context, transform$1, declaration.transform);
        this.transformOrigin = parse(context, transformOrigin, declaration.transformOrigin);
        this.visibility = parse(context, visibility, declaration.visibility);
        this.webkitTextStrokeColor = parse(context, webkitTextStrokeColor, declaration.webkitTextStrokeColor);
        this.webkitTextStrokeWidth = parse(context, webkitTextStrokeWidth, declaration.webkitTextStrokeWidth);
        this.wordBreak = parse(context, wordBreak, declaration.wordBreak);
        this.zIndex = parse(context, zIndex, declaration.zIndex);
      }
      CSSParsedDeclaration2.prototype.isVisible = function() {
        return this.display > 0 && this.opacity > 0 && this.visibility === 0;
      };
      CSSParsedDeclaration2.prototype.isTransparent = function() {
        return isTransparent(this.backgroundColor);
      };
      CSSParsedDeclaration2.prototype.isTransformed = function() {
        return this.transform !== null;
      };
      CSSParsedDeclaration2.prototype.isPositioned = function() {
        return this.position !== 0;
      };
      CSSParsedDeclaration2.prototype.isPositionedWithZIndex = function() {
        return this.isPositioned() && !this.zIndex.auto;
      };
      CSSParsedDeclaration2.prototype.isFloating = function() {
        return this.float !== 0;
      };
      CSSParsedDeclaration2.prototype.isInlineLevel = function() {
        return contains(this.display, 4) || contains(this.display, 33554432) || contains(this.display, 268435456) || contains(this.display, 536870912) || contains(this.display, 67108864) || contains(this.display, 134217728);
      };
      return CSSParsedDeclaration2;
    }();
    var CSSParsedPseudoDeclaration = function() {
      function CSSParsedPseudoDeclaration2(context, declaration) {
        this.content = parse(context, content, declaration.content);
        this.quotes = parse(context, quotes, declaration.quotes);
      }
      return CSSParsedPseudoDeclaration2;
    }();
    var CSSParsedCounterDeclaration = function() {
      function CSSParsedCounterDeclaration2(context, declaration) {
        this.counterIncrement = parse(context, counterIncrement, declaration.counterIncrement);
        this.counterReset = parse(context, counterReset, declaration.counterReset);
      }
      return CSSParsedCounterDeclaration2;
    }();
    var parse = function(context, descriptor, style2) {
      var tokenizer = new Tokenizer;
      var value = style2 !== null && typeof style2 !== "undefined" ? style2.toString() : descriptor.initialValue;
      tokenizer.write(value);
      var parser = new Parser(tokenizer.read());
      switch (descriptor.type) {
        case 2:
          var token = parser.parseComponentValue();
          return descriptor.parse(context, isIdentToken(token) ? token.value : descriptor.initialValue);
        case 0:
          return descriptor.parse(context, parser.parseComponentValue());
        case 1:
          return descriptor.parse(context, parser.parseComponentValues());
        case 4:
          return parser.parseComponentValue();
        case 3:
          switch (descriptor.format) {
            case "angle":
              return angle.parse(context, parser.parseComponentValue());
            case "color":
              return color$1.parse(context, parser.parseComponentValue());
            case "image":
              return image.parse(context, parser.parseComponentValue());
            case "length":
              var length_1 = parser.parseComponentValue();
              return isLength(length_1) ? length_1 : ZERO_LENGTH;
            case "length-percentage":
              var value_1 = parser.parseComponentValue();
              return isLengthPercentage(value_1) ? value_1 : ZERO_LENGTH;
            case "time":
              return time.parse(context, parser.parseComponentValue());
          }
          break;
      }
    };
    var elementDebuggerAttribute = "data-html2canvas-debug";
    var getElementDebugType = function(element) {
      var attribute = element.getAttribute(elementDebuggerAttribute);
      switch (attribute) {
        case "all":
          return 1;
        case "clone":
          return 2;
        case "parse":
          return 3;
        case "render":
          return 4;
        default:
          return 0;
      }
    };
    var isDebugging = function(element, type) {
      var elementType = getElementDebugType(element);
      return elementType === 1 || type === elementType;
    };
    var ElementContainer = function() {
      function ElementContainer2(context, element) {
        this.context = context;
        this.textNodes = [];
        this.elements = [];
        this.flags = 0;
        if (isDebugging(element, 3)) {
          debugger;
        }
        this.styles = new CSSParsedDeclaration(context, window.getComputedStyle(element, null));
        if (isHTMLElementNode(element)) {
          if (this.styles.animationDuration.some(function(duration2) {
            return duration2 > 0;
          })) {
            element.style.animationDuration = "0s";
          }
          if (this.styles.transform !== null) {
            element.style.transform = "none";
          }
        }
        this.bounds = parseBounds(this.context, element);
        if (isDebugging(element, 4)) {
          this.flags |= 16;
        }
      }
      return ElementContainer2;
    }();
    var base64 = "AAAAAAAAAAAAEA4AGBkAAFAaAAACAAAAAAAIABAAGAAwADgACAAQAAgAEAAIABAACAAQAAgAEAAIABAACAAQAAgAEAAIABAAQABIAEQATAAIABAACAAQAAgAEAAIABAAVABcAAgAEAAIABAACAAQAGAAaABwAHgAgACIAI4AlgAIABAAmwCjAKgAsAC2AL4AvQDFAMoA0gBPAVYBWgEIAAgACACMANoAYgFkAWwBdAF8AX0BhQGNAZUBlgGeAaMBlQGWAasBswF8AbsBwwF0AcsBYwHTAQgA2wG/AOMBdAF8AekB8QF0AfkB+wHiAHQBfAEIAAMC5gQIAAsCEgIIAAgAFgIeAggAIgIpAggAMQI5AkACygEIAAgASAJQAlgCYAIIAAgACAAKBQoFCgUTBRMFGQUrBSsFCAAIAAgACAAIAAgACAAIAAgACABdAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABoAmgCrwGvAQgAbgJ2AggAHgEIAAgACADnAXsCCAAIAAgAgwIIAAgACAAIAAgACACKAggAkQKZAggAPADJAAgAoQKkAqwCsgK6AsICCADJAggA0AIIAAgACAAIANYC3gIIAAgACAAIAAgACABAAOYCCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAkASoB+QIEAAgACAA8AEMCCABCBQgACABJBVAFCAAIAAgACAAIAAgACAAIAAgACABTBVoFCAAIAFoFCABfBWUFCAAIAAgACAAIAAgAbQUIAAgACAAIAAgACABzBXsFfQWFBYoFigWKBZEFigWKBYoFmAWfBaYFrgWxBbkFCAAIAAgACAAIAAgACAAIAAgACAAIAMEFCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAMgFCADQBQgACAAIAAgACAAIAAgACAAIAAgACAAIAO4CCAAIAAgAiQAIAAgACABAAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAD0AggACAD8AggACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIANYFCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAMDvwAIAAgAJAIIAAgACAAIAAgACAAIAAgACwMTAwgACAB9BOsEGwMjAwgAKwMyAwsFYgE3A/MEPwMIAEUDTQNRAwgAWQOsAGEDCAAIAAgACAAIAAgACABpAzQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFIQUoBSwFCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABtAwgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABMAEwACAAIAAgACAAIABgACAAIAAgACAC/AAgACAAyAQgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACACAAIAAwAAgACAAIAAgACAAIAAgACAAIAAAARABIAAgACAAIABQASAAIAAgAIABwAEAAjgCIABsAqAC2AL0AigDQAtwC+IJIQqVAZUBWQqVAZUBlQGVAZUBlQGrC5UBlQGVAZUBlQGVAZUBlQGVAXsKlQGVAbAK6wsrDGUMpQzlDJUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAfAKAAuZA64AtwCJALoC6ADwAAgAuACgA/oEpgO6AqsD+AAIAAgAswMIAAgACAAIAIkAuwP5AfsBwwPLAwgACAAIAAgACADRA9kDCAAIAOED6QMIAAgACAAIAAgACADuA/YDCAAIAP4DyQAIAAgABgQIAAgAXQAOBAgACAAIAAgACAAIABMECAAIAAgACAAIAAgACAD8AAQBCAAIAAgAGgQiBCoECAExBAgAEAEIAAgACAAIAAgACAAIAAgACAAIAAgACAA4BAgACABABEYECAAIAAgATAQYAQgAVAQIAAgACAAIAAgACAAIAAgACAAIAFoECAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAOQEIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAB+BAcACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAEABhgSMBAgACAAIAAgAlAQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAwAEAAQABAADAAMAAwADAAQABAAEAAQABAAEAAQABHATAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAdQMIAAgACAAIAAgACAAIAMkACAAIAAgAfQMIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACACFA4kDCAAIAAgACAAIAOcBCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAIcDCAAIAAgACAAIAAgACAAIAAgACAAIAJEDCAAIAAgACADFAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABgBAgAZgQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAbAQCBXIECAAIAHkECAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABAAJwEQACjBKoEsgQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAC6BMIECAAIAAgACAAIAAgACABmBAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAxwQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAGYECAAIAAgAzgQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAigWKBYoFigWKBYoFigWKBd0FXwUIAOIF6gXxBYoF3gT5BQAGCAaKBYoFigWKBYoFigWKBYoFigWKBYoFigXWBIoFigWKBYoFigWKBYoFigWKBYsFEAaKBYoFigWKBYoFigWKBRQGCACKBYoFigWKBQgACAAIANEECAAIABgGigUgBggAJgYIAC4GMwaKBYoF0wQ3Bj4GigWKBYoFigWKBYoFigWKBYoFigWKBYoFigUIAAgACAAIAAgACAAIAAgAigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWLBf///////wQABAAEAAQABAAEAAQABAAEAAQAAwAEAAQAAgAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAQADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAUAAAAFAAUAAAAFAAUAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAEAAQABAAEAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUAAQAAAAUABQAFAAUABQAFAAAAAAAFAAUAAAAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAFAAUAAQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABwAFAAUABQAFAAAABwAHAAcAAAAHAAcABwAFAAEAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAFAAcABwAFAAUAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAAAAQABAAAAAAAAAAAAAAAFAAUABQAFAAAABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAHAAcABwAHAAcAAAAHAAcAAAAAAAUABQAHAAUAAQAHAAEABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABwABAAUABQAFAAUAAAAAAAAAAAAAAAEAAQABAAEAAQABAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABwAFAAUAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUAAQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQABQANAAQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQABAAEAAQABAAEAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAEAAQABAAEAAQABAAEAAQABAAEAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAQABAAEAAQABAAEAAQABAAAAAAAAAAAAAAAAAAAAAAABQAHAAUABQAFAAAAAAAAAAcABQAFAAUABQAFAAQABAAEAAQABAAEAAQABAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUAAAAFAAUABQAFAAUAAAAFAAUABQAAAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAAAAAAAAAAAAUABQAFAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAHAAUAAAAHAAcABwAFAAUABQAFAAUABQAFAAUABwAHAAcABwAFAAcABwAAAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABwAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAUABwAHAAUABQAFAAUAAAAAAAcABwAAAAAABwAHAAUAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAABQAFAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAABwAHAAcABQAFAAAAAAAAAAAABQAFAAAAAAAFAAUABQAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAFAAUABQAFAAUAAAAFAAUABwAAAAcABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAFAAUABwAFAAUABQAFAAAAAAAHAAcAAAAAAAcABwAFAAAAAAAAAAAAAAAAAAAABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAcABwAAAAAAAAAHAAcABwAAAAcABwAHAAUAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAABQAHAAcABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABwAHAAcABwAAAAUABQAFAAAABQAFAAUABQAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAcABQAHAAcABQAHAAcAAAAFAAcABwAAAAcABwAFAAUAAAAAAAAAAAAAAAAAAAAFAAUAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAUABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAFAAcABwAFAAUABQAAAAUAAAAHAAcABwAHAAcABwAHAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAHAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAABwAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAUAAAAFAAAAAAAAAAAABwAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABwAFAAUABQAFAAUAAAAFAAUAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABwAFAAUABQAFAAUABQAAAAUABQAHAAcABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABQAFAAAAAAAAAAAABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAcABQAFAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAHAAUABQAFAAUABQAFAAUABwAHAAcABwAHAAcABwAHAAUABwAHAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABwAHAAcABwAFAAUABwAHAAcAAAAAAAAAAAAHAAcABQAHAAcABwAHAAcABwAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAcABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABQAHAAUABQAFAAUABQAFAAUAAAAFAAAABQAAAAAABQAFAAUABQAFAAUABQAFAAcABwAHAAcABwAHAAUABQAFAAUABQAFAAUABQAFAAUAAAAAAAUABQAFAAUABQAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABwAFAAcABwAHAAcABwAFAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAUABQAFAAUABwAHAAUABQAHAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAcABQAFAAcABwAHAAUABwAFAAUABQAHAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAcABwAHAAcABwAHAAUABQAFAAUABQAFAAUABQAHAAcABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAcABQAFAAUABQAFAAUABQAAAAAAAAAAAAUAAAAAAAAAAAAAAAAABQAAAAAABwAFAAUAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUAAAAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAABQAAAAAAAAAFAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAUABQAHAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAHAAcABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAHAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAcABwAFAAUABQAFAAcABwAFAAUABwAHAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAcABwAFAAUABwAHAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAFAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAFAAUABQAAAAAABQAFAAAAAAAAAAAAAAAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABQAFAAcABwAAAAAAAAAAAAAABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAFAAcABwAFAAcABwAAAAcABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAAAAAAAAAAAAAAAAAFAAUABQAAAAUABQAAAAAAAAAAAAAABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABQAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABwAFAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAcABQAFAAUABQAFAAUABQAFAAUABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAHAAcABQAHAAUABQAAAAAAAAAAAAAAAAAFAAAABwAHAAcABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABwAHAAcABwAAAAAABwAHAAAAAAAHAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAAAAAAFAAUABQAFAAUABQAFAAAAAAAAAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAFAAUABQAFAAUABwAHAAUABQAFAAcABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAHAAcABQAFAAUABQAFAAUABwAFAAcABwAFAAcABQAFAAcABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAHAAcABQAFAAUABQAAAAAABwAHAAcABwAFAAUABwAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAHAAUABQAFAAUABQAFAAUABQAHAAcABQAHAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABwAFAAcABwAFAAUABQAFAAUABQAHAAUAAAAAAAAAAAAAAAAAAAAAAAcABwAFAAUABQAFAAcABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAFAAUABQAFAAUABQAHAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAFAAAAAAAFAAUABwAHAAcABwAFAAAAAAAAAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABwAHAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABQAFAAUABQAFAAUABQAAAAUABQAFAAUABQAFAAcABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAAAHAAUABQAFAAUABQAFAAUABwAFAAUABwAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUAAAAAAAAABQAAAAUABQAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAHAAcAAAAFAAUAAAAHAAcABQAHAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABwAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAAAAAAAAAAAAAAAAAAABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAUABQAFAAAAAAAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAABQAFAAUABQAFAAUABQAAAAUABQAAAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAFAAUABQAFAAUADgAOAA4ADgAOAA4ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAAAAAAAAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAMAAwADAAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAAAAAAAAAAAAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAAAAAAAAAAAAsADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwACwAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAADgAOAA4AAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAAAA4ADgAOAA4ADgAOAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAAAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAAAA4AAAAOAAAAAAAAAAAAAAAAAA4AAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAADgAAAAAAAAAAAA4AAAAOAAAAAAAAAAAADgAOAA4AAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAAAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4AAAAAAA4ADgAOAA4ADgAOAA4ADgAOAAAADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4AAAAAAAAAAAAAAAAAAAAAAA4ADgAOAA4ADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAOAA4ADgAOAA4ADgAAAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAAAAAAAAA=";
    var chars$1 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    var lookup$1 = typeof Uint8Array === "undefined" ? [] : new Uint8Array(256);
    for (var i$1 = 0;i$1 < chars$1.length; i$1++) {
      lookup$1[chars$1.charCodeAt(i$1)] = i$1;
    }
    var decode = function(base642) {
      var bufferLength = base642.length * 0.75, len = base642.length, i4, p = 0, encoded1, encoded2, encoded3, encoded4;
      if (base642[base642.length - 1] === "=") {
        bufferLength--;
        if (base642[base642.length - 2] === "=") {
          bufferLength--;
        }
      }
      var buffer = typeof ArrayBuffer !== "undefined" && typeof Uint8Array !== "undefined" && typeof Uint8Array.prototype.slice !== "undefined" ? new ArrayBuffer(bufferLength) : new Array(bufferLength);
      var bytes = Array.isArray(buffer) ? buffer : new Uint8Array(buffer);
      for (i4 = 0;i4 < len; i4 += 4) {
        encoded1 = lookup$1[base642.charCodeAt(i4)];
        encoded2 = lookup$1[base642.charCodeAt(i4 + 1)];
        encoded3 = lookup$1[base642.charCodeAt(i4 + 2)];
        encoded4 = lookup$1[base642.charCodeAt(i4 + 3)];
        bytes[p++] = encoded1 << 2 | encoded2 >> 4;
        bytes[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;
        bytes[p++] = (encoded3 & 3) << 6 | encoded4 & 63;
      }
      return buffer;
    };
    var polyUint16Array = function(buffer) {
      var length = buffer.length;
      var bytes = [];
      for (var i4 = 0;i4 < length; i4 += 2) {
        bytes.push(buffer[i4 + 1] << 8 | buffer[i4]);
      }
      return bytes;
    };
    var polyUint32Array = function(buffer) {
      var length = buffer.length;
      var bytes = [];
      for (var i4 = 0;i4 < length; i4 += 4) {
        bytes.push(buffer[i4 + 3] << 24 | buffer[i4 + 2] << 16 | buffer[i4 + 1] << 8 | buffer[i4]);
      }
      return bytes;
    };
    var UTRIE2_SHIFT_2 = 5;
    var UTRIE2_SHIFT_1 = 6 + 5;
    var UTRIE2_INDEX_SHIFT = 2;
    var UTRIE2_SHIFT_1_2 = UTRIE2_SHIFT_1 - UTRIE2_SHIFT_2;
    var UTRIE2_LSCP_INDEX_2_OFFSET = 65536 >> UTRIE2_SHIFT_2;
    var UTRIE2_DATA_BLOCK_LENGTH = 1 << UTRIE2_SHIFT_2;
    var UTRIE2_DATA_MASK = UTRIE2_DATA_BLOCK_LENGTH - 1;
    var UTRIE2_LSCP_INDEX_2_LENGTH = 1024 >> UTRIE2_SHIFT_2;
    var UTRIE2_INDEX_2_BMP_LENGTH = UTRIE2_LSCP_INDEX_2_OFFSET + UTRIE2_LSCP_INDEX_2_LENGTH;
    var UTRIE2_UTF8_2B_INDEX_2_OFFSET = UTRIE2_INDEX_2_BMP_LENGTH;
    var UTRIE2_UTF8_2B_INDEX_2_LENGTH = 2048 >> 6;
    var UTRIE2_INDEX_1_OFFSET = UTRIE2_UTF8_2B_INDEX_2_OFFSET + UTRIE2_UTF8_2B_INDEX_2_LENGTH;
    var UTRIE2_OMITTED_BMP_INDEX_1_LENGTH = 65536 >> UTRIE2_SHIFT_1;
    var UTRIE2_INDEX_2_BLOCK_LENGTH = 1 << UTRIE2_SHIFT_1_2;
    var UTRIE2_INDEX_2_MASK = UTRIE2_INDEX_2_BLOCK_LENGTH - 1;
    var slice16 = function(view, start, end) {
      if (view.slice) {
        return view.slice(start, end);
      }
      return new Uint16Array(Array.prototype.slice.call(view, start, end));
    };
    var slice32 = function(view, start, end) {
      if (view.slice) {
        return view.slice(start, end);
      }
      return new Uint32Array(Array.prototype.slice.call(view, start, end));
    };
    var createTrieFromBase64 = function(base642, _byteLength) {
      var buffer = decode(base642);
      var view32 = Array.isArray(buffer) ? polyUint32Array(buffer) : new Uint32Array(buffer);
      var view16 = Array.isArray(buffer) ? polyUint16Array(buffer) : new Uint16Array(buffer);
      var headerLength = 24;
      var index = slice16(view16, headerLength / 2, view32[4] / 2);
      var data = view32[5] === 2 ? slice16(view16, (headerLength + view32[4]) / 2) : slice32(view32, Math.ceil((headerLength + view32[4]) / 4));
      return new Trie(view32[0], view32[1], view32[2], view32[3], index, data);
    };
    var Trie = function() {
      function Trie2(initialValue, errorValue, highStart, highValueIndex, index, data) {
        this.initialValue = initialValue;
        this.errorValue = errorValue;
        this.highStart = highStart;
        this.highValueIndex = highValueIndex;
        this.index = index;
        this.data = data;
      }
      Trie2.prototype.get = function(codePoint) {
        var ix;
        if (codePoint >= 0) {
          if (codePoint < 55296 || codePoint > 56319 && codePoint <= 65535) {
            ix = this.index[codePoint >> UTRIE2_SHIFT_2];
            ix = (ix << UTRIE2_INDEX_SHIFT) + (codePoint & UTRIE2_DATA_MASK);
            return this.data[ix];
          }
          if (codePoint <= 65535) {
            ix = this.index[UTRIE2_LSCP_INDEX_2_OFFSET + (codePoint - 55296 >> UTRIE2_SHIFT_2)];
            ix = (ix << UTRIE2_INDEX_SHIFT) + (codePoint & UTRIE2_DATA_MASK);
            return this.data[ix];
          }
          if (codePoint < this.highStart) {
            ix = UTRIE2_INDEX_1_OFFSET - UTRIE2_OMITTED_BMP_INDEX_1_LENGTH + (codePoint >> UTRIE2_SHIFT_1);
            ix = this.index[ix];
            ix += codePoint >> UTRIE2_SHIFT_2 & UTRIE2_INDEX_2_MASK;
            ix = this.index[ix];
            ix = (ix << UTRIE2_INDEX_SHIFT) + (codePoint & UTRIE2_DATA_MASK);
            return this.data[ix];
          }
          if (codePoint <= 1114111) {
            return this.data[this.highValueIndex];
          }
        }
        return this.errorValue;
      };
      return Trie2;
    }();
    var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    var lookup = typeof Uint8Array === "undefined" ? [] : new Uint8Array(256);
    for (var i3 = 0;i3 < chars.length; i3++) {
      lookup[chars.charCodeAt(i3)] = i3;
    }
    var Prepend = 1;
    var CR = 2;
    var LF = 3;
    var Control = 4;
    var Extend = 5;
    var SpacingMark = 7;
    var L = 8;
    var V = 9;
    var T = 10;
    var LV = 11;
    var LVT = 12;
    var ZWJ = 13;
    var Extended_Pictographic = 14;
    var RI = 15;
    var toCodePoints = function(str) {
      var codePoints = [];
      var i4 = 0;
      var length = str.length;
      while (i4 < length) {
        var value = str.charCodeAt(i4++);
        if (value >= 55296 && value <= 56319 && i4 < length) {
          var extra = str.charCodeAt(i4++);
          if ((extra & 64512) === 56320) {
            codePoints.push(((value & 1023) << 10) + (extra & 1023) + 65536);
          } else {
            codePoints.push(value);
            i4--;
          }
        } else {
          codePoints.push(value);
        }
      }
      return codePoints;
    };
    var fromCodePoint = function() {
      var codePoints = [];
      for (var _i = 0;_i < arguments.length; _i++) {
        codePoints[_i] = arguments[_i];
      }
      if (String.fromCodePoint) {
        return String.fromCodePoint.apply(String, codePoints);
      }
      var length = codePoints.length;
      if (!length) {
        return "";
      }
      var codeUnits = [];
      var index = -1;
      var result = "";
      while (++index < length) {
        var codePoint = codePoints[index];
        if (codePoint <= 65535) {
          codeUnits.push(codePoint);
        } else {
          codePoint -= 65536;
          codeUnits.push((codePoint >> 10) + 55296, codePoint % 1024 + 56320);
        }
        if (index + 1 === length || codeUnits.length > 16384) {
          result += String.fromCharCode.apply(String, codeUnits);
          codeUnits.length = 0;
        }
      }
      return result;
    };
    var UnicodeTrie = createTrieFromBase64(base64);
    var BREAK_NOT_ALLOWED = "";
    var BREAK_ALLOWED = "";
    var codePointToClass = function(codePoint) {
      return UnicodeTrie.get(codePoint);
    };
    var _graphemeBreakAtIndex = function(_codePoints, classTypes, index) {
      var prevIndex = index - 2;
      var prev = classTypes[prevIndex];
      var current = classTypes[index - 1];
      var next = classTypes[index];
      if (current === CR && next === LF) {
        return BREAK_NOT_ALLOWED;
      }
      if (current === CR || current === LF || current === Control) {
        return BREAK_ALLOWED;
      }
      if (next === CR || next === LF || next === Control) {
        return BREAK_ALLOWED;
      }
      if (current === L && [L, V, LV, LVT].indexOf(next) !== -1) {
        return BREAK_NOT_ALLOWED;
      }
      if ((current === LV || current === V) && (next === V || next === T)) {
        return BREAK_NOT_ALLOWED;
      }
      if ((current === LVT || current === T) && next === T) {
        return BREAK_NOT_ALLOWED;
      }
      if (next === ZWJ || next === Extend) {
        return BREAK_NOT_ALLOWED;
      }
      if (next === SpacingMark) {
        return BREAK_NOT_ALLOWED;
      }
      if (current === Prepend) {
        return BREAK_NOT_ALLOWED;
      }
      if (current === ZWJ && next === Extended_Pictographic) {
        while (prev === Extend) {
          prev = classTypes[--prevIndex];
        }
        if (prev === Extended_Pictographic) {
          return BREAK_NOT_ALLOWED;
        }
      }
      if (current === RI && next === RI) {
        var countRI = 0;
        while (prev === RI) {
          countRI++;
          prev = classTypes[--prevIndex];
        }
        if (countRI % 2 === 0) {
          return BREAK_NOT_ALLOWED;
        }
      }
      return BREAK_ALLOWED;
    };
    var GraphemeBreaker = function(str) {
      var codePoints = toCodePoints(str);
      var length = codePoints.length;
      var index = 0;
      var lastEnd = 0;
      var classTypes = codePoints.map(codePointToClass);
      return {
        next: function() {
          if (index >= length) {
            return { done: true, value: null };
          }
          var graphemeBreak = BREAK_NOT_ALLOWED;
          while (index < length && (graphemeBreak = _graphemeBreakAtIndex(codePoints, classTypes, ++index)) === BREAK_NOT_ALLOWED) {}
          if (graphemeBreak !== BREAK_NOT_ALLOWED || index === length) {
            var value = fromCodePoint.apply(null, codePoints.slice(lastEnd, index));
            lastEnd = index;
            return { value, done: false };
          }
          return { done: true, value: null };
        }
      };
    };
    var splitGraphemes = function(str) {
      var breaker = GraphemeBreaker(str);
      var graphemes = [];
      var bk;
      while (!(bk = breaker.next()).done) {
        if (bk.value) {
          graphemes.push(bk.value.slice());
        }
      }
      return graphemes;
    };
    var testRangeBounds = function(document2) {
      var TEST_HEIGHT = 123;
      if (document2.createRange) {
        var range = document2.createRange();
        if (range.getBoundingClientRect) {
          var testElement = document2.createElement("boundtest");
          testElement.style.height = TEST_HEIGHT + "px";
          testElement.style.display = "block";
          document2.body.appendChild(testElement);
          range.selectNode(testElement);
          var rangeBounds = range.getBoundingClientRect();
          var rangeHeight = Math.round(rangeBounds.height);
          document2.body.removeChild(testElement);
          if (rangeHeight === TEST_HEIGHT) {
            return true;
          }
        }
      }
      return false;
    };
    var testIOSLineBreak = function(document2) {
      var testElement = document2.createElement("boundtest");
      testElement.style.width = "50px";
      testElement.style.display = "block";
      testElement.style.fontSize = "12px";
      testElement.style.letterSpacing = "0px";
      testElement.style.wordSpacing = "0px";
      document2.body.appendChild(testElement);
      var range = document2.createRange();
      testElement.innerHTML = typeof "".repeat === "function" ? "&#128104;".repeat(10) : "";
      var node = testElement.firstChild;
      var textList = toCodePoints$1(node.data).map(function(i4) {
        return fromCodePoint$1(i4);
      });
      var offset = 0;
      var prev = {};
      var supports = textList.every(function(text, i4) {
        range.setStart(node, offset);
        range.setEnd(node, offset + text.length);
        var rect = range.getBoundingClientRect();
        offset += text.length;
        var boundAhead = rect.x > prev.x || rect.y > prev.y;
        prev = rect;
        if (i4 === 0) {
          return true;
        }
        return boundAhead;
      });
      document2.body.removeChild(testElement);
      return supports;
    };
    var testCORS = function() {
      return typeof new Image().crossOrigin !== "undefined";
    };
    var testResponseType = function() {
      return typeof new XMLHttpRequest().responseType === "string";
    };
    var testSVG = function(document2) {
      var img = new Image;
      var canvas = document2.createElement("canvas");
      var ctx = canvas.getContext("2d");
      if (!ctx) {
        return false;
      }
      img.src = "data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg'></svg>";
      try {
        ctx.drawImage(img, 0, 0);
        canvas.toDataURL();
      } catch (e2) {
        return false;
      }
      return true;
    };
    var isGreenPixel = function(data) {
      return data[0] === 0 && data[1] === 255 && data[2] === 0 && data[3] === 255;
    };
    var testForeignObject = function(document2) {
      var canvas = document2.createElement("canvas");
      var size = 100;
      canvas.width = size;
      canvas.height = size;
      var ctx = canvas.getContext("2d");
      if (!ctx) {
        return Promise.reject(false);
      }
      ctx.fillStyle = "rgb(0, 255, 0)";
      ctx.fillRect(0, 0, size, size);
      var img = new Image;
      var greenImageSrc = canvas.toDataURL();
      img.src = greenImageSrc;
      var svg = createForeignObjectSVG(size, size, 0, 0, img);
      ctx.fillStyle = "red";
      ctx.fillRect(0, 0, size, size);
      return loadSerializedSVG$1(svg).then(function(img2) {
        ctx.drawImage(img2, 0, 0);
        var data = ctx.getImageData(0, 0, size, size).data;
        ctx.fillStyle = "red";
        ctx.fillRect(0, 0, size, size);
        var node = document2.createElement("div");
        node.style.backgroundImage = "url(" + greenImageSrc + ")";
        node.style.height = size + "px";
        return isGreenPixel(data) ? loadSerializedSVG$1(createForeignObjectSVG(size, size, 0, 0, node)) : Promise.reject(false);
      }).then(function(img2) {
        ctx.drawImage(img2, 0, 0);
        return isGreenPixel(ctx.getImageData(0, 0, size, size).data);
      }).catch(function() {
        return false;
      });
    };
    var createForeignObjectSVG = function(width, height, x2, y, node) {
      var xmlns = "http://www.w3.org/2000/svg";
      var svg = document.createElementNS(xmlns, "svg");
      var foreignObject = document.createElementNS(xmlns, "foreignObject");
      svg.setAttributeNS(null, "width", width.toString());
      svg.setAttributeNS(null, "height", height.toString());
      foreignObject.setAttributeNS(null, "width", "100%");
      foreignObject.setAttributeNS(null, "height", "100%");
      foreignObject.setAttributeNS(null, "x", x2.toString());
      foreignObject.setAttributeNS(null, "y", y.toString());
      foreignObject.setAttributeNS(null, "externalResourcesRequired", "true");
      svg.appendChild(foreignObject);
      foreignObject.appendChild(node);
      return svg;
    };
    var loadSerializedSVG$1 = function(svg) {
      return new Promise(function(resolve, reject) {
        var img = new Image;
        img.onload = function() {
          return resolve(img);
        };
        img.onerror = reject;
        img.src = "data:image/svg+xml;charset=utf-8," + encodeURIComponent(new XMLSerializer().serializeToString(svg));
      });
    };
    var FEATURES = {
      get SUPPORT_RANGE_BOUNDS() {
        var value = testRangeBounds(document);
        Object.defineProperty(FEATURES, "SUPPORT_RANGE_BOUNDS", { value });
        return value;
      },
      get SUPPORT_WORD_BREAKING() {
        var value = FEATURES.SUPPORT_RANGE_BOUNDS && testIOSLineBreak(document);
        Object.defineProperty(FEATURES, "SUPPORT_WORD_BREAKING", { value });
        return value;
      },
      get SUPPORT_SVG_DRAWING() {
        var value = testSVG(document);
        Object.defineProperty(FEATURES, "SUPPORT_SVG_DRAWING", { value });
        return value;
      },
      get SUPPORT_FOREIGNOBJECT_DRAWING() {
        var value = typeof Array.from === "function" && typeof window.fetch === "function" ? testForeignObject(document) : Promise.resolve(false);
        Object.defineProperty(FEATURES, "SUPPORT_FOREIGNOBJECT_DRAWING", { value });
        return value;
      },
      get SUPPORT_CORS_IMAGES() {
        var value = testCORS();
        Object.defineProperty(FEATURES, "SUPPORT_CORS_IMAGES", { value });
        return value;
      },
      get SUPPORT_RESPONSE_TYPE() {
        var value = testResponseType();
        Object.defineProperty(FEATURES, "SUPPORT_RESPONSE_TYPE", { value });
        return value;
      },
      get SUPPORT_CORS_XHR() {
        var value = "withCredentials" in new XMLHttpRequest;
        Object.defineProperty(FEATURES, "SUPPORT_CORS_XHR", { value });
        return value;
      },
      get SUPPORT_NATIVE_TEXT_SEGMENTATION() {
        var value = !!(typeof Intl !== "undefined" && Intl.Segmenter);
        Object.defineProperty(FEATURES, "SUPPORT_NATIVE_TEXT_SEGMENTATION", { value });
        return value;
      }
    };
    var TextBounds = function() {
      function TextBounds2(text, bounds) {
        this.text = text;
        this.bounds = bounds;
      }
      return TextBounds2;
    }();
    var parseTextBounds = function(context, value, styles, node) {
      var textList = breakText(value, styles);
      var textBounds = [];
      var offset = 0;
      textList.forEach(function(text) {
        if (styles.textDecorationLine.length || text.trim().length > 0) {
          if (FEATURES.SUPPORT_RANGE_BOUNDS) {
            var clientRects = createRange(node, offset, text.length).getClientRects();
            if (clientRects.length > 1) {
              var subSegments = segmentGraphemes(text);
              var subOffset_1 = 0;
              subSegments.forEach(function(subSegment) {
                textBounds.push(new TextBounds(subSegment, Bounds.fromDOMRectList(context, createRange(node, subOffset_1 + offset, subSegment.length).getClientRects())));
                subOffset_1 += subSegment.length;
              });
            } else {
              textBounds.push(new TextBounds(text, Bounds.fromDOMRectList(context, clientRects)));
            }
          } else {
            var replacementNode = node.splitText(text.length);
            textBounds.push(new TextBounds(text, getWrapperBounds(context, node)));
            node = replacementNode;
          }
        } else if (!FEATURES.SUPPORT_RANGE_BOUNDS) {
          node = node.splitText(text.length);
        }
        offset += text.length;
      });
      return textBounds;
    };
    var getWrapperBounds = function(context, node) {
      var ownerDocument = node.ownerDocument;
      if (ownerDocument) {
        var wrapper = ownerDocument.createElement("html2canvaswrapper");
        wrapper.appendChild(node.cloneNode(true));
        var parentNode2 = node.parentNode;
        if (parentNode2) {
          parentNode2.replaceChild(wrapper, node);
          var bounds = parseBounds(context, wrapper);
          if (wrapper.firstChild) {
            parentNode2.replaceChild(wrapper.firstChild, wrapper);
          }
          return bounds;
        }
      }
      return Bounds.EMPTY;
    };
    var createRange = function(node, offset, length) {
      var ownerDocument = node.ownerDocument;
      if (!ownerDocument) {
        throw new Error("Node has no owner document");
      }
      var range = ownerDocument.createRange();
      range.setStart(node, offset);
      range.setEnd(node, offset + length);
      return range;
    };
    var segmentGraphemes = function(value) {
      if (FEATURES.SUPPORT_NATIVE_TEXT_SEGMENTATION) {
        var segmenter = new Intl.Segmenter(undefined, { granularity: "grapheme" });
        return Array.from(segmenter.segment(value)).map(function(segment) {
          return segment.segment;
        });
      }
      return splitGraphemes(value);
    };
    var segmentWords = function(value, styles) {
      if (FEATURES.SUPPORT_NATIVE_TEXT_SEGMENTATION) {
        var segmenter = new Intl.Segmenter(undefined, {
          granularity: "word"
        });
        return Array.from(segmenter.segment(value)).map(function(segment) {
          return segment.segment;
        });
      }
      return breakWords(value, styles);
    };
    var breakText = function(value, styles) {
      return styles.letterSpacing !== 0 ? segmentGraphemes(value) : segmentWords(value, styles);
    };
    var wordSeparators = [32, 160, 4961, 65792, 65793, 4153, 4241];
    var breakWords = function(str, styles) {
      var breaker = LineBreaker(str, {
        lineBreak: styles.lineBreak,
        wordBreak: styles.overflowWrap === "break-word" ? "break-word" : styles.wordBreak
      });
      var words = [];
      var bk;
      var _loop_1 = function() {
        if (bk.value) {
          var value = bk.value.slice();
          var codePoints = toCodePoints$1(value);
          var word_1 = "";
          codePoints.forEach(function(codePoint) {
            if (wordSeparators.indexOf(codePoint) === -1) {
              word_1 += fromCodePoint$1(codePoint);
            } else {
              if (word_1.length) {
                words.push(word_1);
              }
              words.push(fromCodePoint$1(codePoint));
              word_1 = "";
            }
          });
          if (word_1.length) {
            words.push(word_1);
          }
        }
      };
      while (!(bk = breaker.next()).done) {
        _loop_1();
      }
      return words;
    };
    var TextContainer = function() {
      function TextContainer2(context, node, styles) {
        this.text = transform(node.data, styles.textTransform);
        this.textBounds = parseTextBounds(context, this.text, styles, node);
      }
      return TextContainer2;
    }();
    var transform = function(text, transform2) {
      switch (transform2) {
        case 1:
          return text.toLowerCase();
        case 3:
          return text.replace(CAPITALIZE, capitalize);
        case 2:
          return text.toUpperCase();
        default:
          return text;
      }
    };
    var CAPITALIZE = /(^|\s|:|-|\(|\))([a-z])/g;
    var capitalize = function(m, p1, p2) {
      if (m.length > 0) {
        return p1 + p2.toUpperCase();
      }
      return m;
    };
    var ImageElementContainer = function(_super) {
      __extends(ImageElementContainer2, _super);
      function ImageElementContainer2(context, img) {
        var _this = _super.call(this, context, img) || this;
        _this.src = img.currentSrc || img.src;
        _this.intrinsicWidth = img.naturalWidth;
        _this.intrinsicHeight = img.naturalHeight;
        _this.context.cache.addImage(_this.src);
        return _this;
      }
      return ImageElementContainer2;
    }(ElementContainer);
    var CanvasElementContainer = function(_super) {
      __extends(CanvasElementContainer2, _super);
      function CanvasElementContainer2(context, canvas) {
        var _this = _super.call(this, context, canvas) || this;
        _this.canvas = canvas;
        _this.intrinsicWidth = canvas.width;
        _this.intrinsicHeight = canvas.height;
        return _this;
      }
      return CanvasElementContainer2;
    }(ElementContainer);
    var SVGElementContainer = function(_super) {
      __extends(SVGElementContainer2, _super);
      function SVGElementContainer2(context, img) {
        var _this = _super.call(this, context, img) || this;
        var s = new XMLSerializer;
        var bounds = parseBounds(context, img);
        img.setAttribute("width", bounds.width + "px");
        img.setAttribute("height", bounds.height + "px");
        _this.svg = "data:image/svg+xml," + encodeURIComponent(s.serializeToString(img));
        _this.intrinsicWidth = img.width.baseVal.value;
        _this.intrinsicHeight = img.height.baseVal.value;
        _this.context.cache.addImage(_this.svg);
        return _this;
      }
      return SVGElementContainer2;
    }(ElementContainer);
    var LIElementContainer = function(_super) {
      __extends(LIElementContainer2, _super);
      function LIElementContainer2(context, element) {
        var _this = _super.call(this, context, element) || this;
        _this.value = element.value;
        return _this;
      }
      return LIElementContainer2;
    }(ElementContainer);
    var OLElementContainer = function(_super) {
      __extends(OLElementContainer2, _super);
      function OLElementContainer2(context, element) {
        var _this = _super.call(this, context, element) || this;
        _this.start = element.start;
        _this.reversed = typeof element.reversed === "boolean" && element.reversed === true;
        return _this;
      }
      return OLElementContainer2;
    }(ElementContainer);
    var CHECKBOX_BORDER_RADIUS = [
      {
        type: 15,
        flags: 0,
        unit: "px",
        number: 3
      }
    ];
    var RADIO_BORDER_RADIUS = [
      {
        type: 16,
        flags: 0,
        number: 50
      }
    ];
    var reformatInputBounds = function(bounds) {
      if (bounds.width > bounds.height) {
        return new Bounds(bounds.left + (bounds.width - bounds.height) / 2, bounds.top, bounds.height, bounds.height);
      } else if (bounds.width < bounds.height) {
        return new Bounds(bounds.left, bounds.top + (bounds.height - bounds.width) / 2, bounds.width, bounds.width);
      }
      return bounds;
    };
    var getInputValue = function(node) {
      var value = node.type === PASSWORD ? new Array(node.value.length + 1).join("") : node.value;
      return value.length === 0 ? node.placeholder || "" : value;
    };
    var CHECKBOX = "checkbox";
    var RADIO = "radio";
    var PASSWORD = "password";
    var INPUT_COLOR = 707406591;
    var InputElementContainer = function(_super) {
      __extends(InputElementContainer2, _super);
      function InputElementContainer2(context, input) {
        var _this = _super.call(this, context, input) || this;
        _this.type = input.type.toLowerCase();
        _this.checked = input.checked;
        _this.value = getInputValue(input);
        if (_this.type === CHECKBOX || _this.type === RADIO) {
          _this.styles.backgroundColor = 3739148031;
          _this.styles.borderTopColor = _this.styles.borderRightColor = _this.styles.borderBottomColor = _this.styles.borderLeftColor = 2779096575;
          _this.styles.borderTopWidth = _this.styles.borderRightWidth = _this.styles.borderBottomWidth = _this.styles.borderLeftWidth = 1;
          _this.styles.borderTopStyle = _this.styles.borderRightStyle = _this.styles.borderBottomStyle = _this.styles.borderLeftStyle = 1;
          _this.styles.backgroundClip = [0];
          _this.styles.backgroundOrigin = [0];
          _this.bounds = reformatInputBounds(_this.bounds);
        }
        switch (_this.type) {
          case CHECKBOX:
            _this.styles.borderTopRightRadius = _this.styles.borderTopLeftRadius = _this.styles.borderBottomRightRadius = _this.styles.borderBottomLeftRadius = CHECKBOX_BORDER_RADIUS;
            break;
          case RADIO:
            _this.styles.borderTopRightRadius = _this.styles.borderTopLeftRadius = _this.styles.borderBottomRightRadius = _this.styles.borderBottomLeftRadius = RADIO_BORDER_RADIUS;
            break;
        }
        return _this;
      }
      return InputElementContainer2;
    }(ElementContainer);
    var SelectElementContainer = function(_super) {
      __extends(SelectElementContainer2, _super);
      function SelectElementContainer2(context, element) {
        var _this = _super.call(this, context, element) || this;
        var option = element.options[element.selectedIndex || 0];
        _this.value = option ? option.text || "" : "";
        return _this;
      }
      return SelectElementContainer2;
    }(ElementContainer);
    var TextareaElementContainer = function(_super) {
      __extends(TextareaElementContainer2, _super);
      function TextareaElementContainer2(context, element) {
        var _this = _super.call(this, context, element) || this;
        _this.value = element.value;
        return _this;
      }
      return TextareaElementContainer2;
    }(ElementContainer);
    var IFrameElementContainer = function(_super) {
      __extends(IFrameElementContainer2, _super);
      function IFrameElementContainer2(context, iframe) {
        var _this = _super.call(this, context, iframe) || this;
        _this.src = iframe.src;
        _this.width = parseInt(iframe.width, 10) || 0;
        _this.height = parseInt(iframe.height, 10) || 0;
        _this.backgroundColor = _this.styles.backgroundColor;
        try {
          if (iframe.contentWindow && iframe.contentWindow.document && iframe.contentWindow.document.documentElement) {
            _this.tree = parseTree(context, iframe.contentWindow.document.documentElement);
            var documentBackgroundColor = iframe.contentWindow.document.documentElement ? parseColor(context, getComputedStyle(iframe.contentWindow.document.documentElement).backgroundColor) : COLORS.TRANSPARENT;
            var bodyBackgroundColor = iframe.contentWindow.document.body ? parseColor(context, getComputedStyle(iframe.contentWindow.document.body).backgroundColor) : COLORS.TRANSPARENT;
            _this.backgroundColor = isTransparent(documentBackgroundColor) ? isTransparent(bodyBackgroundColor) ? _this.styles.backgroundColor : bodyBackgroundColor : documentBackgroundColor;
          }
        } catch (e2) {}
        return _this;
      }
      return IFrameElementContainer2;
    }(ElementContainer);
    var LIST_OWNERS = ["OL", "UL", "MENU"];
    var parseNodeTree = function(context, node, parent, root) {
      for (var childNode = node.firstChild, nextNode = undefined;childNode; childNode = nextNode) {
        nextNode = childNode.nextSibling;
        if (isTextNode(childNode) && childNode.data.trim().length > 0) {
          parent.textNodes.push(new TextContainer(context, childNode, parent.styles));
        } else if (isElementNode(childNode)) {
          if (isSlotElement(childNode) && childNode.assignedNodes) {
            childNode.assignedNodes().forEach(function(childNode2) {
              return parseNodeTree(context, childNode2, parent, root);
            });
          } else {
            var container = createContainer(context, childNode);
            if (container.styles.isVisible()) {
              if (createsRealStackingContext(childNode, container, root)) {
                container.flags |= 4;
              } else if (createsStackingContext(container.styles)) {
                container.flags |= 2;
              }
              if (LIST_OWNERS.indexOf(childNode.tagName) !== -1) {
                container.flags |= 8;
              }
              parent.elements.push(container);
              childNode.slot;
              if (childNode.shadowRoot) {
                parseNodeTree(context, childNode.shadowRoot, container, root);
              } else if (!isTextareaElement(childNode) && !isSVGElement(childNode) && !isSelectElement(childNode)) {
                parseNodeTree(context, childNode, container, root);
              }
            }
          }
        }
      }
    };
    var createContainer = function(context, element) {
      if (isImageElement(element)) {
        return new ImageElementContainer(context, element);
      }
      if (isCanvasElement(element)) {
        return new CanvasElementContainer(context, element);
      }
      if (isSVGElement(element)) {
        return new SVGElementContainer(context, element);
      }
      if (isLIElement(element)) {
        return new LIElementContainer(context, element);
      }
      if (isOLElement(element)) {
        return new OLElementContainer(context, element);
      }
      if (isInputElement(element)) {
        return new InputElementContainer(context, element);
      }
      if (isSelectElement(element)) {
        return new SelectElementContainer(context, element);
      }
      if (isTextareaElement(element)) {
        return new TextareaElementContainer(context, element);
      }
      if (isIFrameElement(element)) {
        return new IFrameElementContainer(context, element);
      }
      return new ElementContainer(context, element);
    };
    var parseTree = function(context, element) {
      var container = createContainer(context, element);
      container.flags |= 4;
      parseNodeTree(context, element, container, container);
      return container;
    };
    var createsRealStackingContext = function(node, container, root) {
      return container.styles.isPositionedWithZIndex() || container.styles.opacity < 1 || container.styles.isTransformed() || isBodyElement(node) && root.styles.isTransparent();
    };
    var createsStackingContext = function(styles) {
      return styles.isPositioned() || styles.isFloating();
    };
    var isTextNode = function(node) {
      return node.nodeType === Node.TEXT_NODE;
    };
    var isElementNode = function(node) {
      return node.nodeType === Node.ELEMENT_NODE;
    };
    var isHTMLElementNode = function(node) {
      return isElementNode(node) && typeof node.style !== "undefined" && !isSVGElementNode(node);
    };
    var isSVGElementNode = function(element) {
      return typeof element.className === "object";
    };
    var isLIElement = function(node) {
      return node.tagName === "LI";
    };
    var isOLElement = function(node) {
      return node.tagName === "OL";
    };
    var isInputElement = function(node) {
      return node.tagName === "INPUT";
    };
    var isHTMLElement = function(node) {
      return node.tagName === "HTML";
    };
    var isSVGElement = function(node) {
      return node.tagName === "svg";
    };
    var isBodyElement = function(node) {
      return node.tagName === "BODY";
    };
    var isCanvasElement = function(node) {
      return node.tagName === "CANVAS";
    };
    var isVideoElement = function(node) {
      return node.tagName === "VIDEO";
    };
    var isImageElement = function(node) {
      return node.tagName === "IMG";
    };
    var isIFrameElement = function(node) {
      return node.tagName === "IFRAME";
    };
    var isStyleElement = function(node) {
      return node.tagName === "STYLE";
    };
    var isScriptElement = function(node) {
      return node.tagName === "SCRIPT";
    };
    var isTextareaElement = function(node) {
      return node.tagName === "TEXTAREA";
    };
    var isSelectElement = function(node) {
      return node.tagName === "SELECT";
    };
    var isSlotElement = function(node) {
      return node.tagName === "SLOT";
    };
    var isCustomElement = function(node) {
      return node.tagName.indexOf("-") > 0;
    };
    var CounterState = function() {
      function CounterState2() {
        this.counters = {};
      }
      CounterState2.prototype.getCounterValue = function(name) {
        var counter = this.counters[name];
        if (counter && counter.length) {
          return counter[counter.length - 1];
        }
        return 1;
      };
      CounterState2.prototype.getCounterValues = function(name) {
        var counter = this.counters[name];
        return counter ? counter : [];
      };
      CounterState2.prototype.pop = function(counters) {
        var _this = this;
        counters.forEach(function(counter) {
          return _this.counters[counter].pop();
        });
      };
      CounterState2.prototype.parse = function(style2) {
        var _this = this;
        var counterIncrement2 = style2.counterIncrement;
        var counterReset2 = style2.counterReset;
        var canReset = true;
        if (counterIncrement2 !== null) {
          counterIncrement2.forEach(function(entry) {
            var counter = _this.counters[entry.counter];
            if (counter && entry.increment !== 0) {
              canReset = false;
              if (!counter.length) {
                counter.push(1);
              }
              counter[Math.max(0, counter.length - 1)] += entry.increment;
            }
          });
        }
        var counterNames = [];
        if (canReset) {
          counterReset2.forEach(function(entry) {
            var counter = _this.counters[entry.counter];
            counterNames.push(entry.counter);
            if (!counter) {
              counter = _this.counters[entry.counter] = [];
            }
            counter.push(entry.reset);
          });
        }
        return counterNames;
      };
      return CounterState2;
    }();
    var ROMAN_UPPER = {
      integers: [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1],
      values: ["M", "CM", "D", "CD", "C", "XC", "L", "XL", "X", "IX", "V", "IV", "I"]
    };
    var ARMENIAN = {
      integers: [
        9000,
        8000,
        7000,
        6000,
        5000,
        4000,
        3000,
        2000,
        1000,
        900,
        800,
        700,
        600,
        500,
        400,
        300,
        200,
        100,
        90,
        80,
        70,
        60,
        50,
        40,
        30,
        20,
        10,
        9,
        8,
        7,
        6,
        5,
        4,
        3,
        2,
        1
      ],
      values: [
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        ""
      ]
    };
    var HEBREW = {
      integers: [
        1e4,
        9000,
        8000,
        7000,
        6000,
        5000,
        4000,
        3000,
        2000,
        1000,
        400,
        300,
        200,
        100,
        90,
        80,
        70,
        60,
        50,
        40,
        30,
        20,
        19,
        18,
        17,
        16,
        15,
        10,
        9,
        8,
        7,
        6,
        5,
        4,
        3,
        2,
        1
      ],
      values: [
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        ""
      ]
    };
    var GEORGIAN = {
      integers: [
        1e4,
        9000,
        8000,
        7000,
        6000,
        5000,
        4000,
        3000,
        2000,
        1000,
        900,
        800,
        700,
        600,
        500,
        400,
        300,
        200,
        100,
        90,
        80,
        70,
        60,
        50,
        40,
        30,
        20,
        10,
        9,
        8,
        7,
        6,
        5,
        4,
        3,
        2,
        1
      ],
      values: [
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        ""
      ]
    };
    var createAdditiveCounter = function(value, min, max2, symbols, fallback, suffix) {
      if (value < min || value > max2) {
        return createCounterText(value, fallback, suffix.length > 0);
      }
      return symbols.integers.reduce(function(string, integer, index) {
        while (value >= integer) {
          value -= integer;
          string += symbols.values[index];
        }
        return string;
      }, "") + suffix;
    };
    var createCounterStyleWithSymbolResolver = function(value, codePointRangeLength, isNumeric, resolver) {
      var string = "";
      do {
        if (!isNumeric) {
          value--;
        }
        string = resolver(value) + string;
        value /= codePointRangeLength;
      } while (value * codePointRangeLength >= codePointRangeLength);
      return string;
    };
    var createCounterStyleFromRange = function(value, codePointRangeStart, codePointRangeEnd, isNumeric, suffix) {
      var codePointRangeLength = codePointRangeEnd - codePointRangeStart + 1;
      return (value < 0 ? "-" : "") + (createCounterStyleWithSymbolResolver(Math.abs(value), codePointRangeLength, isNumeric, function(codePoint) {
        return fromCodePoint$1(Math.floor(codePoint % codePointRangeLength) + codePointRangeStart);
      }) + suffix);
    };
    var createCounterStyleFromSymbols = function(value, symbols, suffix) {
      if (suffix === undefined) {
        suffix = ". ";
      }
      var codePointRangeLength = symbols.length;
      return createCounterStyleWithSymbolResolver(Math.abs(value), codePointRangeLength, false, function(codePoint) {
        return symbols[Math.floor(codePoint % codePointRangeLength)];
      }) + suffix;
    };
    var CJK_ZEROS = 1 << 0;
    var CJK_TEN_COEFFICIENTS = 1 << 1;
    var CJK_TEN_HIGH_COEFFICIENTS = 1 << 2;
    var CJK_HUNDRED_COEFFICIENTS = 1 << 3;
    var createCJKCounter = function(value, numbers, multipliers, negativeSign, suffix, flags) {
      if (value < -9999 || value > 9999) {
        return createCounterText(value, 4, suffix.length > 0);
      }
      var tmp = Math.abs(value);
      var string = suffix;
      if (tmp === 0) {
        return numbers[0] + string;
      }
      for (var digit = 0;tmp > 0 && digit <= 4; digit++) {
        var coefficient = tmp % 10;
        if (coefficient === 0 && contains(flags, CJK_ZEROS) && string !== "") {
          string = numbers[coefficient] + string;
        } else if (coefficient > 1 || coefficient === 1 && digit === 0 || coefficient === 1 && digit === 1 && contains(flags, CJK_TEN_COEFFICIENTS) || coefficient === 1 && digit === 1 && contains(flags, CJK_TEN_HIGH_COEFFICIENTS) && value > 100 || coefficient === 1 && digit > 1 && contains(flags, CJK_HUNDRED_COEFFICIENTS)) {
          string = numbers[coefficient] + (digit > 0 ? multipliers[digit - 1] : "") + string;
        } else if (coefficient === 1 && digit > 0) {
          string = multipliers[digit - 1] + string;
        }
        tmp = Math.floor(tmp / 10);
      }
      return (value < 0 ? negativeSign : "") + string;
    };
    var CHINESE_INFORMAL_MULTIPLIERS = "";
    var CHINESE_FORMAL_MULTIPLIERS = "";
    var JAPANESE_NEGATIVE = "";
    var KOREAN_NEGATIVE = "";
    var createCounterText = function(value, type, appendSuffix) {
      var defaultSuffix = appendSuffix ? ". " : "";
      var cjkSuffix = appendSuffix ? "" : "";
      var koreanSuffix = appendSuffix ? ", " : "";
      var spaceSuffix = appendSuffix ? " " : "";
      switch (type) {
        case 0:
          return "" + spaceSuffix;
        case 1:
          return "" + spaceSuffix;
        case 2:
          return "" + spaceSuffix;
        case 5:
          var string = createCounterStyleFromRange(value, 48, 57, true, defaultSuffix);
          return string.length < 4 ? "0" + string : string;
        case 4:
          return createCounterStyleFromSymbols(value, "", cjkSuffix);
        case 6:
          return createAdditiveCounter(value, 1, 3999, ROMAN_UPPER, 3, defaultSuffix).toLowerCase();
        case 7:
          return createAdditiveCounter(value, 1, 3999, ROMAN_UPPER, 3, defaultSuffix);
        case 8:
          return createCounterStyleFromRange(value, 945, 969, false, defaultSuffix);
        case 9:
          return createCounterStyleFromRange(value, 97, 122, false, defaultSuffix);
        case 10:
          return createCounterStyleFromRange(value, 65, 90, false, defaultSuffix);
        case 11:
          return createCounterStyleFromRange(value, 1632, 1641, true, defaultSuffix);
        case 12:
        case 49:
          return createAdditiveCounter(value, 1, 9999, ARMENIAN, 3, defaultSuffix);
        case 35:
          return createAdditiveCounter(value, 1, 9999, ARMENIAN, 3, defaultSuffix).toLowerCase();
        case 13:
          return createCounterStyleFromRange(value, 2534, 2543, true, defaultSuffix);
        case 14:
        case 30:
          return createCounterStyleFromRange(value, 6112, 6121, true, defaultSuffix);
        case 15:
          return createCounterStyleFromSymbols(value, "", cjkSuffix);
        case 16:
          return createCounterStyleFromSymbols(value, "", cjkSuffix);
        case 17:
        case 48:
          return createCJKCounter(value, "", CHINESE_INFORMAL_MULTIPLIERS, "", cjkSuffix, CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS | CJK_HUNDRED_COEFFICIENTS);
        case 47:
          return createCJKCounter(value, "", CHINESE_FORMAL_MULTIPLIERS, "", cjkSuffix, CJK_ZEROS | CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS | CJK_HUNDRED_COEFFICIENTS);
        case 42:
          return createCJKCounter(value, "", CHINESE_INFORMAL_MULTIPLIERS, "", cjkSuffix, CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS | CJK_HUNDRED_COEFFICIENTS);
        case 41:
          return createCJKCounter(value, "", CHINESE_FORMAL_MULTIPLIERS, "", cjkSuffix, CJK_ZEROS | CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS | CJK_HUNDRED_COEFFICIENTS);
        case 26:
          return createCJKCounter(value, "", "", JAPANESE_NEGATIVE, cjkSuffix, 0);
        case 25:
          return createCJKCounter(value, "", "", JAPANESE_NEGATIVE, cjkSuffix, CJK_ZEROS | CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS);
        case 31:
          return createCJKCounter(value, "", "", KOREAN_NEGATIVE, koreanSuffix, CJK_ZEROS | CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS);
        case 33:
          return createCJKCounter(value, "", "", KOREAN_NEGATIVE, koreanSuffix, 0);
        case 32:
          return createCJKCounter(value, "", "", KOREAN_NEGATIVE, koreanSuffix, CJK_ZEROS | CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS);
        case 18:
          return createCounterStyleFromRange(value, 2406, 2415, true, defaultSuffix);
        case 20:
          return createAdditiveCounter(value, 1, 19999, GEORGIAN, 3, defaultSuffix);
        case 21:
          return createCounterStyleFromRange(value, 2790, 2799, true, defaultSuffix);
        case 22:
          return createCounterStyleFromRange(value, 2662, 2671, true, defaultSuffix);
        case 22:
          return createAdditiveCounter(value, 1, 10999, HEBREW, 3, defaultSuffix);
        case 23:
          return createCounterStyleFromSymbols(value, "");
        case 24:
          return createCounterStyleFromSymbols(value, "");
        case 27:
          return createCounterStyleFromRange(value, 3302, 3311, true, defaultSuffix);
        case 28:
          return createCounterStyleFromSymbols(value, "", cjkSuffix);
        case 29:
          return createCounterStyleFromSymbols(value, "", cjkSuffix);
        case 34:
          return createCounterStyleFromRange(value, 3792, 3801, true, defaultSuffix);
        case 37:
          return createCounterStyleFromRange(value, 6160, 6169, true, defaultSuffix);
        case 38:
          return createCounterStyleFromRange(value, 4160, 4169, true, defaultSuffix);
        case 39:
          return createCounterStyleFromRange(value, 2918, 2927, true, defaultSuffix);
        case 40:
          return createCounterStyleFromRange(value, 1776, 1785, true, defaultSuffix);
        case 43:
          return createCounterStyleFromRange(value, 3046, 3055, true, defaultSuffix);
        case 44:
          return createCounterStyleFromRange(value, 3174, 3183, true, defaultSuffix);
        case 45:
          return createCounterStyleFromRange(value, 3664, 3673, true, defaultSuffix);
        case 46:
          return createCounterStyleFromRange(value, 3872, 3881, true, defaultSuffix);
        case 3:
        default:
          return createCounterStyleFromRange(value, 48, 57, true, defaultSuffix);
      }
    };
    var IGNORE_ATTRIBUTE = "data-html2canvas-ignore";
    var DocumentCloner = function() {
      function DocumentCloner2(context, element, options) {
        this.context = context;
        this.options = options;
        this.scrolledElements = [];
        this.referenceElement = element;
        this.counters = new CounterState;
        this.quoteDepth = 0;
        if (!element.ownerDocument) {
          throw new Error("Cloned element does not have an owner document");
        }
        this.documentElement = this.cloneNode(element.ownerDocument.documentElement, false);
      }
      DocumentCloner2.prototype.toIFrame = function(ownerDocument, windowSize) {
        var _this = this;
        var iframe = createIFrameContainer(ownerDocument, windowSize);
        if (!iframe.contentWindow) {
          return Promise.reject("Unable to find iframe window");
        }
        var scrollX = ownerDocument.defaultView.pageXOffset;
        var scrollY = ownerDocument.defaultView.pageYOffset;
        var cloneWindow = iframe.contentWindow;
        var documentClone = cloneWindow.document;
        var iframeLoad = iframeLoader(iframe).then(function() {
          return __awaiter(_this, undefined, undefined, function() {
            var onclone, referenceElement;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  this.scrolledElements.forEach(restoreNodeScroll);
                  if (cloneWindow) {
                    cloneWindow.scrollTo(windowSize.left, windowSize.top);
                    if (/(iPad|iPhone|iPod)/g.test(navigator.userAgent) && (cloneWindow.scrollY !== windowSize.top || cloneWindow.scrollX !== windowSize.left)) {
                      this.context.logger.warn("Unable to restore scroll position for cloned document");
                      this.context.windowBounds = this.context.windowBounds.add(cloneWindow.scrollX - windowSize.left, cloneWindow.scrollY - windowSize.top, 0, 0);
                    }
                  }
                  onclone = this.options.onclone;
                  referenceElement = this.clonedReferenceElement;
                  if (typeof referenceElement === "undefined") {
                    return [2, Promise.reject("Error finding the " + this.referenceElement.nodeName + " in the cloned document")];
                  }
                  if (!(documentClone.fonts && documentClone.fonts.ready))
                    return [3, 2];
                  return [4, documentClone.fonts.ready];
                case 1:
                  _a2.sent();
                  _a2.label = 2;
                case 2:
                  if (!/(AppleWebKit)/g.test(navigator.userAgent))
                    return [3, 4];
                  return [4, imagesReady(documentClone)];
                case 3:
                  _a2.sent();
                  _a2.label = 4;
                case 4:
                  if (typeof onclone === "function") {
                    return [2, Promise.resolve().then(function() {
                      return onclone(documentClone, referenceElement);
                    }).then(function() {
                      return iframe;
                    })];
                  }
                  return [2, iframe];
              }
            });
          });
        });
        documentClone.open();
        documentClone.write(serializeDoctype(document.doctype) + "<html></html>");
        restoreOwnerScroll(this.referenceElement.ownerDocument, scrollX, scrollY);
        documentClone.replaceChild(documentClone.adoptNode(this.documentElement), documentClone.documentElement);
        documentClone.close();
        return iframeLoad;
      };
      DocumentCloner2.prototype.createElementClone = function(node) {
        if (isDebugging(node, 2)) {
          debugger;
        }
        if (isCanvasElement(node)) {
          return this.createCanvasClone(node);
        }
        if (isVideoElement(node)) {
          return this.createVideoClone(node);
        }
        if (isStyleElement(node)) {
          return this.createStyleClone(node);
        }
        var clone = node.cloneNode(false);
        if (isImageElement(clone)) {
          if (isImageElement(node) && node.currentSrc && node.currentSrc !== node.src) {
            clone.src = node.currentSrc;
            clone.srcset = "";
          }
          if (clone.loading === "lazy") {
            clone.loading = "eager";
          }
        }
        if (isCustomElement(clone)) {
          return this.createCustomElementClone(clone);
        }
        return clone;
      };
      DocumentCloner2.prototype.createCustomElementClone = function(node) {
        var clone = document.createElement("html2canvascustomelement");
        copyCSSStyles(node.style, clone);
        return clone;
      };
      DocumentCloner2.prototype.createStyleClone = function(node) {
        try {
          var sheet = node.sheet;
          if (sheet && sheet.cssRules) {
            var css = [].slice.call(sheet.cssRules, 0).reduce(function(css2, rule) {
              if (rule && typeof rule.cssText === "string") {
                return css2 + rule.cssText;
              }
              return css2;
            }, "");
            var style2 = node.cloneNode(false);
            style2.textContent = css;
            return style2;
          }
        } catch (e2) {
          this.context.logger.error("Unable to access cssRules property", e2);
          if (e2.name !== "SecurityError") {
            throw e2;
          }
        }
        return node.cloneNode(false);
      };
      DocumentCloner2.prototype.createCanvasClone = function(canvas) {
        var _a2;
        if (this.options.inlineImages && canvas.ownerDocument) {
          var img = canvas.ownerDocument.createElement("img");
          try {
            img.src = canvas.toDataURL();
            return img;
          } catch (e2) {
            this.context.logger.info("Unable to inline canvas contents, canvas is tainted", canvas);
          }
        }
        var clonedCanvas = canvas.cloneNode(false);
        try {
          clonedCanvas.width = canvas.width;
          clonedCanvas.height = canvas.height;
          var ctx = canvas.getContext("2d");
          var clonedCtx = clonedCanvas.getContext("2d");
          if (clonedCtx) {
            if (!this.options.allowTaint && ctx) {
              clonedCtx.putImageData(ctx.getImageData(0, 0, canvas.width, canvas.height), 0, 0);
            } else {
              var gl = (_a2 = canvas.getContext("webgl2")) !== null && _a2 !== undefined ? _a2 : canvas.getContext("webgl");
              if (gl) {
                var attribs = gl.getContextAttributes();
                if ((attribs === null || attribs === undefined ? undefined : attribs.preserveDrawingBuffer) === false) {
                  this.context.logger.warn("Unable to clone WebGL context as it has preserveDrawingBuffer=false", canvas);
                }
              }
              clonedCtx.drawImage(canvas, 0, 0);
            }
          }
          return clonedCanvas;
        } catch (e2) {
          this.context.logger.info("Unable to clone canvas as it is tainted", canvas);
        }
        return clonedCanvas;
      };
      DocumentCloner2.prototype.createVideoClone = function(video) {
        var canvas = video.ownerDocument.createElement("canvas");
        canvas.width = video.offsetWidth;
        canvas.height = video.offsetHeight;
        var ctx = canvas.getContext("2d");
        try {
          if (ctx) {
            ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
            if (!this.options.allowTaint) {
              ctx.getImageData(0, 0, canvas.width, canvas.height);
            }
          }
          return canvas;
        } catch (e2) {
          this.context.logger.info("Unable to clone video as it is tainted", video);
        }
        var blankCanvas = video.ownerDocument.createElement("canvas");
        blankCanvas.width = video.offsetWidth;
        blankCanvas.height = video.offsetHeight;
        return blankCanvas;
      };
      DocumentCloner2.prototype.appendChildNode = function(clone, child, copyStyles) {
        if (!isElementNode(child) || !isScriptElement(child) && !child.hasAttribute(IGNORE_ATTRIBUTE) && (typeof this.options.ignoreElements !== "function" || !this.options.ignoreElements(child))) {
          if (!this.options.copyStyles || !isElementNode(child) || !isStyleElement(child)) {
            clone.appendChild(this.cloneNode(child, copyStyles));
          }
        }
      };
      DocumentCloner2.prototype.cloneChildNodes = function(node, clone, copyStyles) {
        var _this = this;
        for (var child = node.shadowRoot ? node.shadowRoot.firstChild : node.firstChild;child; child = child.nextSibling) {
          if (isElementNode(child) && isSlotElement(child) && typeof child.assignedNodes === "function") {
            var assignedNodes = child.assignedNodes();
            if (assignedNodes.length) {
              assignedNodes.forEach(function(assignedNode) {
                return _this.appendChildNode(clone, assignedNode, copyStyles);
              });
            }
          } else {
            this.appendChildNode(clone, child, copyStyles);
          }
        }
      };
      DocumentCloner2.prototype.cloneNode = function(node, copyStyles) {
        if (isTextNode(node)) {
          return document.createTextNode(node.data);
        }
        if (!node.ownerDocument) {
          return node.cloneNode(false);
        }
        var window2 = node.ownerDocument.defaultView;
        if (window2 && isElementNode(node) && (isHTMLElementNode(node) || isSVGElementNode(node))) {
          var clone = this.createElementClone(node);
          clone.style.transitionProperty = "none";
          var style2 = window2.getComputedStyle(node);
          var styleBefore = window2.getComputedStyle(node, ":before");
          var styleAfter = window2.getComputedStyle(node, ":after");
          if (this.referenceElement === node && isHTMLElementNode(clone)) {
            this.clonedReferenceElement = clone;
          }
          if (isBodyElement(clone)) {
            createPseudoHideStyles(clone);
          }
          var counters = this.counters.parse(new CSSParsedCounterDeclaration(this.context, style2));
          var before = this.resolvePseudoContent(node, clone, styleBefore, PseudoElementType.BEFORE);
          if (isCustomElement(node)) {
            copyStyles = true;
          }
          if (!isVideoElement(node)) {
            this.cloneChildNodes(node, clone, copyStyles);
          }
          if (before) {
            clone.insertBefore(before, clone.firstChild);
          }
          var after = this.resolvePseudoContent(node, clone, styleAfter, PseudoElementType.AFTER);
          if (after) {
            clone.appendChild(after);
          }
          this.counters.pop(counters);
          if (style2 && (this.options.copyStyles || isSVGElementNode(node)) && !isIFrameElement(node) || copyStyles) {
            copyCSSStyles(style2, clone);
          }
          if (node.scrollTop !== 0 || node.scrollLeft !== 0) {
            this.scrolledElements.push([clone, node.scrollLeft, node.scrollTop]);
          }
          if ((isTextareaElement(node) || isSelectElement(node)) && (isTextareaElement(clone) || isSelectElement(clone))) {
            clone.value = node.value;
          }
          return clone;
        }
        return node.cloneNode(false);
      };
      DocumentCloner2.prototype.resolvePseudoContent = function(node, clone, style2, pseudoElt) {
        var _this = this;
        if (!style2) {
          return;
        }
        var value = style2.content;
        var document2 = clone.ownerDocument;
        if (!document2 || !value || value === "none" || value === "-moz-alt-content" || style2.display === "none") {
          return;
        }
        this.counters.parse(new CSSParsedCounterDeclaration(this.context, style2));
        var declaration = new CSSParsedPseudoDeclaration(this.context, style2);
        var anonymousReplacedElement = document2.createElement("html2canvaspseudoelement");
        copyCSSStyles(style2, anonymousReplacedElement);
        declaration.content.forEach(function(token) {
          if (token.type === 0) {
            anonymousReplacedElement.appendChild(document2.createTextNode(token.value));
          } else if (token.type === 22) {
            var img = document2.createElement("img");
            img.src = token.value;
            img.style.opacity = "1";
            anonymousReplacedElement.appendChild(img);
          } else if (token.type === 18) {
            if (token.name === "attr") {
              var attr = token.values.filter(isIdentToken);
              if (attr.length) {
                anonymousReplacedElement.appendChild(document2.createTextNode(node.getAttribute(attr[0].value) || ""));
              }
            } else if (token.name === "counter") {
              var _a2 = token.values.filter(nonFunctionArgSeparator), counter = _a2[0], counterStyle = _a2[1];
              if (counter && isIdentToken(counter)) {
                var counterState = _this.counters.getCounterValue(counter.value);
                var counterType = counterStyle && isIdentToken(counterStyle) ? listStyleType.parse(_this.context, counterStyle.value) : 3;
                anonymousReplacedElement.appendChild(document2.createTextNode(createCounterText(counterState, counterType, false)));
              }
            } else if (token.name === "counters") {
              var _b2 = token.values.filter(nonFunctionArgSeparator), counter = _b2[0], delim = _b2[1], counterStyle = _b2[2];
              if (counter && isIdentToken(counter)) {
                var counterStates = _this.counters.getCounterValues(counter.value);
                var counterType_1 = counterStyle && isIdentToken(counterStyle) ? listStyleType.parse(_this.context, counterStyle.value) : 3;
                var separator = delim && delim.type === 0 ? delim.value : "";
                var text = counterStates.map(function(value2) {
                  return createCounterText(value2, counterType_1, false);
                }).join(separator);
                anonymousReplacedElement.appendChild(document2.createTextNode(text));
              }
            } else
              ;
          } else if (token.type === 20) {
            switch (token.value) {
              case "open-quote":
                anonymousReplacedElement.appendChild(document2.createTextNode(getQuote(declaration.quotes, _this.quoteDepth++, true)));
                break;
              case "close-quote":
                anonymousReplacedElement.appendChild(document2.createTextNode(getQuote(declaration.quotes, --_this.quoteDepth, false)));
                break;
              default:
                anonymousReplacedElement.appendChild(document2.createTextNode(token.value));
            }
          }
        });
        anonymousReplacedElement.className = PSEUDO_HIDE_ELEMENT_CLASS_BEFORE + " " + PSEUDO_HIDE_ELEMENT_CLASS_AFTER;
        var newClassName = pseudoElt === PseudoElementType.BEFORE ? " " + PSEUDO_HIDE_ELEMENT_CLASS_BEFORE : " " + PSEUDO_HIDE_ELEMENT_CLASS_AFTER;
        if (isSVGElementNode(clone)) {
          clone.className.baseValue += newClassName;
        } else {
          clone.className += newClassName;
        }
        return anonymousReplacedElement;
      };
      DocumentCloner2.destroy = function(container) {
        if (container.parentNode) {
          container.parentNode.removeChild(container);
          return true;
        }
        return false;
      };
      return DocumentCloner2;
    }();
    var PseudoElementType;
    (function(PseudoElementType2) {
      PseudoElementType2[PseudoElementType2["BEFORE"] = 0] = "BEFORE";
      PseudoElementType2[PseudoElementType2["AFTER"] = 1] = "AFTER";
    })(PseudoElementType || (PseudoElementType = {}));
    var createIFrameContainer = function(ownerDocument, bounds) {
      var cloneIframeContainer = ownerDocument.createElement("iframe");
      cloneIframeContainer.className = "html2canvas-container";
      cloneIframeContainer.style.visibility = "hidden";
      cloneIframeContainer.style.position = "fixed";
      cloneIframeContainer.style.left = "-10000px";
      cloneIframeContainer.style.top = "0px";
      cloneIframeContainer.style.border = "0";
      cloneIframeContainer.width = bounds.width.toString();
      cloneIframeContainer.height = bounds.height.toString();
      cloneIframeContainer.scrolling = "no";
      cloneIframeContainer.setAttribute(IGNORE_ATTRIBUTE, "true");
      ownerDocument.body.appendChild(cloneIframeContainer);
      return cloneIframeContainer;
    };
    var imageReady = function(img) {
      return new Promise(function(resolve) {
        if (img.complete) {
          resolve();
          return;
        }
        if (!img.src) {
          resolve();
          return;
        }
        img.onload = resolve;
        img.onerror = resolve;
      });
    };
    var imagesReady = function(document2) {
      return Promise.all([].slice.call(document2.images, 0).map(imageReady));
    };
    var iframeLoader = function(iframe) {
      return new Promise(function(resolve, reject) {
        var cloneWindow = iframe.contentWindow;
        if (!cloneWindow) {
          return reject("No window assigned for iframe");
        }
        var documentClone = cloneWindow.document;
        cloneWindow.onload = iframe.onload = function() {
          cloneWindow.onload = iframe.onload = null;
          var interval = setInterval(function() {
            if (documentClone.body.childNodes.length > 0 && documentClone.readyState === "complete") {
              clearInterval(interval);
              resolve(iframe);
            }
          }, 50);
        };
      });
    };
    var ignoredStyleProperties = [
      "all",
      "d",
      "content"
    ];
    var copyCSSStyles = function(style2, target) {
      for (var i4 = style2.length - 1;i4 >= 0; i4--) {
        var property = style2.item(i4);
        if (ignoredStyleProperties.indexOf(property) === -1) {
          target.style.setProperty(property, style2.getPropertyValue(property));
        }
      }
      return target;
    };
    var serializeDoctype = function(doctype) {
      var str = "";
      if (doctype) {
        str += "<!DOCTYPE ";
        if (doctype.name) {
          str += doctype.name;
        }
        if (doctype.internalSubset) {
          str += doctype.internalSubset;
        }
        if (doctype.publicId) {
          str += '"' + doctype.publicId + '"';
        }
        if (doctype.systemId) {
          str += '"' + doctype.systemId + '"';
        }
        str += ">";
      }
      return str;
    };
    var restoreOwnerScroll = function(ownerDocument, x2, y) {
      if (ownerDocument && ownerDocument.defaultView && (x2 !== ownerDocument.defaultView.pageXOffset || y !== ownerDocument.defaultView.pageYOffset)) {
        ownerDocument.defaultView.scrollTo(x2, y);
      }
    };
    var restoreNodeScroll = function(_a2) {
      var element = _a2[0], x2 = _a2[1], y = _a2[2];
      element.scrollLeft = x2;
      element.scrollTop = y;
    };
    var PSEUDO_BEFORE = ":before";
    var PSEUDO_AFTER = ":after";
    var PSEUDO_HIDE_ELEMENT_CLASS_BEFORE = "___html2canvas___pseudoelement_before";
    var PSEUDO_HIDE_ELEMENT_CLASS_AFTER = "___html2canvas___pseudoelement_after";
    var PSEUDO_HIDE_ELEMENT_STYLE = `{
    content: "" !important;
    display: none !important;
}`;
    var createPseudoHideStyles = function(body) {
      createStyles(body, "." + PSEUDO_HIDE_ELEMENT_CLASS_BEFORE + PSEUDO_BEFORE + PSEUDO_HIDE_ELEMENT_STYLE + `
         .` + PSEUDO_HIDE_ELEMENT_CLASS_AFTER + PSEUDO_AFTER + PSEUDO_HIDE_ELEMENT_STYLE);
    };
    var createStyles = function(body, styles) {
      var document2 = body.ownerDocument;
      if (document2) {
        var style2 = document2.createElement("style");
        style2.textContent = styles;
        body.appendChild(style2);
      }
    };
    var CacheStorage = function() {
      function CacheStorage2() {}
      CacheStorage2.getOrigin = function(url) {
        var link = CacheStorage2._link;
        if (!link) {
          return "about:blank";
        }
        link.href = url;
        link.href = link.href;
        return link.protocol + link.hostname + link.port;
      };
      CacheStorage2.isSameOrigin = function(src) {
        return CacheStorage2.getOrigin(src) === CacheStorage2._origin;
      };
      CacheStorage2.setContext = function(window2) {
        CacheStorage2._link = window2.document.createElement("a");
        CacheStorage2._origin = CacheStorage2.getOrigin(window2.location.href);
      };
      CacheStorage2._origin = "about:blank";
      return CacheStorage2;
    }();
    var Cache = function() {
      function Cache2(context, _options) {
        this.context = context;
        this._options = _options;
        this._cache = {};
      }
      Cache2.prototype.addImage = function(src) {
        var result = Promise.resolve();
        if (this.has(src)) {
          return result;
        }
        if (isBlobImage(src) || isRenderable(src)) {
          (this._cache[src] = this.loadImage(src)).catch(function() {});
          return result;
        }
        return result;
      };
      Cache2.prototype.match = function(src) {
        return this._cache[src];
      };
      Cache2.prototype.loadImage = function(key) {
        return __awaiter(this, undefined, undefined, function() {
          var isSameOrigin, useCORS, useProxy, src;
          var _this = this;
          return __generator(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                isSameOrigin = CacheStorage.isSameOrigin(key);
                useCORS = !isInlineImage(key) && this._options.useCORS === true && FEATURES.SUPPORT_CORS_IMAGES && !isSameOrigin;
                useProxy = !isInlineImage(key) && !isSameOrigin && !isBlobImage(key) && typeof this._options.proxy === "string" && FEATURES.SUPPORT_CORS_XHR && !useCORS;
                if (!isSameOrigin && this._options.allowTaint === false && !isInlineImage(key) && !isBlobImage(key) && !useProxy && !useCORS) {
                  return [2];
                }
                src = key;
                if (!useProxy)
                  return [3, 2];
                return [4, this.proxy(src)];
              case 1:
                src = _a2.sent();
                _a2.label = 2;
              case 2:
                this.context.logger.debug("Added image " + key.substring(0, 256));
                return [4, new Promise(function(resolve, reject) {
                  var img = new Image;
                  img.onload = function() {
                    return resolve(img);
                  };
                  img.onerror = reject;
                  if (isInlineBase64Image(src) || useCORS) {
                    img.crossOrigin = "anonymous";
                  }
                  img.src = src;
                  if (img.complete === true) {
                    setTimeout(function() {
                      return resolve(img);
                    }, 500);
                  }
                  if (_this._options.imageTimeout > 0) {
                    setTimeout(function() {
                      return reject("Timed out (" + _this._options.imageTimeout + "ms) loading image");
                    }, _this._options.imageTimeout);
                  }
                })];
              case 3:
                return [2, _a2.sent()];
            }
          });
        });
      };
      Cache2.prototype.has = function(key) {
        return typeof this._cache[key] !== "undefined";
      };
      Cache2.prototype.keys = function() {
        return Promise.resolve(Object.keys(this._cache));
      };
      Cache2.prototype.proxy = function(src) {
        var _this = this;
        var proxy = this._options.proxy;
        if (!proxy) {
          throw new Error("No proxy defined");
        }
        var key = src.substring(0, 256);
        return new Promise(function(resolve, reject) {
          var responseType = FEATURES.SUPPORT_RESPONSE_TYPE ? "blob" : "text";
          var xhr = new XMLHttpRequest;
          xhr.onload = function() {
            if (xhr.status === 200) {
              if (responseType === "text") {
                resolve(xhr.response);
              } else {
                var reader_1 = new FileReader;
                reader_1.addEventListener("load", function() {
                  return resolve(reader_1.result);
                }, false);
                reader_1.addEventListener("error", function(e2) {
                  return reject(e2);
                }, false);
                reader_1.readAsDataURL(xhr.response);
              }
            } else {
              reject("Failed to proxy resource " + key + " with status code " + xhr.status);
            }
          };
          xhr.onerror = reject;
          var queryString = proxy.indexOf("?") > -1 ? "&" : "?";
          xhr.open("GET", "" + proxy + queryString + "url=" + encodeURIComponent(src) + "&responseType=" + responseType);
          if (responseType !== "text" && xhr instanceof XMLHttpRequest) {
            xhr.responseType = responseType;
          }
          if (_this._options.imageTimeout) {
            var timeout_1 = _this._options.imageTimeout;
            xhr.timeout = timeout_1;
            xhr.ontimeout = function() {
              return reject("Timed out (" + timeout_1 + "ms) proxying " + key);
            };
          }
          xhr.send();
        });
      };
      return Cache2;
    }();
    var INLINE_SVG = /^data:image\/svg\+xml/i;
    var INLINE_BASE64 = /^data:image\/.*;base64,/i;
    var INLINE_IMG = /^data:image\/.*/i;
    var isRenderable = function(src) {
      return FEATURES.SUPPORT_SVG_DRAWING || !isSVG(src);
    };
    var isInlineImage = function(src) {
      return INLINE_IMG.test(src);
    };
    var isInlineBase64Image = function(src) {
      return INLINE_BASE64.test(src);
    };
    var isBlobImage = function(src) {
      return src.substr(0, 4) === "blob";
    };
    var isSVG = function(src) {
      return src.substr(-3).toLowerCase() === "svg" || INLINE_SVG.test(src);
    };
    var Vector = function() {
      function Vector2(x2, y) {
        this.type = 0;
        this.x = x2;
        this.y = y;
      }
      Vector2.prototype.add = function(deltaX, deltaY) {
        return new Vector2(this.x + deltaX, this.y + deltaY);
      };
      return Vector2;
    }();
    var lerp = function(a2, b, t) {
      return new Vector(a2.x + (b.x - a2.x) * t, a2.y + (b.y - a2.y) * t);
    };
    var BezierCurve = function() {
      function BezierCurve2(start, startControl, endControl, end) {
        this.type = 1;
        this.start = start;
        this.startControl = startControl;
        this.endControl = endControl;
        this.end = end;
      }
      BezierCurve2.prototype.subdivide = function(t, firstHalf) {
        var ab = lerp(this.start, this.startControl, t);
        var bc = lerp(this.startControl, this.endControl, t);
        var cd = lerp(this.endControl, this.end, t);
        var abbc = lerp(ab, bc, t);
        var bccd = lerp(bc, cd, t);
        var dest = lerp(abbc, bccd, t);
        return firstHalf ? new BezierCurve2(this.start, ab, abbc, dest) : new BezierCurve2(dest, bccd, cd, this.end);
      };
      BezierCurve2.prototype.add = function(deltaX, deltaY) {
        return new BezierCurve2(this.start.add(deltaX, deltaY), this.startControl.add(deltaX, deltaY), this.endControl.add(deltaX, deltaY), this.end.add(deltaX, deltaY));
      };
      BezierCurve2.prototype.reverse = function() {
        return new BezierCurve2(this.end, this.endControl, this.startControl, this.start);
      };
      return BezierCurve2;
    }();
    var isBezierCurve = function(path) {
      return path.type === 1;
    };
    var BoundCurves = function() {
      function BoundCurves2(element) {
        var styles = element.styles;
        var bounds = element.bounds;
        var _a2 = getAbsoluteValueForTuple(styles.borderTopLeftRadius, bounds.width, bounds.height), tlh = _a2[0], tlv = _a2[1];
        var _b2 = getAbsoluteValueForTuple(styles.borderTopRightRadius, bounds.width, bounds.height), trh = _b2[0], trv = _b2[1];
        var _c = getAbsoluteValueForTuple(styles.borderBottomRightRadius, bounds.width, bounds.height), brh = _c[0], brv = _c[1];
        var _d = getAbsoluteValueForTuple(styles.borderBottomLeftRadius, bounds.width, bounds.height), blh = _d[0], blv = _d[1];
        var factors = [];
        factors.push((tlh + trh) / bounds.width);
        factors.push((blh + brh) / bounds.width);
        factors.push((tlv + blv) / bounds.height);
        factors.push((trv + brv) / bounds.height);
        var maxFactor = Math.max.apply(Math, factors);
        if (maxFactor > 1) {
          tlh /= maxFactor;
          tlv /= maxFactor;
          trh /= maxFactor;
          trv /= maxFactor;
          brh /= maxFactor;
          brv /= maxFactor;
          blh /= maxFactor;
          blv /= maxFactor;
        }
        var topWidth = bounds.width - trh;
        var rightHeight = bounds.height - brv;
        var bottomWidth = bounds.width - brh;
        var leftHeight = bounds.height - blv;
        var borderTopWidth2 = styles.borderTopWidth;
        var borderRightWidth2 = styles.borderRightWidth;
        var borderBottomWidth2 = styles.borderBottomWidth;
        var borderLeftWidth2 = styles.borderLeftWidth;
        var paddingTop2 = getAbsoluteValue(styles.paddingTop, element.bounds.width);
        var paddingRight2 = getAbsoluteValue(styles.paddingRight, element.bounds.width);
        var paddingBottom2 = getAbsoluteValue(styles.paddingBottom, element.bounds.width);
        var paddingLeft2 = getAbsoluteValue(styles.paddingLeft, element.bounds.width);
        this.topLeftBorderDoubleOuterBox = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2 / 3, bounds.top + borderTopWidth2 / 3, tlh - borderLeftWidth2 / 3, tlv - borderTopWidth2 / 3, CORNER.TOP_LEFT) : new Vector(bounds.left + borderLeftWidth2 / 3, bounds.top + borderTopWidth2 / 3);
        this.topRightBorderDoubleOuterBox = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left + topWidth, bounds.top + borderTopWidth2 / 3, trh - borderRightWidth2 / 3, trv - borderTopWidth2 / 3, CORNER.TOP_RIGHT) : new Vector(bounds.left + bounds.width - borderRightWidth2 / 3, bounds.top + borderTopWidth2 / 3);
        this.bottomRightBorderDoubleOuterBox = brh > 0 || brv > 0 ? getCurvePoints(bounds.left + bottomWidth, bounds.top + rightHeight, brh - borderRightWidth2 / 3, brv - borderBottomWidth2 / 3, CORNER.BOTTOM_RIGHT) : new Vector(bounds.left + bounds.width - borderRightWidth2 / 3, bounds.top + bounds.height - borderBottomWidth2 / 3);
        this.bottomLeftBorderDoubleOuterBox = blh > 0 || blv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2 / 3, bounds.top + leftHeight, blh - borderLeftWidth2 / 3, blv - borderBottomWidth2 / 3, CORNER.BOTTOM_LEFT) : new Vector(bounds.left + borderLeftWidth2 / 3, bounds.top + bounds.height - borderBottomWidth2 / 3);
        this.topLeftBorderDoubleInnerBox = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2 * 2 / 3, bounds.top + borderTopWidth2 * 2 / 3, tlh - borderLeftWidth2 * 2 / 3, tlv - borderTopWidth2 * 2 / 3, CORNER.TOP_LEFT) : new Vector(bounds.left + borderLeftWidth2 * 2 / 3, bounds.top + borderTopWidth2 * 2 / 3);
        this.topRightBorderDoubleInnerBox = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left + topWidth, bounds.top + borderTopWidth2 * 2 / 3, trh - borderRightWidth2 * 2 / 3, trv - borderTopWidth2 * 2 / 3, CORNER.TOP_RIGHT) : new Vector(bounds.left + bounds.width - borderRightWidth2 * 2 / 3, bounds.top + borderTopWidth2 * 2 / 3);
        this.bottomRightBorderDoubleInnerBox = brh > 0 || brv > 0 ? getCurvePoints(bounds.left + bottomWidth, bounds.top + rightHeight, brh - borderRightWidth2 * 2 / 3, brv - borderBottomWidth2 * 2 / 3, CORNER.BOTTOM_RIGHT) : new Vector(bounds.left + bounds.width - borderRightWidth2 * 2 / 3, bounds.top + bounds.height - borderBottomWidth2 * 2 / 3);
        this.bottomLeftBorderDoubleInnerBox = blh > 0 || blv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2 * 2 / 3, bounds.top + leftHeight, blh - borderLeftWidth2 * 2 / 3, blv - borderBottomWidth2 * 2 / 3, CORNER.BOTTOM_LEFT) : new Vector(bounds.left + borderLeftWidth2 * 2 / 3, bounds.top + bounds.height - borderBottomWidth2 * 2 / 3);
        this.topLeftBorderStroke = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2 / 2, bounds.top + borderTopWidth2 / 2, tlh - borderLeftWidth2 / 2, tlv - borderTopWidth2 / 2, CORNER.TOP_LEFT) : new Vector(bounds.left + borderLeftWidth2 / 2, bounds.top + borderTopWidth2 / 2);
        this.topRightBorderStroke = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left + topWidth, bounds.top + borderTopWidth2 / 2, trh - borderRightWidth2 / 2, trv - borderTopWidth2 / 2, CORNER.TOP_RIGHT) : new Vector(bounds.left + bounds.width - borderRightWidth2 / 2, bounds.top + borderTopWidth2 / 2);
        this.bottomRightBorderStroke = brh > 0 || brv > 0 ? getCurvePoints(bounds.left + bottomWidth, bounds.top + rightHeight, brh - borderRightWidth2 / 2, brv - borderBottomWidth2 / 2, CORNER.BOTTOM_RIGHT) : new Vector(bounds.left + bounds.width - borderRightWidth2 / 2, bounds.top + bounds.height - borderBottomWidth2 / 2);
        this.bottomLeftBorderStroke = blh > 0 || blv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2 / 2, bounds.top + leftHeight, blh - borderLeftWidth2 / 2, blv - borderBottomWidth2 / 2, CORNER.BOTTOM_LEFT) : new Vector(bounds.left + borderLeftWidth2 / 2, bounds.top + bounds.height - borderBottomWidth2 / 2);
        this.topLeftBorderBox = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left, bounds.top, tlh, tlv, CORNER.TOP_LEFT) : new Vector(bounds.left, bounds.top);
        this.topRightBorderBox = trh > 0 || trv > 0 ? getCurvePoints(bounds.left + topWidth, bounds.top, trh, trv, CORNER.TOP_RIGHT) : new Vector(bounds.left + bounds.width, bounds.top);
        this.bottomRightBorderBox = brh > 0 || brv > 0 ? getCurvePoints(bounds.left + bottomWidth, bounds.top + rightHeight, brh, brv, CORNER.BOTTOM_RIGHT) : new Vector(bounds.left + bounds.width, bounds.top + bounds.height);
        this.bottomLeftBorderBox = blh > 0 || blv > 0 ? getCurvePoints(bounds.left, bounds.top + leftHeight, blh, blv, CORNER.BOTTOM_LEFT) : new Vector(bounds.left, bounds.top + bounds.height);
        this.topLeftPaddingBox = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2, bounds.top + borderTopWidth2, Math.max(0, tlh - borderLeftWidth2), Math.max(0, tlv - borderTopWidth2), CORNER.TOP_LEFT) : new Vector(bounds.left + borderLeftWidth2, bounds.top + borderTopWidth2);
        this.topRightPaddingBox = trh > 0 || trv > 0 ? getCurvePoints(bounds.left + Math.min(topWidth, bounds.width - borderRightWidth2), bounds.top + borderTopWidth2, topWidth > bounds.width + borderRightWidth2 ? 0 : Math.max(0, trh - borderRightWidth2), Math.max(0, trv - borderTopWidth2), CORNER.TOP_RIGHT) : new Vector(bounds.left + bounds.width - borderRightWidth2, bounds.top + borderTopWidth2);
        this.bottomRightPaddingBox = brh > 0 || brv > 0 ? getCurvePoints(bounds.left + Math.min(bottomWidth, bounds.width - borderLeftWidth2), bounds.top + Math.min(rightHeight, bounds.height - borderBottomWidth2), Math.max(0, brh - borderRightWidth2), Math.max(0, brv - borderBottomWidth2), CORNER.BOTTOM_RIGHT) : new Vector(bounds.left + bounds.width - borderRightWidth2, bounds.top + bounds.height - borderBottomWidth2);
        this.bottomLeftPaddingBox = blh > 0 || blv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2, bounds.top + Math.min(leftHeight, bounds.height - borderBottomWidth2), Math.max(0, blh - borderLeftWidth2), Math.max(0, blv - borderBottomWidth2), CORNER.BOTTOM_LEFT) : new Vector(bounds.left + borderLeftWidth2, bounds.top + bounds.height - borderBottomWidth2);
        this.topLeftContentBox = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2 + paddingLeft2, bounds.top + borderTopWidth2 + paddingTop2, Math.max(0, tlh - (borderLeftWidth2 + paddingLeft2)), Math.max(0, tlv - (borderTopWidth2 + paddingTop2)), CORNER.TOP_LEFT) : new Vector(bounds.left + borderLeftWidth2 + paddingLeft2, bounds.top + borderTopWidth2 + paddingTop2);
        this.topRightContentBox = trh > 0 || trv > 0 ? getCurvePoints(bounds.left + Math.min(topWidth, bounds.width + borderLeftWidth2 + paddingLeft2), bounds.top + borderTopWidth2 + paddingTop2, topWidth > bounds.width + borderLeftWidth2 + paddingLeft2 ? 0 : trh - borderLeftWidth2 + paddingLeft2, trv - (borderTopWidth2 + paddingTop2), CORNER.TOP_RIGHT) : new Vector(bounds.left + bounds.width - (borderRightWidth2 + paddingRight2), bounds.top + borderTopWidth2 + paddingTop2);
        this.bottomRightContentBox = brh > 0 || brv > 0 ? getCurvePoints(bounds.left + Math.min(bottomWidth, bounds.width - (borderLeftWidth2 + paddingLeft2)), bounds.top + Math.min(rightHeight, bounds.height + borderTopWidth2 + paddingTop2), Math.max(0, brh - (borderRightWidth2 + paddingRight2)), brv - (borderBottomWidth2 + paddingBottom2), CORNER.BOTTOM_RIGHT) : new Vector(bounds.left + bounds.width - (borderRightWidth2 + paddingRight2), bounds.top + bounds.height - (borderBottomWidth2 + paddingBottom2));
        this.bottomLeftContentBox = blh > 0 || blv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2 + paddingLeft2, bounds.top + leftHeight, Math.max(0, blh - (borderLeftWidth2 + paddingLeft2)), blv - (borderBottomWidth2 + paddingBottom2), CORNER.BOTTOM_LEFT) : new Vector(bounds.left + borderLeftWidth2 + paddingLeft2, bounds.top + bounds.height - (borderBottomWidth2 + paddingBottom2));
      }
      return BoundCurves2;
    }();
    var CORNER;
    (function(CORNER2) {
      CORNER2[CORNER2["TOP_LEFT"] = 0] = "TOP_LEFT";
      CORNER2[CORNER2["TOP_RIGHT"] = 1] = "TOP_RIGHT";
      CORNER2[CORNER2["BOTTOM_RIGHT"] = 2] = "BOTTOM_RIGHT";
      CORNER2[CORNER2["BOTTOM_LEFT"] = 3] = "BOTTOM_LEFT";
    })(CORNER || (CORNER = {}));
    var getCurvePoints = function(x2, y, r1, r2, position2) {
      var kappa = 4 * ((Math.sqrt(2) - 1) / 3);
      var ox = r1 * kappa;
      var oy = r2 * kappa;
      var xm = x2 + r1;
      var ym = y + r2;
      switch (position2) {
        case CORNER.TOP_LEFT:
          return new BezierCurve(new Vector(x2, ym), new Vector(x2, ym - oy), new Vector(xm - ox, y), new Vector(xm, y));
        case CORNER.TOP_RIGHT:
          return new BezierCurve(new Vector(x2, y), new Vector(x2 + ox, y), new Vector(xm, ym - oy), new Vector(xm, ym));
        case CORNER.BOTTOM_RIGHT:
          return new BezierCurve(new Vector(xm, y), new Vector(xm, y + oy), new Vector(x2 + ox, ym), new Vector(x2, ym));
        case CORNER.BOTTOM_LEFT:
        default:
          return new BezierCurve(new Vector(xm, ym), new Vector(xm - ox, ym), new Vector(x2, y + oy), new Vector(x2, y));
      }
    };
    var calculateBorderBoxPath = function(curves) {
      return [curves.topLeftBorderBox, curves.topRightBorderBox, curves.bottomRightBorderBox, curves.bottomLeftBorderBox];
    };
    var calculateContentBoxPath = function(curves) {
      return [
        curves.topLeftContentBox,
        curves.topRightContentBox,
        curves.bottomRightContentBox,
        curves.bottomLeftContentBox
      ];
    };
    var calculatePaddingBoxPath = function(curves) {
      return [
        curves.topLeftPaddingBox,
        curves.topRightPaddingBox,
        curves.bottomRightPaddingBox,
        curves.bottomLeftPaddingBox
      ];
    };
    var TransformEffect = function() {
      function TransformEffect2(offsetX, offsetY, matrix2) {
        this.offsetX = offsetX;
        this.offsetY = offsetY;
        this.matrix = matrix2;
        this.type = 0;
        this.target = 2 | 4;
      }
      return TransformEffect2;
    }();
    var ClipEffect = function() {
      function ClipEffect2(path, target) {
        this.path = path;
        this.target = target;
        this.type = 1;
      }
      return ClipEffect2;
    }();
    var OpacityEffect = function() {
      function OpacityEffect2(opacity2) {
        this.opacity = opacity2;
        this.type = 2;
        this.target = 2 | 4;
      }
      return OpacityEffect2;
    }();
    var isTransformEffect = function(effect) {
      return effect.type === 0;
    };
    var isClipEffect = function(effect) {
      return effect.type === 1;
    };
    var isOpacityEffect = function(effect) {
      return effect.type === 2;
    };
    var equalPath = function(a2, b) {
      if (a2.length === b.length) {
        return a2.some(function(v, i4) {
          return v === b[i4];
        });
      }
      return false;
    };
    var transformPath = function(path, deltaX, deltaY, deltaW, deltaH) {
      return path.map(function(point, index) {
        switch (index) {
          case 0:
            return point.add(deltaX, deltaY);
          case 1:
            return point.add(deltaX + deltaW, deltaY);
          case 2:
            return point.add(deltaX + deltaW, deltaY + deltaH);
          case 3:
            return point.add(deltaX, deltaY + deltaH);
        }
        return point;
      });
    };
    var StackingContext = function() {
      function StackingContext2(container) {
        this.element = container;
        this.inlineLevel = [];
        this.nonInlineLevel = [];
        this.negativeZIndex = [];
        this.zeroOrAutoZIndexOrTransformedOrOpacity = [];
        this.positiveZIndex = [];
        this.nonPositionedFloats = [];
        this.nonPositionedInlineLevel = [];
      }
      return StackingContext2;
    }();
    var ElementPaint = function() {
      function ElementPaint2(container, parent) {
        this.container = container;
        this.parent = parent;
        this.effects = [];
        this.curves = new BoundCurves(this.container);
        if (this.container.styles.opacity < 1) {
          this.effects.push(new OpacityEffect(this.container.styles.opacity));
        }
        if (this.container.styles.transform !== null) {
          var offsetX = this.container.bounds.left + this.container.styles.transformOrigin[0].number;
          var offsetY = this.container.bounds.top + this.container.styles.transformOrigin[1].number;
          var matrix2 = this.container.styles.transform;
          this.effects.push(new TransformEffect(offsetX, offsetY, matrix2));
        }
        if (this.container.styles.overflowX !== 0) {
          var borderBox = calculateBorderBoxPath(this.curves);
          var paddingBox2 = calculatePaddingBoxPath(this.curves);
          if (equalPath(borderBox, paddingBox2)) {
            this.effects.push(new ClipEffect(borderBox, 2 | 4));
          } else {
            this.effects.push(new ClipEffect(borderBox, 2));
            this.effects.push(new ClipEffect(paddingBox2, 4));
          }
        }
      }
      ElementPaint2.prototype.getEffects = function(target) {
        var inFlow = [2, 3].indexOf(this.container.styles.position) === -1;
        var parent = this.parent;
        var effects = this.effects.slice(0);
        while (parent) {
          var croplessEffects = parent.effects.filter(function(effect) {
            return !isClipEffect(effect);
          });
          if (inFlow || parent.container.styles.position !== 0 || !parent.parent) {
            effects.unshift.apply(effects, croplessEffects);
            inFlow = [2, 3].indexOf(parent.container.styles.position) === -1;
            if (parent.container.styles.overflowX !== 0) {
              var borderBox = calculateBorderBoxPath(parent.curves);
              var paddingBox2 = calculatePaddingBoxPath(parent.curves);
              if (!equalPath(borderBox, paddingBox2)) {
                effects.unshift(new ClipEffect(paddingBox2, 2 | 4));
              }
            }
          } else {
            effects.unshift.apply(effects, croplessEffects);
          }
          parent = parent.parent;
        }
        return effects.filter(function(effect) {
          return contains(effect.target, target);
        });
      };
      return ElementPaint2;
    }();
    var parseStackTree = function(parent, stackingContext, realStackingContext, listItems) {
      parent.container.elements.forEach(function(child) {
        var treatAsRealStackingContext = contains(child.flags, 4);
        var createsStackingContext2 = contains(child.flags, 2);
        var paintContainer = new ElementPaint(child, parent);
        if (contains(child.styles.display, 2048)) {
          listItems.push(paintContainer);
        }
        var listOwnerItems = contains(child.flags, 8) ? [] : listItems;
        if (treatAsRealStackingContext || createsStackingContext2) {
          var parentStack = treatAsRealStackingContext || child.styles.isPositioned() ? realStackingContext : stackingContext;
          var stack = new StackingContext(paintContainer);
          if (child.styles.isPositioned() || child.styles.opacity < 1 || child.styles.isTransformed()) {
            var order_1 = child.styles.zIndex.order;
            if (order_1 < 0) {
              var index_1 = 0;
              parentStack.negativeZIndex.some(function(current, i4) {
                if (order_1 > current.element.container.styles.zIndex.order) {
                  index_1 = i4;
                  return false;
                } else if (index_1 > 0) {
                  return true;
                }
                return false;
              });
              parentStack.negativeZIndex.splice(index_1, 0, stack);
            } else if (order_1 > 0) {
              var index_2 = 0;
              parentStack.positiveZIndex.some(function(current, i4) {
                if (order_1 >= current.element.container.styles.zIndex.order) {
                  index_2 = i4 + 1;
                  return false;
                } else if (index_2 > 0) {
                  return true;
                }
                return false;
              });
              parentStack.positiveZIndex.splice(index_2, 0, stack);
            } else {
              parentStack.zeroOrAutoZIndexOrTransformedOrOpacity.push(stack);
            }
          } else {
            if (child.styles.isFloating()) {
              parentStack.nonPositionedFloats.push(stack);
            } else {
              parentStack.nonPositionedInlineLevel.push(stack);
            }
          }
          parseStackTree(paintContainer, stack, treatAsRealStackingContext ? stack : realStackingContext, listOwnerItems);
        } else {
          if (child.styles.isInlineLevel()) {
            stackingContext.inlineLevel.push(paintContainer);
          } else {
            stackingContext.nonInlineLevel.push(paintContainer);
          }
          parseStackTree(paintContainer, stackingContext, realStackingContext, listOwnerItems);
        }
        if (contains(child.flags, 8)) {
          processListItems(child, listOwnerItems);
        }
      });
    };
    var processListItems = function(owner, elements) {
      var numbering = owner instanceof OLElementContainer ? owner.start : 1;
      var reversed = owner instanceof OLElementContainer ? owner.reversed : false;
      for (var i4 = 0;i4 < elements.length; i4++) {
        var item = elements[i4];
        if (item.container instanceof LIElementContainer && typeof item.container.value === "number" && item.container.value !== 0) {
          numbering = item.container.value;
        }
        item.listValue = createCounterText(numbering, item.container.styles.listStyleType, true);
        numbering += reversed ? -1 : 1;
      }
    };
    var parseStackingContexts = function(container) {
      var paintContainer = new ElementPaint(container, null);
      var root = new StackingContext(paintContainer);
      var listItems = [];
      parseStackTree(paintContainer, root, root, listItems);
      processListItems(paintContainer.container, listItems);
      return root;
    };
    var parsePathForBorder = function(curves, borderSide) {
      switch (borderSide) {
        case 0:
          return createPathFromCurves(curves.topLeftBorderBox, curves.topLeftPaddingBox, curves.topRightBorderBox, curves.topRightPaddingBox);
        case 1:
          return createPathFromCurves(curves.topRightBorderBox, curves.topRightPaddingBox, curves.bottomRightBorderBox, curves.bottomRightPaddingBox);
        case 2:
          return createPathFromCurves(curves.bottomRightBorderBox, curves.bottomRightPaddingBox, curves.bottomLeftBorderBox, curves.bottomLeftPaddingBox);
        case 3:
        default:
          return createPathFromCurves(curves.bottomLeftBorderBox, curves.bottomLeftPaddingBox, curves.topLeftBorderBox, curves.topLeftPaddingBox);
      }
    };
    var parsePathForBorderDoubleOuter = function(curves, borderSide) {
      switch (borderSide) {
        case 0:
          return createPathFromCurves(curves.topLeftBorderBox, curves.topLeftBorderDoubleOuterBox, curves.topRightBorderBox, curves.topRightBorderDoubleOuterBox);
        case 1:
          return createPathFromCurves(curves.topRightBorderBox, curves.topRightBorderDoubleOuterBox, curves.bottomRightBorderBox, curves.bottomRightBorderDoubleOuterBox);
        case 2:
          return createPathFromCurves(curves.bottomRightBorderBox, curves.bottomRightBorderDoubleOuterBox, curves.bottomLeftBorderBox, curves.bottomLeftBorderDoubleOuterBox);
        case 3:
        default:
          return createPathFromCurves(curves.bottomLeftBorderBox, curves.bottomLeftBorderDoubleOuterBox, curves.topLeftBorderBox, curves.topLeftBorderDoubleOuterBox);
      }
    };
    var parsePathForBorderDoubleInner = function(curves, borderSide) {
      switch (borderSide) {
        case 0:
          return createPathFromCurves(curves.topLeftBorderDoubleInnerBox, curves.topLeftPaddingBox, curves.topRightBorderDoubleInnerBox, curves.topRightPaddingBox);
        case 1:
          return createPathFromCurves(curves.topRightBorderDoubleInnerBox, curves.topRightPaddingBox, curves.bottomRightBorderDoubleInnerBox, curves.bottomRightPaddingBox);
        case 2:
          return createPathFromCurves(curves.bottomRightBorderDoubleInnerBox, curves.bottomRightPaddingBox, curves.bottomLeftBorderDoubleInnerBox, curves.bottomLeftPaddingBox);
        case 3:
        default:
          return createPathFromCurves(curves.bottomLeftBorderDoubleInnerBox, curves.bottomLeftPaddingBox, curves.topLeftBorderDoubleInnerBox, curves.topLeftPaddingBox);
      }
    };
    var parsePathForBorderStroke = function(curves, borderSide) {
      switch (borderSide) {
        case 0:
          return createStrokePathFromCurves(curves.topLeftBorderStroke, curves.topRightBorderStroke);
        case 1:
          return createStrokePathFromCurves(curves.topRightBorderStroke, curves.bottomRightBorderStroke);
        case 2:
          return createStrokePathFromCurves(curves.bottomRightBorderStroke, curves.bottomLeftBorderStroke);
        case 3:
        default:
          return createStrokePathFromCurves(curves.bottomLeftBorderStroke, curves.topLeftBorderStroke);
      }
    };
    var createStrokePathFromCurves = function(outer1, outer2) {
      var path = [];
      if (isBezierCurve(outer1)) {
        path.push(outer1.subdivide(0.5, false));
      } else {
        path.push(outer1);
      }
      if (isBezierCurve(outer2)) {
        path.push(outer2.subdivide(0.5, true));
      } else {
        path.push(outer2);
      }
      return path;
    };
    var createPathFromCurves = function(outer1, inner1, outer2, inner2) {
      var path = [];
      if (isBezierCurve(outer1)) {
        path.push(outer1.subdivide(0.5, false));
      } else {
        path.push(outer1);
      }
      if (isBezierCurve(outer2)) {
        path.push(outer2.subdivide(0.5, true));
      } else {
        path.push(outer2);
      }
      if (isBezierCurve(inner2)) {
        path.push(inner2.subdivide(0.5, true).reverse());
      } else {
        path.push(inner2);
      }
      if (isBezierCurve(inner1)) {
        path.push(inner1.subdivide(0.5, false).reverse());
      } else {
        path.push(inner1);
      }
      return path;
    };
    var paddingBox = function(element) {
      var bounds = element.bounds;
      var styles = element.styles;
      return bounds.add(styles.borderLeftWidth, styles.borderTopWidth, -(styles.borderRightWidth + styles.borderLeftWidth), -(styles.borderTopWidth + styles.borderBottomWidth));
    };
    var contentBox = function(element) {
      var styles = element.styles;
      var bounds = element.bounds;
      var paddingLeft2 = getAbsoluteValue(styles.paddingLeft, bounds.width);
      var paddingRight2 = getAbsoluteValue(styles.paddingRight, bounds.width);
      var paddingTop2 = getAbsoluteValue(styles.paddingTop, bounds.width);
      var paddingBottom2 = getAbsoluteValue(styles.paddingBottom, bounds.width);
      return bounds.add(paddingLeft2 + styles.borderLeftWidth, paddingTop2 + styles.borderTopWidth, -(styles.borderRightWidth + styles.borderLeftWidth + paddingLeft2 + paddingRight2), -(styles.borderTopWidth + styles.borderBottomWidth + paddingTop2 + paddingBottom2));
    };
    var calculateBackgroundPositioningArea = function(backgroundOrigin2, element) {
      if (backgroundOrigin2 === 0) {
        return element.bounds;
      }
      if (backgroundOrigin2 === 2) {
        return contentBox(element);
      }
      return paddingBox(element);
    };
    var calculateBackgroundPaintingArea = function(backgroundClip2, element) {
      if (backgroundClip2 === 0) {
        return element.bounds;
      }
      if (backgroundClip2 === 2) {
        return contentBox(element);
      }
      return paddingBox(element);
    };
    var calculateBackgroundRendering = function(container, index, intrinsicSize) {
      var backgroundPositioningArea = calculateBackgroundPositioningArea(getBackgroundValueForIndex(container.styles.backgroundOrigin, index), container);
      var backgroundPaintingArea = calculateBackgroundPaintingArea(getBackgroundValueForIndex(container.styles.backgroundClip, index), container);
      var backgroundImageSize = calculateBackgroundSize(getBackgroundValueForIndex(container.styles.backgroundSize, index), intrinsicSize, backgroundPositioningArea);
      var sizeWidth = backgroundImageSize[0], sizeHeight = backgroundImageSize[1];
      var position2 = getAbsoluteValueForTuple(getBackgroundValueForIndex(container.styles.backgroundPosition, index), backgroundPositioningArea.width - sizeWidth, backgroundPositioningArea.height - sizeHeight);
      var path = calculateBackgroundRepeatPath(getBackgroundValueForIndex(container.styles.backgroundRepeat, index), position2, backgroundImageSize, backgroundPositioningArea, backgroundPaintingArea);
      var offsetX = Math.round(backgroundPositioningArea.left + position2[0]);
      var offsetY = Math.round(backgroundPositioningArea.top + position2[1]);
      return [path, offsetX, offsetY, sizeWidth, sizeHeight];
    };
    var isAuto = function(token) {
      return isIdentToken(token) && token.value === BACKGROUND_SIZE.AUTO;
    };
    var hasIntrinsicValue = function(value) {
      return typeof value === "number";
    };
    var calculateBackgroundSize = function(size, _a2, bounds) {
      var intrinsicWidth = _a2[0], intrinsicHeight = _a2[1], intrinsicProportion = _a2[2];
      var first2 = size[0], second = size[1];
      if (!first2) {
        return [0, 0];
      }
      if (isLengthPercentage(first2) && second && isLengthPercentage(second)) {
        return [getAbsoluteValue(first2, bounds.width), getAbsoluteValue(second, bounds.height)];
      }
      var hasIntrinsicProportion = hasIntrinsicValue(intrinsicProportion);
      if (isIdentToken(first2) && (first2.value === BACKGROUND_SIZE.CONTAIN || first2.value === BACKGROUND_SIZE.COVER)) {
        if (hasIntrinsicValue(intrinsicProportion)) {
          var targetRatio = bounds.width / bounds.height;
          return targetRatio < intrinsicProportion !== (first2.value === BACKGROUND_SIZE.COVER) ? [bounds.width, bounds.width / intrinsicProportion] : [bounds.height * intrinsicProportion, bounds.height];
        }
        return [bounds.width, bounds.height];
      }
      var hasIntrinsicWidth = hasIntrinsicValue(intrinsicWidth);
      var hasIntrinsicHeight = hasIntrinsicValue(intrinsicHeight);
      var hasIntrinsicDimensions = hasIntrinsicWidth || hasIntrinsicHeight;
      if (isAuto(first2) && (!second || isAuto(second))) {
        if (hasIntrinsicWidth && hasIntrinsicHeight) {
          return [intrinsicWidth, intrinsicHeight];
        }
        if (!hasIntrinsicProportion && !hasIntrinsicDimensions) {
          return [bounds.width, bounds.height];
        }
        if (hasIntrinsicDimensions && hasIntrinsicProportion) {
          var width_1 = hasIntrinsicWidth ? intrinsicWidth : intrinsicHeight * intrinsicProportion;
          var height_1 = hasIntrinsicHeight ? intrinsicHeight : intrinsicWidth / intrinsicProportion;
          return [width_1, height_1];
        }
        var width_2 = hasIntrinsicWidth ? intrinsicWidth : bounds.width;
        var height_2 = hasIntrinsicHeight ? intrinsicHeight : bounds.height;
        return [width_2, height_2];
      }
      if (hasIntrinsicProportion) {
        var width_3 = 0;
        var height_3 = 0;
        if (isLengthPercentage(first2)) {
          width_3 = getAbsoluteValue(first2, bounds.width);
        } else if (isLengthPercentage(second)) {
          height_3 = getAbsoluteValue(second, bounds.height);
        }
        if (isAuto(first2)) {
          width_3 = height_3 * intrinsicProportion;
        } else if (!second || isAuto(second)) {
          height_3 = width_3 / intrinsicProportion;
        }
        return [width_3, height_3];
      }
      var width = null;
      var height = null;
      if (isLengthPercentage(first2)) {
        width = getAbsoluteValue(first2, bounds.width);
      } else if (second && isLengthPercentage(second)) {
        height = getAbsoluteValue(second, bounds.height);
      }
      if (width !== null && (!second || isAuto(second))) {
        height = hasIntrinsicWidth && hasIntrinsicHeight ? width / intrinsicWidth * intrinsicHeight : bounds.height;
      }
      if (height !== null && isAuto(first2)) {
        width = hasIntrinsicWidth && hasIntrinsicHeight ? height / intrinsicHeight * intrinsicWidth : bounds.width;
      }
      if (width !== null && height !== null) {
        return [width, height];
      }
      throw new Error("Unable to calculate background-size for element");
    };
    var getBackgroundValueForIndex = function(values, index) {
      var value = values[index];
      if (typeof value === "undefined") {
        return values[0];
      }
      return value;
    };
    var calculateBackgroundRepeatPath = function(repeat, _a2, _b2, backgroundPositioningArea, backgroundPaintingArea) {
      var x2 = _a2[0], y = _a2[1];
      var width = _b2[0], height = _b2[1];
      switch (repeat) {
        case 2:
          return [
            new Vector(Math.round(backgroundPositioningArea.left), Math.round(backgroundPositioningArea.top + y)),
            new Vector(Math.round(backgroundPositioningArea.left + backgroundPositioningArea.width), Math.round(backgroundPositioningArea.top + y)),
            new Vector(Math.round(backgroundPositioningArea.left + backgroundPositioningArea.width), Math.round(height + backgroundPositioningArea.top + y)),
            new Vector(Math.round(backgroundPositioningArea.left), Math.round(height + backgroundPositioningArea.top + y))
          ];
        case 3:
          return [
            new Vector(Math.round(backgroundPositioningArea.left + x2), Math.round(backgroundPositioningArea.top)),
            new Vector(Math.round(backgroundPositioningArea.left + x2 + width), Math.round(backgroundPositioningArea.top)),
            new Vector(Math.round(backgroundPositioningArea.left + x2 + width), Math.round(backgroundPositioningArea.height + backgroundPositioningArea.top)),
            new Vector(Math.round(backgroundPositioningArea.left + x2), Math.round(backgroundPositioningArea.height + backgroundPositioningArea.top))
          ];
        case 1:
          return [
            new Vector(Math.round(backgroundPositioningArea.left + x2), Math.round(backgroundPositioningArea.top + y)),
            new Vector(Math.round(backgroundPositioningArea.left + x2 + width), Math.round(backgroundPositioningArea.top + y)),
            new Vector(Math.round(backgroundPositioningArea.left + x2 + width), Math.round(backgroundPositioningArea.top + y + height)),
            new Vector(Math.round(backgroundPositioningArea.left + x2), Math.round(backgroundPositioningArea.top + y + height))
          ];
        default:
          return [
            new Vector(Math.round(backgroundPaintingArea.left), Math.round(backgroundPaintingArea.top)),
            new Vector(Math.round(backgroundPaintingArea.left + backgroundPaintingArea.width), Math.round(backgroundPaintingArea.top)),
            new Vector(Math.round(backgroundPaintingArea.left + backgroundPaintingArea.width), Math.round(backgroundPaintingArea.height + backgroundPaintingArea.top)),
            new Vector(Math.round(backgroundPaintingArea.left), Math.round(backgroundPaintingArea.height + backgroundPaintingArea.top))
          ];
      }
    };
    var SMALL_IMAGE = "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7";
    var SAMPLE_TEXT = "Hidden Text";
    var FontMetrics = function() {
      function FontMetrics2(document2) {
        this._data = {};
        this._document = document2;
      }
      FontMetrics2.prototype.parseMetrics = function(fontFamily2, fontSize2) {
        var container = this._document.createElement("div");
        var img = this._document.createElement("img");
        var span = this._document.createElement("span");
        var body = this._document.body;
        container.style.visibility = "hidden";
        container.style.fontFamily = fontFamily2;
        container.style.fontSize = fontSize2;
        container.style.margin = "0";
        container.style.padding = "0";
        container.style.whiteSpace = "nowrap";
        body.appendChild(container);
        img.src = SMALL_IMAGE;
        img.width = 1;
        img.height = 1;
        img.style.margin = "0";
        img.style.padding = "0";
        img.style.verticalAlign = "baseline";
        span.style.fontFamily = fontFamily2;
        span.style.fontSize = fontSize2;
        span.style.margin = "0";
        span.style.padding = "0";
        span.appendChild(this._document.createTextNode(SAMPLE_TEXT));
        container.appendChild(span);
        container.appendChild(img);
        var baseline = img.offsetTop - span.offsetTop + 2;
        container.removeChild(span);
        container.appendChild(this._document.createTextNode(SAMPLE_TEXT));
        container.style.lineHeight = "normal";
        img.style.verticalAlign = "super";
        var middle = img.offsetTop - container.offsetTop + 2;
        body.removeChild(container);
        return { baseline, middle };
      };
      FontMetrics2.prototype.getMetrics = function(fontFamily2, fontSize2) {
        var key = fontFamily2 + " " + fontSize2;
        if (typeof this._data[key] === "undefined") {
          this._data[key] = this.parseMetrics(fontFamily2, fontSize2);
        }
        return this._data[key];
      };
      return FontMetrics2;
    }();
    var Renderer = function() {
      function Renderer2(context, options) {
        this.context = context;
        this.options = options;
      }
      return Renderer2;
    }();
    var MASK_OFFSET = 1e4;
    var CanvasRenderer = function(_super) {
      __extends(CanvasRenderer2, _super);
      function CanvasRenderer2(context, options) {
        var _this = _super.call(this, context, options) || this;
        _this._activeEffects = [];
        _this.canvas = options.canvas ? options.canvas : document.createElement("canvas");
        _this.ctx = _this.canvas.getContext("2d");
        if (!options.canvas) {
          _this.canvas.width = Math.floor(options.width * options.scale);
          _this.canvas.height = Math.floor(options.height * options.scale);
          _this.canvas.style.width = options.width + "px";
          _this.canvas.style.height = options.height + "px";
        }
        _this.fontMetrics = new FontMetrics(document);
        _this.ctx.scale(_this.options.scale, _this.options.scale);
        _this.ctx.translate(-options.x, -options.y);
        _this.ctx.textBaseline = "bottom";
        _this._activeEffects = [];
        _this.context.logger.debug("Canvas renderer initialized (" + options.width + "x" + options.height + ") with scale " + options.scale);
        return _this;
      }
      CanvasRenderer2.prototype.applyEffects = function(effects) {
        var _this = this;
        while (this._activeEffects.length) {
          this.popEffect();
        }
        effects.forEach(function(effect) {
          return _this.applyEffect(effect);
        });
      };
      CanvasRenderer2.prototype.applyEffect = function(effect) {
        this.ctx.save();
        if (isOpacityEffect(effect)) {
          this.ctx.globalAlpha = effect.opacity;
        }
        if (isTransformEffect(effect)) {
          this.ctx.translate(effect.offsetX, effect.offsetY);
          this.ctx.transform(effect.matrix[0], effect.matrix[1], effect.matrix[2], effect.matrix[3], effect.matrix[4], effect.matrix[5]);
          this.ctx.translate(-effect.offsetX, -effect.offsetY);
        }
        if (isClipEffect(effect)) {
          this.path(effect.path);
          this.ctx.clip();
        }
        this._activeEffects.push(effect);
      };
      CanvasRenderer2.prototype.popEffect = function() {
        this._activeEffects.pop();
        this.ctx.restore();
      };
      CanvasRenderer2.prototype.renderStack = function(stack) {
        return __awaiter(this, undefined, undefined, function() {
          var styles;
          return __generator(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                styles = stack.element.container.styles;
                if (!styles.isVisible())
                  return [3, 2];
                return [4, this.renderStackContent(stack)];
              case 1:
                _a2.sent();
                _a2.label = 2;
              case 2:
                return [2];
            }
          });
        });
      };
      CanvasRenderer2.prototype.renderNode = function(paint) {
        return __awaiter(this, undefined, undefined, function() {
          return __generator(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                if (contains(paint.container.flags, 16)) {
                  debugger;
                }
                if (!paint.container.styles.isVisible())
                  return [3, 3];
                return [4, this.renderNodeBackgroundAndBorders(paint)];
              case 1:
                _a2.sent();
                return [4, this.renderNodeContent(paint)];
              case 2:
                _a2.sent();
                _a2.label = 3;
              case 3:
                return [2];
            }
          });
        });
      };
      CanvasRenderer2.prototype.renderTextWithLetterSpacing = function(text, letterSpacing2, baseline) {
        var _this = this;
        if (letterSpacing2 === 0) {
          this.ctx.fillText(text.text, text.bounds.left, text.bounds.top + baseline);
        } else {
          var letters = segmentGraphemes(text.text);
          letters.reduce(function(left, letter) {
            _this.ctx.fillText(letter, left, text.bounds.top + baseline);
            return left + _this.ctx.measureText(letter).width;
          }, text.bounds.left);
        }
      };
      CanvasRenderer2.prototype.createFontStyle = function(styles) {
        var fontVariant2 = styles.fontVariant.filter(function(variant) {
          return variant === "normal" || variant === "small-caps";
        }).join("");
        var fontFamily2 = fixIOSSystemFonts(styles.fontFamily).join(", ");
        var fontSize2 = isDimensionToken(styles.fontSize) ? "" + styles.fontSize.number + styles.fontSize.unit : styles.fontSize.number + "px";
        return [
          [styles.fontStyle, fontVariant2, styles.fontWeight, fontSize2, fontFamily2].join(" "),
          fontFamily2,
          fontSize2
        ];
      };
      CanvasRenderer2.prototype.renderTextNode = function(text, styles) {
        return __awaiter(this, undefined, undefined, function() {
          var _a2, font, fontFamily2, fontSize2, _b2, baseline, middle, paintOrder2;
          var _this = this;
          return __generator(this, function(_c) {
            _a2 = this.createFontStyle(styles), font = _a2[0], fontFamily2 = _a2[1], fontSize2 = _a2[2];
            this.ctx.font = font;
            this.ctx.direction = styles.direction === 1 ? "rtl" : "ltr";
            this.ctx.textAlign = "left";
            this.ctx.textBaseline = "alphabetic";
            _b2 = this.fontMetrics.getMetrics(fontFamily2, fontSize2), baseline = _b2.baseline, middle = _b2.middle;
            paintOrder2 = styles.paintOrder;
            text.textBounds.forEach(function(text2) {
              paintOrder2.forEach(function(paintOrderLayer) {
                switch (paintOrderLayer) {
                  case 0:
                    _this.ctx.fillStyle = asString(styles.color);
                    _this.renderTextWithLetterSpacing(text2, styles.letterSpacing, baseline);
                    var textShadows = styles.textShadow;
                    if (textShadows.length && text2.text.trim().length) {
                      textShadows.slice(0).reverse().forEach(function(textShadow2) {
                        _this.ctx.shadowColor = asString(textShadow2.color);
                        _this.ctx.shadowOffsetX = textShadow2.offsetX.number * _this.options.scale;
                        _this.ctx.shadowOffsetY = textShadow2.offsetY.number * _this.options.scale;
                        _this.ctx.shadowBlur = textShadow2.blur.number;
                        _this.renderTextWithLetterSpacing(text2, styles.letterSpacing, baseline);
                      });
                      _this.ctx.shadowColor = "";
                      _this.ctx.shadowOffsetX = 0;
                      _this.ctx.shadowOffsetY = 0;
                      _this.ctx.shadowBlur = 0;
                    }
                    if (styles.textDecorationLine.length) {
                      _this.ctx.fillStyle = asString(styles.textDecorationColor || styles.color);
                      styles.textDecorationLine.forEach(function(textDecorationLine2) {
                        switch (textDecorationLine2) {
                          case 1:
                            _this.ctx.fillRect(text2.bounds.left, Math.round(text2.bounds.top + baseline), text2.bounds.width, 1);
                            break;
                          case 2:
                            _this.ctx.fillRect(text2.bounds.left, Math.round(text2.bounds.top), text2.bounds.width, 1);
                            break;
                          case 3:
                            _this.ctx.fillRect(text2.bounds.left, Math.ceil(text2.bounds.top + middle), text2.bounds.width, 1);
                            break;
                        }
                      });
                    }
                    break;
                  case 1:
                    if (styles.webkitTextStrokeWidth && text2.text.trim().length) {
                      _this.ctx.strokeStyle = asString(styles.webkitTextStrokeColor);
                      _this.ctx.lineWidth = styles.webkitTextStrokeWidth;
                      _this.ctx.lineJoin = window.chrome ? "miter" : "round";
                      _this.ctx.strokeText(text2.text, text2.bounds.left, text2.bounds.top + baseline);
                    }
                    _this.ctx.strokeStyle = "";
                    _this.ctx.lineWidth = 0;
                    _this.ctx.lineJoin = "miter";
                    break;
                }
              });
            });
            return [2];
          });
        });
      };
      CanvasRenderer2.prototype.renderReplacedElement = function(container, curves, image2) {
        if (image2 && container.intrinsicWidth > 0 && container.intrinsicHeight > 0) {
          var box = contentBox(container);
          var path = calculatePaddingBoxPath(curves);
          this.path(path);
          this.ctx.save();
          this.ctx.clip();
          this.ctx.drawImage(image2, 0, 0, container.intrinsicWidth, container.intrinsicHeight, box.left, box.top, box.width, box.height);
          this.ctx.restore();
        }
      };
      CanvasRenderer2.prototype.renderNodeContent = function(paint) {
        return __awaiter(this, undefined, undefined, function() {
          var container, curves, styles, _i, _a2, child, image2, image2, iframeRenderer, canvas, size, _b2, fontFamily2, fontSize2, baseline, bounds, x2, textBounds, img, image2, url, fontFamily2, bounds;
          return __generator(this, function(_c) {
            switch (_c.label) {
              case 0:
                this.applyEffects(paint.getEffects(4));
                container = paint.container;
                curves = paint.curves;
                styles = container.styles;
                _i = 0, _a2 = container.textNodes;
                _c.label = 1;
              case 1:
                if (!(_i < _a2.length))
                  return [3, 4];
                child = _a2[_i];
                return [4, this.renderTextNode(child, styles)];
              case 2:
                _c.sent();
                _c.label = 3;
              case 3:
                _i++;
                return [3, 1];
              case 4:
                if (!(container instanceof ImageElementContainer))
                  return [3, 8];
                _c.label = 5;
              case 5:
                _c.trys.push([5, 7, , 8]);
                return [4, this.context.cache.match(container.src)];
              case 6:
                image2 = _c.sent();
                this.renderReplacedElement(container, curves, image2);
                return [3, 8];
              case 7:
                _c.sent();
                this.context.logger.error("Error loading image " + container.src);
                return [3, 8];
              case 8:
                if (container instanceof CanvasElementContainer) {
                  this.renderReplacedElement(container, curves, container.canvas);
                }
                if (!(container instanceof SVGElementContainer))
                  return [3, 12];
                _c.label = 9;
              case 9:
                _c.trys.push([9, 11, , 12]);
                return [4, this.context.cache.match(container.svg)];
              case 10:
                image2 = _c.sent();
                this.renderReplacedElement(container, curves, image2);
                return [3, 12];
              case 11:
                _c.sent();
                this.context.logger.error("Error loading svg " + container.svg.substring(0, 255));
                return [3, 12];
              case 12:
                if (!(container instanceof IFrameElementContainer && container.tree))
                  return [3, 14];
                iframeRenderer = new CanvasRenderer2(this.context, {
                  scale: this.options.scale,
                  backgroundColor: container.backgroundColor,
                  x: 0,
                  y: 0,
                  width: container.width,
                  height: container.height
                });
                return [4, iframeRenderer.render(container.tree)];
              case 13:
                canvas = _c.sent();
                if (container.width && container.height) {
                  this.ctx.drawImage(canvas, 0, 0, container.width, container.height, container.bounds.left, container.bounds.top, container.bounds.width, container.bounds.height);
                }
                _c.label = 14;
              case 14:
                if (container instanceof InputElementContainer) {
                  size = Math.min(container.bounds.width, container.bounds.height);
                  if (container.type === CHECKBOX) {
                    if (container.checked) {
                      this.ctx.save();
                      this.path([
                        new Vector(container.bounds.left + size * 0.39363, container.bounds.top + size * 0.79),
                        new Vector(container.bounds.left + size * 0.16, container.bounds.top + size * 0.5549),
                        new Vector(container.bounds.left + size * 0.27347, container.bounds.top + size * 0.44071),
                        new Vector(container.bounds.left + size * 0.39694, container.bounds.top + size * 0.5649),
                        new Vector(container.bounds.left + size * 0.72983, container.bounds.top + size * 0.23),
                        new Vector(container.bounds.left + size * 0.84, container.bounds.top + size * 0.34085),
                        new Vector(container.bounds.left + size * 0.39363, container.bounds.top + size * 0.79)
                      ]);
                      this.ctx.fillStyle = asString(INPUT_COLOR);
                      this.ctx.fill();
                      this.ctx.restore();
                    }
                  } else if (container.type === RADIO) {
                    if (container.checked) {
                      this.ctx.save();
                      this.ctx.beginPath();
                      this.ctx.arc(container.bounds.left + size / 2, container.bounds.top + size / 2, size / 4, 0, Math.PI * 2, true);
                      this.ctx.fillStyle = asString(INPUT_COLOR);
                      this.ctx.fill();
                      this.ctx.restore();
                    }
                  }
                }
                if (isTextInputElement(container) && container.value.length) {
                  _b2 = this.createFontStyle(styles), fontFamily2 = _b2[0], fontSize2 = _b2[1];
                  baseline = this.fontMetrics.getMetrics(fontFamily2, fontSize2).baseline;
                  this.ctx.font = fontFamily2;
                  this.ctx.fillStyle = asString(styles.color);
                  this.ctx.textBaseline = "alphabetic";
                  this.ctx.textAlign = canvasTextAlign(container.styles.textAlign);
                  bounds = contentBox(container);
                  x2 = 0;
                  switch (container.styles.textAlign) {
                    case 1:
                      x2 += bounds.width / 2;
                      break;
                    case 2:
                      x2 += bounds.width;
                      break;
                  }
                  textBounds = bounds.add(x2, 0, 0, -bounds.height / 2 + 1);
                  this.ctx.save();
                  this.path([
                    new Vector(bounds.left, bounds.top),
                    new Vector(bounds.left + bounds.width, bounds.top),
                    new Vector(bounds.left + bounds.width, bounds.top + bounds.height),
                    new Vector(bounds.left, bounds.top + bounds.height)
                  ]);
                  this.ctx.clip();
                  this.renderTextWithLetterSpacing(new TextBounds(container.value, textBounds), styles.letterSpacing, baseline);
                  this.ctx.restore();
                  this.ctx.textBaseline = "alphabetic";
                  this.ctx.textAlign = "left";
                }
                if (!contains(container.styles.display, 2048))
                  return [3, 20];
                if (!(container.styles.listStyleImage !== null))
                  return [3, 19];
                img = container.styles.listStyleImage;
                if (!(img.type === 0))
                  return [3, 18];
                image2 = undefined;
                url = img.url;
                _c.label = 15;
              case 15:
                _c.trys.push([15, 17, , 18]);
                return [4, this.context.cache.match(url)];
              case 16:
                image2 = _c.sent();
                this.ctx.drawImage(image2, container.bounds.left - (image2.width + 10), container.bounds.top);
                return [3, 18];
              case 17:
                _c.sent();
                this.context.logger.error("Error loading list-style-image " + url);
                return [3, 18];
              case 18:
                return [3, 20];
              case 19:
                if (paint.listValue && container.styles.listStyleType !== -1) {
                  fontFamily2 = this.createFontStyle(styles)[0];
                  this.ctx.font = fontFamily2;
                  this.ctx.fillStyle = asString(styles.color);
                  this.ctx.textBaseline = "middle";
                  this.ctx.textAlign = "right";
                  bounds = new Bounds(container.bounds.left, container.bounds.top + getAbsoluteValue(container.styles.paddingTop, container.bounds.width), container.bounds.width, computeLineHeight(styles.lineHeight, styles.fontSize.number) / 2 + 1);
                  this.renderTextWithLetterSpacing(new TextBounds(paint.listValue, bounds), styles.letterSpacing, computeLineHeight(styles.lineHeight, styles.fontSize.number) / 2 + 2);
                  this.ctx.textBaseline = "bottom";
                  this.ctx.textAlign = "left";
                }
                _c.label = 20;
              case 20:
                return [2];
            }
          });
        });
      };
      CanvasRenderer2.prototype.renderStackContent = function(stack) {
        return __awaiter(this, undefined, undefined, function() {
          var _i, _a2, child, _b2, _c, child, _d, _e, child, _f, _g, child, _h, _j, child, _k, _l, child, _m, _o, child;
          return __generator(this, function(_p) {
            switch (_p.label) {
              case 0:
                if (contains(stack.element.container.flags, 16)) {
                  debugger;
                }
                return [4, this.renderNodeBackgroundAndBorders(stack.element)];
              case 1:
                _p.sent();
                _i = 0, _a2 = stack.negativeZIndex;
                _p.label = 2;
              case 2:
                if (!(_i < _a2.length))
                  return [3, 5];
                child = _a2[_i];
                return [4, this.renderStack(child)];
              case 3:
                _p.sent();
                _p.label = 4;
              case 4:
                _i++;
                return [3, 2];
              case 5:
                return [4, this.renderNodeContent(stack.element)];
              case 6:
                _p.sent();
                _b2 = 0, _c = stack.nonInlineLevel;
                _p.label = 7;
              case 7:
                if (!(_b2 < _c.length))
                  return [3, 10];
                child = _c[_b2];
                return [4, this.renderNode(child)];
              case 8:
                _p.sent();
                _p.label = 9;
              case 9:
                _b2++;
                return [3, 7];
              case 10:
                _d = 0, _e = stack.nonPositionedFloats;
                _p.label = 11;
              case 11:
                if (!(_d < _e.length))
                  return [3, 14];
                child = _e[_d];
                return [4, this.renderStack(child)];
              case 12:
                _p.sent();
                _p.label = 13;
              case 13:
                _d++;
                return [3, 11];
              case 14:
                _f = 0, _g = stack.nonPositionedInlineLevel;
                _p.label = 15;
              case 15:
                if (!(_f < _g.length))
                  return [3, 18];
                child = _g[_f];
                return [4, this.renderStack(child)];
              case 16:
                _p.sent();
                _p.label = 17;
              case 17:
                _f++;
                return [3, 15];
              case 18:
                _h = 0, _j = stack.inlineLevel;
                _p.label = 19;
              case 19:
                if (!(_h < _j.length))
                  return [3, 22];
                child = _j[_h];
                return [4, this.renderNode(child)];
              case 20:
                _p.sent();
                _p.label = 21;
              case 21:
                _h++;
                return [3, 19];
              case 22:
                _k = 0, _l = stack.zeroOrAutoZIndexOrTransformedOrOpacity;
                _p.label = 23;
              case 23:
                if (!(_k < _l.length))
                  return [3, 26];
                child = _l[_k];
                return [4, this.renderStack(child)];
              case 24:
                _p.sent();
                _p.label = 25;
              case 25:
                _k++;
                return [3, 23];
              case 26:
                _m = 0, _o = stack.positiveZIndex;
                _p.label = 27;
              case 27:
                if (!(_m < _o.length))
                  return [3, 30];
                child = _o[_m];
                return [4, this.renderStack(child)];
              case 28:
                _p.sent();
                _p.label = 29;
              case 29:
                _m++;
                return [3, 27];
              case 30:
                return [2];
            }
          });
        });
      };
      CanvasRenderer2.prototype.mask = function(paths) {
        this.ctx.beginPath();
        this.ctx.moveTo(0, 0);
        this.ctx.lineTo(this.canvas.width, 0);
        this.ctx.lineTo(this.canvas.width, this.canvas.height);
        this.ctx.lineTo(0, this.canvas.height);
        this.ctx.lineTo(0, 0);
        this.formatPath(paths.slice(0).reverse());
        this.ctx.closePath();
      };
      CanvasRenderer2.prototype.path = function(paths) {
        this.ctx.beginPath();
        this.formatPath(paths);
        this.ctx.closePath();
      };
      CanvasRenderer2.prototype.formatPath = function(paths) {
        var _this = this;
        paths.forEach(function(point, index) {
          var start = isBezierCurve(point) ? point.start : point;
          if (index === 0) {
            _this.ctx.moveTo(start.x, start.y);
          } else {
            _this.ctx.lineTo(start.x, start.y);
          }
          if (isBezierCurve(point)) {
            _this.ctx.bezierCurveTo(point.startControl.x, point.startControl.y, point.endControl.x, point.endControl.y, point.end.x, point.end.y);
          }
        });
      };
      CanvasRenderer2.prototype.renderRepeat = function(path, pattern, offsetX, offsetY) {
        this.path(path);
        this.ctx.fillStyle = pattern;
        this.ctx.translate(offsetX, offsetY);
        this.ctx.fill();
        this.ctx.translate(-offsetX, -offsetY);
      };
      CanvasRenderer2.prototype.resizeImage = function(image2, width, height) {
        var _a2;
        if (image2.width === width && image2.height === height) {
          return image2;
        }
        var ownerDocument = (_a2 = this.canvas.ownerDocument) !== null && _a2 !== undefined ? _a2 : document;
        var canvas = ownerDocument.createElement("canvas");
        canvas.width = Math.max(1, width);
        canvas.height = Math.max(1, height);
        var ctx = canvas.getContext("2d");
        ctx.drawImage(image2, 0, 0, image2.width, image2.height, 0, 0, width, height);
        return canvas;
      };
      CanvasRenderer2.prototype.renderBackgroundImage = function(container) {
        return __awaiter(this, undefined, undefined, function() {
          var index, _loop_1, this_1, _i, _a2, backgroundImage2;
          return __generator(this, function(_b2) {
            switch (_b2.label) {
              case 0:
                index = container.styles.backgroundImage.length - 1;
                _loop_1 = function(backgroundImage3) {
                  var image2, url, _c, path, x2, y, width, height, pattern, _d, path, x2, y, width, height, _e, lineLength, x0, x1, y0, y1, canvas, ctx, gradient_1, pattern, _f, path, left, top_1, width, height, position2, x2, y, _g, rx, ry, radialGradient_1, midX, midY, f2, invF;
                  return __generator(this, function(_h) {
                    switch (_h.label) {
                      case 0:
                        if (!(backgroundImage3.type === 0))
                          return [3, 5];
                        image2 = undefined;
                        url = backgroundImage3.url;
                        _h.label = 1;
                      case 1:
                        _h.trys.push([1, 3, , 4]);
                        return [4, this_1.context.cache.match(url)];
                      case 2:
                        image2 = _h.sent();
                        return [3, 4];
                      case 3:
                        _h.sent();
                        this_1.context.logger.error("Error loading background-image " + url);
                        return [3, 4];
                      case 4:
                        if (image2) {
                          _c = calculateBackgroundRendering(container, index, [
                            image2.width,
                            image2.height,
                            image2.width / image2.height
                          ]), path = _c[0], x2 = _c[1], y = _c[2], width = _c[3], height = _c[4];
                          pattern = this_1.ctx.createPattern(this_1.resizeImage(image2, width, height), "repeat");
                          this_1.renderRepeat(path, pattern, x2, y);
                        }
                        return [3, 6];
                      case 5:
                        if (isLinearGradient(backgroundImage3)) {
                          _d = calculateBackgroundRendering(container, index, [null, null, null]), path = _d[0], x2 = _d[1], y = _d[2], width = _d[3], height = _d[4];
                          _e = calculateGradientDirection(backgroundImage3.angle, width, height), lineLength = _e[0], x0 = _e[1], x1 = _e[2], y0 = _e[3], y1 = _e[4];
                          canvas = document.createElement("canvas");
                          canvas.width = width;
                          canvas.height = height;
                          ctx = canvas.getContext("2d");
                          gradient_1 = ctx.createLinearGradient(x0, y0, x1, y1);
                          processColorStops(backgroundImage3.stops, lineLength).forEach(function(colorStop) {
                            return gradient_1.addColorStop(colorStop.stop, asString(colorStop.color));
                          });
                          ctx.fillStyle = gradient_1;
                          ctx.fillRect(0, 0, width, height);
                          if (width > 0 && height > 0) {
                            pattern = this_1.ctx.createPattern(canvas, "repeat");
                            this_1.renderRepeat(path, pattern, x2, y);
                          }
                        } else if (isRadialGradient(backgroundImage3)) {
                          _f = calculateBackgroundRendering(container, index, [
                            null,
                            null,
                            null
                          ]), path = _f[0], left = _f[1], top_1 = _f[2], width = _f[3], height = _f[4];
                          position2 = backgroundImage3.position.length === 0 ? [FIFTY_PERCENT] : backgroundImage3.position;
                          x2 = getAbsoluteValue(position2[0], width);
                          y = getAbsoluteValue(position2[position2.length - 1], height);
                          _g = calculateRadius(backgroundImage3, x2, y, width, height), rx = _g[0], ry = _g[1];
                          if (rx > 0 && ry > 0) {
                            radialGradient_1 = this_1.ctx.createRadialGradient(left + x2, top_1 + y, 0, left + x2, top_1 + y, rx);
                            processColorStops(backgroundImage3.stops, rx * 2).forEach(function(colorStop) {
                              return radialGradient_1.addColorStop(colorStop.stop, asString(colorStop.color));
                            });
                            this_1.path(path);
                            this_1.ctx.fillStyle = radialGradient_1;
                            if (rx !== ry) {
                              midX = container.bounds.left + 0.5 * container.bounds.width;
                              midY = container.bounds.top + 0.5 * container.bounds.height;
                              f2 = ry / rx;
                              invF = 1 / f2;
                              this_1.ctx.save();
                              this_1.ctx.translate(midX, midY);
                              this_1.ctx.transform(1, 0, 0, f2, 0, 0);
                              this_1.ctx.translate(-midX, -midY);
                              this_1.ctx.fillRect(left, invF * (top_1 - midY) + midY, width, height * invF);
                              this_1.ctx.restore();
                            } else {
                              this_1.ctx.fill();
                            }
                          }
                        }
                        _h.label = 6;
                      case 6:
                        index--;
                        return [2];
                    }
                  });
                };
                this_1 = this;
                _i = 0, _a2 = container.styles.backgroundImage.slice(0).reverse();
                _b2.label = 1;
              case 1:
                if (!(_i < _a2.length))
                  return [3, 4];
                backgroundImage2 = _a2[_i];
                return [5, _loop_1(backgroundImage2)];
              case 2:
                _b2.sent();
                _b2.label = 3;
              case 3:
                _i++;
                return [3, 1];
              case 4:
                return [2];
            }
          });
        });
      };
      CanvasRenderer2.prototype.renderSolidBorder = function(color2, side, curvePoints) {
        return __awaiter(this, undefined, undefined, function() {
          return __generator(this, function(_a2) {
            this.path(parsePathForBorder(curvePoints, side));
            this.ctx.fillStyle = asString(color2);
            this.ctx.fill();
            return [2];
          });
        });
      };
      CanvasRenderer2.prototype.renderDoubleBorder = function(color2, width, side, curvePoints) {
        return __awaiter(this, undefined, undefined, function() {
          var outerPaths, innerPaths;
          return __generator(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                if (!(width < 3))
                  return [3, 2];
                return [4, this.renderSolidBorder(color2, side, curvePoints)];
              case 1:
                _a2.sent();
                return [2];
              case 2:
                outerPaths = parsePathForBorderDoubleOuter(curvePoints, side);
                this.path(outerPaths);
                this.ctx.fillStyle = asString(color2);
                this.ctx.fill();
                innerPaths = parsePathForBorderDoubleInner(curvePoints, side);
                this.path(innerPaths);
                this.ctx.fill();
                return [2];
            }
          });
        });
      };
      CanvasRenderer2.prototype.renderNodeBackgroundAndBorders = function(paint) {
        return __awaiter(this, undefined, undefined, function() {
          var styles, hasBackground, borders, backgroundPaintingArea, side, _i, borders_1, border;
          var _this = this;
          return __generator(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                this.applyEffects(paint.getEffects(2));
                styles = paint.container.styles;
                hasBackground = !isTransparent(styles.backgroundColor) || styles.backgroundImage.length;
                borders = [
                  { style: styles.borderTopStyle, color: styles.borderTopColor, width: styles.borderTopWidth },
                  { style: styles.borderRightStyle, color: styles.borderRightColor, width: styles.borderRightWidth },
                  { style: styles.borderBottomStyle, color: styles.borderBottomColor, width: styles.borderBottomWidth },
                  { style: styles.borderLeftStyle, color: styles.borderLeftColor, width: styles.borderLeftWidth }
                ];
                backgroundPaintingArea = calculateBackgroundCurvedPaintingArea(getBackgroundValueForIndex(styles.backgroundClip, 0), paint.curves);
                if (!(hasBackground || styles.boxShadow.length))
                  return [3, 2];
                this.ctx.save();
                this.path(backgroundPaintingArea);
                this.ctx.clip();
                if (!isTransparent(styles.backgroundColor)) {
                  this.ctx.fillStyle = asString(styles.backgroundColor);
                  this.ctx.fill();
                }
                return [4, this.renderBackgroundImage(paint.container)];
              case 1:
                _a2.sent();
                this.ctx.restore();
                styles.boxShadow.slice(0).reverse().forEach(function(shadow) {
                  _this.ctx.save();
                  var borderBoxArea = calculateBorderBoxPath(paint.curves);
                  var maskOffset = shadow.inset ? 0 : MASK_OFFSET;
                  var shadowPaintingArea = transformPath(borderBoxArea, -maskOffset + (shadow.inset ? 1 : -1) * shadow.spread.number, (shadow.inset ? 1 : -1) * shadow.spread.number, shadow.spread.number * (shadow.inset ? -2 : 2), shadow.spread.number * (shadow.inset ? -2 : 2));
                  if (shadow.inset) {
                    _this.path(borderBoxArea);
                    _this.ctx.clip();
                    _this.mask(shadowPaintingArea);
                  } else {
                    _this.mask(borderBoxArea);
                    _this.ctx.clip();
                    _this.path(shadowPaintingArea);
                  }
                  _this.ctx.shadowOffsetX = shadow.offsetX.number + maskOffset;
                  _this.ctx.shadowOffsetY = shadow.offsetY.number;
                  _this.ctx.shadowColor = asString(shadow.color);
                  _this.ctx.shadowBlur = shadow.blur.number;
                  _this.ctx.fillStyle = shadow.inset ? asString(shadow.color) : "rgba(0,0,0,1)";
                  _this.ctx.fill();
                  _this.ctx.restore();
                });
                _a2.label = 2;
              case 2:
                side = 0;
                _i = 0, borders_1 = borders;
                _a2.label = 3;
              case 3:
                if (!(_i < borders_1.length))
                  return [3, 13];
                border = borders_1[_i];
                if (!(border.style !== 0 && !isTransparent(border.color) && border.width > 0))
                  return [3, 11];
                if (!(border.style === 2))
                  return [3, 5];
                return [4, this.renderDashedDottedBorder(border.color, border.width, side, paint.curves, 2)];
              case 4:
                _a2.sent();
                return [3, 11];
              case 5:
                if (!(border.style === 3))
                  return [3, 7];
                return [4, this.renderDashedDottedBorder(border.color, border.width, side, paint.curves, 3)];
              case 6:
                _a2.sent();
                return [3, 11];
              case 7:
                if (!(border.style === 4))
                  return [3, 9];
                return [4, this.renderDoubleBorder(border.color, border.width, side, paint.curves)];
              case 8:
                _a2.sent();
                return [3, 11];
              case 9:
                return [4, this.renderSolidBorder(border.color, side, paint.curves)];
              case 10:
                _a2.sent();
                _a2.label = 11;
              case 11:
                side++;
                _a2.label = 12;
              case 12:
                _i++;
                return [3, 3];
              case 13:
                return [2];
            }
          });
        });
      };
      CanvasRenderer2.prototype.renderDashedDottedBorder = function(color2, width, side, curvePoints, style2) {
        return __awaiter(this, undefined, undefined, function() {
          var strokePaths, boxPaths, startX, startY, endX, endY, length, dashLength, spaceLength, useLineDash, multiplier, numberOfDashes, minSpace, maxSpace, path1, path2, path1, path2;
          return __generator(this, function(_a2) {
            this.ctx.save();
            strokePaths = parsePathForBorderStroke(curvePoints, side);
            boxPaths = parsePathForBorder(curvePoints, side);
            if (style2 === 2) {
              this.path(boxPaths);
              this.ctx.clip();
            }
            if (isBezierCurve(boxPaths[0])) {
              startX = boxPaths[0].start.x;
              startY = boxPaths[0].start.y;
            } else {
              startX = boxPaths[0].x;
              startY = boxPaths[0].y;
            }
            if (isBezierCurve(boxPaths[1])) {
              endX = boxPaths[1].end.x;
              endY = boxPaths[1].end.y;
            } else {
              endX = boxPaths[1].x;
              endY = boxPaths[1].y;
            }
            if (side === 0 || side === 2) {
              length = Math.abs(startX - endX);
            } else {
              length = Math.abs(startY - endY);
            }
            this.ctx.beginPath();
            if (style2 === 3) {
              this.formatPath(strokePaths);
            } else {
              this.formatPath(boxPaths.slice(0, 2));
            }
            dashLength = width < 3 ? width * 3 : width * 2;
            spaceLength = width < 3 ? width * 2 : width;
            if (style2 === 3) {
              dashLength = width;
              spaceLength = width;
            }
            useLineDash = true;
            if (length <= dashLength * 2) {
              useLineDash = false;
            } else if (length <= dashLength * 2 + spaceLength) {
              multiplier = length / (2 * dashLength + spaceLength);
              dashLength *= multiplier;
              spaceLength *= multiplier;
            } else {
              numberOfDashes = Math.floor((length + spaceLength) / (dashLength + spaceLength));
              minSpace = (length - numberOfDashes * dashLength) / (numberOfDashes - 1);
              maxSpace = (length - (numberOfDashes + 1) * dashLength) / numberOfDashes;
              spaceLength = maxSpace <= 0 || Math.abs(spaceLength - minSpace) < Math.abs(spaceLength - maxSpace) ? minSpace : maxSpace;
            }
            if (useLineDash) {
              if (style2 === 3) {
                this.ctx.setLineDash([0, dashLength + spaceLength]);
              } else {
                this.ctx.setLineDash([dashLength, spaceLength]);
              }
            }
            if (style2 === 3) {
              this.ctx.lineCap = "round";
              this.ctx.lineWidth = width;
            } else {
              this.ctx.lineWidth = width * 2 + 1.1;
            }
            this.ctx.strokeStyle = asString(color2);
            this.ctx.stroke();
            this.ctx.setLineDash([]);
            if (style2 === 2) {
              if (isBezierCurve(boxPaths[0])) {
                path1 = boxPaths[3];
                path2 = boxPaths[0];
                this.ctx.beginPath();
                this.formatPath([new Vector(path1.end.x, path1.end.y), new Vector(path2.start.x, path2.start.y)]);
                this.ctx.stroke();
              }
              if (isBezierCurve(boxPaths[1])) {
                path1 = boxPaths[1];
                path2 = boxPaths[2];
                this.ctx.beginPath();
                this.formatPath([new Vector(path1.end.x, path1.end.y), new Vector(path2.start.x, path2.start.y)]);
                this.ctx.stroke();
              }
            }
            this.ctx.restore();
            return [2];
          });
        });
      };
      CanvasRenderer2.prototype.render = function(element) {
        return __awaiter(this, undefined, undefined, function() {
          var stack;
          return __generator(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                if (this.options.backgroundColor) {
                  this.ctx.fillStyle = asString(this.options.backgroundColor);
                  this.ctx.fillRect(this.options.x, this.options.y, this.options.width, this.options.height);
                }
                stack = parseStackingContexts(element);
                return [4, this.renderStack(stack)];
              case 1:
                _a2.sent();
                this.applyEffects([]);
                return [2, this.canvas];
            }
          });
        });
      };
      return CanvasRenderer2;
    }(Renderer);
    var isTextInputElement = function(container) {
      if (container instanceof TextareaElementContainer) {
        return true;
      } else if (container instanceof SelectElementContainer) {
        return true;
      } else if (container instanceof InputElementContainer && container.type !== RADIO && container.type !== CHECKBOX) {
        return true;
      }
      return false;
    };
    var calculateBackgroundCurvedPaintingArea = function(clip, curves) {
      switch (clip) {
        case 0:
          return calculateBorderBoxPath(curves);
        case 2:
          return calculateContentBoxPath(curves);
        case 1:
        default:
          return calculatePaddingBoxPath(curves);
      }
    };
    var canvasTextAlign = function(textAlign2) {
      switch (textAlign2) {
        case 1:
          return "center";
        case 2:
          return "right";
        case 0:
        default:
          return "left";
      }
    };
    var iOSBrokenFonts = ["-apple-system", "system-ui"];
    var fixIOSSystemFonts = function(fontFamilies) {
      return /iPhone OS 15_(0|1)/.test(window.navigator.userAgent) ? fontFamilies.filter(function(fontFamily2) {
        return iOSBrokenFonts.indexOf(fontFamily2) === -1;
      }) : fontFamilies;
    };
    var ForeignObjectRenderer = function(_super) {
      __extends(ForeignObjectRenderer2, _super);
      function ForeignObjectRenderer2(context, options) {
        var _this = _super.call(this, context, options) || this;
        _this.canvas = options.canvas ? options.canvas : document.createElement("canvas");
        _this.ctx = _this.canvas.getContext("2d");
        _this.options = options;
        _this.canvas.width = Math.floor(options.width * options.scale);
        _this.canvas.height = Math.floor(options.height * options.scale);
        _this.canvas.style.width = options.width + "px";
        _this.canvas.style.height = options.height + "px";
        _this.ctx.scale(_this.options.scale, _this.options.scale);
        _this.ctx.translate(-options.x, -options.y);
        _this.context.logger.debug("EXPERIMENTAL ForeignObject renderer initialized (" + options.width + "x" + options.height + " at " + options.x + "," + options.y + ") with scale " + options.scale);
        return _this;
      }
      ForeignObjectRenderer2.prototype.render = function(element) {
        return __awaiter(this, undefined, undefined, function() {
          var svg, img;
          return __generator(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                svg = createForeignObjectSVG(this.options.width * this.options.scale, this.options.height * this.options.scale, this.options.scale, this.options.scale, element);
                return [4, loadSerializedSVG(svg)];
              case 1:
                img = _a2.sent();
                if (this.options.backgroundColor) {
                  this.ctx.fillStyle = asString(this.options.backgroundColor);
                  this.ctx.fillRect(0, 0, this.options.width * this.options.scale, this.options.height * this.options.scale);
                }
                this.ctx.drawImage(img, -this.options.x * this.options.scale, -this.options.y * this.options.scale);
                return [2, this.canvas];
            }
          });
        });
      };
      return ForeignObjectRenderer2;
    }(Renderer);
    var loadSerializedSVG = function(svg) {
      return new Promise(function(resolve, reject) {
        var img = new Image;
        img.onload = function() {
          resolve(img);
        };
        img.onerror = reject;
        img.src = "data:image/svg+xml;charset=utf-8," + encodeURIComponent(new XMLSerializer().serializeToString(svg));
      });
    };
    var Logger = function() {
      function Logger2(_a2) {
        var { id, enabled } = _a2;
        this.id = id;
        this.enabled = enabled;
        this.start = Date.now();
      }
      Logger2.prototype.debug = function() {
        var args = [];
        for (var _i = 0;_i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        if (this.enabled) {
          if (typeof window !== "undefined" && window.console && typeof console.debug === "function") {
            console.debug.apply(console, __spreadArray([this.id, this.getTime() + "ms"], args));
          } else {
            this.info.apply(this, args);
          }
        }
      };
      Logger2.prototype.getTime = function() {
        return Date.now() - this.start;
      };
      Logger2.prototype.info = function() {
        var args = [];
        for (var _i = 0;_i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        if (this.enabled) {
          if (typeof window !== "undefined" && window.console && typeof console.info === "function") {
            console.info.apply(console, __spreadArray([this.id, this.getTime() + "ms"], args));
          }
        }
      };
      Logger2.prototype.warn = function() {
        var args = [];
        for (var _i = 0;_i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        if (this.enabled) {
          if (typeof window !== "undefined" && window.console && typeof console.warn === "function") {
            console.warn.apply(console, __spreadArray([this.id, this.getTime() + "ms"], args));
          } else {
            this.info.apply(this, args);
          }
        }
      };
      Logger2.prototype.error = function() {
        var args = [];
        for (var _i = 0;_i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        if (this.enabled) {
          if (typeof window !== "undefined" && window.console && typeof console.error === "function") {
            console.error.apply(console, __spreadArray([this.id, this.getTime() + "ms"], args));
          } else {
            this.info.apply(this, args);
          }
        }
      };
      Logger2.instances = {};
      return Logger2;
    }();
    var Context = function() {
      function Context2(options, windowBounds) {
        var _a2;
        this.windowBounds = windowBounds;
        this.instanceName = "#" + Context2.instanceCount++;
        this.logger = new Logger({ id: this.instanceName, enabled: options.logging });
        this.cache = (_a2 = options.cache) !== null && _a2 !== undefined ? _a2 : new Cache(this, options);
      }
      Context2.instanceCount = 1;
      return Context2;
    }();
    var html2canvas = function(element, options) {
      if (options === undefined) {
        options = {};
      }
      return renderElement(element, options);
    };
    if (typeof window !== "undefined") {
      CacheStorage.setContext(window);
    }
    var renderElement = function(element, opts) {
      return __awaiter(undefined, undefined, undefined, function() {
        var ownerDocument, defaultView, resourceOptions, contextOptions, windowOptions, windowBounds, context, foreignObjectRendering, cloneOptions, documentCloner, clonedElement, container, _a2, width, height, left, top, backgroundColor2, renderOptions, canvas, renderer, root, renderer;
        var _b2, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t;
        return __generator(this, function(_u) {
          switch (_u.label) {
            case 0:
              if (!element || typeof element !== "object") {
                return [2, Promise.reject("Invalid element provided as first argument")];
              }
              ownerDocument = element.ownerDocument;
              if (!ownerDocument) {
                throw new Error("Element is not attached to a Document");
              }
              defaultView = ownerDocument.defaultView;
              if (!defaultView) {
                throw new Error("Document is not attached to a Window");
              }
              resourceOptions = {
                allowTaint: (_b2 = opts.allowTaint) !== null && _b2 !== undefined ? _b2 : false,
                imageTimeout: (_c = opts.imageTimeout) !== null && _c !== undefined ? _c : 15000,
                proxy: opts.proxy,
                useCORS: (_d = opts.useCORS) !== null && _d !== undefined ? _d : false
              };
              contextOptions = __assign({ logging: (_e = opts.logging) !== null && _e !== undefined ? _e : true, cache: opts.cache }, resourceOptions);
              windowOptions = {
                windowWidth: (_f = opts.windowWidth) !== null && _f !== undefined ? _f : defaultView.innerWidth,
                windowHeight: (_g = opts.windowHeight) !== null && _g !== undefined ? _g : defaultView.innerHeight,
                scrollX: (_h = opts.scrollX) !== null && _h !== undefined ? _h : defaultView.pageXOffset,
                scrollY: (_j = opts.scrollY) !== null && _j !== undefined ? _j : defaultView.pageYOffset
              };
              windowBounds = new Bounds(windowOptions.scrollX, windowOptions.scrollY, windowOptions.windowWidth, windowOptions.windowHeight);
              context = new Context(contextOptions, windowBounds);
              foreignObjectRendering = (_k = opts.foreignObjectRendering) !== null && _k !== undefined ? _k : false;
              cloneOptions = {
                allowTaint: (_l = opts.allowTaint) !== null && _l !== undefined ? _l : false,
                onclone: opts.onclone,
                ignoreElements: opts.ignoreElements,
                inlineImages: foreignObjectRendering,
                copyStyles: foreignObjectRendering
              };
              context.logger.debug("Starting document clone with size " + windowBounds.width + "x" + windowBounds.height + " scrolled to " + -windowBounds.left + "," + -windowBounds.top);
              documentCloner = new DocumentCloner(context, element, cloneOptions);
              clonedElement = documentCloner.clonedReferenceElement;
              if (!clonedElement) {
                return [2, Promise.reject("Unable to find element in cloned iframe")];
              }
              return [4, documentCloner.toIFrame(ownerDocument, windowBounds)];
            case 1:
              container = _u.sent();
              _a2 = isBodyElement(clonedElement) || isHTMLElement(clonedElement) ? parseDocumentSize(clonedElement.ownerDocument) : parseBounds(context, clonedElement), width = _a2.width, height = _a2.height, left = _a2.left, top = _a2.top;
              backgroundColor2 = parseBackgroundColor(context, clonedElement, opts.backgroundColor);
              renderOptions = {
                canvas: opts.canvas,
                backgroundColor: backgroundColor2,
                scale: (_o = (_m = opts.scale) !== null && _m !== undefined ? _m : defaultView.devicePixelRatio) !== null && _o !== undefined ? _o : 1,
                x: ((_p = opts.x) !== null && _p !== undefined ? _p : 0) + left,
                y: ((_q = opts.y) !== null && _q !== undefined ? _q : 0) + top,
                width: (_r = opts.width) !== null && _r !== undefined ? _r : Math.ceil(width),
                height: (_s = opts.height) !== null && _s !== undefined ? _s : Math.ceil(height)
              };
              if (!foreignObjectRendering)
                return [3, 3];
              context.logger.debug("Document cloned, using foreign object rendering");
              renderer = new ForeignObjectRenderer(context, renderOptions);
              return [4, renderer.render(clonedElement)];
            case 2:
              canvas = _u.sent();
              return [3, 5];
            case 3:
              context.logger.debug("Document cloned, element located at " + left + "," + top + " with size " + width + "x" + height + " using computed rendering");
              context.logger.debug("Starting DOM parsing");
              root = parseTree(context, clonedElement);
              if (backgroundColor2 === root.styles.backgroundColor) {
                root.styles.backgroundColor = COLORS.TRANSPARENT;
              }
              context.logger.debug("Starting renderer for element at " + renderOptions.x + "," + renderOptions.y + " with size " + renderOptions.width + "x" + renderOptions.height);
              renderer = new CanvasRenderer(context, renderOptions);
              return [4, renderer.render(root)];
            case 4:
              canvas = _u.sent();
              _u.label = 5;
            case 5:
              if ((_t = opts.removeContainer) !== null && _t !== undefined ? _t : true) {
                if (!DocumentCloner.destroy(container)) {
                  context.logger.error("Cannot detach cloned iframe as it is not in the DOM anymore");
                }
              }
              context.logger.debug("Finished rendering");
              return [2, canvas];
          }
        });
      });
    };
    var parseBackgroundColor = function(context, element, backgroundColorOverride) {
      var ownerDocument = element.ownerDocument;
      var documentBackgroundColor = ownerDocument.documentElement ? parseColor(context, getComputedStyle(ownerDocument.documentElement).backgroundColor) : COLORS.TRANSPARENT;
      var bodyBackgroundColor = ownerDocument.body ? parseColor(context, getComputedStyle(ownerDocument.body).backgroundColor) : COLORS.TRANSPARENT;
      var defaultBackgroundColor = typeof backgroundColorOverride === "string" ? parseColor(context, backgroundColorOverride) : backgroundColorOverride === null ? COLORS.TRANSPARENT : 4294967295;
      return element === ownerDocument.documentElement ? isTransparent(documentBackgroundColor) ? isTransparent(bodyBackgroundColor) ? defaultBackgroundColor : bodyBackgroundColor : documentBackgroundColor : defaultBackgroundColor;
    };
    return html2canvas;
  });
});

// node_modules/dompurify/dist/purify.js
var require_purify = __commonJS((exports, module) => {
  /*! @license DOMPurify 2.5.8 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/2.5.8/LICENSE */
  (function(global2, factory) {
    typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, global2.DOMPurify = factory());
  })(exports, function() {
    function _typeof2(obj) {
      "@babel/helpers - typeof";
      return _typeof2 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(obj2) {
        return typeof obj2;
      } : function(obj2) {
        return obj2 && typeof Symbol == "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      }, _typeof2(obj);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _construct(Parent, args, Class) {
      if (_isNativeReflectConstruct()) {
        _construct = Reflect.construct;
      } else {
        _construct = function _construct(Parent2, args2, Class2) {
          var a = [null];
          a.push.apply(a, args2);
          var Constructor = Function.bind.apply(Parent2, a);
          var instance = new Constructor;
          if (Class2)
            _setPrototypeOf(instance, Class2.prototype);
          return instance;
        };
      }
      return _construct.apply(null, arguments);
    }
    function _toConsumableArray(arr) {
      return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
    }
    function _arrayWithoutHoles(arr) {
      if (Array.isArray(arr))
        return _arrayLikeToArray(arr);
    }
    function _iterableToArray(iter) {
      if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
        return Array.from(iter);
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o)
        return;
      if (typeof o === "string")
        return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor)
        n = o.constructor.name;
      if (n === "Map" || n === "Set")
        return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
        return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i3 = 0, arr2 = new Array(len);i3 < len; i3++)
        arr2[i3] = arr[i3];
      return arr2;
    }
    function _nonIterableSpread() {
      throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
    }
    var { hasOwnProperty, setPrototypeOf, isFrozen, getPrototypeOf, getOwnPropertyDescriptor } = Object;
    var { freeze, seal, create } = Object;
    var _ref = typeof Reflect !== "undefined" && Reflect, apply2 = _ref.apply, construct = _ref.construct;
    if (!apply2) {
      apply2 = function apply(fun, thisValue, args) {
        return fun.apply(thisValue, args);
      };
    }
    if (!freeze) {
      freeze = function freeze(x2) {
        return x2;
      };
    }
    if (!seal) {
      seal = function seal(x2) {
        return x2;
      };
    }
    if (!construct) {
      construct = function construct(Func, args) {
        return _construct(Func, _toConsumableArray(args));
      };
    }
    var arrayForEach = unapply(Array.prototype.forEach);
    var arrayPop = unapply(Array.prototype.pop);
    var arrayPush = unapply(Array.prototype.push);
    var stringToLowerCase = unapply(String.prototype.toLowerCase);
    var stringToString = unapply(String.prototype.toString);
    var stringMatch = unapply(String.prototype.match);
    var stringReplace = unapply(String.prototype.replace);
    var stringIndexOf = unapply(String.prototype.indexOf);
    var stringTrim = unapply(String.prototype.trim);
    var regExpTest = unapply(RegExp.prototype.test);
    var typeErrorCreate = unconstruct(TypeError);
    function unapply(func) {
      return function(thisArg) {
        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1;_key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }
        return apply2(func, thisArg, args);
      };
    }
    function unconstruct(func) {
      return function() {
        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0;_key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }
        return construct(func, args);
      };
    }
    function addToSet(set, array, transformCaseFunc) {
      var _transformCaseFunc;
      transformCaseFunc = (_transformCaseFunc = transformCaseFunc) !== null && _transformCaseFunc !== undefined ? _transformCaseFunc : stringToLowerCase;
      if (setPrototypeOf) {
        setPrototypeOf(set, null);
      }
      var l = array.length;
      while (l--) {
        var element = array[l];
        if (typeof element === "string") {
          var lcElement = transformCaseFunc(element);
          if (lcElement !== element) {
            if (!isFrozen(array)) {
              array[l] = lcElement;
            }
            element = lcElement;
          }
        }
        set[element] = true;
      }
      return set;
    }
    function clone(object) {
      var newObject = create(null);
      var property;
      for (property in object) {
        if (apply2(hasOwnProperty, object, [property]) === true) {
          newObject[property] = object[property];
        }
      }
      return newObject;
    }
    function lookupGetter(object, prop) {
      while (object !== null) {
        var desc = getOwnPropertyDescriptor(object, prop);
        if (desc) {
          if (desc.get) {
            return unapply(desc.get);
          }
          if (typeof desc.value === "function") {
            return unapply(desc.value);
          }
        }
        object = getPrototypeOf(object);
      }
      function fallbackValue(element) {
        console.warn("fallback value for", element);
        return null;
      }
      return fallbackValue;
    }
    var html$1 = freeze(["a", "abbr", "acronym", "address", "area", "article", "aside", "audio", "b", "bdi", "bdo", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "content", "data", "datalist", "dd", "decorator", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "fieldset", "figcaption", "figure", "font", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "img", "input", "ins", "kbd", "label", "legend", "li", "main", "map", "mark", "marquee", "menu", "menuitem", "meter", "nav", "nobr", "ol", "optgroup", "option", "output", "p", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "section", "select", "shadow", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "tt", "u", "ul", "var", "video", "wbr"]);
    var svg$1 = freeze(["svg", "a", "altglyph", "altglyphdef", "altglyphitem", "animatecolor", "animatemotion", "animatetransform", "circle", "clippath", "defs", "desc", "ellipse", "filter", "font", "g", "glyph", "glyphref", "hkern", "image", "line", "lineargradient", "marker", "mask", "metadata", "mpath", "path", "pattern", "polygon", "polyline", "radialgradient", "rect", "stop", "style", "switch", "symbol", "text", "textpath", "title", "tref", "tspan", "view", "vkern"]);
    var svgFilters = freeze(["feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence"]);
    var svgDisallowed = freeze(["animate", "color-profile", "cursor", "discard", "fedropshadow", "font-face", "font-face-format", "font-face-name", "font-face-src", "font-face-uri", "foreignobject", "hatch", "hatchpath", "mesh", "meshgradient", "meshpatch", "meshrow", "missing-glyph", "script", "set", "solidcolor", "unknown", "use"]);
    var mathMl$1 = freeze(["math", "menclose", "merror", "mfenced", "mfrac", "mglyph", "mi", "mlabeledtr", "mmultiscripts", "mn", "mo", "mover", "mpadded", "mphantom", "mroot", "mrow", "ms", "mspace", "msqrt", "mstyle", "msub", "msup", "msubsup", "mtable", "mtd", "mtext", "mtr", "munder", "munderover"]);
    var mathMlDisallowed = freeze(["maction", "maligngroup", "malignmark", "mlongdiv", "mscarries", "mscarry", "msgroup", "mstack", "msline", "msrow", "semantics", "annotation", "annotation-xml", "mprescripts", "none"]);
    var text = freeze(["#text"]);
    var html = freeze(["accept", "action", "align", "alt", "autocapitalize", "autocomplete", "autopictureinpicture", "autoplay", "background", "bgcolor", "border", "capture", "cellpadding", "cellspacing", "checked", "cite", "class", "clear", "color", "cols", "colspan", "controls", "controlslist", "coords", "crossorigin", "datetime", "decoding", "default", "dir", "disabled", "disablepictureinpicture", "disableremoteplayback", "download", "draggable", "enctype", "enterkeyhint", "face", "for", "headers", "height", "hidden", "high", "href", "hreflang", "id", "inputmode", "integrity", "ismap", "kind", "label", "lang", "list", "loading", "loop", "low", "max", "maxlength", "media", "method", "min", "minlength", "multiple", "muted", "name", "nonce", "noshade", "novalidate", "nowrap", "open", "optimum", "pattern", "placeholder", "playsinline", "poster", "preload", "pubdate", "radiogroup", "readonly", "rel", "required", "rev", "reversed", "role", "rows", "rowspan", "spellcheck", "scope", "selected", "shape", "size", "sizes", "span", "srclang", "start", "src", "srcset", "step", "style", "summary", "tabindex", "title", "translate", "type", "usemap", "valign", "value", "width", "xmlns", "slot"]);
    var svg = freeze(["accent-height", "accumulate", "additive", "alignment-baseline", "ascent", "attributename", "attributetype", "azimuth", "basefrequency", "baseline-shift", "begin", "bias", "by", "class", "clip", "clippathunits", "clip-path", "clip-rule", "color", "color-interpolation", "color-interpolation-filters", "color-profile", "color-rendering", "cx", "cy", "d", "dx", "dy", "diffuseconstant", "direction", "display", "divisor", "dur", "edgemode", "elevation", "end", "fill", "fill-opacity", "fill-rule", "filter", "filterunits", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "fx", "fy", "g1", "g2", "glyph-name", "glyphref", "gradientunits", "gradienttransform", "height", "href", "id", "image-rendering", "in", "in2", "k", "k1", "k2", "k3", "k4", "kerning", "keypoints", "keysplines", "keytimes", "lang", "lengthadjust", "letter-spacing", "kernelmatrix", "kernelunitlength", "lighting-color", "local", "marker-end", "marker-mid", "marker-start", "markerheight", "markerunits", "markerwidth", "maskcontentunits", "maskunits", "max", "mask", "media", "method", "mode", "min", "name", "numoctaves", "offset", "operator", "opacity", "order", "orient", "orientation", "origin", "overflow", "paint-order", "path", "pathlength", "patterncontentunits", "patterntransform", "patternunits", "points", "preservealpha", "preserveaspectratio", "primitiveunits", "r", "rx", "ry", "radius", "refx", "refy", "repeatcount", "repeatdur", "restart", "result", "rotate", "scale", "seed", "shape-rendering", "specularconstant", "specularexponent", "spreadmethod", "startoffset", "stddeviation", "stitchtiles", "stop-color", "stop-opacity", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke", "stroke-width", "style", "surfacescale", "systemlanguage", "tabindex", "targetx", "targety", "transform", "transform-origin", "text-anchor", "text-decoration", "text-rendering", "textlength", "type", "u1", "u2", "unicode", "values", "viewbox", "visibility", "version", "vert-adv-y", "vert-origin-x", "vert-origin-y", "width", "word-spacing", "wrap", "writing-mode", "xchannelselector", "ychannelselector", "x", "x1", "x2", "xmlns", "y", "y1", "y2", "z", "zoomandpan"]);
    var mathMl = freeze(["accent", "accentunder", "align", "bevelled", "close", "columnsalign", "columnlines", "columnspan", "denomalign", "depth", "dir", "display", "displaystyle", "encoding", "fence", "frame", "height", "href", "id", "largeop", "length", "linethickness", "lspace", "lquote", "mathbackground", "mathcolor", "mathsize", "mathvariant", "maxsize", "minsize", "movablelimits", "notation", "numalign", "open", "rowalign", "rowlines", "rowspacing", "rowspan", "rspace", "rquote", "scriptlevel", "scriptminsize", "scriptsizemultiplier", "selection", "separator", "separators", "stretchy", "subscriptshift", "supscriptshift", "symmetric", "voffset", "width", "xmlns"]);
    var xml = freeze(["xlink:href", "xml:id", "xlink:title", "xml:space", "xmlns:xlink"]);
    var MUSTACHE_EXPR = seal(/\{\{[\w\W]*|[\w\W]*\}\}/gm);
    var ERB_EXPR = seal(/<%[\w\W]*|[\w\W]*%>/gm);
    var TMPLIT_EXPR = seal(/\${[\w\W]*}/gm);
    var DATA_ATTR = seal(/^data-[\-\w.\u00B7-\uFFFF]+$/);
    var ARIA_ATTR = seal(/^aria-[\-\w]+$/);
    var IS_ALLOWED_URI = seal(/^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i);
    var IS_SCRIPT_OR_DATA = seal(/^(?:\w+script|data):/i);
    var ATTR_WHITESPACE = seal(/[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g);
    var DOCTYPE_NAME = seal(/^html$/i);
    var CUSTOM_ELEMENT = seal(/^[a-z][.\w]*(-[.\w]+)+$/i);
    var getGlobal = function getGlobal() {
      return typeof window === "undefined" ? null : window;
    };
    var _createTrustedTypesPolicy = function _createTrustedTypesPolicy(trustedTypes, document2) {
      if (_typeof2(trustedTypes) !== "object" || typeof trustedTypes.createPolicy !== "function") {
        return null;
      }
      var suffix = null;
      var ATTR_NAME = "data-tt-policy-suffix";
      if (document2.currentScript && document2.currentScript.hasAttribute(ATTR_NAME)) {
        suffix = document2.currentScript.getAttribute(ATTR_NAME);
      }
      var policyName = "dompurify" + (suffix ? "#" + suffix : "");
      try {
        return trustedTypes.createPolicy(policyName, {
          createHTML: function createHTML(html2) {
            return html2;
          },
          createScriptURL: function createScriptURL(scriptUrl) {
            return scriptUrl;
          }
        });
      } catch (_) {
        console.warn("TrustedTypes policy " + policyName + " could not be created.");
        return null;
      }
    };
    function createDOMPurify() {
      var window2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : getGlobal();
      var DOMPurify = function DOMPurify(root) {
        return createDOMPurify(root);
      };
      DOMPurify.version = "2.5.8";
      DOMPurify.removed = [];
      if (!window2 || !window2.document || window2.document.nodeType !== 9) {
        DOMPurify.isSupported = false;
        return DOMPurify;
      }
      var originalDocument = window2.document;
      var document2 = window2.document;
      var { DocumentFragment, HTMLTemplateElement, Node: Node4, Element, NodeFilter, NamedNodeMap: _window$NamedNodeMap } = window2, NamedNodeMap = _window$NamedNodeMap === undefined ? window2.NamedNodeMap || window2.MozNamedAttrMap : _window$NamedNodeMap, HTMLFormElement = window2.HTMLFormElement, DOMParser3 = window2.DOMParser, trustedTypes = window2.trustedTypes;
      var ElementPrototype = Element.prototype;
      var cloneNode = lookupGetter(ElementPrototype, "cloneNode");
      var getNextSibling = lookupGetter(ElementPrototype, "nextSibling");
      var getChildNodes = lookupGetter(ElementPrototype, "childNodes");
      var getParentNode = lookupGetter(ElementPrototype, "parentNode");
      if (typeof HTMLTemplateElement === "function") {
        var template = document2.createElement("template");
        if (template.content && template.content.ownerDocument) {
          document2 = template.content.ownerDocument;
        }
      }
      var trustedTypesPolicy = _createTrustedTypesPolicy(trustedTypes, originalDocument);
      var emptyHTML = trustedTypesPolicy ? trustedTypesPolicy.createHTML("") : "";
      var _document = document2, implementation = _document.implementation, createNodeIterator = _document.createNodeIterator, createDocumentFragment = _document.createDocumentFragment, getElementsByTagName = _document.getElementsByTagName;
      var importNode = originalDocument.importNode;
      var documentMode = {};
      try {
        documentMode = clone(document2).documentMode ? document2.documentMode : {};
      } catch (_) {}
      var hooks = {};
      DOMPurify.isSupported = typeof getParentNode === "function" && implementation && implementation.createHTMLDocument !== undefined && documentMode !== 9;
      var MUSTACHE_EXPR$1 = MUSTACHE_EXPR, ERB_EXPR$1 = ERB_EXPR, TMPLIT_EXPR$1 = TMPLIT_EXPR, DATA_ATTR$1 = DATA_ATTR, ARIA_ATTR$1 = ARIA_ATTR, IS_SCRIPT_OR_DATA$1 = IS_SCRIPT_OR_DATA, ATTR_WHITESPACE$1 = ATTR_WHITESPACE, CUSTOM_ELEMENT$1 = CUSTOM_ELEMENT;
      var IS_ALLOWED_URI$1 = IS_ALLOWED_URI;
      var ALLOWED_TAGS = null;
      var DEFAULT_ALLOWED_TAGS = addToSet({}, [].concat(_toConsumableArray(html$1), _toConsumableArray(svg$1), _toConsumableArray(svgFilters), _toConsumableArray(mathMl$1), _toConsumableArray(text)));
      var ALLOWED_ATTR = null;
      var DEFAULT_ALLOWED_ATTR = addToSet({}, [].concat(_toConsumableArray(html), _toConsumableArray(svg), _toConsumableArray(mathMl), _toConsumableArray(xml)));
      var CUSTOM_ELEMENT_HANDLING = Object.seal(Object.create(null, {
        tagNameCheck: {
          writable: true,
          configurable: false,
          enumerable: true,
          value: null
        },
        attributeNameCheck: {
          writable: true,
          configurable: false,
          enumerable: true,
          value: null
        },
        allowCustomizedBuiltInElements: {
          writable: true,
          configurable: false,
          enumerable: true,
          value: false
        }
      }));
      var FORBID_TAGS = null;
      var FORBID_ATTR = null;
      var ALLOW_ARIA_ATTR = true;
      var ALLOW_DATA_ATTR = true;
      var ALLOW_UNKNOWN_PROTOCOLS = false;
      var ALLOW_SELF_CLOSE_IN_ATTR = true;
      var SAFE_FOR_TEMPLATES = false;
      var SAFE_FOR_XML = true;
      var WHOLE_DOCUMENT = false;
      var SET_CONFIG = false;
      var FORCE_BODY = false;
      var RETURN_DOM = false;
      var RETURN_DOM_FRAGMENT = false;
      var RETURN_TRUSTED_TYPE = false;
      var SANITIZE_DOM = true;
      var SANITIZE_NAMED_PROPS = false;
      var SANITIZE_NAMED_PROPS_PREFIX = "user-content-";
      var KEEP_CONTENT = true;
      var IN_PLACE = false;
      var USE_PROFILES = {};
      var FORBID_CONTENTS = null;
      var DEFAULT_FORBID_CONTENTS = addToSet({}, ["annotation-xml", "audio", "colgroup", "desc", "foreignobject", "head", "iframe", "math", "mi", "mn", "mo", "ms", "mtext", "noembed", "noframes", "noscript", "plaintext", "script", "style", "svg", "template", "thead", "title", "video", "xmp"]);
      var DATA_URI_TAGS = null;
      var DEFAULT_DATA_URI_TAGS = addToSet({}, ["audio", "video", "img", "source", "image", "track"]);
      var URI_SAFE_ATTRIBUTES = null;
      var DEFAULT_URI_SAFE_ATTRIBUTES = addToSet({}, ["alt", "class", "for", "id", "label", "name", "pattern", "placeholder", "role", "summary", "title", "value", "style", "xmlns"]);
      var MATHML_NAMESPACE = "http://www.w3.org/1998/Math/MathML";
      var SVG_NAMESPACE = "http://www.w3.org/2000/svg";
      var HTML_NAMESPACE = "http://www.w3.org/1999/xhtml";
      var NAMESPACE = HTML_NAMESPACE;
      var IS_EMPTY_INPUT = false;
      var ALLOWED_NAMESPACES = null;
      var DEFAULT_ALLOWED_NAMESPACES = addToSet({}, [MATHML_NAMESPACE, SVG_NAMESPACE, HTML_NAMESPACE], stringToString);
      var PARSER_MEDIA_TYPE;
      var SUPPORTED_PARSER_MEDIA_TYPES = ["application/xhtml+xml", "text/html"];
      var DEFAULT_PARSER_MEDIA_TYPE = "text/html";
      var transformCaseFunc;
      var CONFIG = null;
      var formElement = document2.createElement("form");
      var isRegexOrFunction = function isRegexOrFunction(testValue) {
        return testValue instanceof RegExp || testValue instanceof Function;
      };
      var _parseConfig = function _parseConfig(cfg) {
        if (CONFIG && CONFIG === cfg) {
          return;
        }
        if (!cfg || _typeof2(cfg) !== "object") {
          cfg = {};
        }
        cfg = clone(cfg);
        PARSER_MEDIA_TYPE = SUPPORTED_PARSER_MEDIA_TYPES.indexOf(cfg.PARSER_MEDIA_TYPE) === -1 ? PARSER_MEDIA_TYPE = DEFAULT_PARSER_MEDIA_TYPE : PARSER_MEDIA_TYPE = cfg.PARSER_MEDIA_TYPE;
        transformCaseFunc = PARSER_MEDIA_TYPE === "application/xhtml+xml" ? stringToString : stringToLowerCase;
        ALLOWED_TAGS = "ALLOWED_TAGS" in cfg ? addToSet({}, cfg.ALLOWED_TAGS, transformCaseFunc) : DEFAULT_ALLOWED_TAGS;
        ALLOWED_ATTR = "ALLOWED_ATTR" in cfg ? addToSet({}, cfg.ALLOWED_ATTR, transformCaseFunc) : DEFAULT_ALLOWED_ATTR;
        ALLOWED_NAMESPACES = "ALLOWED_NAMESPACES" in cfg ? addToSet({}, cfg.ALLOWED_NAMESPACES, stringToString) : DEFAULT_ALLOWED_NAMESPACES;
        URI_SAFE_ATTRIBUTES = "ADD_URI_SAFE_ATTR" in cfg ? addToSet(clone(DEFAULT_URI_SAFE_ATTRIBUTES), cfg.ADD_URI_SAFE_ATTR, transformCaseFunc) : DEFAULT_URI_SAFE_ATTRIBUTES;
        DATA_URI_TAGS = "ADD_DATA_URI_TAGS" in cfg ? addToSet(clone(DEFAULT_DATA_URI_TAGS), cfg.ADD_DATA_URI_TAGS, transformCaseFunc) : DEFAULT_DATA_URI_TAGS;
        FORBID_CONTENTS = "FORBID_CONTENTS" in cfg ? addToSet({}, cfg.FORBID_CONTENTS, transformCaseFunc) : DEFAULT_FORBID_CONTENTS;
        FORBID_TAGS = "FORBID_TAGS" in cfg ? addToSet({}, cfg.FORBID_TAGS, transformCaseFunc) : {};
        FORBID_ATTR = "FORBID_ATTR" in cfg ? addToSet({}, cfg.FORBID_ATTR, transformCaseFunc) : {};
        USE_PROFILES = "USE_PROFILES" in cfg ? cfg.USE_PROFILES : false;
        ALLOW_ARIA_ATTR = cfg.ALLOW_ARIA_ATTR !== false;
        ALLOW_DATA_ATTR = cfg.ALLOW_DATA_ATTR !== false;
        ALLOW_UNKNOWN_PROTOCOLS = cfg.ALLOW_UNKNOWN_PROTOCOLS || false;
        ALLOW_SELF_CLOSE_IN_ATTR = cfg.ALLOW_SELF_CLOSE_IN_ATTR !== false;
        SAFE_FOR_TEMPLATES = cfg.SAFE_FOR_TEMPLATES || false;
        SAFE_FOR_XML = cfg.SAFE_FOR_XML !== false;
        WHOLE_DOCUMENT = cfg.WHOLE_DOCUMENT || false;
        RETURN_DOM = cfg.RETURN_DOM || false;
        RETURN_DOM_FRAGMENT = cfg.RETURN_DOM_FRAGMENT || false;
        RETURN_TRUSTED_TYPE = cfg.RETURN_TRUSTED_TYPE || false;
        FORCE_BODY = cfg.FORCE_BODY || false;
        SANITIZE_DOM = cfg.SANITIZE_DOM !== false;
        SANITIZE_NAMED_PROPS = cfg.SANITIZE_NAMED_PROPS || false;
        KEEP_CONTENT = cfg.KEEP_CONTENT !== false;
        IN_PLACE = cfg.IN_PLACE || false;
        IS_ALLOWED_URI$1 = cfg.ALLOWED_URI_REGEXP || IS_ALLOWED_URI$1;
        NAMESPACE = cfg.NAMESPACE || HTML_NAMESPACE;
        CUSTOM_ELEMENT_HANDLING = cfg.CUSTOM_ELEMENT_HANDLING || {};
        if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck)) {
          CUSTOM_ELEMENT_HANDLING.tagNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck;
        }
        if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck)) {
          CUSTOM_ELEMENT_HANDLING.attributeNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck;
        }
        if (cfg.CUSTOM_ELEMENT_HANDLING && typeof cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements === "boolean") {
          CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements = cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements;
        }
        if (SAFE_FOR_TEMPLATES) {
          ALLOW_DATA_ATTR = false;
        }
        if (RETURN_DOM_FRAGMENT) {
          RETURN_DOM = true;
        }
        if (USE_PROFILES) {
          ALLOWED_TAGS = addToSet({}, _toConsumableArray(text));
          ALLOWED_ATTR = [];
          if (USE_PROFILES.html === true) {
            addToSet(ALLOWED_TAGS, html$1);
            addToSet(ALLOWED_ATTR, html);
          }
          if (USE_PROFILES.svg === true) {
            addToSet(ALLOWED_TAGS, svg$1);
            addToSet(ALLOWED_ATTR, svg);
            addToSet(ALLOWED_ATTR, xml);
          }
          if (USE_PROFILES.svgFilters === true) {
            addToSet(ALLOWED_TAGS, svgFilters);
            addToSet(ALLOWED_ATTR, svg);
            addToSet(ALLOWED_ATTR, xml);
          }
          if (USE_PROFILES.mathMl === true) {
            addToSet(ALLOWED_TAGS, mathMl$1);
            addToSet(ALLOWED_ATTR, mathMl);
            addToSet(ALLOWED_ATTR, xml);
          }
        }
        if (cfg.ADD_TAGS) {
          if (ALLOWED_TAGS === DEFAULT_ALLOWED_TAGS) {
            ALLOWED_TAGS = clone(ALLOWED_TAGS);
          }
          addToSet(ALLOWED_TAGS, cfg.ADD_TAGS, transformCaseFunc);
        }
        if (cfg.ADD_ATTR) {
          if (ALLOWED_ATTR === DEFAULT_ALLOWED_ATTR) {
            ALLOWED_ATTR = clone(ALLOWED_ATTR);
          }
          addToSet(ALLOWED_ATTR, cfg.ADD_ATTR, transformCaseFunc);
        }
        if (cfg.ADD_URI_SAFE_ATTR) {
          addToSet(URI_SAFE_ATTRIBUTES, cfg.ADD_URI_SAFE_ATTR, transformCaseFunc);
        }
        if (cfg.FORBID_CONTENTS) {
          if (FORBID_CONTENTS === DEFAULT_FORBID_CONTENTS) {
            FORBID_CONTENTS = clone(FORBID_CONTENTS);
          }
          addToSet(FORBID_CONTENTS, cfg.FORBID_CONTENTS, transformCaseFunc);
        }
        if (KEEP_CONTENT) {
          ALLOWED_TAGS["#text"] = true;
        }
        if (WHOLE_DOCUMENT) {
          addToSet(ALLOWED_TAGS, ["html", "head", "body"]);
        }
        if (ALLOWED_TAGS.table) {
          addToSet(ALLOWED_TAGS, ["tbody"]);
          delete FORBID_TAGS.tbody;
        }
        if (freeze) {
          freeze(cfg);
        }
        CONFIG = cfg;
      };
      var MATHML_TEXT_INTEGRATION_POINTS = addToSet({}, ["mi", "mo", "mn", "ms", "mtext"]);
      var HTML_INTEGRATION_POINTS = addToSet({}, ["annotation-xml"]);
      var COMMON_SVG_AND_HTML_ELEMENTS = addToSet({}, ["title", "style", "font", "a", "script"]);
      var ALL_SVG_TAGS = addToSet({}, svg$1);
      addToSet(ALL_SVG_TAGS, svgFilters);
      addToSet(ALL_SVG_TAGS, svgDisallowed);
      var ALL_MATHML_TAGS = addToSet({}, mathMl$1);
      addToSet(ALL_MATHML_TAGS, mathMlDisallowed);
      var _checkValidNamespace = function _checkValidNamespace(element) {
        var parent = getParentNode(element);
        if (!parent || !parent.tagName) {
          parent = {
            namespaceURI: NAMESPACE,
            tagName: "template"
          };
        }
        var tagName = stringToLowerCase(element.tagName);
        var parentTagName = stringToLowerCase(parent.tagName);
        if (!ALLOWED_NAMESPACES[element.namespaceURI]) {
          return false;
        }
        if (element.namespaceURI === SVG_NAMESPACE) {
          if (parent.namespaceURI === HTML_NAMESPACE) {
            return tagName === "svg";
          }
          if (parent.namespaceURI === MATHML_NAMESPACE) {
            return tagName === "svg" && (parentTagName === "annotation-xml" || MATHML_TEXT_INTEGRATION_POINTS[parentTagName]);
          }
          return Boolean(ALL_SVG_TAGS[tagName]);
        }
        if (element.namespaceURI === MATHML_NAMESPACE) {
          if (parent.namespaceURI === HTML_NAMESPACE) {
            return tagName === "math";
          }
          if (parent.namespaceURI === SVG_NAMESPACE) {
            return tagName === "math" && HTML_INTEGRATION_POINTS[parentTagName];
          }
          return Boolean(ALL_MATHML_TAGS[tagName]);
        }
        if (element.namespaceURI === HTML_NAMESPACE) {
          if (parent.namespaceURI === SVG_NAMESPACE && !HTML_INTEGRATION_POINTS[parentTagName]) {
            return false;
          }
          if (parent.namespaceURI === MATHML_NAMESPACE && !MATHML_TEXT_INTEGRATION_POINTS[parentTagName]) {
            return false;
          }
          return !ALL_MATHML_TAGS[tagName] && (COMMON_SVG_AND_HTML_ELEMENTS[tagName] || !ALL_SVG_TAGS[tagName]);
        }
        if (PARSER_MEDIA_TYPE === "application/xhtml+xml" && ALLOWED_NAMESPACES[element.namespaceURI]) {
          return true;
        }
        return false;
      };
      var _forceRemove = function _forceRemove(node) {
        arrayPush(DOMPurify.removed, {
          element: node
        });
        try {
          node.parentNode.removeChild(node);
        } catch (_) {
          try {
            node.outerHTML = emptyHTML;
          } catch (_2) {
            node.remove();
          }
        }
      };
      var _removeAttribute = function _removeAttribute(name, node) {
        try {
          arrayPush(DOMPurify.removed, {
            attribute: node.getAttributeNode(name),
            from: node
          });
        } catch (_) {
          arrayPush(DOMPurify.removed, {
            attribute: null,
            from: node
          });
        }
        node.removeAttribute(name);
        if (name === "is" && !ALLOWED_ATTR[name]) {
          if (RETURN_DOM || RETURN_DOM_FRAGMENT) {
            try {
              _forceRemove(node);
            } catch (_) {}
          } else {
            try {
              node.setAttribute(name, "");
            } catch (_) {}
          }
        }
      };
      var _initDocument = function _initDocument(dirty) {
        var doc3;
        var leadingWhitespace;
        if (FORCE_BODY) {
          dirty = "<remove></remove>" + dirty;
        } else {
          var matches2 = stringMatch(dirty, /^[\r\n\t ]+/);
          leadingWhitespace = matches2 && matches2[0];
        }
        if (PARSER_MEDIA_TYPE === "application/xhtml+xml" && NAMESPACE === HTML_NAMESPACE) {
          dirty = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + dirty + "</body></html>";
        }
        var dirtyPayload = trustedTypesPolicy ? trustedTypesPolicy.createHTML(dirty) : dirty;
        if (NAMESPACE === HTML_NAMESPACE) {
          try {
            doc3 = new DOMParser3().parseFromString(dirtyPayload, PARSER_MEDIA_TYPE);
          } catch (_) {}
        }
        if (!doc3 || !doc3.documentElement) {
          doc3 = implementation.createDocument(NAMESPACE, "template", null);
          try {
            doc3.documentElement.innerHTML = IS_EMPTY_INPUT ? emptyHTML : dirtyPayload;
          } catch (_) {}
        }
        var body = doc3.body || doc3.documentElement;
        if (dirty && leadingWhitespace) {
          body.insertBefore(document2.createTextNode(leadingWhitespace), body.childNodes[0] || null);
        }
        if (NAMESPACE === HTML_NAMESPACE) {
          return getElementsByTagName.call(doc3, WHOLE_DOCUMENT ? "html" : "body")[0];
        }
        return WHOLE_DOCUMENT ? doc3.documentElement : body;
      };
      var _createIterator = function _createIterator(root) {
        return createNodeIterator.call(root.ownerDocument || root, root, NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT | NodeFilter.SHOW_PROCESSING_INSTRUCTION | NodeFilter.SHOW_CDATA_SECTION, null, false);
      };
      var _isClobbered = function _isClobbered(elm) {
        return elm instanceof HTMLFormElement && (typeof elm.nodeName !== "string" || typeof elm.textContent !== "string" || typeof elm.removeChild !== "function" || !(elm.attributes instanceof NamedNodeMap) || typeof elm.removeAttribute !== "function" || typeof elm.setAttribute !== "function" || typeof elm.namespaceURI !== "string" || typeof elm.insertBefore !== "function" || typeof elm.hasChildNodes !== "function");
      };
      var _isNode = function _isNode(object) {
        return _typeof2(Node4) === "object" ? object instanceof Node4 : object && _typeof2(object) === "object" && typeof object.nodeType === "number" && typeof object.nodeName === "string";
      };
      var _executeHook = function _executeHook(entryPoint, currentNode, data) {
        if (!hooks[entryPoint]) {
          return;
        }
        arrayForEach(hooks[entryPoint], function(hook) {
          hook.call(DOMPurify, currentNode, data, CONFIG);
        });
      };
      var _sanitizeElements = function _sanitizeElements(currentNode) {
        var content;
        _executeHook("beforeSanitizeElements", currentNode, null);
        if (_isClobbered(currentNode)) {
          _forceRemove(currentNode);
          return true;
        }
        if (regExpTest(/[\u0080-\uFFFF]/, currentNode.nodeName)) {
          _forceRemove(currentNode);
          return true;
        }
        var tagName = transformCaseFunc(currentNode.nodeName);
        _executeHook("uponSanitizeElement", currentNode, {
          tagName,
          allowedTags: ALLOWED_TAGS
        });
        if (currentNode.hasChildNodes() && !_isNode(currentNode.firstElementChild) && (!_isNode(currentNode.content) || !_isNode(currentNode.content.firstElementChild)) && regExpTest(/<[/\w]/g, currentNode.innerHTML) && regExpTest(/<[/\w]/g, currentNode.textContent)) {
          _forceRemove(currentNode);
          return true;
        }
        if (tagName === "select" && regExpTest(/<template/i, currentNode.innerHTML)) {
          _forceRemove(currentNode);
          return true;
        }
        if (currentNode.nodeType === 7) {
          _forceRemove(currentNode);
          return true;
        }
        if (SAFE_FOR_XML && currentNode.nodeType === 8 && regExpTest(/<[/\w]/g, currentNode.data)) {
          _forceRemove(currentNode);
          return true;
        }
        if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
          if (!FORBID_TAGS[tagName] && _basicCustomElementTest(tagName)) {
            if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, tagName))
              return false;
            if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(tagName))
              return false;
          }
          if (KEEP_CONTENT && !FORBID_CONTENTS[tagName]) {
            var parentNode2 = getParentNode(currentNode) || currentNode.parentNode;
            var childNodes = getChildNodes(currentNode) || currentNode.childNodes;
            if (childNodes && parentNode2) {
              var childCount = childNodes.length;
              for (var i3 = childCount - 1;i3 >= 0; --i3) {
                var childClone = cloneNode(childNodes[i3], true);
                childClone.__removalCount = (currentNode.__removalCount || 0) + 1;
                parentNode2.insertBefore(childClone, getNextSibling(currentNode));
              }
            }
          }
          _forceRemove(currentNode);
          return true;
        }
        if (currentNode instanceof Element && !_checkValidNamespace(currentNode)) {
          _forceRemove(currentNode);
          return true;
        }
        if ((tagName === "noscript" || tagName === "noembed" || tagName === "noframes") && regExpTest(/<\/no(script|embed|frames)/i, currentNode.innerHTML)) {
          _forceRemove(currentNode);
          return true;
        }
        if (SAFE_FOR_TEMPLATES && currentNode.nodeType === 3) {
          content = currentNode.textContent;
          content = stringReplace(content, MUSTACHE_EXPR$1, " ");
          content = stringReplace(content, ERB_EXPR$1, " ");
          content = stringReplace(content, TMPLIT_EXPR$1, " ");
          if (currentNode.textContent !== content) {
            arrayPush(DOMPurify.removed, {
              element: currentNode.cloneNode()
            });
            currentNode.textContent = content;
          }
        }
        _executeHook("afterSanitizeElements", currentNode, null);
        return false;
      };
      var _isValidAttribute = function _isValidAttribute(lcTag, lcName, value) {
        if (SANITIZE_DOM && (lcName === "id" || lcName === "name") && ((value in document2) || (value in formElement))) {
          return false;
        }
        if (ALLOW_DATA_ATTR && !FORBID_ATTR[lcName] && regExpTest(DATA_ATTR$1, lcName))
          ;
        else if (ALLOW_ARIA_ATTR && regExpTest(ARIA_ATTR$1, lcName))
          ;
        else if (!ALLOWED_ATTR[lcName] || FORBID_ATTR[lcName]) {
          if (_basicCustomElementTest(lcTag) && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, lcTag) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(lcTag)) && (CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.attributeNameCheck, lcName) || CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.attributeNameCheck(lcName)) || lcName === "is" && CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, value) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(value)))
            ;
          else {
            return false;
          }
        } else if (URI_SAFE_ATTRIBUTES[lcName])
          ;
        else if (regExpTest(IS_ALLOWED_URI$1, stringReplace(value, ATTR_WHITESPACE$1, "")))
          ;
        else if ((lcName === "src" || lcName === "xlink:href" || lcName === "href") && lcTag !== "script" && stringIndexOf(value, "data:") === 0 && DATA_URI_TAGS[lcTag])
          ;
        else if (ALLOW_UNKNOWN_PROTOCOLS && !regExpTest(IS_SCRIPT_OR_DATA$1, stringReplace(value, ATTR_WHITESPACE$1, "")))
          ;
        else if (value) {
          return false;
        } else
          ;
        return true;
      };
      var _basicCustomElementTest = function _basicCustomElementTest(tagName) {
        return tagName !== "annotation-xml" && stringMatch(tagName, CUSTOM_ELEMENT$1);
      };
      var _sanitizeAttributes = function _sanitizeAttributes(currentNode) {
        var attr;
        var value;
        var lcName;
        var l;
        _executeHook("beforeSanitizeAttributes", currentNode, null);
        var attributes = currentNode.attributes;
        if (!attributes || _isClobbered(currentNode)) {
          return;
        }
        var hookEvent = {
          attrName: "",
          attrValue: "",
          keepAttr: true,
          allowedAttributes: ALLOWED_ATTR
        };
        l = attributes.length;
        while (l--) {
          attr = attributes[l];
          var _attr = attr, name = _attr.name, namespaceURI = _attr.namespaceURI;
          value = name === "value" ? attr.value : stringTrim(attr.value);
          lcName = transformCaseFunc(name);
          hookEvent.attrName = lcName;
          hookEvent.attrValue = value;
          hookEvent.keepAttr = true;
          hookEvent.forceKeepAttr = undefined;
          _executeHook("uponSanitizeAttribute", currentNode, hookEvent);
          value = hookEvent.attrValue;
          if (hookEvent.forceKeepAttr) {
            continue;
          }
          _removeAttribute(name, currentNode);
          if (!hookEvent.keepAttr) {
            continue;
          }
          if (!ALLOW_SELF_CLOSE_IN_ATTR && regExpTest(/\/>/i, value)) {
            _removeAttribute(name, currentNode);
            continue;
          }
          if (SAFE_FOR_TEMPLATES) {
            value = stringReplace(value, MUSTACHE_EXPR$1, " ");
            value = stringReplace(value, ERB_EXPR$1, " ");
            value = stringReplace(value, TMPLIT_EXPR$1, " ");
          }
          var lcTag = transformCaseFunc(currentNode.nodeName);
          if (!_isValidAttribute(lcTag, lcName, value)) {
            continue;
          }
          if (SANITIZE_NAMED_PROPS && (lcName === "id" || lcName === "name")) {
            _removeAttribute(name, currentNode);
            value = SANITIZE_NAMED_PROPS_PREFIX + value;
          }
          if (SAFE_FOR_XML && regExpTest(/((--!?|])>)|<\/(style|title)/i, value)) {
            _removeAttribute(name, currentNode);
            continue;
          }
          if (trustedTypesPolicy && _typeof2(trustedTypes) === "object" && typeof trustedTypes.getAttributeType === "function") {
            if (namespaceURI)
              ;
            else {
              switch (trustedTypes.getAttributeType(lcTag, lcName)) {
                case "TrustedHTML": {
                  value = trustedTypesPolicy.createHTML(value);
                  break;
                }
                case "TrustedScriptURL": {
                  value = trustedTypesPolicy.createScriptURL(value);
                  break;
                }
              }
            }
          }
          try {
            if (namespaceURI) {
              currentNode.setAttributeNS(namespaceURI, name, value);
            } else {
              currentNode.setAttribute(name, value);
            }
            if (_isClobbered(currentNode)) {
              _forceRemove(currentNode);
            } else {
              arrayPop(DOMPurify.removed);
            }
          } catch (_) {}
        }
        _executeHook("afterSanitizeAttributes", currentNode, null);
      };
      var _sanitizeShadowDOM = function _sanitizeShadowDOM(fragment) {
        var shadowNode;
        var shadowIterator = _createIterator(fragment);
        _executeHook("beforeSanitizeShadowDOM", fragment, null);
        while (shadowNode = shadowIterator.nextNode()) {
          _executeHook("uponSanitizeShadowNode", shadowNode, null);
          _sanitizeElements(shadowNode);
          _sanitizeAttributes(shadowNode);
          if (shadowNode.content instanceof DocumentFragment) {
            _sanitizeShadowDOM(shadowNode.content);
          }
        }
        _executeHook("afterSanitizeShadowDOM", fragment, null);
      };
      DOMPurify.sanitize = function(dirty) {
        var cfg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var body;
        var importedNode;
        var currentNode;
        var oldNode;
        var returnNode;
        IS_EMPTY_INPUT = !dirty;
        if (IS_EMPTY_INPUT) {
          dirty = "<!-->";
        }
        if (typeof dirty !== "string" && !_isNode(dirty)) {
          if (typeof dirty.toString === "function") {
            dirty = dirty.toString();
            if (typeof dirty !== "string") {
              throw typeErrorCreate("dirty is not a string, aborting");
            }
          } else {
            throw typeErrorCreate("toString is not a function");
          }
        }
        if (!DOMPurify.isSupported) {
          if (_typeof2(window2.toStaticHTML) === "object" || typeof window2.toStaticHTML === "function") {
            if (typeof dirty === "string") {
              return window2.toStaticHTML(dirty);
            }
            if (_isNode(dirty)) {
              return window2.toStaticHTML(dirty.outerHTML);
            }
          }
          return dirty;
        }
        if (!SET_CONFIG) {
          _parseConfig(cfg);
        }
        DOMPurify.removed = [];
        if (typeof dirty === "string") {
          IN_PLACE = false;
        }
        if (IN_PLACE) {
          if (dirty.nodeName) {
            var tagName = transformCaseFunc(dirty.nodeName);
            if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
              throw typeErrorCreate("root node is forbidden and cannot be sanitized in-place");
            }
          }
        } else if (dirty instanceof Node4) {
          body = _initDocument("<!---->");
          importedNode = body.ownerDocument.importNode(dirty, true);
          if (importedNode.nodeType === 1 && importedNode.nodeName === "BODY") {
            body = importedNode;
          } else if (importedNode.nodeName === "HTML") {
            body = importedNode;
          } else {
            body.appendChild(importedNode);
          }
        } else {
          if (!RETURN_DOM && !SAFE_FOR_TEMPLATES && !WHOLE_DOCUMENT && dirty.indexOf("<") === -1) {
            return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(dirty) : dirty;
          }
          body = _initDocument(dirty);
          if (!body) {
            return RETURN_DOM ? null : RETURN_TRUSTED_TYPE ? emptyHTML : "";
          }
        }
        if (body && FORCE_BODY) {
          _forceRemove(body.firstChild);
        }
        var nodeIterator = _createIterator(IN_PLACE ? dirty : body);
        while (currentNode = nodeIterator.nextNode()) {
          if (currentNode.nodeType === 3 && currentNode === oldNode) {
            continue;
          }
          _sanitizeElements(currentNode);
          _sanitizeAttributes(currentNode);
          if (currentNode.content instanceof DocumentFragment) {
            _sanitizeShadowDOM(currentNode.content);
          }
          oldNode = currentNode;
        }
        oldNode = null;
        if (IN_PLACE) {
          return dirty;
        }
        if (RETURN_DOM) {
          if (RETURN_DOM_FRAGMENT) {
            returnNode = createDocumentFragment.call(body.ownerDocument);
            while (body.firstChild) {
              returnNode.appendChild(body.firstChild);
            }
          } else {
            returnNode = body;
          }
          if (ALLOWED_ATTR.shadowroot || ALLOWED_ATTR.shadowrootmod) {
            returnNode = importNode.call(originalDocument, returnNode, true);
          }
          return returnNode;
        }
        var serializedHTML = WHOLE_DOCUMENT ? body.outerHTML : body.innerHTML;
        if (WHOLE_DOCUMENT && ALLOWED_TAGS["!doctype"] && body.ownerDocument && body.ownerDocument.doctype && body.ownerDocument.doctype.name && regExpTest(DOCTYPE_NAME, body.ownerDocument.doctype.name)) {
          serializedHTML = "<!DOCTYPE " + body.ownerDocument.doctype.name + `>
` + serializedHTML;
        }
        if (SAFE_FOR_TEMPLATES) {
          serializedHTML = stringReplace(serializedHTML, MUSTACHE_EXPR$1, " ");
          serializedHTML = stringReplace(serializedHTML, ERB_EXPR$1, " ");
          serializedHTML = stringReplace(serializedHTML, TMPLIT_EXPR$1, " ");
        }
        return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(serializedHTML) : serializedHTML;
      };
      DOMPurify.setConfig = function(cfg) {
        _parseConfig(cfg);
        SET_CONFIG = true;
      };
      DOMPurify.clearConfig = function() {
        CONFIG = null;
        SET_CONFIG = false;
      };
      DOMPurify.isValidAttribute = function(tag, attr, value) {
        if (!CONFIG) {
          _parseConfig({});
        }
        var lcTag = transformCaseFunc(tag);
        var lcName = transformCaseFunc(attr);
        return _isValidAttribute(lcTag, lcName, value);
      };
      DOMPurify.addHook = function(entryPoint, hookFunction) {
        if (typeof hookFunction !== "function") {
          return;
        }
        hooks[entryPoint] = hooks[entryPoint] || [];
        arrayPush(hooks[entryPoint], hookFunction);
      };
      DOMPurify.removeHook = function(entryPoint) {
        if (hooks[entryPoint]) {
          return arrayPop(hooks[entryPoint]);
        }
      };
      DOMPurify.removeHooks = function(entryPoint) {
        if (hooks[entryPoint]) {
          hooks[entryPoint] = [];
        }
      };
      DOMPurify.removeAllHooks = function() {
        hooks = {};
      };
      return DOMPurify;
    }
    var purify = createDOMPurify();
    return purify;
  });
});

// node_modules/core-js/internals/global-this.js
var require_global_this = __commonJS((exports, module) => {
  var check = function(it) {
    return it && it.Math === Math && it;
  };
  module.exports = check(typeof globalThis == "object" && globalThis) || check(typeof window == "object" && window) || check(typeof self == "object" && self) || check(typeof global == "object" && global) || check(typeof exports == "object" && exports) || function() {
    return this;
  }() || Function("return this")();
});

// node_modules/core-js/internals/fails.js
var require_fails = __commonJS((exports, module) => {
  module.exports = function(exec) {
    try {
      return !!exec();
    } catch (error) {
      return true;
    }
  };
});

// node_modules/core-js/internals/descriptors.js
var require_descriptors = __commonJS((exports, module) => {
  var fails = require_fails();
  module.exports = !fails(function() {
    return Object.defineProperty({}, 1, { get: function() {
      return 7;
    } })[1] !== 7;
  });
});

// node_modules/core-js/internals/function-bind-native.js
var require_function_bind_native = __commonJS((exports, module) => {
  var fails = require_fails();
  module.exports = !fails(function() {
    var test = function() {}.bind();
    return typeof test != "function" || test.hasOwnProperty("prototype");
  });
});

// node_modules/core-js/internals/function-call.js
var require_function_call = __commonJS((exports, module) => {
  var NATIVE_BIND = require_function_bind_native();
  var call = Function.prototype.call;
  module.exports = NATIVE_BIND ? call.bind(call) : function() {
    return call.apply(call, arguments);
  };
});

// node_modules/core-js/internals/object-property-is-enumerable.js
var require_object_property_is_enumerable = __commonJS((exports) => {
  var $propertyIsEnumerable = {}.propertyIsEnumerable;
  var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
  var NASHORN_BUG = getOwnPropertyDescriptor && !$propertyIsEnumerable.call({ 1: 2 }, 1);
  exports.f = NASHORN_BUG ? function propertyIsEnumerable(V) {
    var descriptor = getOwnPropertyDescriptor(this, V);
    return !!descriptor && descriptor.enumerable;
  } : $propertyIsEnumerable;
});

// node_modules/core-js/internals/create-property-descriptor.js
var require_create_property_descriptor = __commonJS((exports, module) => {
  module.exports = function(bitmap, value) {
    return {
      enumerable: !(bitmap & 1),
      configurable: !(bitmap & 2),
      writable: !(bitmap & 4),
      value
    };
  };
});

// node_modules/core-js/internals/function-uncurry-this.js
var require_function_uncurry_this = __commonJS((exports, module) => {
  var NATIVE_BIND = require_function_bind_native();
  var FunctionPrototype = Function.prototype;
  var call = FunctionPrototype.call;
  var uncurryThisWithBind = NATIVE_BIND && FunctionPrototype.bind.bind(call, call);
  module.exports = NATIVE_BIND ? uncurryThisWithBind : function(fn) {
    return function() {
      return call.apply(fn, arguments);
    };
  };
});

// node_modules/core-js/internals/classof-raw.js
var require_classof_raw = __commonJS((exports, module) => {
  var uncurryThis = require_function_uncurry_this();
  var toString = uncurryThis({}.toString);
  var stringSlice = uncurryThis("".slice);
  module.exports = function(it) {
    return stringSlice(toString(it), 8, -1);
  };
});

// node_modules/core-js/internals/indexed-object.js
var require_indexed_object = __commonJS((exports, module) => {
  var uncurryThis = require_function_uncurry_this();
  var fails = require_fails();
  var classof = require_classof_raw();
  var $Object = Object;
  var split2 = uncurryThis("".split);
  module.exports = fails(function() {
    return !$Object("z").propertyIsEnumerable(0);
  }) ? function(it) {
    return classof(it) === "String" ? split2(it, "") : $Object(it);
  } : $Object;
});

// node_modules/core-js/internals/is-null-or-undefined.js
var require_is_null_or_undefined = __commonJS((exports, module) => {
  module.exports = function(it) {
    return it === null || it === undefined;
  };
});

// node_modules/core-js/internals/require-object-coercible.js
var require_require_object_coercible = __commonJS((exports, module) => {
  var isNullOrUndefined = require_is_null_or_undefined();
  var $TypeError = TypeError;
  module.exports = function(it) {
    if (isNullOrUndefined(it))
      throw new $TypeError("Can't call method on " + it);
    return it;
  };
});

// node_modules/core-js/internals/to-indexed-object.js
var require_to_indexed_object = __commonJS((exports, module) => {
  var IndexedObject = require_indexed_object();
  var requireObjectCoercible = require_require_object_coercible();
  module.exports = function(it) {
    return IndexedObject(requireObjectCoercible(it));
  };
});

// node_modules/core-js/internals/is-callable.js
var require_is_callable = __commonJS((exports, module) => {
  var documentAll = typeof document == "object" && document.all;
  module.exports = typeof documentAll == "undefined" && documentAll !== undefined ? function(argument) {
    return typeof argument == "function" || argument === documentAll;
  } : function(argument) {
    return typeof argument == "function";
  };
});

// node_modules/core-js/internals/is-object.js
var require_is_object = __commonJS((exports, module) => {
  var isCallable = require_is_callable();
  module.exports = function(it) {
    return typeof it == "object" ? it !== null : isCallable(it);
  };
});

// node_modules/core-js/internals/get-built-in.js
var require_get_built_in = __commonJS((exports, module) => {
  var globalThis2 = require_global_this();
  var isCallable = require_is_callable();
  var aFunction = function(argument) {
    return isCallable(argument) ? argument : undefined;
  };
  module.exports = function(namespace, method) {
    return arguments.length < 2 ? aFunction(globalThis2[namespace]) : globalThis2[namespace] && globalThis2[namespace][method];
  };
});

// node_modules/core-js/internals/object-is-prototype-of.js
var require_object_is_prototype_of = __commonJS((exports, module) => {
  var uncurryThis = require_function_uncurry_this();
  module.exports = uncurryThis({}.isPrototypeOf);
});

// node_modules/core-js/internals/environment-user-agent.js
var require_environment_user_agent = __commonJS((exports, module) => {
  var globalThis2 = require_global_this();
  var navigator2 = globalThis2.navigator;
  var userAgent = navigator2 && navigator2.userAgent;
  module.exports = userAgent ? String(userAgent) : "";
});

// node_modules/core-js/internals/environment-v8-version.js
var require_environment_v8_version = __commonJS((exports, module) => {
  var globalThis2 = require_global_this();
  var userAgent = require_environment_user_agent();
  var process2 = globalThis2.process;
  var Deno2 = globalThis2.Deno;
  var versions = process2 && process2.versions || Deno2 && Deno2.version;
  var v8 = versions && versions.v8;
  var match;
  var version;
  if (v8) {
    match = v8.split(".");
    version = match[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1]);
  }
  if (!version && userAgent) {
    match = userAgent.match(/Edge\/(\d+)/);
    if (!match || match[1] >= 74) {
      match = userAgent.match(/Chrome\/(\d+)/);
      if (match)
        version = +match[1];
    }
  }
  module.exports = version;
});

// node_modules/core-js/internals/symbol-constructor-detection.js
var require_symbol_constructor_detection = __commonJS((exports, module) => {
  var V8_VERSION = require_environment_v8_version();
  var fails = require_fails();
  var globalThis2 = require_global_this();
  var $String = globalThis2.String;
  module.exports = !!Object.getOwnPropertySymbols && !fails(function() {
    var symbol = Symbol("symbol detection");
    return !$String(symbol) || !(Object(symbol) instanceof Symbol) || !Symbol.sham && V8_VERSION && V8_VERSION < 41;
  });
});

// node_modules/core-js/internals/use-symbol-as-uid.js
var require_use_symbol_as_uid = __commonJS((exports, module) => {
  var NATIVE_SYMBOL = require_symbol_constructor_detection();
  module.exports = NATIVE_SYMBOL && !Symbol.sham && typeof Symbol.iterator == "symbol";
});

// node_modules/core-js/internals/is-symbol.js
var require_is_symbol = __commonJS((exports, module) => {
  var getBuiltIn = require_get_built_in();
  var isCallable = require_is_callable();
  var isPrototypeOf = require_object_is_prototype_of();
  var USE_SYMBOL_AS_UID = require_use_symbol_as_uid();
  var $Object = Object;
  module.exports = USE_SYMBOL_AS_UID ? function(it) {
    return typeof it == "symbol";
  } : function(it) {
    var $Symbol = getBuiltIn("Symbol");
    return isCallable($Symbol) && isPrototypeOf($Symbol.prototype, $Object(it));
  };
});

// node_modules/core-js/internals/try-to-string.js
var require_try_to_string = __commonJS((exports, module) => {
  var $String = String;
  module.exports = function(argument) {
    try {
      return $String(argument);
    } catch (error) {
      return "Object";
    }
  };
});

// node_modules/core-js/internals/a-callable.js
var require_a_callable = __commonJS((exports, module) => {
  var isCallable = require_is_callable();
  var tryToString = require_try_to_string();
  var $TypeError = TypeError;
  module.exports = function(argument) {
    if (isCallable(argument))
      return argument;
    throw new $TypeError(tryToString(argument) + " is not a function");
  };
});

// node_modules/core-js/internals/get-method.js
var require_get_method = __commonJS((exports, module) => {
  var aCallable = require_a_callable();
  var isNullOrUndefined = require_is_null_or_undefined();
  module.exports = function(V, P) {
    var func = V[P];
    return isNullOrUndefined(func) ? undefined : aCallable(func);
  };
});

// node_modules/core-js/internals/ordinary-to-primitive.js
var require_ordinary_to_primitive = __commonJS((exports, module) => {
  var call = require_function_call();
  var isCallable = require_is_callable();
  var isObject = require_is_object();
  var $TypeError = TypeError;
  module.exports = function(input, pref) {
    var fn, val;
    if (pref === "string" && isCallable(fn = input.toString) && !isObject(val = call(fn, input)))
      return val;
    if (isCallable(fn = input.valueOf) && !isObject(val = call(fn, input)))
      return val;
    if (pref !== "string" && isCallable(fn = input.toString) && !isObject(val = call(fn, input)))
      return val;
    throw new $TypeError("Can't convert object to primitive value");
  };
});

// node_modules/core-js/internals/is-pure.js
var require_is_pure = __commonJS((exports, module) => {
  module.exports = false;
});

// node_modules/core-js/internals/define-global-property.js
var require_define_global_property = __commonJS((exports, module) => {
  var globalThis2 = require_global_this();
  var defineProperty = Object.defineProperty;
  module.exports = function(key, value) {
    try {
      defineProperty(globalThis2, key, { value, configurable: true, writable: true });
    } catch (error) {
      globalThis2[key] = value;
    }
    return value;
  };
});

// node_modules/core-js/internals/shared-store.js
var require_shared_store = __commonJS((exports, module) => {
  var IS_PURE = require_is_pure();
  var globalThis2 = require_global_this();
  var defineGlobalProperty = require_define_global_property();
  var SHARED = "__core-js_shared__";
  var store = module.exports = globalThis2[SHARED] || defineGlobalProperty(SHARED, {});
  (store.versions || (store.versions = [])).push({
    version: "3.48.0",
    mode: IS_PURE ? "pure" : "global",
    copyright: " 20132025 Denis Pushkarev (zloirock.ru), 20252026 CoreJS Company (core-js.io). All rights reserved.",
    license: "https://github.com/zloirock/core-js/blob/v3.48.0/LICENSE",
    source: "https://github.com/zloirock/core-js"
  });
});

// node_modules/core-js/internals/shared.js
var require_shared = __commonJS((exports, module) => {
  var store = require_shared_store();
  module.exports = function(key, value) {
    return store[key] || (store[key] = value || {});
  };
});

// node_modules/core-js/internals/to-object.js
var require_to_object = __commonJS((exports, module) => {
  var requireObjectCoercible = require_require_object_coercible();
  var $Object = Object;
  module.exports = function(argument) {
    return $Object(requireObjectCoercible(argument));
  };
});

// node_modules/core-js/internals/has-own-property.js
var require_has_own_property = __commonJS((exports, module) => {
  var uncurryThis = require_function_uncurry_this();
  var toObject = require_to_object();
  var hasOwnProperty = uncurryThis({}.hasOwnProperty);
  module.exports = Object.hasOwn || function hasOwn(it, key) {
    return hasOwnProperty(toObject(it), key);
  };
});

// node_modules/core-js/internals/uid.js
var require_uid = __commonJS((exports, module) => {
  var uncurryThis = require_function_uncurry_this();
  var id = 0;
  var postfix = Math.random();
  var toString = uncurryThis(1.1 .toString);
  module.exports = function(key) {
    return "Symbol(" + (key === undefined ? "" : key) + ")_" + toString(++id + postfix, 36);
  };
});

// node_modules/core-js/internals/well-known-symbol.js
var require_well_known_symbol = __commonJS((exports, module) => {
  var globalThis2 = require_global_this();
  var shared = require_shared();
  var hasOwn = require_has_own_property();
  var uid = require_uid();
  var NATIVE_SYMBOL = require_symbol_constructor_detection();
  var USE_SYMBOL_AS_UID = require_use_symbol_as_uid();
  var Symbol2 = globalThis2.Symbol;
  var WellKnownSymbolsStore = shared("wks");
  var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol2["for"] || Symbol2 : Symbol2 && Symbol2.withoutSetter || uid;
  module.exports = function(name) {
    if (!hasOwn(WellKnownSymbolsStore, name)) {
      WellKnownSymbolsStore[name] = NATIVE_SYMBOL && hasOwn(Symbol2, name) ? Symbol2[name] : createWellKnownSymbol("Symbol." + name);
    }
    return WellKnownSymbolsStore[name];
  };
});

// node_modules/core-js/internals/to-primitive.js
var require_to_primitive = __commonJS((exports, module) => {
  var call = require_function_call();
  var isObject = require_is_object();
  var isSymbol = require_is_symbol();
  var getMethod = require_get_method();
  var ordinaryToPrimitive = require_ordinary_to_primitive();
  var wellKnownSymbol = require_well_known_symbol();
  var $TypeError = TypeError;
  var TO_PRIMITIVE = wellKnownSymbol("toPrimitive");
  module.exports = function(input, pref) {
    if (!isObject(input) || isSymbol(input))
      return input;
    var exoticToPrim = getMethod(input, TO_PRIMITIVE);
    var result;
    if (exoticToPrim) {
      if (pref === undefined)
        pref = "default";
      result = call(exoticToPrim, input, pref);
      if (!isObject(result) || isSymbol(result))
        return result;
      throw new $TypeError("Can't convert object to primitive value");
    }
    if (pref === undefined)
      pref = "number";
    return ordinaryToPrimitive(input, pref);
  };
});

// node_modules/core-js/internals/to-property-key.js
var require_to_property_key = __commonJS((exports, module) => {
  var toPrimitive = require_to_primitive();
  var isSymbol = require_is_symbol();
  module.exports = function(argument) {
    var key = toPrimitive(argument, "string");
    return isSymbol(key) ? key : key + "";
  };
});

// node_modules/core-js/internals/document-create-element.js
var require_document_create_element = __commonJS((exports, module) => {
  var globalThis2 = require_global_this();
  var isObject = require_is_object();
  var document2 = globalThis2.document;
  var EXISTS = isObject(document2) && isObject(document2.createElement);
  module.exports = function(it) {
    return EXISTS ? document2.createElement(it) : {};
  };
});

// node_modules/core-js/internals/ie8-dom-define.js
var require_ie8_dom_define = __commonJS((exports, module) => {
  var DESCRIPTORS = require_descriptors();
  var fails = require_fails();
  var createElement = require_document_create_element();
  module.exports = !DESCRIPTORS && !fails(function() {
    return Object.defineProperty(createElement("div"), "a", {
      get: function() {
        return 7;
      }
    }).a !== 7;
  });
});

// node_modules/core-js/internals/object-get-own-property-descriptor.js
var require_object_get_own_property_descriptor = __commonJS((exports) => {
  var DESCRIPTORS = require_descriptors();
  var call = require_function_call();
  var propertyIsEnumerableModule = require_object_property_is_enumerable();
  var createPropertyDescriptor = require_create_property_descriptor();
  var toIndexedObject = require_to_indexed_object();
  var toPropertyKey = require_to_property_key();
  var hasOwn = require_has_own_property();
  var IE8_DOM_DEFINE = require_ie8_dom_define();
  var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
  exports.f = DESCRIPTORS ? $getOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {
    O = toIndexedObject(O);
    P = toPropertyKey(P);
    if (IE8_DOM_DEFINE)
      try {
        return $getOwnPropertyDescriptor(O, P);
      } catch (error) {}
    if (hasOwn(O, P))
      return createPropertyDescriptor(!call(propertyIsEnumerableModule.f, O, P), O[P]);
  };
});

// node_modules/core-js/internals/v8-prototype-define-bug.js
var require_v8_prototype_define_bug = __commonJS((exports, module) => {
  var DESCRIPTORS = require_descriptors();
  var fails = require_fails();
  module.exports = DESCRIPTORS && fails(function() {
    return Object.defineProperty(function() {}, "prototype", {
      value: 42,
      writable: false
    }).prototype !== 42;
  });
});

// node_modules/core-js/internals/an-object.js
var require_an_object = __commonJS((exports, module) => {
  var isObject = require_is_object();
  var $String = String;
  var $TypeError = TypeError;
  module.exports = function(argument) {
    if (isObject(argument))
      return argument;
    throw new $TypeError($String(argument) + " is not an object");
  };
});

// node_modules/core-js/internals/object-define-property.js
var require_object_define_property = __commonJS((exports) => {
  var DESCRIPTORS = require_descriptors();
  var IE8_DOM_DEFINE = require_ie8_dom_define();
  var V8_PROTOTYPE_DEFINE_BUG = require_v8_prototype_define_bug();
  var anObject = require_an_object();
  var toPropertyKey = require_to_property_key();
  var $TypeError = TypeError;
  var $defineProperty = Object.defineProperty;
  var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
  var ENUMERABLE = "enumerable";
  var CONFIGURABLE = "configurable";
  var WRITABLE = "writable";
  exports.f = DESCRIPTORS ? V8_PROTOTYPE_DEFINE_BUG ? function defineProperty(O, P, Attributes) {
    anObject(O);
    P = toPropertyKey(P);
    anObject(Attributes);
    if (typeof O === "function" && P === "prototype" && "value" in Attributes && WRITABLE in Attributes && !Attributes[WRITABLE]) {
      var current = $getOwnPropertyDescriptor(O, P);
      if (current && current[WRITABLE]) {
        O[P] = Attributes.value;
        Attributes = {
          configurable: CONFIGURABLE in Attributes ? Attributes[CONFIGURABLE] : current[CONFIGURABLE],
          enumerable: ENUMERABLE in Attributes ? Attributes[ENUMERABLE] : current[ENUMERABLE],
          writable: false
        };
      }
    }
    return $defineProperty(O, P, Attributes);
  } : $defineProperty : function defineProperty(O, P, Attributes) {
    anObject(O);
    P = toPropertyKey(P);
    anObject(Attributes);
    if (IE8_DOM_DEFINE)
      try {
        return $defineProperty(O, P, Attributes);
      } catch (error) {}
    if ("get" in Attributes || "set" in Attributes)
      throw new $TypeError("Accessors not supported");
    if ("value" in Attributes)
      O[P] = Attributes.value;
    return O;
  };
});

// node_modules/core-js/internals/create-non-enumerable-property.js
var require_create_non_enumerable_property = __commonJS((exports, module) => {
  var DESCRIPTORS = require_descriptors();
  var definePropertyModule = require_object_define_property();
  var createPropertyDescriptor = require_create_property_descriptor();
  module.exports = DESCRIPTORS ? function(object, key, value) {
    return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));
  } : function(object, key, value) {
    object[key] = value;
    return object;
  };
});

// node_modules/core-js/internals/function-name.js
var require_function_name = __commonJS((exports, module) => {
  var DESCRIPTORS = require_descriptors();
  var hasOwn = require_has_own_property();
  var FunctionPrototype = Function.prototype;
  var getDescriptor = DESCRIPTORS && Object.getOwnPropertyDescriptor;
  var EXISTS = hasOwn(FunctionPrototype, "name");
  var PROPER = EXISTS && function something() {}.name === "something";
  var CONFIGURABLE = EXISTS && (!DESCRIPTORS || DESCRIPTORS && getDescriptor(FunctionPrototype, "name").configurable);
  module.exports = {
    EXISTS,
    PROPER,
    CONFIGURABLE
  };
});

// node_modules/core-js/internals/inspect-source.js
var require_inspect_source = __commonJS((exports, module) => {
  var uncurryThis = require_function_uncurry_this();
  var isCallable = require_is_callable();
  var store = require_shared_store();
  var functionToString = uncurryThis(Function.toString);
  if (!isCallable(store.inspectSource)) {
    store.inspectSource = function(it) {
      return functionToString(it);
    };
  }
  module.exports = store.inspectSource;
});

// node_modules/core-js/internals/weak-map-basic-detection.js
var require_weak_map_basic_detection = __commonJS((exports, module) => {
  var globalThis2 = require_global_this();
  var isCallable = require_is_callable();
  var WeakMap2 = globalThis2.WeakMap;
  module.exports = isCallable(WeakMap2) && /native code/.test(String(WeakMap2));
});

// node_modules/core-js/internals/shared-key.js
var require_shared_key = __commonJS((exports, module) => {
  var shared = require_shared();
  var uid = require_uid();
  var keys2 = shared("keys");
  module.exports = function(key) {
    return keys2[key] || (keys2[key] = uid(key));
  };
});

// node_modules/core-js/internals/hidden-keys.js
var require_hidden_keys = __commonJS((exports, module) => {
  module.exports = {};
});

// node_modules/core-js/internals/internal-state.js
var require_internal_state = __commonJS((exports, module) => {
  var NATIVE_WEAK_MAP = require_weak_map_basic_detection();
  var globalThis2 = require_global_this();
  var isObject = require_is_object();
  var createNonEnumerableProperty = require_create_non_enumerable_property();
  var hasOwn = require_has_own_property();
  var shared = require_shared_store();
  var sharedKey = require_shared_key();
  var hiddenKeys = require_hidden_keys();
  var OBJECT_ALREADY_INITIALIZED = "Object already initialized";
  var TypeError2 = globalThis2.TypeError;
  var WeakMap2 = globalThis2.WeakMap;
  var set;
  var get2;
  var has;
  var enforce = function(it) {
    return has(it) ? get2(it) : set(it, {});
  };
  var getterFor = function(TYPE) {
    return function(it) {
      var state;
      if (!isObject(it) || (state = get2(it)).type !== TYPE) {
        throw new TypeError2("Incompatible receiver, " + TYPE + " required");
      }
      return state;
    };
  };
  if (NATIVE_WEAK_MAP || shared.state) {
    store = shared.state || (shared.state = new WeakMap2);
    store.get = store.get;
    store.has = store.has;
    store.set = store.set;
    set = function(it, metadata) {
      if (store.has(it))
        throw new TypeError2(OBJECT_ALREADY_INITIALIZED);
      metadata.facade = it;
      store.set(it, metadata);
      return metadata;
    };
    get2 = function(it) {
      return store.get(it) || {};
    };
    has = function(it) {
      return store.has(it);
    };
  } else {
    STATE = sharedKey("state");
    hiddenKeys[STATE] = true;
    set = function(it, metadata) {
      if (hasOwn(it, STATE))
        throw new TypeError2(OBJECT_ALREADY_INITIALIZED);
      metadata.facade = it;
      createNonEnumerableProperty(it, STATE, metadata);
      return metadata;
    };
    get2 = function(it) {
      return hasOwn(it, STATE) ? it[STATE] : {};
    };
    has = function(it) {
      return hasOwn(it, STATE);
    };
  }
  var store;
  var STATE;
  module.exports = {
    set,
    get: get2,
    has,
    enforce,
    getterFor
  };
});

// node_modules/core-js/internals/make-built-in.js
var require_make_built_in = __commonJS((exports, module) => {
  var uncurryThis = require_function_uncurry_this();
  var fails = require_fails();
  var isCallable = require_is_callable();
  var hasOwn = require_has_own_property();
  var DESCRIPTORS = require_descriptors();
  var CONFIGURABLE_FUNCTION_NAME = require_function_name().CONFIGURABLE;
  var inspectSource = require_inspect_source();
  var InternalStateModule = require_internal_state();
  var enforceInternalState = InternalStateModule.enforce;
  var getInternalState = InternalStateModule.get;
  var $String = String;
  var defineProperty = Object.defineProperty;
  var stringSlice = uncurryThis("".slice);
  var replace2 = uncurryThis("".replace);
  var join2 = uncurryThis([].join);
  var CONFIGURABLE_LENGTH = DESCRIPTORS && !fails(function() {
    return defineProperty(function() {}, "length", { value: 8 }).length !== 8;
  });
  var TEMPLATE = String(String).split("String");
  var makeBuiltIn = module.exports = function(value, name, options) {
    if (stringSlice($String(name), 0, 7) === "Symbol(") {
      name = "[" + replace2($String(name), /^Symbol\(([^)]*)\).*$/, "$1") + "]";
    }
    if (options && options.getter)
      name = "get " + name;
    if (options && options.setter)
      name = "set " + name;
    if (!hasOwn(value, "name") || CONFIGURABLE_FUNCTION_NAME && value.name !== name) {
      if (DESCRIPTORS)
        defineProperty(value, "name", { value: name, configurable: true });
      else
        value.name = name;
    }
    if (CONFIGURABLE_LENGTH && options && hasOwn(options, "arity") && value.length !== options.arity) {
      defineProperty(value, "length", { value: options.arity });
    }
    try {
      if (options && hasOwn(options, "constructor") && options.constructor) {
        if (DESCRIPTORS)
          defineProperty(value, "prototype", { writable: false });
      } else if (value.prototype)
        value.prototype = undefined;
    } catch (error) {}
    var state = enforceInternalState(value);
    if (!hasOwn(state, "source")) {
      state.source = join2(TEMPLATE, typeof name == "string" ? name : "");
    }
    return value;
  };
  Function.prototype.toString = makeBuiltIn(function toString() {
    return isCallable(this) && getInternalState(this).source || inspectSource(this);
  }, "toString");
});

// node_modules/core-js/internals/define-built-in.js
var require_define_built_in = __commonJS((exports, module) => {
  var isCallable = require_is_callable();
  var definePropertyModule = require_object_define_property();
  var makeBuiltIn = require_make_built_in();
  var defineGlobalProperty = require_define_global_property();
  module.exports = function(O, key, value, options) {
    if (!options)
      options = {};
    var simple = options.enumerable;
    var name = options.name !== undefined ? options.name : key;
    if (isCallable(value))
      makeBuiltIn(value, name, options);
    if (options.global) {
      if (simple)
        O[key] = value;
      else
        defineGlobalProperty(key, value);
    } else {
      try {
        if (!options.unsafe)
          delete O[key];
        else if (O[key])
          simple = true;
      } catch (error) {}
      if (simple)
        O[key] = value;
      else
        definePropertyModule.f(O, key, {
          value,
          enumerable: false,
          configurable: !options.nonConfigurable,
          writable: !options.nonWritable
        });
    }
    return O;
  };
});

// node_modules/core-js/internals/math-trunc.js
var require_math_trunc = __commonJS((exports, module) => {
  var ceil = Math.ceil;
  var floor = Math.floor;
  module.exports = Math.trunc || function trunc(x2) {
    var n = +x2;
    return (n > 0 ? floor : ceil)(n);
  };
});

// node_modules/core-js/internals/to-integer-or-infinity.js
var require_to_integer_or_infinity = __commonJS((exports, module) => {
  var trunc = require_math_trunc();
  module.exports = function(argument) {
    var number = +argument;
    return number !== number || number === 0 ? 0 : trunc(number);
  };
});

// node_modules/core-js/internals/to-absolute-index.js
var require_to_absolute_index = __commonJS((exports, module) => {
  var toIntegerOrInfinity = require_to_integer_or_infinity();
  var max2 = Math.max;
  var min = Math.min;
  module.exports = function(index, length) {
    var integer = toIntegerOrInfinity(index);
    return integer < 0 ? max2(integer + length, 0) : min(integer, length);
  };
});

// node_modules/core-js/internals/to-length.js
var require_to_length = __commonJS((exports, module) => {
  var toIntegerOrInfinity = require_to_integer_or_infinity();
  var min = Math.min;
  module.exports = function(argument) {
    var len = toIntegerOrInfinity(argument);
    return len > 0 ? min(len, 9007199254740991) : 0;
  };
});

// node_modules/core-js/internals/length-of-array-like.js
var require_length_of_array_like = __commonJS((exports, module) => {
  var toLength = require_to_length();
  module.exports = function(obj) {
    return toLength(obj.length);
  };
});

// node_modules/core-js/internals/array-includes.js
var require_array_includes = __commonJS((exports, module) => {
  var toIndexedObject = require_to_indexed_object();
  var toAbsoluteIndex = require_to_absolute_index();
  var lengthOfArrayLike = require_length_of_array_like();
  var createMethod = function(IS_INCLUDES) {
    return function($this, el, fromIndex) {
      var O = toIndexedObject($this);
      var length = lengthOfArrayLike(O);
      if (length === 0)
        return !IS_INCLUDES && -1;
      var index = toAbsoluteIndex(fromIndex, length);
      var value;
      if (IS_INCLUDES && el !== el)
        while (length > index) {
          value = O[index++];
          if (value !== value)
            return true;
        }
      else
        for (;length > index; index++) {
          if ((IS_INCLUDES || (index in O)) && O[index] === el)
            return IS_INCLUDES || index || 0;
        }
      return !IS_INCLUDES && -1;
    };
  };
  module.exports = {
    includes: createMethod(true),
    indexOf: createMethod(false)
  };
});

// node_modules/core-js/internals/object-keys-internal.js
var require_object_keys_internal = __commonJS((exports, module) => {
  var uncurryThis = require_function_uncurry_this();
  var hasOwn = require_has_own_property();
  var toIndexedObject = require_to_indexed_object();
  var indexOf = require_array_includes().indexOf;
  var hiddenKeys = require_hidden_keys();
  var push = uncurryThis([].push);
  module.exports = function(object, names) {
    var O = toIndexedObject(object);
    var i3 = 0;
    var result = [];
    var key;
    for (key in O)
      !hasOwn(hiddenKeys, key) && hasOwn(O, key) && push(result, key);
    while (names.length > i3)
      if (hasOwn(O, key = names[i3++])) {
        ~indexOf(result, key) || push(result, key);
      }
    return result;
  };
});

// node_modules/core-js/internals/enum-bug-keys.js
var require_enum_bug_keys = __commonJS((exports, module) => {
  module.exports = [
    "constructor",
    "hasOwnProperty",
    "isPrototypeOf",
    "propertyIsEnumerable",
    "toLocaleString",
    "toString",
    "valueOf"
  ];
});

// node_modules/core-js/internals/object-get-own-property-names.js
var require_object_get_own_property_names = __commonJS((exports) => {
  var internalObjectKeys = require_object_keys_internal();
  var enumBugKeys = require_enum_bug_keys();
  var hiddenKeys = enumBugKeys.concat("length", "prototype");
  exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
    return internalObjectKeys(O, hiddenKeys);
  };
});

// node_modules/core-js/internals/object-get-own-property-symbols.js
var require_object_get_own_property_symbols = __commonJS((exports) => {
  exports.f = Object.getOwnPropertySymbols;
});

// node_modules/core-js/internals/own-keys.js
var require_own_keys = __commonJS((exports, module) => {
  var getBuiltIn = require_get_built_in();
  var uncurryThis = require_function_uncurry_this();
  var getOwnPropertyNamesModule = require_object_get_own_property_names();
  var getOwnPropertySymbolsModule = require_object_get_own_property_symbols();
  var anObject = require_an_object();
  var concat = uncurryThis([].concat);
  module.exports = getBuiltIn("Reflect", "ownKeys") || function ownKeys(it) {
    var keys2 = getOwnPropertyNamesModule.f(anObject(it));
    var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
    return getOwnPropertySymbols ? concat(keys2, getOwnPropertySymbols(it)) : keys2;
  };
});

// node_modules/core-js/internals/copy-constructor-properties.js
var require_copy_constructor_properties = __commonJS((exports, module) => {
  var hasOwn = require_has_own_property();
  var ownKeys = require_own_keys();
  var getOwnPropertyDescriptorModule = require_object_get_own_property_descriptor();
  var definePropertyModule = require_object_define_property();
  module.exports = function(target, source, exceptions) {
    var keys2 = ownKeys(source);
    var defineProperty = definePropertyModule.f;
    var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
    for (var i3 = 0;i3 < keys2.length; i3++) {
      var key = keys2[i3];
      if (!hasOwn(target, key) && !(exceptions && hasOwn(exceptions, key))) {
        defineProperty(target, key, getOwnPropertyDescriptor(source, key));
      }
    }
  };
});

// node_modules/core-js/internals/is-forced.js
var require_is_forced = __commonJS((exports, module) => {
  var fails = require_fails();
  var isCallable = require_is_callable();
  var replacement = /#|\.prototype\./;
  var isForced = function(feature, detection) {
    var value = data[normalize2(feature)];
    return value === POLYFILL ? true : value === NATIVE ? false : isCallable(detection) ? fails(detection) : !!detection;
  };
  var normalize2 = isForced.normalize = function(string) {
    return String(string).replace(replacement, ".").toLowerCase();
  };
  var data = isForced.data = {};
  var NATIVE = isForced.NATIVE = "N";
  var POLYFILL = isForced.POLYFILL = "P";
  module.exports = isForced;
});

// node_modules/core-js/internals/export.js
var require_export = __commonJS((exports, module) => {
  var globalThis2 = require_global_this();
  var getOwnPropertyDescriptor = require_object_get_own_property_descriptor().f;
  var createNonEnumerableProperty = require_create_non_enumerable_property();
  var defineBuiltIn = require_define_built_in();
  var defineGlobalProperty = require_define_global_property();
  var copyConstructorProperties = require_copy_constructor_properties();
  var isForced = require_is_forced();
  module.exports = function(options, source) {
    var TARGET = options.target;
    var GLOBAL = options.global;
    var STATIC = options.stat;
    var FORCED, target, key, targetProperty, sourceProperty, descriptor;
    if (GLOBAL) {
      target = globalThis2;
    } else if (STATIC) {
      target = globalThis2[TARGET] || defineGlobalProperty(TARGET, {});
    } else {
      target = globalThis2[TARGET] && globalThis2[TARGET].prototype;
    }
    if (target)
      for (key in source) {
        sourceProperty = source[key];
        if (options.dontCallGetSet) {
          descriptor = getOwnPropertyDescriptor(target, key);
          targetProperty = descriptor && descriptor.value;
        } else
          targetProperty = target[key];
        FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? "." : "#") + key, options.forced);
        if (!FORCED && targetProperty !== undefined) {
          if (typeof sourceProperty == typeof targetProperty)
            continue;
          copyConstructorProperties(sourceProperty, targetProperty);
        }
        if (options.sham || targetProperty && targetProperty.sham) {
          createNonEnumerableProperty(sourceProperty, "sham", true);
        }
        defineBuiltIn(target, key, sourceProperty, options);
      }
  };
});

// node_modules/core-js/internals/environment.js
var require_environment = __commonJS((exports, module) => {
  var globalThis2 = require_global_this();
  var userAgent = require_environment_user_agent();
  var classof = require_classof_raw();
  var userAgentStartsWith = function(string) {
    return userAgent.slice(0, string.length) === string;
  };
  module.exports = function() {
    if (userAgentStartsWith("Bun/"))
      return "BUN";
    if (userAgentStartsWith("Cloudflare-Workers"))
      return "CLOUDFLARE";
    if (userAgentStartsWith("Deno/"))
      return "DENO";
    if (userAgentStartsWith("Node.js/"))
      return "NODE";
    if (globalThis2.Bun && typeof Bun.version == "string")
      return "BUN";
    if (globalThis2.Deno && typeof Deno.version == "object")
      return "DENO";
    if (classof(globalThis2.process) === "process")
      return "NODE";
    if (globalThis2.window && globalThis2.document)
      return "BROWSER";
    return "REST";
  }();
});

// node_modules/core-js/internals/environment-is-node.js
var require_environment_is_node = __commonJS((exports, module) => {
  var ENVIRONMENT = require_environment();
  module.exports = ENVIRONMENT === "NODE";
});

// node_modules/core-js/internals/path.js
var require_path = __commonJS((exports, module) => {
  var globalThis2 = require_global_this();
  module.exports = globalThis2;
});

// node_modules/core-js/internals/function-uncurry-this-accessor.js
var require_function_uncurry_this_accessor = __commonJS((exports, module) => {
  var uncurryThis = require_function_uncurry_this();
  var aCallable = require_a_callable();
  module.exports = function(object, key, method) {
    try {
      return uncurryThis(aCallable(Object.getOwnPropertyDescriptor(object, key)[method]));
    } catch (error) {}
  };
});

// node_modules/core-js/internals/is-possible-prototype.js
var require_is_possible_prototype = __commonJS((exports, module) => {
  var isObject = require_is_object();
  module.exports = function(argument) {
    return isObject(argument) || argument === null;
  };
});

// node_modules/core-js/internals/a-possible-prototype.js
var require_a_possible_prototype = __commonJS((exports, module) => {
  var isPossiblePrototype = require_is_possible_prototype();
  var $String = String;
  var $TypeError = TypeError;
  module.exports = function(argument) {
    if (isPossiblePrototype(argument))
      return argument;
    throw new $TypeError("Can't set " + $String(argument) + " as a prototype");
  };
});

// node_modules/core-js/internals/object-set-prototype-of.js
var require_object_set_prototype_of = __commonJS((exports, module) => {
  var uncurryThisAccessor = require_function_uncurry_this_accessor();
  var isObject = require_is_object();
  var requireObjectCoercible = require_require_object_coercible();
  var aPossiblePrototype = require_a_possible_prototype();
  module.exports = Object.setPrototypeOf || ("__proto__" in {} ? function() {
    var CORRECT_SETTER = false;
    var test = {};
    var setter;
    try {
      setter = uncurryThisAccessor(Object.prototype, "__proto__", "set");
      setter(test, []);
      CORRECT_SETTER = test instanceof Array;
    } catch (error) {}
    return function setPrototypeOf(O, proto) {
      requireObjectCoercible(O);
      aPossiblePrototype(proto);
      if (!isObject(O))
        return O;
      if (CORRECT_SETTER)
        setter(O, proto);
      else
        O.__proto__ = proto;
      return O;
    };
  }() : undefined);
});

// node_modules/core-js/internals/set-to-string-tag.js
var require_set_to_string_tag = __commonJS((exports, module) => {
  var defineProperty = require_object_define_property().f;
  var hasOwn = require_has_own_property();
  var wellKnownSymbol = require_well_known_symbol();
  var TO_STRING_TAG = wellKnownSymbol("toStringTag");
  module.exports = function(target, TAG, STATIC) {
    if (target && !STATIC)
      target = target.prototype;
    if (target && !hasOwn(target, TO_STRING_TAG)) {
      defineProperty(target, TO_STRING_TAG, { configurable: true, value: TAG });
    }
  };
});

// node_modules/core-js/internals/define-built-in-accessor.js
var require_define_built_in_accessor = __commonJS((exports, module) => {
  var makeBuiltIn = require_make_built_in();
  var defineProperty = require_object_define_property();
  module.exports = function(target, name, descriptor) {
    if (descriptor.get)
      makeBuiltIn(descriptor.get, name, { getter: true });
    if (descriptor.set)
      makeBuiltIn(descriptor.set, name, { setter: true });
    return defineProperty.f(target, name, descriptor);
  };
});

// node_modules/core-js/internals/set-species.js
var require_set_species = __commonJS((exports, module) => {
  var getBuiltIn = require_get_built_in();
  var defineBuiltInAccessor = require_define_built_in_accessor();
  var wellKnownSymbol = require_well_known_symbol();
  var DESCRIPTORS = require_descriptors();
  var SPECIES = wellKnownSymbol("species");
  module.exports = function(CONSTRUCTOR_NAME) {
    var Constructor = getBuiltIn(CONSTRUCTOR_NAME);
    if (DESCRIPTORS && Constructor && !Constructor[SPECIES]) {
      defineBuiltInAccessor(Constructor, SPECIES, {
        configurable: true,
        get: function() {
          return this;
        }
      });
    }
  };
});

// node_modules/core-js/internals/an-instance.js
var require_an_instance = __commonJS((exports, module) => {
  var isPrototypeOf = require_object_is_prototype_of();
  var $TypeError = TypeError;
  module.exports = function(it, Prototype) {
    if (isPrototypeOf(Prototype, it))
      return it;
    throw new $TypeError("Incorrect invocation");
  };
});

// node_modules/core-js/internals/to-string-tag-support.js
var require_to_string_tag_support = __commonJS((exports, module) => {
  var wellKnownSymbol = require_well_known_symbol();
  var TO_STRING_TAG = wellKnownSymbol("toStringTag");
  var test = {};
  test[TO_STRING_TAG] = "z";
  module.exports = String(test) === "[object z]";
});

// node_modules/core-js/internals/classof.js
var require_classof = __commonJS((exports, module) => {
  var TO_STRING_TAG_SUPPORT = require_to_string_tag_support();
  var isCallable = require_is_callable();
  var classofRaw = require_classof_raw();
  var wellKnownSymbol = require_well_known_symbol();
  var TO_STRING_TAG = wellKnownSymbol("toStringTag");
  var $Object = Object;
  var CORRECT_ARGUMENTS = classofRaw(function() {
    return arguments;
  }()) === "Arguments";
  var tryGet = function(it, key) {
    try {
      return it[key];
    } catch (error) {}
  };
  module.exports = TO_STRING_TAG_SUPPORT ? classofRaw : function(it) {
    var O, tag, result;
    return it === undefined ? "Undefined" : it === null ? "Null" : typeof (tag = tryGet(O = $Object(it), TO_STRING_TAG)) == "string" ? tag : CORRECT_ARGUMENTS ? classofRaw(O) : (result = classofRaw(O)) === "Object" && isCallable(O.callee) ? "Arguments" : result;
  };
});

// node_modules/core-js/internals/is-constructor.js
var require_is_constructor = __commonJS((exports, module) => {
  var uncurryThis = require_function_uncurry_this();
  var fails = require_fails();
  var isCallable = require_is_callable();
  var classof = require_classof();
  var getBuiltIn = require_get_built_in();
  var inspectSource = require_inspect_source();
  var noop = function() {};
  var construct = getBuiltIn("Reflect", "construct");
  var constructorRegExp = /^\s*(?:class|function)\b/;
  var exec = uncurryThis(constructorRegExp.exec);
  var INCORRECT_TO_STRING = !constructorRegExp.test(noop);
  var isConstructorModern = function isConstructor(argument) {
    if (!isCallable(argument))
      return false;
    try {
      construct(noop, [], argument);
      return true;
    } catch (error) {
      return false;
    }
  };
  var isConstructorLegacy = function isConstructor(argument) {
    if (!isCallable(argument))
      return false;
    switch (classof(argument)) {
      case "AsyncFunction":
      case "GeneratorFunction":
      case "AsyncGeneratorFunction":
        return false;
    }
    try {
      return INCORRECT_TO_STRING || !!exec(constructorRegExp, inspectSource(argument));
    } catch (error) {
      return true;
    }
  };
  isConstructorLegacy.sham = true;
  module.exports = !construct || fails(function() {
    var called;
    return isConstructorModern(isConstructorModern.call) || !isConstructorModern(Object) || !isConstructorModern(function() {
      called = true;
    }) || called;
  }) ? isConstructorLegacy : isConstructorModern;
});

// node_modules/core-js/internals/a-constructor.js
var require_a_constructor = __commonJS((exports, module) => {
  var isConstructor = require_is_constructor();
  var tryToString = require_try_to_string();
  var $TypeError = TypeError;
  module.exports = function(argument) {
    if (isConstructor(argument))
      return argument;
    throw new $TypeError(tryToString(argument) + " is not a constructor");
  };
});

// node_modules/core-js/internals/species-constructor.js
var require_species_constructor = __commonJS((exports, module) => {
  var anObject = require_an_object();
  var aConstructor = require_a_constructor();
  var isNullOrUndefined = require_is_null_or_undefined();
  var wellKnownSymbol = require_well_known_symbol();
  var SPECIES = wellKnownSymbol("species");
  module.exports = function(O, defaultConstructor) {
    var C = anObject(O).constructor;
    var S;
    return C === undefined || isNullOrUndefined(S = anObject(C)[SPECIES]) ? defaultConstructor : aConstructor(S);
  };
});

// node_modules/core-js/internals/function-apply.js
var require_function_apply = __commonJS((exports, module) => {
  var NATIVE_BIND = require_function_bind_native();
  var FunctionPrototype = Function.prototype;
  var apply2 = FunctionPrototype.apply;
  var call = FunctionPrototype.call;
  module.exports = typeof Reflect == "object" && Reflect.apply || (NATIVE_BIND ? call.bind(apply2) : function() {
    return call.apply(apply2, arguments);
  });
});

// node_modules/core-js/internals/function-uncurry-this-clause.js
var require_function_uncurry_this_clause = __commonJS((exports, module) => {
  var classofRaw = require_classof_raw();
  var uncurryThis = require_function_uncurry_this();
  module.exports = function(fn) {
    if (classofRaw(fn) === "Function")
      return uncurryThis(fn);
  };
});

// node_modules/core-js/internals/function-bind-context.js
var require_function_bind_context = __commonJS((exports, module) => {
  var uncurryThis = require_function_uncurry_this_clause();
  var aCallable = require_a_callable();
  var NATIVE_BIND = require_function_bind_native();
  var bind2 = uncurryThis(uncurryThis.bind);
  module.exports = function(fn, that) {
    aCallable(fn);
    return that === undefined ? fn : NATIVE_BIND ? bind2(fn, that) : function() {
      return fn.apply(that, arguments);
    };
  };
});

// node_modules/core-js/internals/html.js
var require_html = __commonJS((exports, module) => {
  var getBuiltIn = require_get_built_in();
  module.exports = getBuiltIn("document", "documentElement");
});

// node_modules/core-js/internals/array-slice.js
var require_array_slice = __commonJS((exports, module) => {
  var uncurryThis = require_function_uncurry_this();
  module.exports = uncurryThis([].slice);
});

// node_modules/core-js/internals/validate-arguments-length.js
var require_validate_arguments_length = __commonJS((exports, module) => {
  var $TypeError = TypeError;
  module.exports = function(passed, required) {
    if (passed < required)
      throw new $TypeError("Not enough arguments");
    return passed;
  };
});

// node_modules/core-js/internals/environment-is-ios.js
var require_environment_is_ios = __commonJS((exports, module) => {
  var userAgent = require_environment_user_agent();
  module.exports = /(?:ipad|iphone|ipod).*applewebkit/i.test(userAgent);
});

// node_modules/core-js/internals/task.js
var require_task = __commonJS((exports, module) => {
  var globalThis2 = require_global_this();
  var apply2 = require_function_apply();
  var bind2 = require_function_bind_context();
  var isCallable = require_is_callable();
  var hasOwn = require_has_own_property();
  var fails = require_fails();
  var html = require_html();
  var arraySlice = require_array_slice();
  var createElement = require_document_create_element();
  var validateArgumentsLength = require_validate_arguments_length();
  var IS_IOS = require_environment_is_ios();
  var IS_NODE = require_environment_is_node();
  var set = globalThis2.setImmediate;
  var clear = globalThis2.clearImmediate;
  var process2 = globalThis2.process;
  var Dispatch = globalThis2.Dispatch;
  var Function2 = globalThis2.Function;
  var MessageChannel = globalThis2.MessageChannel;
  var String2 = globalThis2.String;
  var counter = 0;
  var queue = {};
  var ONREADYSTATECHANGE = "onreadystatechange";
  var $location;
  var defer;
  var channel;
  var port;
  fails(function() {
    $location = globalThis2.location;
  });
  var run2 = function(id) {
    if (hasOwn(queue, id)) {
      var fn = queue[id];
      delete queue[id];
      fn();
    }
  };
  var runner = function(id) {
    return function() {
      run2(id);
    };
  };
  var eventListener = function(event) {
    run2(event.data);
  };
  var globalPostMessageDefer = function(id) {
    globalThis2.postMessage(String2(id), $location.protocol + "//" + $location.host);
  };
  if (!set || !clear) {
    set = function setImmediate(handler) {
      validateArgumentsLength(arguments.length, 1);
      var fn = isCallable(handler) ? handler : Function2(handler);
      var args = arraySlice(arguments, 1);
      queue[++counter] = function() {
        apply2(fn, undefined, args);
      };
      defer(counter);
      return counter;
    };
    clear = function clearImmediate(id) {
      delete queue[id];
    };
    if (IS_NODE) {
      defer = function(id) {
        process2.nextTick(runner(id));
      };
    } else if (Dispatch && Dispatch.now) {
      defer = function(id) {
        Dispatch.now(runner(id));
      };
    } else if (MessageChannel && !IS_IOS) {
      channel = new MessageChannel;
      port = channel.port2;
      channel.port1.onmessage = eventListener;
      defer = bind2(port.postMessage, port);
    } else if (globalThis2.addEventListener && isCallable(globalThis2.postMessage) && !globalThis2.importScripts && $location && $location.protocol !== "file:" && !fails(globalPostMessageDefer)) {
      defer = globalPostMessageDefer;
      globalThis2.addEventListener("message", eventListener, false);
    } else if (ONREADYSTATECHANGE in createElement("script")) {
      defer = function(id) {
        html.appendChild(createElement("script"))[ONREADYSTATECHANGE] = function() {
          html.removeChild(this);
          run2(id);
        };
      };
    } else {
      defer = function(id) {
        setTimeout(runner(id), 0);
      };
    }
  }
  module.exports = {
    set,
    clear
  };
});

// node_modules/core-js/internals/safe-get-built-in.js
var require_safe_get_built_in = __commonJS((exports, module) => {
  var globalThis2 = require_global_this();
  var DESCRIPTORS = require_descriptors();
  var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
  module.exports = function(name) {
    if (!DESCRIPTORS)
      return globalThis2[name];
    var descriptor = getOwnPropertyDescriptor(globalThis2, name);
    return descriptor && descriptor.value;
  };
});

// node_modules/core-js/internals/queue.js
var require_queue = __commonJS((exports, module) => {
  var Queue = function() {
    this.head = null;
    this.tail = null;
  };
  Queue.prototype = {
    add: function(item) {
      var entry = { item, next: null };
      var tail = this.tail;
      if (tail)
        tail.next = entry;
      else
        this.head = entry;
      this.tail = entry;
    },
    get: function() {
      var entry = this.head;
      if (entry) {
        var next = this.head = entry.next;
        if (next === null)
          this.tail = null;
        return entry.item;
      }
    }
  };
  module.exports = Queue;
});

// node_modules/core-js/internals/environment-is-ios-pebble.js
var require_environment_is_ios_pebble = __commonJS((exports, module) => {
  var userAgent = require_environment_user_agent();
  module.exports = /ipad|iphone|ipod/i.test(userAgent) && typeof Pebble != "undefined";
});

// node_modules/core-js/internals/environment-is-webos-webkit.js
var require_environment_is_webos_webkit = __commonJS((exports, module) => {
  var userAgent = require_environment_user_agent();
  module.exports = /web0s(?!.*chrome)/i.test(userAgent);
});

// node_modules/core-js/internals/microtask.js
var require_microtask = __commonJS((exports, module) => {
  var globalThis2 = require_global_this();
  var safeGetBuiltIn = require_safe_get_built_in();
  var bind2 = require_function_bind_context();
  var macrotask = require_task().set;
  var Queue = require_queue();
  var IS_IOS = require_environment_is_ios();
  var IS_IOS_PEBBLE = require_environment_is_ios_pebble();
  var IS_WEBOS_WEBKIT = require_environment_is_webos_webkit();
  var IS_NODE = require_environment_is_node();
  var MutationObserver = globalThis2.MutationObserver || globalThis2.WebKitMutationObserver;
  var document2 = globalThis2.document;
  var process2 = globalThis2.process;
  var Promise2 = globalThis2.Promise;
  var microtask = safeGetBuiltIn("queueMicrotask");
  var notify;
  var toggle;
  var node;
  var promise;
  var then;
  if (!microtask) {
    queue = new Queue;
    flush = function() {
      var parent, fn;
      if (IS_NODE && (parent = process2.domain))
        parent.exit();
      while (fn = queue.get())
        try {
          fn();
        } catch (error) {
          if (queue.head)
            notify();
          throw error;
        }
      if (parent)
        parent.enter();
    };
    if (!IS_IOS && !IS_NODE && !IS_WEBOS_WEBKIT && MutationObserver && document2) {
      toggle = true;
      node = document2.createTextNode("");
      new MutationObserver(flush).observe(node, { characterData: true });
      notify = function() {
        node.data = toggle = !toggle;
      };
    } else if (!IS_IOS_PEBBLE && Promise2 && Promise2.resolve) {
      promise = Promise2.resolve(undefined);
      promise.constructor = Promise2;
      then = bind2(promise.then, promise);
      notify = function() {
        then(flush);
      };
    } else if (IS_NODE) {
      notify = function() {
        process2.nextTick(flush);
      };
    } else {
      macrotask = bind2(macrotask, globalThis2);
      notify = function() {
        macrotask(flush);
      };
    }
    microtask = function(fn) {
      if (!queue.head)
        notify();
      queue.add(fn);
    };
  }
  var queue;
  var flush;
  module.exports = microtask;
});

// node_modules/core-js/internals/host-report-errors.js
var require_host_report_errors = __commonJS((exports, module) => {
  module.exports = function(a, b) {
    try {
      arguments.length === 1 ? console.error(a) : console.error(a, b);
    } catch (error) {}
  };
});

// node_modules/core-js/internals/perform.js
var require_perform = __commonJS((exports, module) => {
  module.exports = function(exec) {
    try {
      return { error: false, value: exec() };
    } catch (error) {
      return { error: true, value: error };
    }
  };
});

// node_modules/core-js/internals/promise-native-constructor.js
var require_promise_native_constructor = __commonJS((exports, module) => {
  var globalThis2 = require_global_this();
  module.exports = globalThis2.Promise;
});

// node_modules/core-js/internals/promise-constructor-detection.js
var require_promise_constructor_detection = __commonJS((exports, module) => {
  var globalThis2 = require_global_this();
  var NativePromiseConstructor = require_promise_native_constructor();
  var isCallable = require_is_callable();
  var isForced = require_is_forced();
  var inspectSource = require_inspect_source();
  var wellKnownSymbol = require_well_known_symbol();
  var ENVIRONMENT = require_environment();
  var IS_PURE = require_is_pure();
  var V8_VERSION = require_environment_v8_version();
  var NativePromisePrototype = NativePromiseConstructor && NativePromiseConstructor.prototype;
  var SPECIES = wellKnownSymbol("species");
  var SUBCLASSING = false;
  var NATIVE_PROMISE_REJECTION_EVENT = isCallable(globalThis2.PromiseRejectionEvent);
  var FORCED_PROMISE_CONSTRUCTOR = isForced("Promise", function() {
    var PROMISE_CONSTRUCTOR_SOURCE = inspectSource(NativePromiseConstructor);
    var GLOBAL_CORE_JS_PROMISE = PROMISE_CONSTRUCTOR_SOURCE !== String(NativePromiseConstructor);
    if (!GLOBAL_CORE_JS_PROMISE && V8_VERSION === 66)
      return true;
    if (IS_PURE && !(NativePromisePrototype["catch"] && NativePromisePrototype["finally"]))
      return true;
    if (!V8_VERSION || V8_VERSION < 51 || !/native code/.test(PROMISE_CONSTRUCTOR_SOURCE)) {
      var promise = new NativePromiseConstructor(function(resolve) {
        resolve(1);
      });
      var FakePromise = function(exec) {
        exec(function() {}, function() {});
      };
      var constructor = promise.constructor = {};
      constructor[SPECIES] = FakePromise;
      SUBCLASSING = promise.then(function() {}) instanceof FakePromise;
      if (!SUBCLASSING)
        return true;
    }
    return !GLOBAL_CORE_JS_PROMISE && (ENVIRONMENT === "BROWSER" || ENVIRONMENT === "DENO") && !NATIVE_PROMISE_REJECTION_EVENT;
  });
  module.exports = {
    CONSTRUCTOR: FORCED_PROMISE_CONSTRUCTOR,
    REJECTION_EVENT: NATIVE_PROMISE_REJECTION_EVENT,
    SUBCLASSING
  };
});

// node_modules/core-js/internals/new-promise-capability.js
var require_new_promise_capability = __commonJS((exports, module) => {
  var aCallable = require_a_callable();
  var $TypeError = TypeError;
  var PromiseCapability = function(C) {
    var resolve, reject;
    this.promise = new C(function($$resolve, $$reject) {
      if (resolve !== undefined || reject !== undefined)
        throw new $TypeError("Bad Promise constructor");
      resolve = $$resolve;
      reject = $$reject;
    });
    this.resolve = aCallable(resolve);
    this.reject = aCallable(reject);
  };
  exports.f = function(C) {
    return new PromiseCapability(C);
  };
});

// node_modules/core-js/modules/es.promise.constructor.js
var require_es_promise_constructor = __commonJS(() => {
  var $ = require_export();
  var IS_PURE = require_is_pure();
  var IS_NODE = require_environment_is_node();
  var globalThis2 = require_global_this();
  var path = require_path();
  var call = require_function_call();
  var defineBuiltIn = require_define_built_in();
  var setPrototypeOf = require_object_set_prototype_of();
  var setToStringTag = require_set_to_string_tag();
  var setSpecies = require_set_species();
  var aCallable = require_a_callable();
  var isCallable = require_is_callable();
  var isObject = require_is_object();
  var anInstance = require_an_instance();
  var speciesConstructor = require_species_constructor();
  var task = require_task().set;
  var microtask = require_microtask();
  var hostReportErrors = require_host_report_errors();
  var perform = require_perform();
  var Queue = require_queue();
  var InternalStateModule = require_internal_state();
  var NativePromiseConstructor = require_promise_native_constructor();
  var PromiseConstructorDetection = require_promise_constructor_detection();
  var newPromiseCapabilityModule = require_new_promise_capability();
  var PROMISE = "Promise";
  var FORCED_PROMISE_CONSTRUCTOR = PromiseConstructorDetection.CONSTRUCTOR;
  var NATIVE_PROMISE_REJECTION_EVENT = PromiseConstructorDetection.REJECTION_EVENT;
  var NATIVE_PROMISE_SUBCLASSING = PromiseConstructorDetection.SUBCLASSING;
  var getInternalPromiseState = InternalStateModule.getterFor(PROMISE);
  var setInternalState = InternalStateModule.set;
  var NativePromisePrototype = NativePromiseConstructor && NativePromiseConstructor.prototype;
  var PromiseConstructor = NativePromiseConstructor;
  var PromisePrototype = NativePromisePrototype;
  var TypeError2 = globalThis2.TypeError;
  var document2 = globalThis2.document;
  var process2 = globalThis2.process;
  var newPromiseCapability = newPromiseCapabilityModule.f;
  var newGenericPromiseCapability = newPromiseCapability;
  var DISPATCH_EVENT = !!(document2 && document2.createEvent && globalThis2.dispatchEvent);
  var UNHANDLED_REJECTION = "unhandledrejection";
  var REJECTION_HANDLED = "rejectionhandled";
  var PENDING = 0;
  var FULFILLED = 1;
  var REJECTED = 2;
  var HANDLED = 1;
  var UNHANDLED = 2;
  var Internal;
  var OwnPromiseCapability;
  var PromiseWrapper;
  var nativeThen;
  var isThenable = function(it) {
    var then;
    return isObject(it) && isCallable(then = it.then) ? then : false;
  };
  var callReaction = function(reaction, state) {
    var value = state.value;
    var ok = state.state === FULFILLED;
    var handler = ok ? reaction.ok : reaction.fail;
    var resolve = reaction.resolve;
    var reject = reaction.reject;
    var domain = reaction.domain;
    var result, then, exited;
    try {
      if (handler) {
        if (!ok) {
          if (state.rejection === UNHANDLED)
            onHandleUnhandled(state);
          state.rejection = HANDLED;
        }
        if (handler === true)
          result = value;
        else {
          if (domain)
            domain.enter();
          result = handler(value);
          if (domain) {
            domain.exit();
            exited = true;
          }
        }
        if (result === reaction.promise) {
          reject(new TypeError2("Promise-chain cycle"));
        } else if (then = isThenable(result)) {
          call(then, result, resolve, reject);
        } else
          resolve(result);
      } else
        reject(value);
    } catch (error) {
      if (domain && !exited)
        domain.exit();
      reject(error);
    }
  };
  var notify = function(state, isReject) {
    if (state.notified)
      return;
    state.notified = true;
    microtask(function() {
      var reactions = state.reactions;
      var reaction;
      while (reaction = reactions.get()) {
        callReaction(reaction, state);
      }
      state.notified = false;
      if (isReject && !state.rejection)
        onUnhandled(state);
    });
  };
  var dispatchEvent2 = function(name, promise, reason) {
    var event, handler;
    if (DISPATCH_EVENT) {
      event = document2.createEvent("Event");
      event.promise = promise;
      event.reason = reason;
      event.initEvent(name, false, true);
      globalThis2.dispatchEvent(event);
    } else
      event = { promise, reason };
    if (!NATIVE_PROMISE_REJECTION_EVENT && (handler = globalThis2["on" + name]))
      handler(event);
    else if (name === UNHANDLED_REJECTION)
      hostReportErrors("Unhandled promise rejection", reason);
  };
  var onUnhandled = function(state) {
    call(task, globalThis2, function() {
      var promise = state.facade;
      var value = state.value;
      var IS_UNHANDLED = isUnhandled(state);
      var result;
      if (IS_UNHANDLED) {
        result = perform(function() {
          if (IS_NODE) {
            process2.emit("unhandledRejection", value, promise);
          } else
            dispatchEvent2(UNHANDLED_REJECTION, promise, value);
        });
        state.rejection = IS_NODE || isUnhandled(state) ? UNHANDLED : HANDLED;
        if (result.error)
          throw result.value;
      }
    });
  };
  var isUnhandled = function(state) {
    return state.rejection !== HANDLED && !state.parent;
  };
  var onHandleUnhandled = function(state) {
    call(task, globalThis2, function() {
      var promise = state.facade;
      if (IS_NODE) {
        process2.emit("rejectionHandled", promise);
      } else
        dispatchEvent2(REJECTION_HANDLED, promise, state.value);
    });
  };
  var bind2 = function(fn, state, unwrap) {
    return function(value) {
      fn(state, value, unwrap);
    };
  };
  var internalReject = function(state, value, unwrap) {
    if (state.done)
      return;
    state.done = true;
    if (unwrap)
      state = unwrap;
    state.value = value;
    state.state = REJECTED;
    notify(state, true);
  };
  var internalResolve = function(state, value, unwrap) {
    if (state.done)
      return;
    state.done = true;
    if (unwrap)
      state = unwrap;
    try {
      if (state.facade === value)
        throw new TypeError2("Promise can't be resolved itself");
      var then = isThenable(value);
      if (then) {
        microtask(function() {
          var wrapper = { done: false };
          try {
            call(then, value, bind2(internalResolve, wrapper, state), bind2(internalReject, wrapper, state));
          } catch (error) {
            internalReject(wrapper, error, state);
          }
        });
      } else {
        state.value = value;
        state.state = FULFILLED;
        notify(state, false);
      }
    } catch (error) {
      internalReject({ done: false }, error, state);
    }
  };
  if (FORCED_PROMISE_CONSTRUCTOR) {
    PromiseConstructor = function Promise(executor) {
      anInstance(this, PromisePrototype);
      aCallable(executor);
      call(Internal, this);
      var state = getInternalPromiseState(this);
      try {
        executor(bind2(internalResolve, state), bind2(internalReject, state));
      } catch (error) {
        internalReject(state, error);
      }
    };
    PromisePrototype = PromiseConstructor.prototype;
    Internal = function Promise(executor) {
      setInternalState(this, {
        type: PROMISE,
        done: false,
        notified: false,
        parent: false,
        reactions: new Queue,
        rejection: false,
        state: PENDING,
        value: null
      });
    };
    Internal.prototype = defineBuiltIn(PromisePrototype, "then", function then(onFulfilled, onRejected) {
      var state = getInternalPromiseState(this);
      var reaction = newPromiseCapability(speciesConstructor(this, PromiseConstructor));
      state.parent = true;
      reaction.ok = isCallable(onFulfilled) ? onFulfilled : true;
      reaction.fail = isCallable(onRejected) && onRejected;
      reaction.domain = IS_NODE ? process2.domain : undefined;
      if (state.state === PENDING)
        state.reactions.add(reaction);
      else
        microtask(function() {
          callReaction(reaction, state);
        });
      return reaction.promise;
    });
    OwnPromiseCapability = function() {
      var promise = new Internal;
      var state = getInternalPromiseState(promise);
      this.promise = promise;
      this.resolve = bind2(internalResolve, state);
      this.reject = bind2(internalReject, state);
    };
    newPromiseCapabilityModule.f = newPromiseCapability = function(C) {
      return C === PromiseConstructor || C === PromiseWrapper ? new OwnPromiseCapability(C) : newGenericPromiseCapability(C);
    };
    if (!IS_PURE && isCallable(NativePromiseConstructor) && NativePromisePrototype !== Object.prototype) {
      nativeThen = NativePromisePrototype.then;
      if (!NATIVE_PROMISE_SUBCLASSING) {
        defineBuiltIn(NativePromisePrototype, "then", function then(onFulfilled, onRejected) {
          var that = this;
          return new PromiseConstructor(function(resolve, reject) {
            call(nativeThen, that, resolve, reject);
          }).then(onFulfilled, onRejected);
        }, { unsafe: true });
      }
      try {
        delete NativePromisePrototype.constructor;
      } catch (error) {}
      if (setPrototypeOf) {
        setPrototypeOf(NativePromisePrototype, PromisePrototype);
      }
    }
  }
  $({ global: true, constructor: true, wrap: true, forced: FORCED_PROMISE_CONSTRUCTOR }, {
    Promise: PromiseConstructor
  });
  PromiseWrapper = path.Promise;
  setToStringTag(PromiseConstructor, PROMISE, false, true);
  setSpecies(PROMISE);
});

// node_modules/core-js/internals/iterators.js
var require_iterators = __commonJS((exports, module) => {
  module.exports = {};
});

// node_modules/core-js/internals/is-array-iterator-method.js
var require_is_array_iterator_method = __commonJS((exports, module) => {
  var wellKnownSymbol = require_well_known_symbol();
  var Iterators = require_iterators();
  var ITERATOR = wellKnownSymbol("iterator");
  var ArrayPrototype = Array.prototype;
  module.exports = function(it) {
    return it !== undefined && (Iterators.Array === it || ArrayPrototype[ITERATOR] === it);
  };
});

// node_modules/core-js/internals/get-iterator-method.js
var require_get_iterator_method = __commonJS((exports, module) => {
  var classof = require_classof();
  var getMethod = require_get_method();
  var isNullOrUndefined = require_is_null_or_undefined();
  var Iterators = require_iterators();
  var wellKnownSymbol = require_well_known_symbol();
  var ITERATOR = wellKnownSymbol("iterator");
  module.exports = function(it) {
    if (!isNullOrUndefined(it))
      return getMethod(it, ITERATOR) || getMethod(it, "@@iterator") || Iterators[classof(it)];
  };
});

// node_modules/core-js/internals/get-iterator.js
var require_get_iterator = __commonJS((exports, module) => {
  var call = require_function_call();
  var aCallable = require_a_callable();
  var anObject = require_an_object();
  var tryToString = require_try_to_string();
  var getIteratorMethod = require_get_iterator_method();
  var $TypeError = TypeError;
  module.exports = function(argument, usingIterator) {
    var iteratorMethod = arguments.length < 2 ? getIteratorMethod(argument) : usingIterator;
    if (aCallable(iteratorMethod))
      return anObject(call(iteratorMethod, argument));
    throw new $TypeError(tryToString(argument) + " is not iterable");
  };
});

// node_modules/core-js/internals/iterator-close.js
var require_iterator_close = __commonJS((exports, module) => {
  var call = require_function_call();
  var anObject = require_an_object();
  var getMethod = require_get_method();
  module.exports = function(iterator, kind, value) {
    var innerResult, innerError;
    anObject(iterator);
    try {
      innerResult = getMethod(iterator, "return");
      if (!innerResult) {
        if (kind === "throw")
          throw value;
        return value;
      }
      innerResult = call(innerResult, iterator);
    } catch (error) {
      innerError = true;
      innerResult = error;
    }
    if (kind === "throw")
      throw value;
    if (innerError)
      throw innerResult;
    anObject(innerResult);
    return value;
  };
});

// node_modules/core-js/internals/iterate.js
var require_iterate = __commonJS((exports, module) => {
  var bind2 = require_function_bind_context();
  var call = require_function_call();
  var anObject = require_an_object();
  var tryToString = require_try_to_string();
  var isArrayIteratorMethod = require_is_array_iterator_method();
  var lengthOfArrayLike = require_length_of_array_like();
  var isPrototypeOf = require_object_is_prototype_of();
  var getIterator = require_get_iterator();
  var getIteratorMethod = require_get_iterator_method();
  var iteratorClose = require_iterator_close();
  var $TypeError = TypeError;
  var Result = function(stopped, result) {
    this.stopped = stopped;
    this.result = result;
  };
  var ResultPrototype = Result.prototype;
  module.exports = function(iterable, unboundFunction, options) {
    var that = options && options.that;
    var AS_ENTRIES = !!(options && options.AS_ENTRIES);
    var IS_RECORD = !!(options && options.IS_RECORD);
    var IS_ITERATOR = !!(options && options.IS_ITERATOR);
    var INTERRUPTED = !!(options && options.INTERRUPTED);
    var fn = bind2(unboundFunction, that);
    var iterator, iterFn, index, length, result, next, step;
    var stop = function(condition) {
      if (iterator)
        iteratorClose(iterator, "normal");
      return new Result(true, condition);
    };
    var callFn = function(value) {
      if (AS_ENTRIES) {
        anObject(value);
        return INTERRUPTED ? fn(value[0], value[1], stop) : fn(value[0], value[1]);
      }
      return INTERRUPTED ? fn(value, stop) : fn(value);
    };
    if (IS_RECORD) {
      iterator = iterable.iterator;
    } else if (IS_ITERATOR) {
      iterator = iterable;
    } else {
      iterFn = getIteratorMethod(iterable);
      if (!iterFn)
        throw new $TypeError(tryToString(iterable) + " is not iterable");
      if (isArrayIteratorMethod(iterFn)) {
        for (index = 0, length = lengthOfArrayLike(iterable);length > index; index++) {
          result = callFn(iterable[index]);
          if (result && isPrototypeOf(ResultPrototype, result))
            return result;
        }
        return new Result(false);
      }
      iterator = getIterator(iterable, iterFn);
    }
    next = IS_RECORD ? iterable.next : iterator.next;
    while (!(step = call(next, iterator)).done) {
      try {
        result = callFn(step.value);
      } catch (error) {
        iteratorClose(iterator, "throw", error);
      }
      if (typeof result == "object" && result && isPrototypeOf(ResultPrototype, result))
        return result;
    }
    return new Result(false);
  };
});

// node_modules/core-js/internals/check-correctness-of-iteration.js
var require_check_correctness_of_iteration = __commonJS((exports, module) => {
  var wellKnownSymbol = require_well_known_symbol();
  var ITERATOR = wellKnownSymbol("iterator");
  var SAFE_CLOSING = false;
  try {
    called = 0;
    iteratorWithReturn = {
      next: function() {
        return { done: !!called++ };
      },
      return: function() {
        SAFE_CLOSING = true;
      }
    };
    iteratorWithReturn[ITERATOR] = function() {
      return this;
    };
    Array.from(iteratorWithReturn, function() {
      throw 2;
    });
  } catch (error) {}
  var called;
  var iteratorWithReturn;
  module.exports = function(exec, SKIP_CLOSING) {
    try {
      if (!SKIP_CLOSING && !SAFE_CLOSING)
        return false;
    } catch (error) {
      return false;
    }
    var ITERATION_SUPPORT = false;
    try {
      var object = {};
      object[ITERATOR] = function() {
        return {
          next: function() {
            return { done: ITERATION_SUPPORT = true };
          }
        };
      };
      exec(object);
    } catch (error) {}
    return ITERATION_SUPPORT;
  };
});

// node_modules/core-js/internals/promise-statics-incorrect-iteration.js
var require_promise_statics_incorrect_iteration = __commonJS((exports, module) => {
  var NativePromiseConstructor = require_promise_native_constructor();
  var checkCorrectnessOfIteration = require_check_correctness_of_iteration();
  var FORCED_PROMISE_CONSTRUCTOR = require_promise_constructor_detection().CONSTRUCTOR;
  module.exports = FORCED_PROMISE_CONSTRUCTOR || !checkCorrectnessOfIteration(function(iterable) {
    NativePromiseConstructor.all(iterable).then(undefined, function() {});
  });
});

// node_modules/core-js/modules/es.promise.all.js
var require_es_promise_all = __commonJS(() => {
  var $ = require_export();
  var call = require_function_call();
  var aCallable = require_a_callable();
  var newPromiseCapabilityModule = require_new_promise_capability();
  var perform = require_perform();
  var iterate = require_iterate();
  var PROMISE_STATICS_INCORRECT_ITERATION = require_promise_statics_incorrect_iteration();
  $({ target: "Promise", stat: true, forced: PROMISE_STATICS_INCORRECT_ITERATION }, {
    all: function all(iterable) {
      var C = this;
      var capability = newPromiseCapabilityModule.f(C);
      var resolve = capability.resolve;
      var reject = capability.reject;
      var result = perform(function() {
        var $promiseResolve = aCallable(C.resolve);
        var values = [];
        var counter = 0;
        var remaining = 1;
        iterate(iterable, function(promise) {
          var index = counter++;
          var alreadyCalled = false;
          remaining++;
          call($promiseResolve, C, promise).then(function(value) {
            if (alreadyCalled)
              return;
            alreadyCalled = true;
            values[index] = value;
            --remaining || resolve(values);
          }, reject);
        });
        --remaining || resolve(values);
      });
      if (result.error)
        reject(result.value);
      return capability.promise;
    }
  });
});

// node_modules/core-js/modules/es.promise.catch.js
var require_es_promise_catch = __commonJS(() => {
  var $ = require_export();
  var IS_PURE = require_is_pure();
  var FORCED_PROMISE_CONSTRUCTOR = require_promise_constructor_detection().CONSTRUCTOR;
  var NativePromiseConstructor = require_promise_native_constructor();
  var getBuiltIn = require_get_built_in();
  var isCallable = require_is_callable();
  var defineBuiltIn = require_define_built_in();
  var NativePromisePrototype = NativePromiseConstructor && NativePromiseConstructor.prototype;
  $({ target: "Promise", proto: true, forced: FORCED_PROMISE_CONSTRUCTOR, real: true }, {
    catch: function(onRejected) {
      return this.then(undefined, onRejected);
    }
  });
  if (!IS_PURE && isCallable(NativePromiseConstructor)) {
    method = getBuiltIn("Promise").prototype["catch"];
    if (NativePromisePrototype["catch"] !== method) {
      defineBuiltIn(NativePromisePrototype, "catch", method, { unsafe: true });
    }
  }
  var method;
});

// node_modules/core-js/modules/es.promise.race.js
var require_es_promise_race = __commonJS(() => {
  var $ = require_export();
  var call = require_function_call();
  var aCallable = require_a_callable();
  var newPromiseCapabilityModule = require_new_promise_capability();
  var perform = require_perform();
  var iterate = require_iterate();
  var PROMISE_STATICS_INCORRECT_ITERATION = require_promise_statics_incorrect_iteration();
  $({ target: "Promise", stat: true, forced: PROMISE_STATICS_INCORRECT_ITERATION }, {
    race: function race(iterable) {
      var C = this;
      var capability = newPromiseCapabilityModule.f(C);
      var reject = capability.reject;
      var result = perform(function() {
        var $promiseResolve = aCallable(C.resolve);
        iterate(iterable, function(promise) {
          call($promiseResolve, C, promise).then(capability.resolve, reject);
        });
      });
      if (result.error)
        reject(result.value);
      return capability.promise;
    }
  });
});

// node_modules/core-js/modules/es.promise.reject.js
var require_es_promise_reject = __commonJS(() => {
  var $ = require_export();
  var newPromiseCapabilityModule = require_new_promise_capability();
  var FORCED_PROMISE_CONSTRUCTOR = require_promise_constructor_detection().CONSTRUCTOR;
  $({ target: "Promise", stat: true, forced: FORCED_PROMISE_CONSTRUCTOR }, {
    reject: function reject(r) {
      var capability = newPromiseCapabilityModule.f(this);
      var capabilityReject = capability.reject;
      capabilityReject(r);
      return capability.promise;
    }
  });
});

// node_modules/core-js/internals/promise-resolve.js
var require_promise_resolve = __commonJS((exports, module) => {
  var anObject = require_an_object();
  var isObject = require_is_object();
  var newPromiseCapability = require_new_promise_capability();
  module.exports = function(C, x2) {
    anObject(C);
    if (isObject(x2) && x2.constructor === C)
      return x2;
    var promiseCapability = newPromiseCapability.f(C);
    var resolve = promiseCapability.resolve;
    resolve(x2);
    return promiseCapability.promise;
  };
});

// node_modules/core-js/modules/es.promise.resolve.js
var require_es_promise_resolve = __commonJS(() => {
  var $ = require_export();
  var getBuiltIn = require_get_built_in();
  var IS_PURE = require_is_pure();
  var NativePromiseConstructor = require_promise_native_constructor();
  var FORCED_PROMISE_CONSTRUCTOR = require_promise_constructor_detection().CONSTRUCTOR;
  var promiseResolve = require_promise_resolve();
  var PromiseConstructorWrapper = getBuiltIn("Promise");
  var CHECK_WRAPPER = IS_PURE && !FORCED_PROMISE_CONSTRUCTOR;
  $({ target: "Promise", stat: true, forced: IS_PURE || FORCED_PROMISE_CONSTRUCTOR }, {
    resolve: function resolve(x2) {
      return promiseResolve(CHECK_WRAPPER && this === PromiseConstructorWrapper ? NativePromiseConstructor : this, x2);
    }
  });
});

// node_modules/core-js/modules/es.promise.js
var require_es_promise = __commonJS(() => {
  require_es_promise_constructor();
  require_es_promise_all();
  require_es_promise_catch();
  require_es_promise_race();
  require_es_promise_reject();
  require_es_promise_resolve();
});

// node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js
function asyncGeneratorStep(n, t, e, r, o, a, c) {
  try {
    var i3 = n[a](c), u = i3.value;
  } catch (n2) {
    return void e(n2);
  }
  i3.done ? t(u) : Promise.resolve(u).then(r, o);
}
function _asyncToGenerator(n) {
  return function() {
    var t = this, e = arguments;
    return new Promise(function(r, o) {
      var a = n.apply(t, e);
      function _next(n2) {
        asyncGeneratorStep(a, r, o, _next, _throw, "next", n2);
      }
      function _throw(n2) {
        asyncGeneratorStep(a, r, o, _next, _throw, "throw", n2);
      }
      _next(undefined);
    });
  };
}
var init_asyncToGenerator = () => {};

// node_modules/core-js/internals/to-string.js
var require_to_string = __commonJS((exports, module) => {
  var classof = require_classof();
  var $String = String;
  module.exports = function(argument) {
    if (classof(argument) === "Symbol")
      throw new TypeError("Cannot convert a Symbol value to a string");
    return $String(argument);
  };
});

// node_modules/core-js/internals/regexp-flags.js
var require_regexp_flags = __commonJS((exports, module) => {
  var anObject = require_an_object();
  module.exports = function() {
    var that = anObject(this);
    var result = "";
    if (that.hasIndices)
      result += "d";
    if (that.global)
      result += "g";
    if (that.ignoreCase)
      result += "i";
    if (that.multiline)
      result += "m";
    if (that.dotAll)
      result += "s";
    if (that.unicode)
      result += "u";
    if (that.unicodeSets)
      result += "v";
    if (that.sticky)
      result += "y";
    return result;
  };
});

// node_modules/core-js/internals/regexp-sticky-helpers.js
var require_regexp_sticky_helpers = __commonJS((exports, module) => {
  var fails = require_fails();
  var globalThis2 = require_global_this();
  var $RegExp = globalThis2.RegExp;
  var UNSUPPORTED_Y = fails(function() {
    var re = $RegExp("a", "y");
    re.lastIndex = 2;
    return re.exec("abcd") !== null;
  });
  var MISSED_STICKY = UNSUPPORTED_Y || fails(function() {
    return !$RegExp("a", "y").sticky;
  });
  var BROKEN_CARET = UNSUPPORTED_Y || fails(function() {
    var re = $RegExp("^r", "gy");
    re.lastIndex = 2;
    return re.exec("str") !== null;
  });
  module.exports = {
    BROKEN_CARET,
    MISSED_STICKY,
    UNSUPPORTED_Y
  };
});

// node_modules/core-js/internals/object-keys.js
var require_object_keys = __commonJS((exports, module) => {
  var internalObjectKeys = require_object_keys_internal();
  var enumBugKeys = require_enum_bug_keys();
  module.exports = Object.keys || function keys(O) {
    return internalObjectKeys(O, enumBugKeys);
  };
});

// node_modules/core-js/internals/object-define-properties.js
var require_object_define_properties = __commonJS((exports) => {
  var DESCRIPTORS = require_descriptors();
  var V8_PROTOTYPE_DEFINE_BUG = require_v8_prototype_define_bug();
  var definePropertyModule = require_object_define_property();
  var anObject = require_an_object();
  var toIndexedObject = require_to_indexed_object();
  var objectKeys = require_object_keys();
  exports.f = DESCRIPTORS && !V8_PROTOTYPE_DEFINE_BUG ? Object.defineProperties : function defineProperties(O, Properties) {
    anObject(O);
    var props = toIndexedObject(Properties);
    var keys2 = objectKeys(Properties);
    var length = keys2.length;
    var index = 0;
    var key;
    while (length > index)
      definePropertyModule.f(O, key = keys2[index++], props[key]);
    return O;
  };
});

// node_modules/core-js/internals/object-create.js
var require_object_create = __commonJS((exports, module) => {
  var anObject = require_an_object();
  var definePropertiesModule = require_object_define_properties();
  var enumBugKeys = require_enum_bug_keys();
  var hiddenKeys = require_hidden_keys();
  var html = require_html();
  var documentCreateElement = require_document_create_element();
  var sharedKey = require_shared_key();
  var GT = ">";
  var LT = "<";
  var PROTOTYPE = "prototype";
  var SCRIPT = "script";
  var IE_PROTO = sharedKey("IE_PROTO");
  var EmptyConstructor = function() {};
  var scriptTag = function(content) {
    return LT + SCRIPT + GT + content + LT + "/" + SCRIPT + GT;
  };
  var NullProtoObjectViaActiveX = function(activeXDocument2) {
    activeXDocument2.write(scriptTag(""));
    activeXDocument2.close();
    var temp = activeXDocument2.parentWindow.Object;
    activeXDocument2 = null;
    return temp;
  };
  var NullProtoObjectViaIFrame = function() {
    var iframe = documentCreateElement("iframe");
    var JS = "java" + SCRIPT + ":";
    var iframeDocument;
    iframe.style.display = "none";
    html.appendChild(iframe);
    iframe.src = String(JS);
    iframeDocument = iframe.contentWindow.document;
    iframeDocument.open();
    iframeDocument.write(scriptTag("document.F=Object"));
    iframeDocument.close();
    return iframeDocument.F;
  };
  var activeXDocument;
  var NullProtoObject = function() {
    try {
      activeXDocument = new ActiveXObject("htmlfile");
    } catch (error) {}
    NullProtoObject = typeof document != "undefined" ? document.domain && activeXDocument ? NullProtoObjectViaActiveX(activeXDocument) : NullProtoObjectViaIFrame() : NullProtoObjectViaActiveX(activeXDocument);
    var length = enumBugKeys.length;
    while (length--)
      delete NullProtoObject[PROTOTYPE][enumBugKeys[length]];
    return NullProtoObject();
  };
  hiddenKeys[IE_PROTO] = true;
  module.exports = Object.create || function create(O, Properties) {
    var result;
    if (O !== null) {
      EmptyConstructor[PROTOTYPE] = anObject(O);
      result = new EmptyConstructor;
      EmptyConstructor[PROTOTYPE] = null;
      result[IE_PROTO] = O;
    } else
      result = NullProtoObject();
    return Properties === undefined ? result : definePropertiesModule.f(result, Properties);
  };
});

// node_modules/core-js/internals/regexp-unsupported-dot-all.js
var require_regexp_unsupported_dot_all = __commonJS((exports, module) => {
  var fails = require_fails();
  var globalThis2 = require_global_this();
  var $RegExp = globalThis2.RegExp;
  module.exports = fails(function() {
    var re = $RegExp(".", "s");
    return !(re.dotAll && re.test(`
`) && re.flags === "s");
  });
});

// node_modules/core-js/internals/regexp-unsupported-ncg.js
var require_regexp_unsupported_ncg = __commonJS((exports, module) => {
  var fails = require_fails();
  var globalThis2 = require_global_this();
  var $RegExp = globalThis2.RegExp;
  module.exports = fails(function() {
    var re = $RegExp("(?<a>b)", "g");
    return re.exec("b").groups.a !== "b" || "b".replace(re, "$<a>c") !== "bc";
  });
});

// node_modules/core-js/internals/regexp-exec.js
var require_regexp_exec = __commonJS((exports, module) => {
  var call = require_function_call();
  var uncurryThis = require_function_uncurry_this();
  var toString = require_to_string();
  var regexpFlags = require_regexp_flags();
  var stickyHelpers = require_regexp_sticky_helpers();
  var shared = require_shared();
  var create = require_object_create();
  var getInternalState = require_internal_state().get;
  var UNSUPPORTED_DOT_ALL = require_regexp_unsupported_dot_all();
  var UNSUPPORTED_NCG = require_regexp_unsupported_ncg();
  var nativeReplace = shared("native-string-replace", String.prototype.replace);
  var nativeExec = RegExp.prototype.exec;
  var patchedExec = nativeExec;
  var charAt = uncurryThis("".charAt);
  var indexOf = uncurryThis("".indexOf);
  var replace2 = uncurryThis("".replace);
  var stringSlice = uncurryThis("".slice);
  var UPDATES_LAST_INDEX_WRONG = function() {
    var re1 = /a/;
    var re2 = /b*/g;
    call(nativeExec, re1, "a");
    call(nativeExec, re2, "a");
    return re1.lastIndex !== 0 || re2.lastIndex !== 0;
  }();
  var UNSUPPORTED_Y = stickyHelpers.BROKEN_CARET;
  var NPCG_INCLUDED = /()??/.exec("")[1] !== undefined;
  var PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED || UNSUPPORTED_Y || UNSUPPORTED_DOT_ALL || UNSUPPORTED_NCG;
  if (PATCH) {
    patchedExec = function exec(string) {
      var re = this;
      var state = getInternalState(re);
      var str = toString(string);
      var raw = state.raw;
      var result, reCopy, lastIndex, match, i3, object, group;
      if (raw) {
        raw.lastIndex = re.lastIndex;
        result = call(patchedExec, raw, str);
        re.lastIndex = raw.lastIndex;
        return result;
      }
      var groups = state.groups;
      var sticky = UNSUPPORTED_Y && re.sticky;
      var flags = call(regexpFlags, re);
      var source = re.source;
      var charsAdded = 0;
      var strCopy = str;
      if (sticky) {
        flags = replace2(flags, "y", "");
        if (indexOf(flags, "g") === -1) {
          flags += "g";
        }
        strCopy = stringSlice(str, re.lastIndex);
        if (re.lastIndex > 0 && (!re.multiline || re.multiline && charAt(str, re.lastIndex - 1) !== `
`)) {
          source = "(?: " + source + ")";
          strCopy = " " + strCopy;
          charsAdded++;
        }
        reCopy = new RegExp("^(?:" + source + ")", flags);
      }
      if (NPCG_INCLUDED) {
        reCopy = new RegExp("^" + source + "$(?!\\s)", flags);
      }
      if (UPDATES_LAST_INDEX_WRONG)
        lastIndex = re.lastIndex;
      match = call(nativeExec, sticky ? reCopy : re, strCopy);
      if (sticky) {
        if (match) {
          match.input = stringSlice(match.input, charsAdded);
          match[0] = stringSlice(match[0], charsAdded);
          match.index = re.lastIndex;
          re.lastIndex += match[0].length;
        } else
          re.lastIndex = 0;
      } else if (UPDATES_LAST_INDEX_WRONG && match) {
        re.lastIndex = re.global ? match.index + match[0].length : lastIndex;
      }
      if (NPCG_INCLUDED && match && match.length > 1) {
        call(nativeReplace, match[0], reCopy, function() {
          for (i3 = 1;i3 < arguments.length - 2; i3++) {
            if (arguments[i3] === undefined)
              match[i3] = undefined;
          }
        });
      }
      if (match && groups) {
        match.groups = object = create(null);
        for (i3 = 0;i3 < groups.length; i3++) {
          group = groups[i3];
          object[group[0]] = match[group[1]];
        }
      }
      return match;
    };
  }
  module.exports = patchedExec;
});

// node_modules/core-js/modules/es.regexp.exec.js
var require_es_regexp_exec = __commonJS(() => {
  var $ = require_export();
  var exec = require_regexp_exec();
  $({ target: "RegExp", proto: true, forced: /./.exec !== exec }, {
    exec
  });
});

// node_modules/core-js/internals/fix-regexp-well-known-symbol-logic.js
var require_fix_regexp_well_known_symbol_logic = __commonJS((exports, module) => {
  require_es_regexp_exec();
  var call = require_function_call();
  var defineBuiltIn = require_define_built_in();
  var regexpExec = require_regexp_exec();
  var fails = require_fails();
  var wellKnownSymbol = require_well_known_symbol();
  var createNonEnumerableProperty = require_create_non_enumerable_property();
  var SPECIES = wellKnownSymbol("species");
  var RegExpPrototype = RegExp.prototype;
  module.exports = function(KEY, exec, FORCED, SHAM) {
    var SYMBOL = wellKnownSymbol(KEY);
    var DELEGATES_TO_SYMBOL = !fails(function() {
      var O = {};
      O[SYMBOL] = function() {
        return 7;
      };
      return ""[KEY](O) !== 7;
    });
    var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL && !fails(function() {
      var execCalled = false;
      var re = /a/;
      if (KEY === "split") {
        var constructor = {};
        constructor[SPECIES] = function() {
          return re;
        };
        re = { constructor, flags: "" };
        re[SYMBOL] = /./[SYMBOL];
      }
      re.exec = function() {
        execCalled = true;
        return null;
      };
      re[SYMBOL]("");
      return !execCalled;
    });
    if (!DELEGATES_TO_SYMBOL || !DELEGATES_TO_EXEC || FORCED) {
      var nativeRegExpMethod = /./[SYMBOL];
      var methods = exec(SYMBOL, ""[KEY], function(nativeMethod, regexp, str, arg2, forceStringMethod) {
        var $exec = regexp.exec;
        if ($exec === regexpExec || $exec === RegExpPrototype.exec) {
          if (DELEGATES_TO_SYMBOL && !forceStringMethod) {
            return { done: true, value: call(nativeRegExpMethod, regexp, str, arg2) };
          }
          return { done: true, value: call(nativeMethod, str, regexp, arg2) };
        }
        return { done: false };
      });
      defineBuiltIn(String.prototype, KEY, methods[0]);
      defineBuiltIn(RegExpPrototype, SYMBOL, methods[1]);
    }
    if (SHAM)
      createNonEnumerableProperty(RegExpPrototype[SYMBOL], "sham", true);
  };
});

// node_modules/core-js/internals/string-multibyte.js
var require_string_multibyte = __commonJS((exports, module) => {
  var uncurryThis = require_function_uncurry_this();
  var toIntegerOrInfinity = require_to_integer_or_infinity();
  var toString = require_to_string();
  var requireObjectCoercible = require_require_object_coercible();
  var charAt = uncurryThis("".charAt);
  var charCodeAt = uncurryThis("".charCodeAt);
  var stringSlice = uncurryThis("".slice);
  var createMethod = function(CONVERT_TO_STRING) {
    return function($this, pos) {
      var S = toString(requireObjectCoercible($this));
      var position = toIntegerOrInfinity(pos);
      var size = S.length;
      var first2, second;
      if (position < 0 || position >= size)
        return CONVERT_TO_STRING ? "" : undefined;
      first2 = charCodeAt(S, position);
      return first2 < 55296 || first2 > 56319 || position + 1 === size || (second = charCodeAt(S, position + 1)) < 56320 || second > 57343 ? CONVERT_TO_STRING ? charAt(S, position) : first2 : CONVERT_TO_STRING ? stringSlice(S, position, position + 2) : (first2 - 55296 << 10) + (second - 56320) + 65536;
    };
  };
  module.exports = {
    codeAt: createMethod(false),
    charAt: createMethod(true)
  };
});

// node_modules/core-js/internals/advance-string-index.js
var require_advance_string_index = __commonJS((exports, module) => {
  var charAt = require_string_multibyte().charAt;
  module.exports = function(S, index, unicode) {
    return index + (unicode ? charAt(S, index).length : 1);
  };
});

// node_modules/core-js/internals/regexp-flags-detection.js
var require_regexp_flags_detection = __commonJS((exports, module) => {
  var globalThis2 = require_global_this();
  var fails = require_fails();
  var RegExp2 = globalThis2.RegExp;
  var FLAGS_GETTER_IS_CORRECT = !fails(function() {
    var INDICES_SUPPORT = true;
    try {
      RegExp2(".", "d");
    } catch (error) {
      INDICES_SUPPORT = false;
    }
    var O = {};
    var calls = "";
    var expected = INDICES_SUPPORT ? "dgimsy" : "gimsy";
    var addGetter = function(key2, chr) {
      Object.defineProperty(O, key2, { get: function() {
        calls += chr;
        return true;
      } });
    };
    var pairs = {
      dotAll: "s",
      global: "g",
      ignoreCase: "i",
      multiline: "m",
      sticky: "y"
    };
    if (INDICES_SUPPORT)
      pairs.hasIndices = "d";
    for (var key in pairs)
      addGetter(key, pairs[key]);
    var result = Object.getOwnPropertyDescriptor(RegExp2.prototype, "flags").get.call(O);
    return result !== expected || calls !== expected;
  });
  module.exports = { correct: FLAGS_GETTER_IS_CORRECT };
});

// node_modules/core-js/internals/regexp-get-flags.js
var require_regexp_get_flags = __commonJS((exports, module) => {
  var call = require_function_call();
  var hasOwn = require_has_own_property();
  var isPrototypeOf = require_object_is_prototype_of();
  var regExpFlagsDetection = require_regexp_flags_detection();
  var regExpFlagsGetterImplementation = require_regexp_flags();
  var RegExpPrototype = RegExp.prototype;
  module.exports = regExpFlagsDetection.correct ? function(it) {
    return it.flags;
  } : function(it) {
    return !regExpFlagsDetection.correct && isPrototypeOf(RegExpPrototype, it) && !hasOwn(it, "flags") ? call(regExpFlagsGetterImplementation, it) : it.flags;
  };
});

// node_modules/core-js/internals/regexp-exec-abstract.js
var require_regexp_exec_abstract = __commonJS((exports, module) => {
  var call = require_function_call();
  var anObject = require_an_object();
  var isCallable = require_is_callable();
  var classof = require_classof_raw();
  var regexpExec = require_regexp_exec();
  var $TypeError = TypeError;
  module.exports = function(R, S) {
    var exec = R.exec;
    if (isCallable(exec)) {
      var result = call(exec, R, S);
      if (result !== null)
        anObject(result);
      return result;
    }
    if (classof(R) === "RegExp")
      return call(regexpExec, R, S);
    throw new $TypeError("RegExp#exec called on incompatible receiver");
  };
});

// node_modules/core-js/modules/es.string.match.js
var require_es_string_match = __commonJS(() => {
  var call = require_function_call();
  var uncurryThis = require_function_uncurry_this();
  var fixRegExpWellKnownSymbolLogic = require_fix_regexp_well_known_symbol_logic();
  var anObject = require_an_object();
  var isObject = require_is_object();
  var toLength = require_to_length();
  var toString = require_to_string();
  var requireObjectCoercible = require_require_object_coercible();
  var getMethod = require_get_method();
  var advanceStringIndex = require_advance_string_index();
  var getRegExpFlags = require_regexp_get_flags();
  var regExpExec = require_regexp_exec_abstract();
  var stringIndexOf = uncurryThis("".indexOf);
  fixRegExpWellKnownSymbolLogic("match", function(MATCH, nativeMatch, maybeCallNative) {
    return [
      function match(regexp) {
        var O = requireObjectCoercible(this);
        var matcher = isObject(regexp) ? getMethod(regexp, MATCH) : undefined;
        return matcher ? call(matcher, regexp, O) : new RegExp(regexp)[MATCH](toString(O));
      },
      function(string) {
        var rx = anObject(this);
        var S = toString(string);
        var res = maybeCallNative(nativeMatch, rx, S);
        if (res.done)
          return res.value;
        var flags = toString(getRegExpFlags(rx));
        if (stringIndexOf(flags, "g") === -1)
          return regExpExec(rx, S);
        var fullUnicode = stringIndexOf(flags, "u") !== -1;
        rx.lastIndex = 0;
        var A = [];
        var n = 0;
        var result;
        while ((result = regExpExec(rx, S)) !== null) {
          var matchStr = toString(result[0]);
          A[n] = matchStr;
          if (matchStr === "")
            rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
          n++;
        }
        return n === 0 ? null : A;
      }
    ];
  });
});

// node_modules/core-js/internals/get-substitution.js
var require_get_substitution = __commonJS((exports, module) => {
  var uncurryThis = require_function_uncurry_this();
  var toObject = require_to_object();
  var floor = Math.floor;
  var charAt = uncurryThis("".charAt);
  var replace2 = uncurryThis("".replace);
  var stringSlice = uncurryThis("".slice);
  var SUBSTITUTION_SYMBOLS = /\$([$&'`]|\d{1,2}|<[^>]*>)/g;
  var SUBSTITUTION_SYMBOLS_NO_NAMED = /\$([$&'`]|\d{1,2})/g;
  module.exports = function(matched, str, position, captures, namedCaptures, replacement) {
    var tailPos = position + matched.length;
    var m = captures.length;
    var symbols = SUBSTITUTION_SYMBOLS_NO_NAMED;
    if (namedCaptures !== undefined) {
      namedCaptures = toObject(namedCaptures);
      symbols = SUBSTITUTION_SYMBOLS;
    }
    return replace2(replacement, symbols, function(match, ch) {
      var capture;
      switch (charAt(ch, 0)) {
        case "$":
          return "$";
        case "&":
          return matched;
        case "`":
          return stringSlice(str, 0, position);
        case "'":
          return stringSlice(str, tailPos);
        case "<":
          capture = namedCaptures[stringSlice(ch, 1, -1)];
          break;
        default:
          var n = +ch;
          if (n === 0)
            return match;
          if (n > m) {
            var f = floor(n / 10);
            if (f === 0)
              return match;
            if (f <= m)
              return captures[f - 1] === undefined ? charAt(ch, 1) : captures[f - 1] + charAt(ch, 1);
            return match;
          }
          capture = captures[n - 1];
      }
      return capture === undefined ? "" : capture;
    });
  };
});

// node_modules/core-js/modules/es.string.replace.js
var require_es_string_replace = __commonJS(() => {
  var apply2 = require_function_apply();
  var call = require_function_call();
  var uncurryThis = require_function_uncurry_this();
  var fixRegExpWellKnownSymbolLogic = require_fix_regexp_well_known_symbol_logic();
  var fails = require_fails();
  var anObject = require_an_object();
  var isCallable = require_is_callable();
  var isObject = require_is_object();
  var toIntegerOrInfinity = require_to_integer_or_infinity();
  var toLength = require_to_length();
  var toString = require_to_string();
  var requireObjectCoercible = require_require_object_coercible();
  var advanceStringIndex = require_advance_string_index();
  var getMethod = require_get_method();
  var getSubstitution = require_get_substitution();
  var getRegExpFlags = require_regexp_get_flags();
  var regExpExec = require_regexp_exec_abstract();
  var wellKnownSymbol = require_well_known_symbol();
  var REPLACE = wellKnownSymbol("replace");
  var max2 = Math.max;
  var min = Math.min;
  var concat = uncurryThis([].concat);
  var push = uncurryThis([].push);
  var stringIndexOf = uncurryThis("".indexOf);
  var stringSlice = uncurryThis("".slice);
  var maybeToString = function(it) {
    return it === undefined ? it : String(it);
  };
  var REPLACE_KEEPS_$0 = function() {
    return "a".replace(/./, "$0") === "$0";
  }();
  var REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE = function() {
    if (/./[REPLACE]) {
      return /./[REPLACE]("a", "$0") === "";
    }
    return false;
  }();
  var REPLACE_SUPPORTS_NAMED_GROUPS = !fails(function() {
    var re = /./;
    re.exec = function() {
      var result = [];
      result.groups = { a: "7" };
      return result;
    };
    return "".replace(re, "$<a>") !== "7";
  });
  fixRegExpWellKnownSymbolLogic("replace", function(_, nativeReplace, maybeCallNative) {
    var UNSAFE_SUBSTITUTE = REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE ? "$" : "$0";
    return [
      function replace(searchValue, replaceValue) {
        var O = requireObjectCoercible(this);
        var replacer = isObject(searchValue) ? getMethod(searchValue, REPLACE) : undefined;
        return replacer ? call(replacer, searchValue, O, replaceValue) : call(nativeReplace, toString(O), searchValue, replaceValue);
      },
      function(string, replaceValue) {
        var rx = anObject(this);
        var S = toString(string);
        if (typeof replaceValue == "string" && stringIndexOf(replaceValue, UNSAFE_SUBSTITUTE) === -1 && stringIndexOf(replaceValue, "$<") === -1) {
          var res = maybeCallNative(nativeReplace, rx, S, replaceValue);
          if (res.done)
            return res.value;
        }
        var functionalReplace = isCallable(replaceValue);
        if (!functionalReplace)
          replaceValue = toString(replaceValue);
        var flags = toString(getRegExpFlags(rx));
        var global2 = stringIndexOf(flags, "g") !== -1;
        var fullUnicode;
        if (global2) {
          fullUnicode = stringIndexOf(flags, "u") !== -1;
          rx.lastIndex = 0;
        }
        var results = [];
        var result;
        while (true) {
          result = regExpExec(rx, S);
          if (result === null)
            break;
          push(results, result);
          if (!global2)
            break;
          var matchStr = toString(result[0]);
          if (matchStr === "")
            rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
        }
        var accumulatedResult = "";
        var nextSourcePosition = 0;
        for (var i3 = 0;i3 < results.length; i3++) {
          result = results[i3];
          var matched = toString(result[0]);
          var position = max2(min(toIntegerOrInfinity(result.index), S.length), 0);
          var captures = [];
          var replacement;
          for (var j = 1;j < result.length; j++)
            push(captures, maybeToString(result[j]));
          var namedCaptures = result.groups;
          if (functionalReplace) {
            var replacerArgs = concat([matched], captures, position, S);
            if (namedCaptures !== undefined)
              push(replacerArgs, namedCaptures);
            replacement = toString(apply2(replaceValue, undefined, replacerArgs));
          } else {
            replacement = getSubstitution(matched, S, position, captures, namedCaptures, replaceValue);
          }
          if (position >= nextSourcePosition) {
            accumulatedResult += stringSlice(S, nextSourcePosition, position) + replacement;
            nextSourcePosition = position + matched.length;
          }
        }
        return accumulatedResult + stringSlice(S, nextSourcePosition);
      }
    ];
  }, !REPLACE_SUPPORTS_NAMED_GROUPS || !REPLACE_KEEPS_$0 || REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE);
});

// node_modules/core-js/internals/is-regexp.js
var require_is_regexp = __commonJS((exports, module) => {
  var isObject = require_is_object();
  var classof = require_classof_raw();
  var wellKnownSymbol = require_well_known_symbol();
  var MATCH = wellKnownSymbol("match");
  module.exports = function(it) {
    var isRegExp2;
    return isObject(it) && ((isRegExp2 = it[MATCH]) !== undefined ? !!isRegExp2 : classof(it) === "RegExp");
  };
});

// node_modules/core-js/internals/not-a-regexp.js
var require_not_a_regexp = __commonJS((exports, module) => {
  var isRegExp2 = require_is_regexp();
  var $TypeError = TypeError;
  module.exports = function(it) {
    if (isRegExp2(it)) {
      throw new $TypeError("The method doesn't accept regular expressions");
    }
    return it;
  };
});

// node_modules/core-js/internals/correct-is-regexp-logic.js
var require_correct_is_regexp_logic = __commonJS((exports, module) => {
  var wellKnownSymbol = require_well_known_symbol();
  var MATCH = wellKnownSymbol("match");
  module.exports = function(METHOD_NAME) {
    var regexp = /./;
    try {
      "/./"[METHOD_NAME](regexp);
    } catch (error1) {
      try {
        regexp[MATCH] = false;
        return "/./"[METHOD_NAME](regexp);
      } catch (error2) {}
    }
    return false;
  };
});

// node_modules/core-js/modules/es.string.starts-with.js
var require_es_string_starts_with = __commonJS(() => {
  var $ = require_export();
  var uncurryThis = require_function_uncurry_this_clause();
  var getOwnPropertyDescriptor = require_object_get_own_property_descriptor().f;
  var toLength = require_to_length();
  var toString = require_to_string();
  var notARegExp = require_not_a_regexp();
  var requireObjectCoercible = require_require_object_coercible();
  var correctIsRegExpLogic = require_correct_is_regexp_logic();
  var IS_PURE = require_is_pure();
  var stringSlice = uncurryThis("".slice);
  var min = Math.min;
  var CORRECT_IS_REGEXP_LOGIC = correctIsRegExpLogic("startsWith");
  var MDN_POLYFILL_BUG = !IS_PURE && !CORRECT_IS_REGEXP_LOGIC && !!function() {
    var descriptor = getOwnPropertyDescriptor(String.prototype, "startsWith");
    return descriptor && !descriptor.writable;
  }();
  $({ target: "String", proto: true, forced: !MDN_POLYFILL_BUG && !CORRECT_IS_REGEXP_LOGIC }, {
    startsWith: function startsWith(searchString) {
      var that = toString(requireObjectCoercible(this));
      notARegExp(searchString);
      var index = toLength(min(arguments.length > 1 ? arguments[1] : undefined, that.length));
      var search = toString(searchString);
      return stringSlice(that, index, index + search.length) === search;
    }
  });
});

// node_modules/core-js/internals/add-to-unscopables.js
var require_add_to_unscopables = __commonJS((exports, module) => {
  var wellKnownSymbol = require_well_known_symbol();
  var create = require_object_create();
  var defineProperty = require_object_define_property().f;
  var UNSCOPABLES = wellKnownSymbol("unscopables");
  var ArrayPrototype = Array.prototype;
  if (ArrayPrototype[UNSCOPABLES] === undefined) {
    defineProperty(ArrayPrototype, UNSCOPABLES, {
      configurable: true,
      value: create(null)
    });
  }
  module.exports = function(key) {
    ArrayPrototype[UNSCOPABLES][key] = true;
  };
});

// node_modules/core-js/internals/correct-prototype-getter.js
var require_correct_prototype_getter = __commonJS((exports, module) => {
  var fails = require_fails();
  module.exports = !fails(function() {
    function F() {}
    F.prototype.constructor = null;
    return Object.getPrototypeOf(new F) !== F.prototype;
  });
});

// node_modules/core-js/internals/object-get-prototype-of.js
var require_object_get_prototype_of = __commonJS((exports, module) => {
  var hasOwn = require_has_own_property();
  var isCallable = require_is_callable();
  var toObject = require_to_object();
  var sharedKey = require_shared_key();
  var CORRECT_PROTOTYPE_GETTER = require_correct_prototype_getter();
  var IE_PROTO = sharedKey("IE_PROTO");
  var $Object = Object;
  var ObjectPrototype = $Object.prototype;
  module.exports = CORRECT_PROTOTYPE_GETTER ? $Object.getPrototypeOf : function(O) {
    var object = toObject(O);
    if (hasOwn(object, IE_PROTO))
      return object[IE_PROTO];
    var constructor = object.constructor;
    if (isCallable(constructor) && object instanceof constructor) {
      return constructor.prototype;
    }
    return object instanceof $Object ? ObjectPrototype : null;
  };
});

// node_modules/core-js/internals/iterators-core.js
var require_iterators_core = __commonJS((exports, module) => {
  var fails = require_fails();
  var isCallable = require_is_callable();
  var isObject = require_is_object();
  var create = require_object_create();
  var getPrototypeOf = require_object_get_prototype_of();
  var defineBuiltIn = require_define_built_in();
  var wellKnownSymbol = require_well_known_symbol();
  var IS_PURE = require_is_pure();
  var ITERATOR = wellKnownSymbol("iterator");
  var BUGGY_SAFARI_ITERATORS = false;
  var IteratorPrototype;
  var PrototypeOfArrayIteratorPrototype;
  var arrayIterator;
  if ([].keys) {
    arrayIterator = [].keys();
    if (!("next" in arrayIterator))
      BUGGY_SAFARI_ITERATORS = true;
    else {
      PrototypeOfArrayIteratorPrototype = getPrototypeOf(getPrototypeOf(arrayIterator));
      if (PrototypeOfArrayIteratorPrototype !== Object.prototype)
        IteratorPrototype = PrototypeOfArrayIteratorPrototype;
    }
  }
  var NEW_ITERATOR_PROTOTYPE = !isObject(IteratorPrototype) || fails(function() {
    var test = {};
    return IteratorPrototype[ITERATOR].call(test) !== test;
  });
  if (NEW_ITERATOR_PROTOTYPE)
    IteratorPrototype = {};
  else if (IS_PURE)
    IteratorPrototype = create(IteratorPrototype);
  if (!isCallable(IteratorPrototype[ITERATOR])) {
    defineBuiltIn(IteratorPrototype, ITERATOR, function() {
      return this;
    });
  }
  module.exports = {
    IteratorPrototype,
    BUGGY_SAFARI_ITERATORS
  };
});

// node_modules/core-js/internals/iterator-create-constructor.js
var require_iterator_create_constructor = __commonJS((exports, module) => {
  var IteratorPrototype = require_iterators_core().IteratorPrototype;
  var create = require_object_create();
  var createPropertyDescriptor = require_create_property_descriptor();
  var setToStringTag = require_set_to_string_tag();
  var Iterators = require_iterators();
  var returnThis = function() {
    return this;
  };
  module.exports = function(IteratorConstructor, NAME, next, ENUMERABLE_NEXT) {
    var TO_STRING_TAG = NAME + " Iterator";
    IteratorConstructor.prototype = create(IteratorPrototype, { next: createPropertyDescriptor(+!ENUMERABLE_NEXT, next) });
    setToStringTag(IteratorConstructor, TO_STRING_TAG, false, true);
    Iterators[TO_STRING_TAG] = returnThis;
    return IteratorConstructor;
  };
});

// node_modules/core-js/internals/iterator-define.js
var require_iterator_define = __commonJS((exports, module) => {
  var $ = require_export();
  var call = require_function_call();
  var IS_PURE = require_is_pure();
  var FunctionName = require_function_name();
  var isCallable = require_is_callable();
  var createIteratorConstructor = require_iterator_create_constructor();
  var getPrototypeOf = require_object_get_prototype_of();
  var setPrototypeOf = require_object_set_prototype_of();
  var setToStringTag = require_set_to_string_tag();
  var createNonEnumerableProperty = require_create_non_enumerable_property();
  var defineBuiltIn = require_define_built_in();
  var wellKnownSymbol = require_well_known_symbol();
  var Iterators = require_iterators();
  var IteratorsCore = require_iterators_core();
  var PROPER_FUNCTION_NAME = FunctionName.PROPER;
  var CONFIGURABLE_FUNCTION_NAME = FunctionName.CONFIGURABLE;
  var IteratorPrototype = IteratorsCore.IteratorPrototype;
  var BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;
  var ITERATOR = wellKnownSymbol("iterator");
  var KEYS = "keys";
  var VALUES = "values";
  var ENTRIES = "entries";
  var returnThis = function() {
    return this;
  };
  module.exports = function(Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {
    createIteratorConstructor(IteratorConstructor, NAME, next);
    var getIterationMethod = function(KIND) {
      if (KIND === DEFAULT && defaultIterator)
        return defaultIterator;
      if (!BUGGY_SAFARI_ITERATORS && KIND && KIND in IterablePrototype)
        return IterablePrototype[KIND];
      switch (KIND) {
        case KEYS:
          return function keys() {
            return new IteratorConstructor(this, KIND);
          };
        case VALUES:
          return function values() {
            return new IteratorConstructor(this, KIND);
          };
        case ENTRIES:
          return function entries() {
            return new IteratorConstructor(this, KIND);
          };
      }
      return function() {
        return new IteratorConstructor(this);
      };
    };
    var TO_STRING_TAG = NAME + " Iterator";
    var INCORRECT_VALUES_NAME = false;
    var IterablePrototype = Iterable.prototype;
    var nativeIterator = IterablePrototype[ITERATOR] || IterablePrototype["@@iterator"] || DEFAULT && IterablePrototype[DEFAULT];
    var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT);
    var anyNativeIterator = NAME === "Array" ? IterablePrototype.entries || nativeIterator : nativeIterator;
    var CurrentIteratorPrototype, methods, KEY;
    if (anyNativeIterator) {
      CurrentIteratorPrototype = getPrototypeOf(anyNativeIterator.call(new Iterable));
      if (CurrentIteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {
        if (!IS_PURE && getPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype) {
          if (setPrototypeOf) {
            setPrototypeOf(CurrentIteratorPrototype, IteratorPrototype);
          } else if (!isCallable(CurrentIteratorPrototype[ITERATOR])) {
            defineBuiltIn(CurrentIteratorPrototype, ITERATOR, returnThis);
          }
        }
        setToStringTag(CurrentIteratorPrototype, TO_STRING_TAG, true, true);
        if (IS_PURE)
          Iterators[TO_STRING_TAG] = returnThis;
      }
    }
    if (PROPER_FUNCTION_NAME && DEFAULT === VALUES && nativeIterator && nativeIterator.name !== VALUES) {
      if (!IS_PURE && CONFIGURABLE_FUNCTION_NAME) {
        createNonEnumerableProperty(IterablePrototype, "name", VALUES);
      } else {
        INCORRECT_VALUES_NAME = true;
        defaultIterator = function values() {
          return call(nativeIterator, this);
        };
      }
    }
    if (DEFAULT) {
      methods = {
        values: getIterationMethod(VALUES),
        keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),
        entries: getIterationMethod(ENTRIES)
      };
      if (FORCED)
        for (KEY in methods) {
          if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {
            defineBuiltIn(IterablePrototype, KEY, methods[KEY]);
          }
        }
      else
        $({ target: NAME, proto: true, forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME }, methods);
    }
    if ((!IS_PURE || FORCED) && IterablePrototype[ITERATOR] !== defaultIterator) {
      defineBuiltIn(IterablePrototype, ITERATOR, defaultIterator, { name: DEFAULT });
    }
    Iterators[NAME] = defaultIterator;
    return methods;
  };
});

// node_modules/core-js/internals/create-iter-result-object.js
var require_create_iter_result_object = __commonJS((exports, module) => {
  module.exports = function(value, done) {
    return { value, done };
  };
});

// node_modules/core-js/modules/es.array.iterator.js
var require_es_array_iterator = __commonJS((exports, module) => {
  var toIndexedObject = require_to_indexed_object();
  var addToUnscopables = require_add_to_unscopables();
  var Iterators = require_iterators();
  var InternalStateModule = require_internal_state();
  var defineProperty = require_object_define_property().f;
  var defineIterator = require_iterator_define();
  var createIterResultObject = require_create_iter_result_object();
  var IS_PURE = require_is_pure();
  var DESCRIPTORS = require_descriptors();
  var ARRAY_ITERATOR = "Array Iterator";
  var setInternalState = InternalStateModule.set;
  var getInternalState = InternalStateModule.getterFor(ARRAY_ITERATOR);
  module.exports = defineIterator(Array, "Array", function(iterated, kind) {
    setInternalState(this, {
      type: ARRAY_ITERATOR,
      target: toIndexedObject(iterated),
      index: 0,
      kind
    });
  }, function() {
    var state = getInternalState(this);
    var target = state.target;
    var index = state.index++;
    if (!target || index >= target.length) {
      state.target = null;
      return createIterResultObject(undefined, true);
    }
    switch (state.kind) {
      case "keys":
        return createIterResultObject(index, false);
      case "values":
        return createIterResultObject(target[index], false);
    }
    return createIterResultObject([index, target[index]], false);
  }, "values");
  var values = Iterators.Arguments = Iterators.Array;
  addToUnscopables("keys");
  addToUnscopables("values");
  addToUnscopables("entries");
  if (!IS_PURE && DESCRIPTORS && values.name !== "values")
    try {
      defineProperty(values, "name", { value: "values" });
    } catch (error) {}
});

// node_modules/core-js/internals/dom-iterables.js
var require_dom_iterables = __commonJS((exports, module) => {
  module.exports = {
    CSSRuleList: 0,
    CSSStyleDeclaration: 0,
    CSSValueList: 0,
    ClientRectList: 0,
    DOMRectList: 0,
    DOMStringList: 0,
    DOMTokenList: 1,
    DataTransferItemList: 0,
    FileList: 0,
    HTMLAllCollection: 0,
    HTMLCollection: 0,
    HTMLFormElement: 0,
    HTMLSelectElement: 0,
    MediaList: 0,
    MimeTypeArray: 0,
    NamedNodeMap: 0,
    NodeList: 1,
    PaintRequestList: 0,
    Plugin: 0,
    PluginArray: 0,
    SVGLengthList: 0,
    SVGNumberList: 0,
    SVGPathSegList: 0,
    SVGPointList: 0,
    SVGStringList: 0,
    SVGTransformList: 0,
    SourceBufferList: 0,
    StyleSheetList: 0,
    TextTrackCueList: 0,
    TextTrackList: 0,
    TouchList: 0
  };
});

// node_modules/core-js/internals/dom-token-list-prototype.js
var require_dom_token_list_prototype = __commonJS((exports, module) => {
  var documentCreateElement = require_document_create_element();
  var classList = documentCreateElement("span").classList;
  var DOMTokenListPrototype = classList && classList.constructor && classList.constructor.prototype;
  module.exports = DOMTokenListPrototype === Object.prototype ? undefined : DOMTokenListPrototype;
});

// node_modules/core-js/modules/web.dom-collections.iterator.js
var require_web_dom_collections_iterator = __commonJS(() => {
  var globalThis2 = require_global_this();
  var DOMIterables = require_dom_iterables();
  var DOMTokenListPrototype = require_dom_token_list_prototype();
  var ArrayIteratorMethods = require_es_array_iterator();
  var createNonEnumerableProperty = require_create_non_enumerable_property();
  var setToStringTag = require_set_to_string_tag();
  var wellKnownSymbol = require_well_known_symbol();
  var ITERATOR = wellKnownSymbol("iterator");
  var ArrayValues = ArrayIteratorMethods.values;
  var handlePrototype = function(CollectionPrototype, COLLECTION_NAME2) {
    if (CollectionPrototype) {
      if (CollectionPrototype[ITERATOR] !== ArrayValues)
        try {
          createNonEnumerableProperty(CollectionPrototype, ITERATOR, ArrayValues);
        } catch (error) {
          CollectionPrototype[ITERATOR] = ArrayValues;
        }
      setToStringTag(CollectionPrototype, COLLECTION_NAME2, true);
      if (DOMIterables[COLLECTION_NAME2])
        for (var METHOD_NAME in ArrayIteratorMethods) {
          if (CollectionPrototype[METHOD_NAME] !== ArrayIteratorMethods[METHOD_NAME])
            try {
              createNonEnumerableProperty(CollectionPrototype, METHOD_NAME, ArrayIteratorMethods[METHOD_NAME]);
            } catch (error) {
              CollectionPrototype[METHOD_NAME] = ArrayIteratorMethods[METHOD_NAME];
            }
        }
    }
  };
  for (COLLECTION_NAME in DOMIterables) {
    handlePrototype(globalThis2[COLLECTION_NAME] && globalThis2[COLLECTION_NAME].prototype, COLLECTION_NAME);
  }
  var COLLECTION_NAME;
  handlePrototype(DOMTokenListPrototype, "DOMTokenList");
});

// node_modules/@babel/runtime/helpers/esm/toPrimitive.js
function toPrimitive(t, r) {
  if (_typeof(t) != "object" || !t)
    return t;
  var e = t[Symbol.toPrimitive];
  if (e !== undefined) {
    var i3 = e.call(t, r || "default");
    if (_typeof(i3) != "object")
      return i3;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (r === "string" ? String : Number)(t);
}
var init_toPrimitive = __esm(() => {
  init_typeof();
});

// node_modules/@babel/runtime/helpers/esm/toPropertyKey.js
function toPropertyKey(t) {
  var i3 = toPrimitive(t, "string");
  return _typeof(i3) == "symbol" ? i3 : i3 + "";
}
var init_toPropertyKey = __esm(() => {
  init_typeof();
  init_toPrimitive();
});

// node_modules/@babel/runtime/helpers/esm/defineProperty.js
function _defineProperty(e, r, t) {
  return (r = toPropertyKey(r)) in e ? Object.defineProperty(e, r, {
    value: t,
    enumerable: true,
    configurable: true,
    writable: true
  }) : e[r] = t, e;
}
var init_defineProperty = __esm(() => {
  init_toPropertyKey();
});

// node_modules/core-js/internals/array-reduce.js
var require_array_reduce = __commonJS((exports, module) => {
  var aCallable = require_a_callable();
  var toObject = require_to_object();
  var IndexedObject = require_indexed_object();
  var lengthOfArrayLike = require_length_of_array_like();
  var $TypeError = TypeError;
  var REDUCE_EMPTY = "Reduce of empty array with no initial value";
  var createMethod = function(IS_RIGHT) {
    return function(that, callbackfn, argumentsLength, memo) {
      var O = toObject(that);
      var self2 = IndexedObject(O);
      var length = lengthOfArrayLike(O);
      aCallable(callbackfn);
      if (length === 0 && argumentsLength < 2)
        throw new $TypeError(REDUCE_EMPTY);
      var index = IS_RIGHT ? length - 1 : 0;
      var i3 = IS_RIGHT ? -1 : 1;
      if (argumentsLength < 2)
        while (true) {
          if (index in self2) {
            memo = self2[index];
            index += i3;
            break;
          }
          index += i3;
          if (IS_RIGHT ? index < 0 : length <= index) {
            throw new $TypeError(REDUCE_EMPTY);
          }
        }
      for (;IS_RIGHT ? index >= 0 : length > index; index += i3)
        if (index in self2) {
          memo = callbackfn(memo, self2[index], index, O);
        }
      return memo;
    };
  };
  module.exports = {
    left: createMethod(false),
    right: createMethod(true)
  };
});

// node_modules/core-js/internals/array-method-is-strict.js
var require_array_method_is_strict = __commonJS((exports, module) => {
  var fails = require_fails();
  module.exports = function(METHOD_NAME, argument) {
    var method = [][METHOD_NAME];
    return !!method && fails(function() {
      method.call(null, argument || function() {
        return 1;
      }, 1);
    });
  };
});

// node_modules/core-js/modules/es.array.reduce.js
var require_es_array_reduce = __commonJS(() => {
  var $ = require_export();
  var $reduce = require_array_reduce().left;
  var arrayMethodIsStrict = require_array_method_is_strict();
  var CHROME_VERSION = require_environment_v8_version();
  var IS_NODE = require_environment_is_node();
  var CHROME_BUG = !IS_NODE && CHROME_VERSION > 79 && CHROME_VERSION < 83;
  var FORCED = CHROME_BUG || !arrayMethodIsStrict("reduce");
  $({ target: "Array", proto: true, forced: FORCED }, {
    reduce: function reduce(callbackfn) {
      var length = arguments.length;
      return $reduce(this, callbackfn, length, length > 1 ? arguments[1] : undefined);
    }
  });
});

// node_modules/core-js/modules/es.string.ends-with.js
var require_es_string_ends_with = __commonJS(() => {
  var $ = require_export();
  var uncurryThis = require_function_uncurry_this_clause();
  var getOwnPropertyDescriptor = require_object_get_own_property_descriptor().f;
  var toLength = require_to_length();
  var toString = require_to_string();
  var notARegExp = require_not_a_regexp();
  var requireObjectCoercible = require_require_object_coercible();
  var correctIsRegExpLogic = require_correct_is_regexp_logic();
  var IS_PURE = require_is_pure();
  var slice2 = uncurryThis("".slice);
  var min = Math.min;
  var CORRECT_IS_REGEXP_LOGIC = correctIsRegExpLogic("endsWith");
  var MDN_POLYFILL_BUG = !IS_PURE && !CORRECT_IS_REGEXP_LOGIC && !!function() {
    var descriptor = getOwnPropertyDescriptor(String.prototype, "endsWith");
    return descriptor && !descriptor.writable;
  }();
  $({ target: "String", proto: true, forced: !MDN_POLYFILL_BUG && !CORRECT_IS_REGEXP_LOGIC }, {
    endsWith: function endsWith(searchString) {
      var that = toString(requireObjectCoercible(this));
      notARegExp(searchString);
      var endPosition = arguments.length > 1 ? arguments[1] : undefined;
      var len = that.length;
      var end = endPosition === undefined ? len : min(toLength(endPosition), len);
      var search = toString(searchString);
      return slice2(that, end - search.length, end) === search;
    }
  });
});

// node_modules/core-js/modules/es.string.split.js
var require_es_string_split = __commonJS(() => {
  var call = require_function_call();
  var uncurryThis = require_function_uncurry_this();
  var fixRegExpWellKnownSymbolLogic = require_fix_regexp_well_known_symbol_logic();
  var anObject = require_an_object();
  var isObject = require_is_object();
  var requireObjectCoercible = require_require_object_coercible();
  var speciesConstructor = require_species_constructor();
  var advanceStringIndex = require_advance_string_index();
  var toLength = require_to_length();
  var toString = require_to_string();
  var getMethod = require_get_method();
  var regExpExec = require_regexp_exec_abstract();
  var stickyHelpers = require_regexp_sticky_helpers();
  var fails = require_fails();
  var UNSUPPORTED_Y = stickyHelpers.UNSUPPORTED_Y;
  var MAX_UINT32 = 4294967295;
  var min = Math.min;
  var push = uncurryThis([].push);
  var stringSlice = uncurryThis("".slice);
  var SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = !fails(function() {
    var re = /(?:)/;
    var originalExec = re.exec;
    re.exec = function() {
      return originalExec.apply(this, arguments);
    };
    var result = "ab".split(re);
    return result.length !== 2 || result[0] !== "a" || result[1] !== "b";
  });
  var BUGGY = "abbc".split(/(b)*/)[1] === "c" || "test".split(/(?:)/, -1).length !== 4 || "ab".split(/(?:ab)*/).length !== 2 || ".".split(/(.?)(.?)/).length !== 4 || ".".split(/()()/).length > 1 || "".split(/.?/).length;
  fixRegExpWellKnownSymbolLogic("split", function(SPLIT, nativeSplit, maybeCallNative) {
    var internalSplit = "0".split(undefined, 0).length ? function(separator, limit) {
      return separator === undefined && limit === 0 ? [] : call(nativeSplit, this, separator, limit);
    } : nativeSplit;
    return [
      function split(separator, limit) {
        var O = requireObjectCoercible(this);
        var splitter = isObject(separator) ? getMethod(separator, SPLIT) : undefined;
        return splitter ? call(splitter, separator, O, limit) : call(internalSplit, toString(O), separator, limit);
      },
      function(string, limit) {
        var rx = anObject(this);
        var S = toString(string);
        if (!BUGGY) {
          var res = maybeCallNative(internalSplit, rx, S, limit, internalSplit !== nativeSplit);
          if (res.done)
            return res.value;
        }
        var C = speciesConstructor(rx, RegExp);
        var unicodeMatching = rx.unicode;
        var flags = (rx.ignoreCase ? "i" : "") + (rx.multiline ? "m" : "") + (rx.unicode ? "u" : "") + (UNSUPPORTED_Y ? "g" : "y");
        var splitter = new C(UNSUPPORTED_Y ? "^(?:" + rx.source + ")" : rx, flags);
        var lim = limit === undefined ? MAX_UINT32 : limit >>> 0;
        if (lim === 0)
          return [];
        if (S.length === 0)
          return regExpExec(splitter, S) === null ? [S] : [];
        var p = 0;
        var q = 0;
        var A = [];
        while (q < S.length) {
          splitter.lastIndex = UNSUPPORTED_Y ? 0 : q;
          var z = regExpExec(splitter, UNSUPPORTED_Y ? stringSlice(S, q) : S);
          var e;
          if (z === null || (e = min(toLength(splitter.lastIndex + (UNSUPPORTED_Y ? q : 0)), S.length)) === p) {
            q = advanceStringIndex(S, q, unicodeMatching);
          } else {
            push(A, stringSlice(S, p, q));
            if (A.length === lim)
              return A;
            for (var i3 = 1;i3 <= z.length - 1; i3++) {
              push(A, z[i3]);
              if (A.length === lim)
                return A;
            }
            q = p = e;
          }
        }
        push(A, stringSlice(S, p));
        return A;
      }
    ];
  }, BUGGY || !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC, UNSUPPORTED_Y);
});

// node_modules/performance-now/lib/performance-now.js
var require_performance_now = __commonJS((exports, module) => {
  (function() {
    var getNanoSeconds, hrtime, loadTime, moduleLoadTime, nodeLoadTime, upTime;
    if (typeof performance !== "undefined" && performance !== null && performance.now) {
      module.exports = function() {
        return performance.now();
      };
    } else if (typeof process !== "undefined" && process !== null && process.hrtime) {
      module.exports = function() {
        return (getNanoSeconds() - nodeLoadTime) / 1e6;
      };
      hrtime = process.hrtime;
      getNanoSeconds = function() {
        var hr;
        hr = hrtime();
        return hr[0] * 1e9 + hr[1];
      };
      moduleLoadTime = getNanoSeconds();
      upTime = process.uptime() * 1e9;
      nodeLoadTime = moduleLoadTime - upTime;
    } else if (Date.now) {
      module.exports = function() {
        return Date.now() - loadTime;
      };
      loadTime = Date.now();
    } else {
      module.exports = function() {
        return new Date().getTime() - loadTime;
      };
      loadTime = new Date().getTime();
    }
  }).call(exports);
});

// node_modules/raf/index.js
var require_raf = __commonJS((exports, module) => {
  var now = require_performance_now();
  var root = typeof window === "undefined" ? global : window;
  var vendors = ["moz", "webkit"];
  var suffix = "AnimationFrame";
  var raf = root["request" + suffix];
  var caf = root["cancel" + suffix] || root["cancelRequest" + suffix];
  for (i3 = 0;!raf && i3 < vendors.length; i3++) {
    raf = root[vendors[i3] + "Request" + suffix];
    caf = root[vendors[i3] + "Cancel" + suffix] || root[vendors[i3] + "CancelRequest" + suffix];
  }
  var i3;
  if (!raf || !caf) {
    last = 0, id = 0, queue = [], frameDuration = 1000 / 60;
    raf = function(callback) {
      if (queue.length === 0) {
        var _now = now(), next = Math.max(0, frameDuration - (_now - last));
        last = next + _now;
        setTimeout(function() {
          var cp = queue.slice(0);
          queue.length = 0;
          for (var i4 = 0;i4 < cp.length; i4++) {
            if (!cp[i4].cancelled) {
              try {
                cp[i4].callback(last);
              } catch (e) {
                setTimeout(function() {
                  throw e;
                }, 0);
              }
            }
          }
        }, Math.round(next));
      }
      queue.push({
        handle: ++id,
        callback,
        cancelled: false
      });
      return id;
    };
    caf = function(handle) {
      for (var i4 = 0;i4 < queue.length; i4++) {
        if (queue[i4].handle === handle) {
          queue[i4].cancelled = true;
        }
      }
    };
  }
  var last;
  var id;
  var queue;
  var frameDuration;
  module.exports = function(fn) {
    return raf.call(root, fn);
  };
  module.exports.cancel = function() {
    caf.apply(root, arguments);
  };
  module.exports.polyfill = function(object) {
    if (!object) {
      object = root;
    }
    object.requestAnimationFrame = raf;
    object.cancelAnimationFrame = caf;
  };
});

// node_modules/core-js/internals/whitespaces.js
var require_whitespaces = __commonJS((exports, module) => {
  module.exports = `	
\v\f\r ` + "\u2028\u2029\uFEFF";
});

// node_modules/core-js/internals/string-trim.js
var require_string_trim = __commonJS((exports, module) => {
  var uncurryThis = require_function_uncurry_this();
  var requireObjectCoercible = require_require_object_coercible();
  var toString = require_to_string();
  var whitespaces = require_whitespaces();
  var replace2 = uncurryThis("".replace);
  var ltrim = RegExp("^[" + whitespaces + "]+");
  var rtrim = RegExp("(^|[^" + whitespaces + "])[" + whitespaces + "]+$");
  var createMethod = function(TYPE) {
    return function($this) {
      var string = toString(requireObjectCoercible($this));
      if (TYPE & 1)
        string = replace2(string, ltrim, "");
      if (TYPE & 2)
        string = replace2(string, rtrim, "$1");
      return string;
    };
  };
  module.exports = {
    start: createMethod(1),
    end: createMethod(2),
    trim: createMethod(3)
  };
});

// node_modules/core-js/internals/string-trim-forced.js
var require_string_trim_forced = __commonJS((exports, module) => {
  var PROPER_FUNCTION_NAME = require_function_name().PROPER;
  var fails = require_fails();
  var whitespaces = require_whitespaces();
  var non = "";
  module.exports = function(METHOD_NAME) {
    return fails(function() {
      return !!whitespaces[METHOD_NAME]() || non[METHOD_NAME]() !== non || PROPER_FUNCTION_NAME && whitespaces[METHOD_NAME].name !== METHOD_NAME;
    });
  };
});

// node_modules/core-js/modules/es.string.trim.js
var require_es_string_trim = __commonJS(() => {
  var $ = require_export();
  var $trim = require_string_trim().trim;
  var forcedStringTrimMethod = require_string_trim_forced();
  $({ target: "String", proto: true, forced: forcedStringTrimMethod("trim") }, {
    trim: function trim() {
      return $trim(this);
    }
  });
});

// node_modules/rgbcolor/index.js
var require_rgbcolor = __commonJS((exports, module) => {
  module.exports = function(color_string) {
    this.ok = false;
    this.alpha = 1;
    if (color_string.charAt(0) == "#") {
      color_string = color_string.substr(1, 6);
    }
    color_string = color_string.replace(/ /g, "");
    color_string = color_string.toLowerCase();
    var simple_colors = {
      aliceblue: "f0f8ff",
      antiquewhite: "faebd7",
      aqua: "00ffff",
      aquamarine: "7fffd4",
      azure: "f0ffff",
      beige: "f5f5dc",
      bisque: "ffe4c4",
      black: "000000",
      blanchedalmond: "ffebcd",
      blue: "0000ff",
      blueviolet: "8a2be2",
      brown: "a52a2a",
      burlywood: "deb887",
      cadetblue: "5f9ea0",
      chartreuse: "7fff00",
      chocolate: "d2691e",
      coral: "ff7f50",
      cornflowerblue: "6495ed",
      cornsilk: "fff8dc",
      crimson: "dc143c",
      cyan: "00ffff",
      darkblue: "00008b",
      darkcyan: "008b8b",
      darkgoldenrod: "b8860b",
      darkgray: "a9a9a9",
      darkgreen: "006400",
      darkkhaki: "bdb76b",
      darkmagenta: "8b008b",
      darkolivegreen: "556b2f",
      darkorange: "ff8c00",
      darkorchid: "9932cc",
      darkred: "8b0000",
      darksalmon: "e9967a",
      darkseagreen: "8fbc8f",
      darkslateblue: "483d8b",
      darkslategray: "2f4f4f",
      darkturquoise: "00ced1",
      darkviolet: "9400d3",
      deeppink: "ff1493",
      deepskyblue: "00bfff",
      dimgray: "696969",
      dodgerblue: "1e90ff",
      feldspar: "d19275",
      firebrick: "b22222",
      floralwhite: "fffaf0",
      forestgreen: "228b22",
      fuchsia: "ff00ff",
      gainsboro: "dcdcdc",
      ghostwhite: "f8f8ff",
      gold: "ffd700",
      goldenrod: "daa520",
      gray: "808080",
      green: "008000",
      greenyellow: "adff2f",
      honeydew: "f0fff0",
      hotpink: "ff69b4",
      indianred: "cd5c5c",
      indigo: "4b0082",
      ivory: "fffff0",
      khaki: "f0e68c",
      lavender: "e6e6fa",
      lavenderblush: "fff0f5",
      lawngreen: "7cfc00",
      lemonchiffon: "fffacd",
      lightblue: "add8e6",
      lightcoral: "f08080",
      lightcyan: "e0ffff",
      lightgoldenrodyellow: "fafad2",
      lightgrey: "d3d3d3",
      lightgreen: "90ee90",
      lightpink: "ffb6c1",
      lightsalmon: "ffa07a",
      lightseagreen: "20b2aa",
      lightskyblue: "87cefa",
      lightslateblue: "8470ff",
      lightslategray: "778899",
      lightsteelblue: "b0c4de",
      lightyellow: "ffffe0",
      lime: "00ff00",
      limegreen: "32cd32",
      linen: "faf0e6",
      magenta: "ff00ff",
      maroon: "800000",
      mediumaquamarine: "66cdaa",
      mediumblue: "0000cd",
      mediumorchid: "ba55d3",
      mediumpurple: "9370d8",
      mediumseagreen: "3cb371",
      mediumslateblue: "7b68ee",
      mediumspringgreen: "00fa9a",
      mediumturquoise: "48d1cc",
      mediumvioletred: "c71585",
      midnightblue: "191970",
      mintcream: "f5fffa",
      mistyrose: "ffe4e1",
      moccasin: "ffe4b5",
      navajowhite: "ffdead",
      navy: "000080",
      oldlace: "fdf5e6",
      olive: "808000",
      olivedrab: "6b8e23",
      orange: "ffa500",
      orangered: "ff4500",
      orchid: "da70d6",
      palegoldenrod: "eee8aa",
      palegreen: "98fb98",
      paleturquoise: "afeeee",
      palevioletred: "d87093",
      papayawhip: "ffefd5",
      peachpuff: "ffdab9",
      peru: "cd853f",
      pink: "ffc0cb",
      plum: "dda0dd",
      powderblue: "b0e0e6",
      purple: "800080",
      rebeccapurple: "663399",
      red: "ff0000",
      rosybrown: "bc8f8f",
      royalblue: "4169e1",
      saddlebrown: "8b4513",
      salmon: "fa8072",
      sandybrown: "f4a460",
      seagreen: "2e8b57",
      seashell: "fff5ee",
      sienna: "a0522d",
      silver: "c0c0c0",
      skyblue: "87ceeb",
      slateblue: "6a5acd",
      slategray: "708090",
      snow: "fffafa",
      springgreen: "00ff7f",
      steelblue: "4682b4",
      tan: "d2b48c",
      teal: "008080",
      thistle: "d8bfd8",
      tomato: "ff6347",
      turquoise: "40e0d0",
      violet: "ee82ee",
      violetred: "d02090",
      wheat: "f5deb3",
      white: "ffffff",
      whitesmoke: "f5f5f5",
      yellow: "ffff00",
      yellowgreen: "9acd32"
    };
    color_string = simple_colors[color_string] || color_string;
    var color_defs = [
      {
        re: /^rgba\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3}),\s*((?:\d?\.)?\d)\)$/,
        example: ["rgba(123, 234, 45, 0.8)", "rgba(255,234,245,1.0)"],
        process: function(bits3) {
          return [
            parseInt(bits3[1]),
            parseInt(bits3[2]),
            parseInt(bits3[3]),
            parseFloat(bits3[4])
          ];
        }
      },
      {
        re: /^rgb\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})\)$/,
        example: ["rgb(123, 234, 45)", "rgb(255,234,245)"],
        process: function(bits3) {
          return [
            parseInt(bits3[1]),
            parseInt(bits3[2]),
            parseInt(bits3[3])
          ];
        }
      },
      {
        re: /^([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
        example: ["#00ff00", "336699"],
        process: function(bits3) {
          return [
            parseInt(bits3[1], 16),
            parseInt(bits3[2], 16),
            parseInt(bits3[3], 16)
          ];
        }
      },
      {
        re: /^([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
        example: ["#fb0", "f0f"],
        process: function(bits3) {
          return [
            parseInt(bits3[1] + bits3[1], 16),
            parseInt(bits3[2] + bits3[2], 16),
            parseInt(bits3[3] + bits3[3], 16)
          ];
        }
      }
    ];
    for (var i3 = 0;i3 < color_defs.length; i3++) {
      var re = color_defs[i3].re;
      var processor = color_defs[i3].process;
      var bits2 = re.exec(color_string);
      if (bits2) {
        var channels = processor(bits2);
        this.r = channels[0];
        this.g = channels[1];
        this.b = channels[2];
        if (channels.length > 3) {
          this.alpha = channels[3];
        }
        this.ok = true;
      }
    }
    this.r = this.r < 0 || isNaN(this.r) ? 0 : this.r > 255 ? 255 : this.r;
    this.g = this.g < 0 || isNaN(this.g) ? 0 : this.g > 255 ? 255 : this.g;
    this.b = this.b < 0 || isNaN(this.b) ? 0 : this.b > 255 ? 255 : this.b;
    this.alpha = this.alpha < 0 ? 0 : this.alpha > 1 || isNaN(this.alpha) ? 1 : this.alpha;
    this.toRGB = function() {
      return "rgb(" + this.r + ", " + this.g + ", " + this.b + ")";
    };
    this.toRGBA = function() {
      return "rgba(" + this.r + ", " + this.g + ", " + this.b + ", " + this.alpha + ")";
    };
    this.toHex = function() {
      var r = this.r.toString(16);
      var g = this.g.toString(16);
      var b = this.b.toString(16);
      if (r.length == 1)
        r = "0" + r;
      if (g.length == 1)
        g = "0" + g;
      if (b.length == 1)
        b = "0" + b;
      return "#" + r + g + b;
    };
    this.getHelpXML = function() {
      var examples = new Array;
      for (var i4 = 0;i4 < color_defs.length; i4++) {
        var example = color_defs[i4].example;
        for (var j = 0;j < example.length; j++) {
          examples[examples.length] = example[j];
        }
      }
      for (var sc in simple_colors) {
        examples[examples.length] = sc;
      }
      var xml = document.createElement("ul");
      xml.setAttribute("id", "rgbcolor-examples");
      for (var i4 = 0;i4 < examples.length; i4++) {
        try {
          var list_item = document.createElement("li");
          var list_color = new RGBColor(examples[i4]);
          var example_div = document.createElement("div");
          example_div.style.cssText = "margin: 3px; " + "border: 1px solid black; " + "background:" + list_color.toHex() + "; " + "color:" + list_color.toHex();
          example_div.appendChild(document.createTextNode("test"));
          var list_item_value = document.createTextNode(" " + examples[i4] + " -> " + list_color.toRGB() + " -> " + list_color.toHex());
          list_item.appendChild(example_div);
          list_item.appendChild(list_item_value);
          xml.appendChild(list_item);
        } catch (e) {}
      }
      return xml;
    };
  };
});

// node_modules/core-js/modules/es.array.index-of.js
var require_es_array_index_of = __commonJS(() => {
  var $ = require_export();
  var uncurryThis = require_function_uncurry_this_clause();
  var $indexOf = require_array_includes().indexOf;
  var arrayMethodIsStrict = require_array_method_is_strict();
  var nativeIndexOf = uncurryThis([].indexOf);
  var NEGATIVE_ZERO = !!nativeIndexOf && 1 / nativeIndexOf([1], 1, -0) < 0;
  var FORCED = NEGATIVE_ZERO || !arrayMethodIsStrict("indexOf");
  $({ target: "Array", proto: true, forced: FORCED }, {
    indexOf: function indexOf(searchElement) {
      var fromIndex = arguments.length > 1 ? arguments[1] : undefined;
      return NEGATIVE_ZERO ? nativeIndexOf(this, searchElement, fromIndex) || 0 : $indexOf(this, searchElement, fromIndex);
    }
  });
});

// node_modules/core-js/modules/es.string.includes.js
var require_es_string_includes = __commonJS(() => {
  var $ = require_export();
  var uncurryThis = require_function_uncurry_this();
  var notARegExp = require_not_a_regexp();
  var requireObjectCoercible = require_require_object_coercible();
  var toString = require_to_string();
  var correctIsRegExpLogic = require_correct_is_regexp_logic();
  var stringIndexOf = uncurryThis("".indexOf);
  $({ target: "String", proto: true, forced: !correctIsRegExpLogic("includes") }, {
    includes: function includes(searchString) {
      return !!~stringIndexOf(toString(requireObjectCoercible(this)), toString(notARegExp(searchString)), arguments.length > 1 ? arguments[1] : undefined);
    }
  });
});

// node_modules/core-js/internals/is-array.js
var require_is_array = __commonJS((exports, module) => {
  var classof = require_classof_raw();
  module.exports = Array.isArray || function isArray(argument) {
    return classof(argument) === "Array";
  };
});

// node_modules/core-js/modules/es.array.reverse.js
var require_es_array_reverse = __commonJS(() => {
  var $ = require_export();
  var uncurryThis = require_function_uncurry_this();
  var isArray = require_is_array();
  var nativeReverse = uncurryThis([].reverse);
  var test = [1, 2];
  $({ target: "Array", proto: true, forced: String(test) === String(test.reverse()) }, {
    reverse: function reverse() {
      if (isArray(this))
        this.length = this.length;
      return nativeReverse(this);
    }
  });
});

// node_modules/svg-pathdata/lib/SVGPathData.module.js
function r(r2, e) {
  if (typeof e != "function" && e !== null)
    throw new TypeError("Class extends value " + String(e) + " is not a constructor or null");
  function i3() {
    this.constructor = r2;
  }
  t(r2, e), r2.prototype = e === null ? Object.create(e) : (i3.prototype = e.prototype, new i3);
}
function e(t2) {
  var r2 = "";
  Array.isArray(t2) || (t2 = [t2]);
  for (var e2 = 0;e2 < t2.length; e2++) {
    var i3 = t2[e2];
    if (i3.type === _.CLOSE_PATH)
      r2 += "z";
    else if (i3.type === _.HORIZ_LINE_TO)
      r2 += (i3.relative ? "h" : "H") + i3.x;
    else if (i3.type === _.VERT_LINE_TO)
      r2 += (i3.relative ? "v" : "V") + i3.y;
    else if (i3.type === _.MOVE_TO)
      r2 += (i3.relative ? "m" : "M") + i3.x + " " + i3.y;
    else if (i3.type === _.LINE_TO)
      r2 += (i3.relative ? "l" : "L") + i3.x + " " + i3.y;
    else if (i3.type === _.CURVE_TO)
      r2 += (i3.relative ? "c" : "C") + i3.x1 + " " + i3.y1 + " " + i3.x2 + " " + i3.y2 + " " + i3.x + " " + i3.y;
    else if (i3.type === _.SMOOTH_CURVE_TO)
      r2 += (i3.relative ? "s" : "S") + i3.x2 + " " + i3.y2 + " " + i3.x + " " + i3.y;
    else if (i3.type === _.QUAD_TO)
      r2 += (i3.relative ? "q" : "Q") + i3.x1 + " " + i3.y1 + " " + i3.x + " " + i3.y;
    else if (i3.type === _.SMOOTH_QUAD_TO)
      r2 += (i3.relative ? "t" : "T") + i3.x + " " + i3.y;
    else {
      if (i3.type !== _.ARC)
        throw new Error('Unexpected command type "' + i3.type + '" at index ' + e2 + ".");
      r2 += (i3.relative ? "a" : "A") + i3.rX + " " + i3.rY + " " + i3.xRot + " " + +i3.lArcFlag + " " + +i3.sweepFlag + " " + i3.x + " " + i3.y;
    }
  }
  return r2;
}
function i3(t2, r2) {
  var e2 = t2[0], i4 = t2[1];
  return [e2 * Math.cos(r2) - i4 * Math.sin(r2), e2 * Math.sin(r2) + i4 * Math.cos(r2)];
}
function a() {
  for (var t2 = [], r2 = 0;r2 < arguments.length; r2++)
    t2[r2] = arguments[r2];
  for (var e2 = 0;e2 < t2.length; e2++)
    if (typeof t2[e2] != "number")
      throw new Error("assertNumbers arguments[" + e2 + "] is not a number. " + typeof t2[e2] + " == typeof " + t2[e2]);
  return true;
}
function o(t2, r2, e2) {
  t2.lArcFlag = t2.lArcFlag === 0 ? 0 : 1, t2.sweepFlag = t2.sweepFlag === 0 ? 0 : 1;
  var { rX: a2, rY: o2, x: s, y: u } = t2;
  a2 = Math.abs(t2.rX), o2 = Math.abs(t2.rY);
  var h = i3([(r2 - s) / 2, (e2 - u) / 2], -t2.xRot / 180 * n), c = h[0], y = h[1], p = Math.pow(c, 2) / Math.pow(a2, 2) + Math.pow(y, 2) / Math.pow(o2, 2);
  1 < p && (a2 *= Math.sqrt(p), o2 *= Math.sqrt(p)), t2.rX = a2, t2.rY = o2;
  var m = Math.pow(a2, 2) * Math.pow(y, 2) + Math.pow(o2, 2) * Math.pow(c, 2), O = (t2.lArcFlag !== t2.sweepFlag ? 1 : -1) * Math.sqrt(Math.max(0, (Math.pow(a2, 2) * Math.pow(o2, 2) - m) / m)), l = a2 * y / o2 * O, T = -o2 * c / a2 * O, v = i3([l, T], t2.xRot / 180 * n);
  t2.cX = v[0] + (r2 + s) / 2, t2.cY = v[1] + (e2 + u) / 2, t2.phi1 = Math.atan2((y - T) / o2, (c - l) / a2), t2.phi2 = Math.atan2((-y - T) / o2, (-c - l) / a2), t2.sweepFlag === 0 && t2.phi2 > t2.phi1 && (t2.phi2 -= 2 * n), t2.sweepFlag === 1 && t2.phi2 < t2.phi1 && (t2.phi2 += 2 * n), t2.phi1 *= 180 / n, t2.phi2 *= 180 / n;
}
function s(t2, r2, e2) {
  a(t2, r2, e2);
  var i4 = t2 * t2 + r2 * r2 - e2 * e2;
  if (0 > i4)
    return [];
  if (i4 === 0)
    return [[t2 * e2 / (t2 * t2 + r2 * r2), r2 * e2 / (t2 * t2 + r2 * r2)]];
  var n2 = Math.sqrt(i4);
  return [[(t2 * e2 + r2 * n2) / (t2 * t2 + r2 * r2), (r2 * e2 - t2 * n2) / (t2 * t2 + r2 * r2)], [(t2 * e2 - r2 * n2) / (t2 * t2 + r2 * r2), (r2 * e2 + t2 * n2) / (t2 * t2 + r2 * r2)]];
}
function c(t2, r2, e2) {
  return (1 - e2) * t2 + e2 * r2;
}
function y(t2, r2, e2, i4) {
  return t2 + Math.cos(i4 / 180 * n) * r2 + Math.sin(i4 / 180 * n) * e2;
}
function p(t2, r2, e2, i4) {
  var a2 = 0.000001, n2 = r2 - t2, o2 = e2 - r2, s2 = 3 * n2 + 3 * (i4 - e2) - 6 * o2, u2 = 6 * (o2 - n2), h2 = 3 * n2;
  return Math.abs(s2) < a2 ? [-h2 / u2] : function(t3, r3, e3) {
    e3 === undefined && (e3 = 0.000001);
    var i5 = t3 * t3 / 4 - r3;
    if (i5 < -e3)
      return [];
    if (i5 <= e3)
      return [-t3 / 2];
    var a3 = Math.sqrt(i5);
    return [-t3 / 2 - a3, -t3 / 2 + a3];
  }(u2 / s2, h2 / s2, a2);
}
function m(t2, r2, e2, i4, a2) {
  var n2 = 1 - a2;
  return t2 * (n2 * n2 * n2) + r2 * (3 * n2 * n2 * a2) + e2 * (3 * n2 * a2 * a2) + i4 * (a2 * a2 * a2);
}
var t = function(r, e) {
  return (t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t2, r2) {
    t2.__proto__ = r2;
  } || function(t2, r2) {
    for (var e2 in r2)
      Object.prototype.hasOwnProperty.call(r2, e2) && (t2[e2] = r2[e2]);
  })(r, e);
}, n, u, h, O, l, T = function(t2) {
  return t2 === " " || t2 === "\t" || t2 === "\r" || t2 === `
`;
}, v = function(t2) {
  return 48 <= t2.charCodeAt(0) && t2.charCodeAt(0) <= 57;
}, f, _, N;
var init_SVGPathData_module = __esm(() => {
  /*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** */
  n = Math.PI;
  h = Math.PI / 180;
  (function(t2) {
    function r2() {
      return u2(function(t3, r3, e3) {
        return t3.relative && (t3.x1 !== undefined && (t3.x1 += r3), t3.y1 !== undefined && (t3.y1 += e3), t3.x2 !== undefined && (t3.x2 += r3), t3.y2 !== undefined && (t3.y2 += e3), t3.x !== undefined && (t3.x += r3), t3.y !== undefined && (t3.y += e3), t3.relative = false), t3;
      });
    }
    function e2() {
      var t3 = NaN, r3 = NaN, e3 = NaN, i4 = NaN;
      return u2(function(a2, n3, o2) {
        return a2.type & _.SMOOTH_CURVE_TO && (a2.type = _.CURVE_TO, t3 = isNaN(t3) ? n3 : t3, r3 = isNaN(r3) ? o2 : r3, a2.x1 = a2.relative ? n3 - t3 : 2 * n3 - t3, a2.y1 = a2.relative ? o2 - r3 : 2 * o2 - r3), a2.type & _.CURVE_TO ? (t3 = a2.relative ? n3 + a2.x2 : a2.x2, r3 = a2.relative ? o2 + a2.y2 : a2.y2) : (t3 = NaN, r3 = NaN), a2.type & _.SMOOTH_QUAD_TO && (a2.type = _.QUAD_TO, e3 = isNaN(e3) ? n3 : e3, i4 = isNaN(i4) ? o2 : i4, a2.x1 = a2.relative ? n3 - e3 : 2 * n3 - e3, a2.y1 = a2.relative ? o2 - i4 : 2 * o2 - i4), a2.type & _.QUAD_TO ? (e3 = a2.relative ? n3 + a2.x1 : a2.x1, i4 = a2.relative ? o2 + a2.y1 : a2.y1) : (e3 = NaN, i4 = NaN), a2;
      });
    }
    function n2() {
      var t3 = NaN, r3 = NaN;
      return u2(function(e3, i4, a2) {
        if (e3.type & _.SMOOTH_QUAD_TO && (e3.type = _.QUAD_TO, t3 = isNaN(t3) ? i4 : t3, r3 = isNaN(r3) ? a2 : r3, e3.x1 = e3.relative ? i4 - t3 : 2 * i4 - t3, e3.y1 = e3.relative ? a2 - r3 : 2 * a2 - r3), e3.type & _.QUAD_TO) {
          t3 = e3.relative ? i4 + e3.x1 : e3.x1, r3 = e3.relative ? a2 + e3.y1 : e3.y1;
          var { x1: n3, y1: o2 } = e3;
          e3.type = _.CURVE_TO, e3.x1 = ((e3.relative ? 0 : i4) + 2 * n3) / 3, e3.y1 = ((e3.relative ? 0 : a2) + 2 * o2) / 3, e3.x2 = (e3.x + 2 * n3) / 3, e3.y2 = (e3.y + 2 * o2) / 3;
        } else
          t3 = NaN, r3 = NaN;
        return e3;
      });
    }
    function u2(t3) {
      var r3 = 0, e3 = 0, i4 = NaN, a2 = NaN;
      return function(n3) {
        if (isNaN(i4) && !(n3.type & _.MOVE_TO))
          throw new Error("path must start with moveto");
        var o2 = t3(n3, r3, e3, i4, a2);
        return n3.type & _.CLOSE_PATH && (r3 = i4, e3 = a2), n3.x !== undefined && (r3 = n3.relative ? r3 + n3.x : n3.x), n3.y !== undefined && (e3 = n3.relative ? e3 + n3.y : n3.y), n3.type & _.MOVE_TO && (i4 = r3, a2 = e3), o2;
      };
    }
    function O(t3, r3, e3, i4, n3, o2) {
      return a(t3, r3, e3, i4, n3, o2), u2(function(a2, s2, u3, h2) {
        var { x1: c2, x2: y2 } = a2, p2 = a2.relative && !isNaN(h2), m2 = a2.x !== undefined ? a2.x : p2 ? 0 : s2, O2 = a2.y !== undefined ? a2.y : p2 ? 0 : u3;
        function l2(t4) {
          return t4 * t4;
        }
        a2.type & _.HORIZ_LINE_TO && r3 !== 0 && (a2.type = _.LINE_TO, a2.y = a2.relative ? 0 : u3), a2.type & _.VERT_LINE_TO && e3 !== 0 && (a2.type = _.LINE_TO, a2.x = a2.relative ? 0 : s2), a2.x !== undefined && (a2.x = a2.x * t3 + O2 * e3 + (p2 ? 0 : n3)), a2.y !== undefined && (a2.y = m2 * r3 + a2.y * i4 + (p2 ? 0 : o2)), a2.x1 !== undefined && (a2.x1 = a2.x1 * t3 + a2.y1 * e3 + (p2 ? 0 : n3)), a2.y1 !== undefined && (a2.y1 = c2 * r3 + a2.y1 * i4 + (p2 ? 0 : o2)), a2.x2 !== undefined && (a2.x2 = a2.x2 * t3 + a2.y2 * e3 + (p2 ? 0 : n3)), a2.y2 !== undefined && (a2.y2 = y2 * r3 + a2.y2 * i4 + (p2 ? 0 : o2));
        var T = t3 * i4 - r3 * e3;
        if (a2.xRot !== undefined && (t3 !== 1 || r3 !== 0 || e3 !== 0 || i4 !== 1))
          if (T === 0)
            delete a2.rX, delete a2.rY, delete a2.xRot, delete a2.lArcFlag, delete a2.sweepFlag, a2.type = _.LINE_TO;
          else {
            var v = a2.xRot * Math.PI / 180, f = Math.sin(v), N = Math.cos(v), x2 = 1 / l2(a2.rX), d = 1 / l2(a2.rY), E = l2(N) * x2 + l2(f) * d, A = 2 * f * N * (x2 - d), C = l2(f) * x2 + l2(N) * d, M = E * i4 * i4 - A * r3 * i4 + C * r3 * r3, R = A * (t3 * i4 + r3 * e3) - 2 * (E * e3 * i4 + C * t3 * r3), g = E * e3 * e3 - A * t3 * e3 + C * t3 * t3, I = (Math.atan2(R, M - g) + Math.PI) % Math.PI / 2, S = Math.sin(I), L = Math.cos(I);
            a2.rX = Math.abs(T) / Math.sqrt(M * l2(L) + R * S * L + g * l2(S)), a2.rY = Math.abs(T) / Math.sqrt(M * l2(S) - R * S * L + g * l2(L)), a2.xRot = 180 * I / Math.PI;
          }
        return a2.sweepFlag !== undefined && 0 > T && (a2.sweepFlag = +!a2.sweepFlag), a2;
      });
    }
    function l() {
      return function(t3) {
        var r3 = {};
        for (var e3 in t3)
          r3[e3] = t3[e3];
        return r3;
      };
    }
    t2.ROUND = function(t3) {
      function r3(r4) {
        return Math.round(r4 * t3) / t3;
      }
      return t3 === undefined && (t3 = 10000000000000), a(t3), function(t4) {
        return t4.x1 !== undefined && (t4.x1 = r3(t4.x1)), t4.y1 !== undefined && (t4.y1 = r3(t4.y1)), t4.x2 !== undefined && (t4.x2 = r3(t4.x2)), t4.y2 !== undefined && (t4.y2 = r3(t4.y2)), t4.x !== undefined && (t4.x = r3(t4.x)), t4.y !== undefined && (t4.y = r3(t4.y)), t4.rX !== undefined && (t4.rX = r3(t4.rX)), t4.rY !== undefined && (t4.rY = r3(t4.rY)), t4;
      };
    }, t2.TO_ABS = r2, t2.TO_REL = function() {
      return u2(function(t3, r3, e3) {
        return t3.relative || (t3.x1 !== undefined && (t3.x1 -= r3), t3.y1 !== undefined && (t3.y1 -= e3), t3.x2 !== undefined && (t3.x2 -= r3), t3.y2 !== undefined && (t3.y2 -= e3), t3.x !== undefined && (t3.x -= r3), t3.y !== undefined && (t3.y -= e3), t3.relative = true), t3;
      });
    }, t2.NORMALIZE_HVZ = function(t3, r3, e3) {
      return t3 === undefined && (t3 = true), r3 === undefined && (r3 = true), e3 === undefined && (e3 = true), u2(function(i4, a2, n3, o2, s2) {
        if (isNaN(o2) && !(i4.type & _.MOVE_TO))
          throw new Error("path must start with moveto");
        return r3 && i4.type & _.HORIZ_LINE_TO && (i4.type = _.LINE_TO, i4.y = i4.relative ? 0 : n3), e3 && i4.type & _.VERT_LINE_TO && (i4.type = _.LINE_TO, i4.x = i4.relative ? 0 : a2), t3 && i4.type & _.CLOSE_PATH && (i4.type = _.LINE_TO, i4.x = i4.relative ? o2 - a2 : o2, i4.y = i4.relative ? s2 - n3 : s2), i4.type & _.ARC && (i4.rX === 0 || i4.rY === 0) && (i4.type = _.LINE_TO, delete i4.rX, delete i4.rY, delete i4.xRot, delete i4.lArcFlag, delete i4.sweepFlag), i4;
      });
    }, t2.NORMALIZE_ST = e2, t2.QT_TO_C = n2, t2.INFO = u2, t2.SANITIZE = function(t3) {
      t3 === undefined && (t3 = 0), a(t3);
      var r3 = NaN, e3 = NaN, i4 = NaN, n3 = NaN;
      return u2(function(a2, o2, s2, u3, h2) {
        var c2 = Math.abs, y2 = false, p2 = 0, m2 = 0;
        if (a2.type & _.SMOOTH_CURVE_TO && (p2 = isNaN(r3) ? 0 : o2 - r3, m2 = isNaN(e3) ? 0 : s2 - e3), a2.type & (_.CURVE_TO | _.SMOOTH_CURVE_TO) ? (r3 = a2.relative ? o2 + a2.x2 : a2.x2, e3 = a2.relative ? s2 + a2.y2 : a2.y2) : (r3 = NaN, e3 = NaN), a2.type & _.SMOOTH_QUAD_TO ? (i4 = isNaN(i4) ? o2 : 2 * o2 - i4, n3 = isNaN(n3) ? s2 : 2 * s2 - n3) : a2.type & _.QUAD_TO ? (i4 = a2.relative ? o2 + a2.x1 : a2.x1, n3 = a2.relative ? s2 + a2.y1 : a2.y2) : (i4 = NaN, n3 = NaN), a2.type & _.LINE_COMMANDS || a2.type & _.ARC && (a2.rX === 0 || a2.rY === 0 || !a2.lArcFlag) || a2.type & _.CURVE_TO || a2.type & _.SMOOTH_CURVE_TO || a2.type & _.QUAD_TO || a2.type & _.SMOOTH_QUAD_TO) {
          var O2 = a2.x === undefined ? 0 : a2.relative ? a2.x : a2.x - o2, l2 = a2.y === undefined ? 0 : a2.relative ? a2.y : a2.y - s2;
          p2 = isNaN(i4) ? a2.x1 === undefined ? p2 : a2.relative ? a2.x : a2.x1 - o2 : i4 - o2, m2 = isNaN(n3) ? a2.y1 === undefined ? m2 : a2.relative ? a2.y : a2.y1 - s2 : n3 - s2;
          var T = a2.x2 === undefined ? 0 : a2.relative ? a2.x : a2.x2 - o2, v = a2.y2 === undefined ? 0 : a2.relative ? a2.y : a2.y2 - s2;
          c2(O2) <= t3 && c2(l2) <= t3 && c2(p2) <= t3 && c2(m2) <= t3 && c2(T) <= t3 && c2(v) <= t3 && (y2 = true);
        }
        return a2.type & _.CLOSE_PATH && c2(o2 - u3) <= t3 && c2(s2 - h2) <= t3 && (y2 = true), y2 ? [] : a2;
      });
    }, t2.MATRIX = O, t2.ROTATE = function(t3, r3, e3) {
      r3 === undefined && (r3 = 0), e3 === undefined && (e3 = 0), a(t3, r3, e3);
      var i4 = Math.sin(t3), n3 = Math.cos(t3);
      return O(n3, i4, -i4, n3, r3 - r3 * n3 + e3 * i4, e3 - r3 * i4 - e3 * n3);
    }, t2.TRANSLATE = function(t3, r3) {
      return r3 === undefined && (r3 = 0), a(t3, r3), O(1, 0, 0, 1, t3, r3);
    }, t2.SCALE = function(t3, r3) {
      return r3 === undefined && (r3 = t3), a(t3, r3), O(t3, 0, 0, r3, 0, 0);
    }, t2.SKEW_X = function(t3) {
      return a(t3), O(1, 0, Math.atan(t3), 1, 0, 0);
    }, t2.SKEW_Y = function(t3) {
      return a(t3), O(1, Math.atan(t3), 0, 1, 0, 0);
    }, t2.X_AXIS_SYMMETRY = function(t3) {
      return t3 === undefined && (t3 = 0), a(t3), O(-1, 0, 0, 1, t3, 0);
    }, t2.Y_AXIS_SYMMETRY = function(t3) {
      return t3 === undefined && (t3 = 0), a(t3), O(1, 0, 0, -1, 0, t3);
    }, t2.A_TO_C = function() {
      return u2(function(t3, r3, e3) {
        return _.ARC === t3.type ? function(t4, r4, e4) {
          var a2, n3, s2, u3;
          t4.cX || o(t4, r4, e4);
          for (var y2 = Math.min(t4.phi1, t4.phi2), p2 = Math.max(t4.phi1, t4.phi2) - y2, m2 = Math.ceil(p2 / 90), O2 = new Array(m2), l2 = r4, T = e4, v = 0;v < m2; v++) {
            var f = c(t4.phi1, t4.phi2, v / m2), N = c(t4.phi1, t4.phi2, (v + 1) / m2), x2 = N - f, d = 4 / 3 * Math.tan(x2 * h / 4), E = [Math.cos(f * h) - d * Math.sin(f * h), Math.sin(f * h) + d * Math.cos(f * h)], A = E[0], C = E[1], M = [Math.cos(N * h), Math.sin(N * h)], R = M[0], g = M[1], I = [R + d * Math.sin(N * h), g - d * Math.cos(N * h)], S = I[0], L = I[1];
            O2[v] = { relative: t4.relative, type: _.CURVE_TO };
            var H = function(r5, e5) {
              var a3 = i3([r5 * t4.rX, e5 * t4.rY], t4.xRot), n4 = a3[0], o2 = a3[1];
              return [t4.cX + n4, t4.cY + o2];
            };
            a2 = H(A, C), O2[v].x1 = a2[0], O2[v].y1 = a2[1], n3 = H(S, L), O2[v].x2 = n3[0], O2[v].y2 = n3[1], s2 = H(R, g), O2[v].x = s2[0], O2[v].y = s2[1], t4.relative && (O2[v].x1 -= l2, O2[v].y1 -= T, O2[v].x2 -= l2, O2[v].y2 -= T, O2[v].x -= l2, O2[v].y -= T), l2 = (u3 = [O2[v].x, O2[v].y])[0], T = u3[1];
          }
          return O2;
        }(t3, t3.relative ? 0 : r3, t3.relative ? 0 : e3) : t3;
      });
    }, t2.ANNOTATE_ARCS = function() {
      return u2(function(t3, r3, e3) {
        return t3.relative && (r3 = 0, e3 = 0), _.ARC === t3.type && o(t3, r3, e3), t3;
      });
    }, t2.CLONE = l, t2.CALCULATE_BOUNDS = function() {
      var t3 = function(t4) {
        var r3 = {};
        for (var e3 in t4)
          r3[e3] = t4[e3];
        return r3;
      }, i4 = r2(), a2 = n2(), h2 = e2(), c2 = u2(function(r3, e3, n3) {
        var u3 = h2(a2(i4(t3(r3))));
        function O2(t4) {
          t4 > c2.maxX && (c2.maxX = t4), t4 < c2.minX && (c2.minX = t4);
        }
        function l2(t4) {
          t4 > c2.maxY && (c2.maxY = t4), t4 < c2.minY && (c2.minY = t4);
        }
        if (u3.type & _.DRAWING_COMMANDS && (O2(e3), l2(n3)), u3.type & _.HORIZ_LINE_TO && O2(u3.x), u3.type & _.VERT_LINE_TO && l2(u3.y), u3.type & _.LINE_TO && (O2(u3.x), l2(u3.y)), u3.type & _.CURVE_TO) {
          O2(u3.x), l2(u3.y);
          for (var T = 0, v = p(e3, u3.x1, u3.x2, u3.x);T < v.length; T++) {
            0 < (w = v[T]) && 1 > w && O2(m(e3, u3.x1, u3.x2, u3.x, w));
          }
          for (var f = 0, N = p(n3, u3.y1, u3.y2, u3.y);f < N.length; f++) {
            0 < (w = N[f]) && 1 > w && l2(m(n3, u3.y1, u3.y2, u3.y, w));
          }
        }
        if (u3.type & _.ARC) {
          O2(u3.x), l2(u3.y), o(u3, e3, n3);
          for (var x2 = u3.xRot / 180 * Math.PI, d = Math.cos(x2) * u3.rX, E = Math.sin(x2) * u3.rX, A = -Math.sin(x2) * u3.rY, C = Math.cos(x2) * u3.rY, M = u3.phi1 < u3.phi2 ? [u3.phi1, u3.phi2] : -180 > u3.phi2 ? [u3.phi2 + 360, u3.phi1 + 360] : [u3.phi2, u3.phi1], R = M[0], g = M[1], I = function(t4) {
            var r4 = t4[0], e4 = t4[1], i5 = 180 * Math.atan2(e4, r4) / Math.PI;
            return i5 < R ? i5 + 360 : i5;
          }, S = 0, L = s(A, -d, 0).map(I);S < L.length; S++) {
            (w = L[S]) > R && w < g && O2(y(u3.cX, d, A, w));
          }
          for (var H = 0, U = s(C, -E, 0).map(I);H < U.length; H++) {
            var w;
            (w = U[H]) > R && w < g && l2(y(u3.cY, E, C, w));
          }
        }
        return r3;
      });
      return c2.minX = 1 / 0, c2.maxX = -1 / 0, c2.minY = 1 / 0, c2.maxY = -1 / 0, c2;
    };
  })(u || (u = {}));
  l = function() {
    function t2() {}
    return t2.prototype.round = function(t3) {
      return this.transform(u.ROUND(t3));
    }, t2.prototype.toAbs = function() {
      return this.transform(u.TO_ABS());
    }, t2.prototype.toRel = function() {
      return this.transform(u.TO_REL());
    }, t2.prototype.normalizeHVZ = function(t3, r2, e2) {
      return this.transform(u.NORMALIZE_HVZ(t3, r2, e2));
    }, t2.prototype.normalizeST = function() {
      return this.transform(u.NORMALIZE_ST());
    }, t2.prototype.qtToC = function() {
      return this.transform(u.QT_TO_C());
    }, t2.prototype.aToC = function() {
      return this.transform(u.A_TO_C());
    }, t2.prototype.sanitize = function(t3) {
      return this.transform(u.SANITIZE(t3));
    }, t2.prototype.translate = function(t3, r2) {
      return this.transform(u.TRANSLATE(t3, r2));
    }, t2.prototype.scale = function(t3, r2) {
      return this.transform(u.SCALE(t3, r2));
    }, t2.prototype.rotate = function(t3, r2, e2) {
      return this.transform(u.ROTATE(t3, r2, e2));
    }, t2.prototype.matrix = function(t3, r2, e2, i4, a2, n2) {
      return this.transform(u.MATRIX(t3, r2, e2, i4, a2, n2));
    }, t2.prototype.skewX = function(t3) {
      return this.transform(u.SKEW_X(t3));
    }, t2.prototype.skewY = function(t3) {
      return this.transform(u.SKEW_Y(t3));
    }, t2.prototype.xSymmetry = function(t3) {
      return this.transform(u.X_AXIS_SYMMETRY(t3));
    }, t2.prototype.ySymmetry = function(t3) {
      return this.transform(u.Y_AXIS_SYMMETRY(t3));
    }, t2.prototype.annotateArcs = function() {
      return this.transform(u.ANNOTATE_ARCS());
    }, t2;
  }();
  f = function(t2) {
    function e2() {
      var r2 = t2.call(this) || this;
      return r2.curNumber = "", r2.curCommandType = -1, r2.curCommandRelative = false, r2.canParseCommandOrComma = true, r2.curNumberHasExp = false, r2.curNumberHasExpDigits = false, r2.curNumberHasDecimal = false, r2.curArgs = [], r2;
    }
    return r(e2, t2), e2.prototype.finish = function(t3) {
      if (t3 === undefined && (t3 = []), this.parse(" ", t3), this.curArgs.length !== 0 || !this.canParseCommandOrComma)
        throw new SyntaxError("Unterminated command at the path end.");
      return t3;
    }, e2.prototype.parse = function(t3, r2) {
      var e3 = this;
      r2 === undefined && (r2 = []);
      for (var i4 = function(t4) {
        r2.push(t4), e3.curArgs.length = 0, e3.canParseCommandOrComma = true;
      }, a2 = 0;a2 < t3.length; a2++) {
        var n2 = t3[a2], o2 = !(this.curCommandType !== _.ARC || this.curArgs.length !== 3 && this.curArgs.length !== 4 || this.curNumber.length !== 1 || this.curNumber !== "0" && this.curNumber !== "1"), s2 = v(n2) && (this.curNumber === "0" && n2 === "0" || o2);
        if (!v(n2) || s2)
          if (n2 !== "e" && n2 !== "E")
            if (n2 !== "-" && n2 !== "+" || !this.curNumberHasExp || this.curNumberHasExpDigits)
              if (n2 !== "." || this.curNumberHasExp || this.curNumberHasDecimal || o2) {
                if (this.curNumber && this.curCommandType !== -1) {
                  var u2 = Number(this.curNumber);
                  if (isNaN(u2))
                    throw new SyntaxError("Invalid number ending at " + a2);
                  if (this.curCommandType === _.ARC) {
                    if (this.curArgs.length === 0 || this.curArgs.length === 1) {
                      if (0 > u2)
                        throw new SyntaxError('Expected positive number, got "' + u2 + '" at index "' + a2 + '"');
                    } else if ((this.curArgs.length === 3 || this.curArgs.length === 4) && this.curNumber !== "0" && this.curNumber !== "1")
                      throw new SyntaxError('Expected a flag, got "' + this.curNumber + '" at index "' + a2 + '"');
                  }
                  this.curArgs.push(u2), this.curArgs.length === N[this.curCommandType] && (_.HORIZ_LINE_TO === this.curCommandType ? i4({ type: _.HORIZ_LINE_TO, relative: this.curCommandRelative, x: u2 }) : _.VERT_LINE_TO === this.curCommandType ? i4({ type: _.VERT_LINE_TO, relative: this.curCommandRelative, y: u2 }) : this.curCommandType === _.MOVE_TO || this.curCommandType === _.LINE_TO || this.curCommandType === _.SMOOTH_QUAD_TO ? (i4({ type: this.curCommandType, relative: this.curCommandRelative, x: this.curArgs[0], y: this.curArgs[1] }), _.MOVE_TO === this.curCommandType && (this.curCommandType = _.LINE_TO)) : this.curCommandType === _.CURVE_TO ? i4({ type: _.CURVE_TO, relative: this.curCommandRelative, x1: this.curArgs[0], y1: this.curArgs[1], x2: this.curArgs[2], y2: this.curArgs[3], x: this.curArgs[4], y: this.curArgs[5] }) : this.curCommandType === _.SMOOTH_CURVE_TO ? i4({ type: _.SMOOTH_CURVE_TO, relative: this.curCommandRelative, x2: this.curArgs[0], y2: this.curArgs[1], x: this.curArgs[2], y: this.curArgs[3] }) : this.curCommandType === _.QUAD_TO ? i4({ type: _.QUAD_TO, relative: this.curCommandRelative, x1: this.curArgs[0], y1: this.curArgs[1], x: this.curArgs[2], y: this.curArgs[3] }) : this.curCommandType === _.ARC && i4({ type: _.ARC, relative: this.curCommandRelative, rX: this.curArgs[0], rY: this.curArgs[1], xRot: this.curArgs[2], lArcFlag: this.curArgs[3], sweepFlag: this.curArgs[4], x: this.curArgs[5], y: this.curArgs[6] })), this.curNumber = "", this.curNumberHasExpDigits = false, this.curNumberHasExp = false, this.curNumberHasDecimal = false, this.canParseCommandOrComma = true;
                }
                if (!T(n2))
                  if (n2 === "," && this.canParseCommandOrComma)
                    this.canParseCommandOrComma = false;
                  else if (n2 !== "+" && n2 !== "-" && n2 !== ".")
                    if (s2)
                      this.curNumber = n2, this.curNumberHasDecimal = false;
                    else {
                      if (this.curArgs.length !== 0)
                        throw new SyntaxError("Unterminated command at index " + a2 + ".");
                      if (!this.canParseCommandOrComma)
                        throw new SyntaxError('Unexpected character "' + n2 + '" at index ' + a2 + ". Command cannot follow comma");
                      if (this.canParseCommandOrComma = false, n2 !== "z" && n2 !== "Z")
                        if (n2 === "h" || n2 === "H")
                          this.curCommandType = _.HORIZ_LINE_TO, this.curCommandRelative = n2 === "h";
                        else if (n2 === "v" || n2 === "V")
                          this.curCommandType = _.VERT_LINE_TO, this.curCommandRelative = n2 === "v";
                        else if (n2 === "m" || n2 === "M")
                          this.curCommandType = _.MOVE_TO, this.curCommandRelative = n2 === "m";
                        else if (n2 === "l" || n2 === "L")
                          this.curCommandType = _.LINE_TO, this.curCommandRelative = n2 === "l";
                        else if (n2 === "c" || n2 === "C")
                          this.curCommandType = _.CURVE_TO, this.curCommandRelative = n2 === "c";
                        else if (n2 === "s" || n2 === "S")
                          this.curCommandType = _.SMOOTH_CURVE_TO, this.curCommandRelative = n2 === "s";
                        else if (n2 === "q" || n2 === "Q")
                          this.curCommandType = _.QUAD_TO, this.curCommandRelative = n2 === "q";
                        else if (n2 === "t" || n2 === "T")
                          this.curCommandType = _.SMOOTH_QUAD_TO, this.curCommandRelative = n2 === "t";
                        else {
                          if (n2 !== "a" && n2 !== "A")
                            throw new SyntaxError('Unexpected character "' + n2 + '" at index ' + a2 + ".");
                          this.curCommandType = _.ARC, this.curCommandRelative = n2 === "a";
                        }
                      else
                        r2.push({ type: _.CLOSE_PATH }), this.canParseCommandOrComma = true, this.curCommandType = -1;
                    }
                  else
                    this.curNumber = n2, this.curNumberHasDecimal = n2 === ".";
              } else
                this.curNumber += n2, this.curNumberHasDecimal = true;
            else
              this.curNumber += n2;
          else
            this.curNumber += n2, this.curNumberHasExp = true;
        else
          this.curNumber += n2, this.curNumberHasExpDigits = this.curNumberHasExp;
      }
      return r2;
    }, e2.prototype.transform = function(t3) {
      return Object.create(this, { parse: { value: function(r2, e3) {
        e3 === undefined && (e3 = []);
        for (var i4 = 0, a2 = Object.getPrototypeOf(this).parse.call(this, r2);i4 < a2.length; i4++) {
          var n2 = a2[i4], o2 = t3(n2);
          Array.isArray(o2) ? e3.push.apply(e3, o2) : e3.push(o2);
        }
        return e3;
      } } });
    }, e2;
  }(l);
  _ = function(t2) {
    function i4(r2) {
      var e2 = t2.call(this) || this;
      return e2.commands = typeof r2 == "string" ? i4.parse(r2) : r2, e2;
    }
    return r(i4, t2), i4.prototype.encode = function() {
      return i4.encode(this.commands);
    }, i4.prototype.getBounds = function() {
      var t3 = u.CALCULATE_BOUNDS();
      return this.transform(t3), t3;
    }, i4.prototype.transform = function(t3) {
      for (var r2 = [], e2 = 0, i5 = this.commands;e2 < i5.length; e2++) {
        var a2 = t3(i5[e2]);
        Array.isArray(a2) ? r2.push.apply(r2, a2) : r2.push(a2);
      }
      return this.commands = r2, this;
    }, i4.encode = function(t3) {
      return e(t3);
    }, i4.parse = function(t3) {
      var r2 = new f, e2 = [];
      return r2.parse(t3, e2), r2.finish(e2), e2;
    }, i4.CLOSE_PATH = 1, i4.MOVE_TO = 2, i4.HORIZ_LINE_TO = 4, i4.VERT_LINE_TO = 8, i4.LINE_TO = 16, i4.CURVE_TO = 32, i4.SMOOTH_CURVE_TO = 64, i4.QUAD_TO = 128, i4.SMOOTH_QUAD_TO = 256, i4.ARC = 512, i4.LINE_COMMANDS = i4.LINE_TO | i4.HORIZ_LINE_TO | i4.VERT_LINE_TO, i4.DRAWING_COMMANDS = i4.HORIZ_LINE_TO | i4.VERT_LINE_TO | i4.LINE_TO | i4.CURVE_TO | i4.SMOOTH_CURVE_TO | i4.QUAD_TO | i4.SMOOTH_QUAD_TO | i4.ARC, i4;
  }(l);
  N = ((O = {})[_.MOVE_TO] = 2, O[_.LINE_TO] = 2, O[_.HORIZ_LINE_TO] = 1, O[_.VERT_LINE_TO] = 1, O[_.CLOSE_PATH] = 0, O[_.QUAD_TO] = 4, O[_.SMOOTH_QUAD_TO] = 2, O[_.CURVE_TO] = 6, O[_.SMOOTH_CURVE_TO] = 4, O[_.ARC] = 7, O);
});

// node_modules/core-js/modules/es.regexp.to-string.js
var require_es_regexp_to_string = __commonJS(() => {
  var PROPER_FUNCTION_NAME = require_function_name().PROPER;
  var defineBuiltIn = require_define_built_in();
  var anObject = require_an_object();
  var $toString = require_to_string();
  var fails = require_fails();
  var getRegExpFlags = require_regexp_get_flags();
  var TO_STRING = "toString";
  var RegExpPrototype = RegExp.prototype;
  var nativeToString = RegExpPrototype[TO_STRING];
  var NOT_GENERIC = fails(function() {
    return nativeToString.call({ source: "a", flags: "b" }) !== "/a/b";
  });
  var INCORRECT_NAME = PROPER_FUNCTION_NAME && nativeToString.name !== TO_STRING;
  if (NOT_GENERIC || INCORRECT_NAME) {
    defineBuiltIn(RegExpPrototype, TO_STRING, function toString() {
      var R = anObject(this);
      var pattern = $toString(R.source);
      var flags = $toString(getRegExpFlags(R));
      return "/" + pattern + "/" + flags;
    }, { unsafe: true });
  }
});

// node_modules/stackblur-canvas/dist/stackblur-es.js
function _typeof2(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof2 = function(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof2 = function(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof2(obj);
}
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function getImageDataFromCanvas(canvas, topX, topY, width, height) {
  if (typeof canvas === "string") {
    canvas = document.getElementById(canvas);
  }
  if (!canvas || _typeof2(canvas) !== "object" || !("getContext" in canvas)) {
    throw new TypeError("Expecting canvas with `getContext` method " + "in processCanvasRGB(A) calls!");
  }
  var context = canvas.getContext("2d");
  try {
    return context.getImageData(topX, topY, width, height);
  } catch (e2) {
    throw new Error("unable to access image data: " + e2);
  }
}
function processCanvasRGBA(canvas, topX, topY, width, height, radius) {
  if (isNaN(radius) || radius < 1) {
    return;
  }
  radius |= 0;
  var imageData = getImageDataFromCanvas(canvas, topX, topY, width, height);
  imageData = processImageDataRGBA(imageData, topX, topY, width, height, radius);
  canvas.getContext("2d").putImageData(imageData, topX, topY);
}
function processImageDataRGBA(imageData, topX, topY, width, height, radius) {
  var pixels = imageData.data;
  var div = 2 * radius + 1;
  var widthMinus1 = width - 1;
  var heightMinus1 = height - 1;
  var radiusPlus1 = radius + 1;
  var sumFactor = radiusPlus1 * (radiusPlus1 + 1) / 2;
  var stackStart = new BlurStack;
  var stack = stackStart;
  var stackEnd;
  for (var i4 = 1;i4 < div; i4++) {
    stack = stack.next = new BlurStack;
    if (i4 === radiusPlus1) {
      stackEnd = stack;
    }
  }
  stack.next = stackStart;
  var stackIn = null, stackOut = null, yw = 0, yi = 0;
  var mulSum = mulTable[radius];
  var shgSum = shgTable[radius];
  for (var y2 = 0;y2 < height; y2++) {
    stack = stackStart;
    var pr = pixels[yi], pg = pixels[yi + 1], pb = pixels[yi + 2], pa = pixels[yi + 3];
    for (var _i = 0;_i < radiusPlus1; _i++) {
      stack.r = pr;
      stack.g = pg;
      stack.b = pb;
      stack.a = pa;
      stack = stack.next;
    }
    var rInSum = 0, gInSum = 0, bInSum = 0, aInSum = 0, rOutSum = radiusPlus1 * pr, gOutSum = radiusPlus1 * pg, bOutSum = radiusPlus1 * pb, aOutSum = radiusPlus1 * pa, rSum = sumFactor * pr, gSum = sumFactor * pg, bSum = sumFactor * pb, aSum = sumFactor * pa;
    for (var _i2 = 1;_i2 < radiusPlus1; _i2++) {
      var p2 = yi + ((widthMinus1 < _i2 ? widthMinus1 : _i2) << 2);
      var r2 = pixels[p2], g = pixels[p2 + 1], b = pixels[p2 + 2], a2 = pixels[p2 + 3];
      var rbs = radiusPlus1 - _i2;
      rSum += (stack.r = r2) * rbs;
      gSum += (stack.g = g) * rbs;
      bSum += (stack.b = b) * rbs;
      aSum += (stack.a = a2) * rbs;
      rInSum += r2;
      gInSum += g;
      bInSum += b;
      aInSum += a2;
      stack = stack.next;
    }
    stackIn = stackStart;
    stackOut = stackEnd;
    for (var x2 = 0;x2 < width; x2++) {
      var paInitial = aSum * mulSum >>> shgSum;
      pixels[yi + 3] = paInitial;
      if (paInitial !== 0) {
        var _a2 = 255 / paInitial;
        pixels[yi] = (rSum * mulSum >>> shgSum) * _a2;
        pixels[yi + 1] = (gSum * mulSum >>> shgSum) * _a2;
        pixels[yi + 2] = (bSum * mulSum >>> shgSum) * _a2;
      } else {
        pixels[yi] = pixels[yi + 1] = pixels[yi + 2] = 0;
      }
      rSum -= rOutSum;
      gSum -= gOutSum;
      bSum -= bOutSum;
      aSum -= aOutSum;
      rOutSum -= stackIn.r;
      gOutSum -= stackIn.g;
      bOutSum -= stackIn.b;
      aOutSum -= stackIn.a;
      var _p = x2 + radius + 1;
      _p = yw + (_p < widthMinus1 ? _p : widthMinus1) << 2;
      rInSum += stackIn.r = pixels[_p];
      gInSum += stackIn.g = pixels[_p + 1];
      bInSum += stackIn.b = pixels[_p + 2];
      aInSum += stackIn.a = pixels[_p + 3];
      rSum += rInSum;
      gSum += gInSum;
      bSum += bInSum;
      aSum += aInSum;
      stackIn = stackIn.next;
      var _stackOut = stackOut, _r = _stackOut.r, _g = _stackOut.g, _b2 = _stackOut.b, _a3 = _stackOut.a;
      rOutSum += _r;
      gOutSum += _g;
      bOutSum += _b2;
      aOutSum += _a3;
      rInSum -= _r;
      gInSum -= _g;
      bInSum -= _b2;
      aInSum -= _a3;
      stackOut = stackOut.next;
      yi += 4;
    }
    yw += width;
  }
  for (var _x = 0;_x < width; _x++) {
    yi = _x << 2;
    var _pr = pixels[yi], _pg = pixels[yi + 1], _pb = pixels[yi + 2], _pa = pixels[yi + 3], _rOutSum = radiusPlus1 * _pr, _gOutSum = radiusPlus1 * _pg, _bOutSum = radiusPlus1 * _pb, _aOutSum = radiusPlus1 * _pa, _rSum = sumFactor * _pr, _gSum = sumFactor * _pg, _bSum = sumFactor * _pb, _aSum = sumFactor * _pa;
    stack = stackStart;
    for (var _i3 = 0;_i3 < radiusPlus1; _i3++) {
      stack.r = _pr;
      stack.g = _pg;
      stack.b = _pb;
      stack.a = _pa;
      stack = stack.next;
    }
    var yp = width;
    var _gInSum = 0, _bInSum = 0, _aInSum = 0, _rInSum = 0;
    for (var _i4 = 1;_i4 <= radius; _i4++) {
      yi = yp + _x << 2;
      var _rbs = radiusPlus1 - _i4;
      _rSum += (stack.r = _pr = pixels[yi]) * _rbs;
      _gSum += (stack.g = _pg = pixels[yi + 1]) * _rbs;
      _bSum += (stack.b = _pb = pixels[yi + 2]) * _rbs;
      _aSum += (stack.a = _pa = pixels[yi + 3]) * _rbs;
      _rInSum += _pr;
      _gInSum += _pg;
      _bInSum += _pb;
      _aInSum += _pa;
      stack = stack.next;
      if (_i4 < heightMinus1) {
        yp += width;
      }
    }
    yi = _x;
    stackIn = stackStart;
    stackOut = stackEnd;
    for (var _y = 0;_y < height; _y++) {
      var _p2 = yi << 2;
      pixels[_p2 + 3] = _pa = _aSum * mulSum >>> shgSum;
      if (_pa > 0) {
        _pa = 255 / _pa;
        pixels[_p2] = (_rSum * mulSum >>> shgSum) * _pa;
        pixels[_p2 + 1] = (_gSum * mulSum >>> shgSum) * _pa;
        pixels[_p2 + 2] = (_bSum * mulSum >>> shgSum) * _pa;
      } else {
        pixels[_p2] = pixels[_p2 + 1] = pixels[_p2 + 2] = 0;
      }
      _rSum -= _rOutSum;
      _gSum -= _gOutSum;
      _bSum -= _bOutSum;
      _aSum -= _aOutSum;
      _rOutSum -= stackIn.r;
      _gOutSum -= stackIn.g;
      _bOutSum -= stackIn.b;
      _aOutSum -= stackIn.a;
      _p2 = _x + ((_p2 = _y + radiusPlus1) < heightMinus1 ? _p2 : heightMinus1) * width << 2;
      _rSum += _rInSum += stackIn.r = pixels[_p2];
      _gSum += _gInSum += stackIn.g = pixels[_p2 + 1];
      _bSum += _bInSum += stackIn.b = pixels[_p2 + 2];
      _aSum += _aInSum += stackIn.a = pixels[_p2 + 3];
      stackIn = stackIn.next;
      _rOutSum += _pr = stackOut.r;
      _gOutSum += _pg = stackOut.g;
      _bOutSum += _pb = stackOut.b;
      _aOutSum += _pa = stackOut.a;
      _rInSum -= _pr;
      _gInSum -= _pg;
      _bInSum -= _pb;
      _aInSum -= _pa;
      stackOut = stackOut.next;
      yi += width;
    }
  }
  return imageData;
}
var mulTable, shgTable, BlurStack = function BlurStack2() {
  _classCallCheck(this, BlurStack2);
  this.r = 0;
  this.g = 0;
  this.b = 0;
  this.a = 0;
  this.next = null;
};
var init_stackblur_es = __esm(() => {
  mulTable = [512, 512, 456, 512, 328, 456, 335, 512, 405, 328, 271, 456, 388, 335, 292, 512, 454, 405, 364, 328, 298, 271, 496, 456, 420, 388, 360, 335, 312, 292, 273, 512, 482, 454, 428, 405, 383, 364, 345, 328, 312, 298, 284, 271, 259, 496, 475, 456, 437, 420, 404, 388, 374, 360, 347, 335, 323, 312, 302, 292, 282, 273, 265, 512, 497, 482, 468, 454, 441, 428, 417, 405, 394, 383, 373, 364, 354, 345, 337, 328, 320, 312, 305, 298, 291, 284, 278, 271, 265, 259, 507, 496, 485, 475, 465, 456, 446, 437, 428, 420, 412, 404, 396, 388, 381, 374, 367, 360, 354, 347, 341, 335, 329, 323, 318, 312, 307, 302, 297, 292, 287, 282, 278, 273, 269, 265, 261, 512, 505, 497, 489, 482, 475, 468, 461, 454, 447, 441, 435, 428, 422, 417, 411, 405, 399, 394, 389, 383, 378, 373, 368, 364, 359, 354, 350, 345, 341, 337, 332, 328, 324, 320, 316, 312, 309, 305, 301, 298, 294, 291, 287, 284, 281, 278, 274, 271, 268, 265, 262, 259, 257, 507, 501, 496, 491, 485, 480, 475, 470, 465, 460, 456, 451, 446, 442, 437, 433, 428, 424, 420, 416, 412, 408, 404, 400, 396, 392, 388, 385, 381, 377, 374, 370, 367, 363, 360, 357, 354, 350, 347, 344, 341, 338, 335, 332, 329, 326, 323, 320, 318, 315, 312, 310, 307, 304, 302, 299, 297, 294, 292, 289, 287, 285, 282, 280, 278, 275, 273, 271, 269, 267, 265, 263, 261, 259];
  shgTable = [9, 11, 12, 13, 13, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16, 17, 17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 18, 18, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24];
});

// node_modules/canvg/lib/index.es.js
var exports_index_es = {};
__export(exports_index_es, {
  vectorsRatio: () => vectorsRatio,
  vectorsAngle: () => vectorsAngle,
  vectorMagnitude: () => vectorMagnitude,
  trimRight: () => trimRight,
  trimLeft: () => trimLeft,
  toNumbers: () => toNumbers,
  presets: () => index,
  parseExternalUrl: () => parseExternalUrl,
  normalizeColor: () => normalizeColor,
  normalizeAttributeName: () => normalizeAttributeName,
  getSelectorSpecificity: () => getSelectorSpecificity,
  default: () => Canvg,
  compressSpaces: () => compressSpaces,
  ViewPort: () => ViewPort,
  UseElement: () => UseElement,
  UnknownElement: () => UnknownElement,
  Translate: () => Translate,
  Transform: () => Transform2,
  TitleElement: () => TitleElement,
  TextPathElement: () => TextPathElement,
  TextElement: () => TextElement,
  TSpanElement: () => TSpanElement,
  TRefElement: () => TRefElement,
  SymbolElement: () => SymbolElement,
  StyleElement: () => StyleElement,
  StopElement: () => StopElement,
  SkewY: () => SkewY,
  SkewX: () => SkewX,
  Skew: () => Skew,
  Screen: () => Screen,
  Scale: () => Scale,
  SVGFontLoader: () => SVGFontLoader,
  SVGElement: () => SVGElement,
  Rotate: () => Rotate,
  RenderedElement: () => RenderedElement,
  RectElement: () => RectElement,
  RadialGradientElement: () => RadialGradientElement,
  QB3: () => QB3,
  QB2: () => QB2,
  QB1: () => QB1,
  Property: () => Property,
  PolylineElement: () => PolylineElement,
  PolygonElement: () => PolygonElement,
  Point: () => Point,
  PatternElement: () => PatternElement,
  PathParser: () => PathParser,
  PathElement: () => PathElement,
  Parser: () => Parser,
  PSEUDO_ZERO: () => PSEUDO_ZERO,
  Mouse: () => Mouse,
  MissingGlyphElement: () => MissingGlyphElement,
  Matrix: () => Matrix,
  MaskElement: () => MaskElement,
  MarkerElement: () => MarkerElement,
  LinearGradientElement: () => LinearGradientElement,
  LineElement: () => LineElement,
  ImageElement: () => ImageElement,
  GradientElement: () => GradientElement,
  GlyphElement: () => GlyphElement,
  GElement: () => GElement,
  FontFaceElement: () => FontFaceElement,
  FontElement: () => FontElement,
  Font: () => Font,
  FilterElement: () => FilterElement,
  FeMorphologyElement: () => FeMorphologyElement,
  FeGaussianBlurElement: () => FeGaussianBlurElement,
  FeDropShadowElement: () => FeDropShadowElement,
  FeCompositeElement: () => FeCompositeElement,
  FeColorMatrixElement: () => FeColorMatrixElement,
  EllipseElement: () => EllipseElement,
  Element: () => Element,
  Document: () => Document2,
  DescElement: () => DescElement,
  DefsElement: () => DefsElement,
  ClipPathElement: () => ClipPathElement,
  CircleElement: () => CircleElement,
  Canvg: () => Canvg,
  CB4: () => CB4,
  CB3: () => CB3,
  CB2: () => CB2,
  CB1: () => CB1,
  BoundingBox: () => BoundingBox,
  AnimateTransformElement: () => AnimateTransformElement,
  AnimateElement: () => AnimateElement,
  AnimateColorElement: () => AnimateColorElement,
  AElement: () => AElement
});
function offscreen() {
  var {
    DOMParser: DOMParserFallback
  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var preset = {
    window: null,
    ignoreAnimation: true,
    ignoreMouse: true,
    DOMParser: DOMParserFallback,
    createCanvas(width, height) {
      return new OffscreenCanvas(width, height);
    },
    createImage(url) {
      return _asyncToGenerator(function* () {
        var response = yield fetch(url);
        var blob = yield response.blob();
        var img = yield createImageBitmap(blob);
        return img;
      })();
    }
  };
  if (typeof DOMParser !== "undefined" || typeof DOMParserFallback === "undefined") {
    Reflect.deleteProperty(preset, "DOMParser");
  }
  return preset;
}
function node(_ref) {
  var {
    DOMParser: DOMParser3,
    canvas,
    fetch: fetch2
  } = _ref;
  return {
    window: null,
    ignoreAnimation: true,
    ignoreMouse: true,
    DOMParser: DOMParser3,
    fetch: fetch2,
    createCanvas: canvas.createCanvas,
    createImage: canvas.loadImage
  };
}
function compressSpaces(str) {
  return str.replace(/(?!\u3000)\s+/gm, " ");
}
function trimLeft(str) {
  return str.replace(/^[\n \t]+/, "");
}
function trimRight(str) {
  return str.replace(/[\n \t]+$/, "");
}
function toNumbers(str) {
  var matches2 = (str || "").match(/-?(\d+(?:\.\d*(?:[eE][+-]?\d+)?)?|\.\d+)(?=\D|$)/gm) || [];
  return matches2.map(parseFloat);
}
function normalizeAttributeName(name) {
  if (allUppercase.test(name)) {
    return name.toLowerCase();
  }
  return name;
}
function parseExternalUrl(url) {
  var urlMatch = /url\(('([^']+)'|"([^"]+)"|([^'")]+))\)/.exec(url) || [];
  return urlMatch[2] || urlMatch[3] || urlMatch[4];
}
function normalizeColor(color) {
  if (!color.startsWith("rgb")) {
    return color;
  }
  var rgbParts = 3;
  var normalizedColor = color.replace(/\d+(\.\d+)?/g, (num, isFloat) => rgbParts-- && isFloat ? String(Math.round(parseFloat(num))) : num);
  return normalizedColor;
}
function findSelectorMatch(selector, regex) {
  var matches2 = regex.exec(selector);
  if (!matches2) {
    return [selector, 0];
  }
  return [selector.replace(regex, " "), matches2.length];
}
function getSelectorSpecificity(selector) {
  var specificity = [0, 0, 0];
  var currentSelector = selector.replace(/:not\(([^)]*)\)/g, "     $1 ").replace(/{[\s\S]*/gm, " ");
  var delta = 0;
  [currentSelector, delta] = findSelectorMatch(currentSelector, attributeRegex);
  specificity[1] += delta;
  [currentSelector, delta] = findSelectorMatch(currentSelector, idRegex);
  specificity[0] += delta;
  [currentSelector, delta] = findSelectorMatch(currentSelector, classRegex);
  specificity[1] += delta;
  [currentSelector, delta] = findSelectorMatch(currentSelector, pseudoElementRegex);
  specificity[2] += delta;
  [currentSelector, delta] = findSelectorMatch(currentSelector, pseudoClassWithBracketsRegex);
  specificity[1] += delta;
  [currentSelector, delta] = findSelectorMatch(currentSelector, pseudoClassRegex);
  specificity[1] += delta;
  currentSelector = currentSelector.replace(/[*\s+>~]/g, " ").replace(/[#.]/g, " ");
  [currentSelector, delta] = findSelectorMatch(currentSelector, elementRegex);
  specificity[2] += delta;
  return specificity.join("");
}
function vectorMagnitude(v2) {
  return Math.sqrt(Math.pow(v2[0], 2) + Math.pow(v2[1], 2));
}
function vectorsRatio(u2, v2) {
  return (u2[0] * v2[0] + u2[1] * v2[1]) / (vectorMagnitude(u2) * vectorMagnitude(v2));
}
function vectorsAngle(u2, v2) {
  return (u2[0] * v2[1] < u2[1] * v2[0] ? -1 : 1) * Math.acos(vectorsRatio(u2, v2));
}
function CB1(t2) {
  return t2 * t2 * t2;
}
function CB2(t2) {
  return 3 * t2 * t2 * (1 - t2);
}
function CB3(t2) {
  return 3 * t2 * (1 - t2) * (1 - t2);
}
function CB4(t2) {
  return (1 - t2) * (1 - t2) * (1 - t2);
}
function QB1(t2) {
  return t2 * t2;
}
function QB2(t2) {
  return 2 * t2 * (1 - t2);
}
function QB3(t2) {
  return (1 - t2) * (1 - t2);
}

class Property {
  constructor(document2, name, value) {
    this.document = document2;
    this.name = name;
    this.value = value;
    this.isNormalizedColor = false;
  }
  static empty(document2) {
    return new Property(document2, "EMPTY", "");
  }
  split() {
    var separator = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : " ";
    var {
      document: document2,
      name
    } = this;
    return compressSpaces(this.getString()).trim().split(separator).map((value) => new Property(document2, name, value));
  }
  hasValue(zeroIsValue) {
    var {
      value
    } = this;
    return value !== null && value !== "" && (zeroIsValue || value !== 0) && typeof value !== "undefined";
  }
  isString(regexp) {
    var {
      value
    } = this;
    var result = typeof value === "string";
    if (!result || !regexp) {
      return result;
    }
    return regexp.test(value);
  }
  isUrlDefinition() {
    return this.isString(/^url\(/);
  }
  isPixels() {
    if (!this.hasValue()) {
      return false;
    }
    var asString = this.getString();
    switch (true) {
      case asString.endsWith("px"):
      case /^[0-9]+$/.test(asString):
        return true;
      default:
        return false;
    }
  }
  setValue(value) {
    this.value = value;
    return this;
  }
  getValue(def) {
    if (typeof def === "undefined" || this.hasValue()) {
      return this.value;
    }
    return def;
  }
  getNumber(def) {
    if (!this.hasValue()) {
      if (typeof def === "undefined") {
        return 0;
      }
      return parseFloat(def);
    }
    var {
      value
    } = this;
    var n2 = parseFloat(value);
    if (this.isString(/%$/)) {
      n2 /= 100;
    }
    return n2;
  }
  getString(def) {
    if (typeof def === "undefined" || this.hasValue()) {
      return typeof this.value === "undefined" ? "" : String(this.value);
    }
    return String(def);
  }
  getColor(def) {
    var color = this.getString(def);
    if (this.isNormalizedColor) {
      return color;
    }
    this.isNormalizedColor = true;
    color = normalizeColor(color);
    this.value = color;
    return color;
  }
  getDpi() {
    return 96;
  }
  getRem() {
    return this.document.rootEmSize;
  }
  getEm() {
    return this.document.emSize;
  }
  getUnits() {
    return this.getString().replace(/[0-9.-]/g, "");
  }
  getPixels(axisOrIsFontSize) {
    var processPercent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    if (!this.hasValue()) {
      return 0;
    }
    var [axis, isFontSize] = typeof axisOrIsFontSize === "boolean" ? [undefined, axisOrIsFontSize] : [axisOrIsFontSize];
    var {
      viewPort
    } = this.document.screen;
    switch (true) {
      case this.isString(/vmin$/):
        return this.getNumber() / 100 * Math.min(viewPort.computeSize("x"), viewPort.computeSize("y"));
      case this.isString(/vmax$/):
        return this.getNumber() / 100 * Math.max(viewPort.computeSize("x"), viewPort.computeSize("y"));
      case this.isString(/vw$/):
        return this.getNumber() / 100 * viewPort.computeSize("x");
      case this.isString(/vh$/):
        return this.getNumber() / 100 * viewPort.computeSize("y");
      case this.isString(/rem$/):
        return this.getNumber() * this.getRem();
      case this.isString(/em$/):
        return this.getNumber() * this.getEm();
      case this.isString(/ex$/):
        return this.getNumber() * this.getEm() / 2;
      case this.isString(/px$/):
        return this.getNumber();
      case this.isString(/pt$/):
        return this.getNumber() * this.getDpi() * (1 / 72);
      case this.isString(/pc$/):
        return this.getNumber() * 15;
      case this.isString(/cm$/):
        return this.getNumber() * this.getDpi() / 2.54;
      case this.isString(/mm$/):
        return this.getNumber() * this.getDpi() / 25.4;
      case this.isString(/in$/):
        return this.getNumber() * this.getDpi();
      case (this.isString(/%$/) && isFontSize):
        return this.getNumber() * this.getEm();
      case this.isString(/%$/):
        return this.getNumber() * viewPort.computeSize(axis);
      default: {
        var n2 = this.getNumber();
        if (processPercent && n2 < 1) {
          return n2 * viewPort.computeSize(axis);
        }
        return n2;
      }
    }
  }
  getMilliseconds() {
    if (!this.hasValue()) {
      return 0;
    }
    if (this.isString(/ms$/)) {
      return this.getNumber();
    }
    return this.getNumber() * 1000;
  }
  getRadians() {
    if (!this.hasValue()) {
      return 0;
    }
    switch (true) {
      case this.isString(/deg$/):
        return this.getNumber() * (Math.PI / 180);
      case this.isString(/grad$/):
        return this.getNumber() * (Math.PI / 200);
      case this.isString(/rad$/):
        return this.getNumber();
      default:
        return this.getNumber() * (Math.PI / 180);
    }
  }
  getDefinition() {
    var asString = this.getString();
    var name = /#([^)'"]+)/.exec(asString);
    if (name) {
      name = name[1];
    }
    if (!name) {
      name = asString;
    }
    return this.document.definitions[name];
  }
  getFillStyleDefinition(element, opacity) {
    var def = this.getDefinition();
    if (!def) {
      return null;
    }
    if (typeof def.createGradient === "function") {
      return def.createGradient(this.document.ctx, element, opacity);
    }
    if (typeof def.createPattern === "function") {
      if (def.getHrefAttribute().hasValue()) {
        var patternTransform = def.getAttribute("patternTransform");
        def = def.getHrefAttribute().getDefinition();
        if (patternTransform.hasValue()) {
          def.getAttribute("patternTransform", true).setValue(patternTransform.value);
        }
      }
      return def.createPattern(this.document.ctx, element, opacity);
    }
    return null;
  }
  getTextBaseline() {
    if (!this.hasValue()) {
      return null;
    }
    return Property.textBaselineMapping[this.getString()];
  }
  addOpacity(opacity) {
    var value = this.getColor();
    var len = value.length;
    var commas = 0;
    for (var i4 = 0;i4 < len; i4++) {
      if (value[i4] === ",") {
        commas++;
      }
      if (commas === 3) {
        break;
      }
    }
    if (opacity.hasValue() && this.isString() && commas !== 3) {
      var color = new import_rgbcolor.default(value);
      if (color.ok) {
        color.alpha = opacity.getNumber();
        value = color.toRGBA();
      }
    }
    return new Property(this.document, this.name, value);
  }
}

class ViewPort {
  constructor() {
    this.viewPorts = [];
  }
  clear() {
    this.viewPorts = [];
  }
  setCurrent(width, height) {
    this.viewPorts.push({
      width,
      height
    });
  }
  removeCurrent() {
    this.viewPorts.pop();
  }
  getCurrent() {
    var {
      viewPorts
    } = this;
    return viewPorts[viewPorts.length - 1];
  }
  get width() {
    return this.getCurrent().width;
  }
  get height() {
    return this.getCurrent().height;
  }
  computeSize(d) {
    if (typeof d === "number") {
      return d;
    }
    if (d === "x") {
      return this.width;
    }
    if (d === "y") {
      return this.height;
    }
    return Math.sqrt(Math.pow(this.width, 2) + Math.pow(this.height, 2)) / Math.sqrt(2);
  }
}

class Point {
  constructor(x2, y2) {
    this.x = x2;
    this.y = y2;
  }
  static parse(point) {
    var defaultValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var [x2 = defaultValue, y2 = defaultValue] = toNumbers(point);
    return new Point(x2, y2);
  }
  static parseScale(scale) {
    var defaultValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    var [x2 = defaultValue, y2 = x2] = toNumbers(scale);
    return new Point(x2, y2);
  }
  static parsePath(path) {
    var points = toNumbers(path);
    var len = points.length;
    var pathPoints = [];
    for (var i4 = 0;i4 < len; i4 += 2) {
      pathPoints.push(new Point(points[i4], points[i4 + 1]));
    }
    return pathPoints;
  }
  angleTo(point) {
    return Math.atan2(point.y - this.y, point.x - this.x);
  }
  applyTransform(transform) {
    var {
      x: x2,
      y: y2
    } = this;
    var xp = x2 * transform[0] + y2 * transform[2] + transform[4];
    var yp = x2 * transform[1] + y2 * transform[3] + transform[5];
    this.x = xp;
    this.y = yp;
  }
}

class Mouse {
  constructor(screen) {
    this.screen = screen;
    this.working = false;
    this.events = [];
    this.eventElements = [];
    this.onClick = this.onClick.bind(this);
    this.onMouseMove = this.onMouseMove.bind(this);
  }
  isWorking() {
    return this.working;
  }
  start() {
    if (this.working) {
      return;
    }
    var {
      screen,
      onClick,
      onMouseMove
    } = this;
    var canvas = screen.ctx.canvas;
    canvas.onclick = onClick;
    canvas.onmousemove = onMouseMove;
    this.working = true;
  }
  stop() {
    if (!this.working) {
      return;
    }
    var canvas = this.screen.ctx.canvas;
    this.working = false;
    canvas.onclick = null;
    canvas.onmousemove = null;
  }
  hasEvents() {
    return this.working && this.events.length > 0;
  }
  runEvents() {
    if (!this.working) {
      return;
    }
    var {
      screen: document2,
      events,
      eventElements
    } = this;
    var {
      style: style2
    } = document2.ctx.canvas;
    if (style2) {
      style2.cursor = "";
    }
    events.forEach((_ref, i4) => {
      var {
        run: run2
      } = _ref;
      var element = eventElements[i4];
      while (element) {
        run2(element);
        element = element.parent;
      }
    });
    this.events = [];
    this.eventElements = [];
  }
  checkPath(element, ctx) {
    if (!this.working || !ctx) {
      return;
    }
    var {
      events,
      eventElements
    } = this;
    events.forEach((_ref2, i4) => {
      var {
        x: x2,
        y: y2
      } = _ref2;
      if (!eventElements[i4] && ctx.isPointInPath && ctx.isPointInPath(x2, y2)) {
        eventElements[i4] = element;
      }
    });
  }
  checkBoundingBox(element, boundingBox) {
    if (!this.working || !boundingBox) {
      return;
    }
    var {
      events,
      eventElements
    } = this;
    events.forEach((_ref3, i4) => {
      var {
        x: x2,
        y: y2
      } = _ref3;
      if (!eventElements[i4] && boundingBox.isPointInBox(x2, y2)) {
        eventElements[i4] = element;
      }
    });
  }
  mapXY(x2, y2) {
    var {
      window: window2,
      ctx
    } = this.screen;
    var point = new Point(x2, y2);
    var element = ctx.canvas;
    while (element) {
      point.x -= element.offsetLeft;
      point.y -= element.offsetTop;
      element = element.offsetParent;
    }
    if (window2.scrollX) {
      point.x += window2.scrollX;
    }
    if (window2.scrollY) {
      point.y += window2.scrollY;
    }
    return point;
  }
  onClick(event) {
    var {
      x: x2,
      y: y2
    } = this.mapXY(event.clientX, event.clientY);
    this.events.push({
      type: "onclick",
      x: x2,
      y: y2,
      run(eventTarget) {
        if (eventTarget.onClick) {
          eventTarget.onClick();
        }
      }
    });
  }
  onMouseMove(event) {
    var {
      x: x2,
      y: y2
    } = this.mapXY(event.clientX, event.clientY);
    this.events.push({
      type: "onmousemove",
      x: x2,
      y: y2,
      run(eventTarget) {
        if (eventTarget.onMouseMove) {
          eventTarget.onMouseMove();
        }
      }
    });
  }
}

class Screen {
  constructor(ctx) {
    var {
      fetch: fetch2 = defaultFetch$1,
      window: window2 = defaultWindow
    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    this.ctx = ctx;
    this.FRAMERATE = 30;
    this.MAX_VIRTUAL_PIXELS = 30000;
    this.CLIENT_WIDTH = 800;
    this.CLIENT_HEIGHT = 600;
    this.viewPort = new ViewPort;
    this.mouse = new Mouse(this);
    this.animations = [];
    this.waits = [];
    this.frameDuration = 0;
    this.isReadyLock = false;
    this.isFirstRender = true;
    this.intervalId = null;
    this.window = window2;
    this.fetch = fetch2;
  }
  wait(checker) {
    this.waits.push(checker);
  }
  ready() {
    if (!this.readyPromise) {
      return Promise.resolve();
    }
    return this.readyPromise;
  }
  isReady() {
    if (this.isReadyLock) {
      return true;
    }
    var isReadyLock = this.waits.every((_2) => _2());
    if (isReadyLock) {
      this.waits = [];
      if (this.resolveReady) {
        this.resolveReady();
      }
    }
    this.isReadyLock = isReadyLock;
    return isReadyLock;
  }
  setDefaults(ctx) {
    ctx.strokeStyle = "rgba(0,0,0,0)";
    ctx.lineCap = "butt";
    ctx.lineJoin = "miter";
    ctx.miterLimit = 4;
  }
  setViewBox(_ref) {
    var {
      document: document2,
      ctx,
      aspectRatio,
      width,
      desiredWidth,
      height,
      desiredHeight,
      minX = 0,
      minY = 0,
      refX,
      refY,
      clip = false,
      clipX = 0,
      clipY = 0
    } = _ref;
    var cleanAspectRatio = compressSpaces(aspectRatio).replace(/^defer\s/, "");
    var [aspectRatioAlign, aspectRatioMeetOrSlice] = cleanAspectRatio.split(" ");
    var align = aspectRatioAlign || "xMidYMid";
    var meetOrSlice = aspectRatioMeetOrSlice || "meet";
    var scaleX = width / desiredWidth;
    var scaleY = height / desiredHeight;
    var scaleMin = Math.min(scaleX, scaleY);
    var scaleMax = Math.max(scaleX, scaleY);
    var finalDesiredWidth = desiredWidth;
    var finalDesiredHeight = desiredHeight;
    if (meetOrSlice === "meet") {
      finalDesiredWidth *= scaleMin;
      finalDesiredHeight *= scaleMin;
    }
    if (meetOrSlice === "slice") {
      finalDesiredWidth *= scaleMax;
      finalDesiredHeight *= scaleMax;
    }
    var refXProp = new Property(document2, "refX", refX);
    var refYProp = new Property(document2, "refY", refY);
    var hasRefs = refXProp.hasValue() && refYProp.hasValue();
    if (hasRefs) {
      ctx.translate(-scaleMin * refXProp.getPixels("x"), -scaleMin * refYProp.getPixels("y"));
    }
    if (clip) {
      var scaledClipX = scaleMin * clipX;
      var scaledClipY = scaleMin * clipY;
      ctx.beginPath();
      ctx.moveTo(scaledClipX, scaledClipY);
      ctx.lineTo(width, scaledClipY);
      ctx.lineTo(width, height);
      ctx.lineTo(scaledClipX, height);
      ctx.closePath();
      ctx.clip();
    }
    if (!hasRefs) {
      var isMeetMinY = meetOrSlice === "meet" && scaleMin === scaleY;
      var isSliceMaxY = meetOrSlice === "slice" && scaleMax === scaleY;
      var isMeetMinX = meetOrSlice === "meet" && scaleMin === scaleX;
      var isSliceMaxX = meetOrSlice === "slice" && scaleMax === scaleX;
      if (align.startsWith("xMid") && (isMeetMinY || isSliceMaxY)) {
        ctx.translate(width / 2 - finalDesiredWidth / 2, 0);
      }
      if (align.endsWith("YMid") && (isMeetMinX || isSliceMaxX)) {
        ctx.translate(0, height / 2 - finalDesiredHeight / 2);
      }
      if (align.startsWith("xMax") && (isMeetMinY || isSliceMaxY)) {
        ctx.translate(width - finalDesiredWidth, 0);
      }
      if (align.endsWith("YMax") && (isMeetMinX || isSliceMaxX)) {
        ctx.translate(0, height - finalDesiredHeight);
      }
    }
    switch (true) {
      case align === "none":
        ctx.scale(scaleX, scaleY);
        break;
      case meetOrSlice === "meet":
        ctx.scale(scaleMin, scaleMin);
        break;
      case meetOrSlice === "slice":
        ctx.scale(scaleMax, scaleMax);
        break;
    }
    ctx.translate(-minX, -minY);
  }
  start(element) {
    var {
      enableRedraw = false,
      ignoreMouse = false,
      ignoreAnimation = false,
      ignoreDimensions = false,
      ignoreClear = false,
      forceRedraw,
      scaleWidth,
      scaleHeight,
      offsetX,
      offsetY
    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var {
      FRAMERATE,
      mouse
    } = this;
    var frameDuration = 1000 / FRAMERATE;
    this.frameDuration = frameDuration;
    this.readyPromise = new Promise((resolve) => {
      this.resolveReady = resolve;
    });
    if (this.isReady()) {
      this.render(element, ignoreDimensions, ignoreClear, scaleWidth, scaleHeight, offsetX, offsetY);
    }
    if (!enableRedraw) {
      return;
    }
    var now = Date.now();
    var then = now;
    var delta = 0;
    var tick = () => {
      now = Date.now();
      delta = now - then;
      if (delta >= frameDuration) {
        then = now - delta % frameDuration;
        if (this.shouldUpdate(ignoreAnimation, forceRedraw)) {
          this.render(element, ignoreDimensions, ignoreClear, scaleWidth, scaleHeight, offsetX, offsetY);
          mouse.runEvents();
        }
      }
      this.intervalId = import_raf.default(tick);
    };
    if (!ignoreMouse) {
      mouse.start();
    }
    this.intervalId = import_raf.default(tick);
  }
  stop() {
    if (this.intervalId) {
      import_raf.default.cancel(this.intervalId);
      this.intervalId = null;
    }
    this.mouse.stop();
  }
  shouldUpdate(ignoreAnimation, forceRedraw) {
    if (!ignoreAnimation) {
      var {
        frameDuration
      } = this;
      var shouldUpdate = this.animations.reduce((shouldUpdate2, animation) => animation.update(frameDuration) || shouldUpdate2, false);
      if (shouldUpdate) {
        return true;
      }
    }
    if (typeof forceRedraw === "function" && forceRedraw()) {
      return true;
    }
    if (!this.isReadyLock && this.isReady()) {
      return true;
    }
    if (this.mouse.hasEvents()) {
      return true;
    }
    return false;
  }
  render(element, ignoreDimensions, ignoreClear, scaleWidth, scaleHeight, offsetX, offsetY) {
    var {
      CLIENT_WIDTH,
      CLIENT_HEIGHT,
      viewPort,
      ctx,
      isFirstRender
    } = this;
    var canvas = ctx.canvas;
    viewPort.clear();
    if (canvas.width && canvas.height) {
      viewPort.setCurrent(canvas.width, canvas.height);
    } else {
      viewPort.setCurrent(CLIENT_WIDTH, CLIENT_HEIGHT);
    }
    var widthStyle = element.getStyle("width");
    var heightStyle = element.getStyle("height");
    if (!ignoreDimensions && (isFirstRender || typeof scaleWidth !== "number" && typeof scaleHeight !== "number")) {
      if (widthStyle.hasValue()) {
        canvas.width = widthStyle.getPixels("x");
        if (canvas.style) {
          canvas.style.width = "".concat(canvas.width, "px");
        }
      }
      if (heightStyle.hasValue()) {
        canvas.height = heightStyle.getPixels("y");
        if (canvas.style) {
          canvas.style.height = "".concat(canvas.height, "px");
        }
      }
    }
    var cWidth = canvas.clientWidth || canvas.width;
    var cHeight = canvas.clientHeight || canvas.height;
    if (ignoreDimensions && widthStyle.hasValue() && heightStyle.hasValue()) {
      cWidth = widthStyle.getPixels("x");
      cHeight = heightStyle.getPixels("y");
    }
    viewPort.setCurrent(cWidth, cHeight);
    if (typeof offsetX === "number") {
      element.getAttribute("x", true).setValue(offsetX);
    }
    if (typeof offsetY === "number") {
      element.getAttribute("y", true).setValue(offsetY);
    }
    if (typeof scaleWidth === "number" || typeof scaleHeight === "number") {
      var viewBox = toNumbers(element.getAttribute("viewBox").getString());
      var xRatio = 0;
      var yRatio = 0;
      if (typeof scaleWidth === "number") {
        var _widthStyle = element.getStyle("width");
        if (_widthStyle.hasValue()) {
          xRatio = _widthStyle.getPixels("x") / scaleWidth;
        } else if (!isNaN(viewBox[2])) {
          xRatio = viewBox[2] / scaleWidth;
        }
      }
      if (typeof scaleHeight === "number") {
        var _heightStyle = element.getStyle("height");
        if (_heightStyle.hasValue()) {
          yRatio = _heightStyle.getPixels("y") / scaleHeight;
        } else if (!isNaN(viewBox[3])) {
          yRatio = viewBox[3] / scaleHeight;
        }
      }
      if (!xRatio) {
        xRatio = yRatio;
      }
      if (!yRatio) {
        yRatio = xRatio;
      }
      element.getAttribute("width", true).setValue(scaleWidth);
      element.getAttribute("height", true).setValue(scaleHeight);
      var transformStyle = element.getStyle("transform", true, true);
      transformStyle.setValue("".concat(transformStyle.getString(), " scale(").concat(1 / xRatio, ", ").concat(1 / yRatio, ")"));
    }
    if (!ignoreClear) {
      ctx.clearRect(0, 0, cWidth, cHeight);
    }
    element.render(ctx);
    if (isFirstRender) {
      this.isFirstRender = false;
    }
  }
}

class Parser {
  constructor() {
    var {
      fetch: fetch2 = defaultFetch,
      DOMParser: DOMParser3 = DefaultDOMParser
    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    this.fetch = fetch2;
    this.DOMParser = DOMParser3;
  }
  parse(resource) {
    var _this = this;
    return _asyncToGenerator(function* () {
      if (resource.startsWith("<")) {
        return _this.parseFromString(resource);
      }
      return _this.load(resource);
    })();
  }
  parseFromString(xml) {
    var parser = new this.DOMParser;
    try {
      return this.checkDocument(parser.parseFromString(xml, "image/svg+xml"));
    } catch (err2) {
      return this.checkDocument(parser.parseFromString(xml, "text/xml"));
    }
  }
  checkDocument(document2) {
    var parserError = document2.getElementsByTagName("parsererror")[0];
    if (parserError) {
      throw new Error(parserError.textContent);
    }
    return document2;
  }
  load(url) {
    var _this2 = this;
    return _asyncToGenerator(function* () {
      var response = yield _this2.fetch(url);
      var xml = yield response.text();
      return _this2.parseFromString(xml);
    })();
  }
}

class Translate {
  constructor(_2, point) {
    this.type = "translate";
    this.point = null;
    this.point = Point.parse(point);
  }
  apply(ctx) {
    var {
      x: x2,
      y: y2
    } = this.point;
    ctx.translate(x2 || 0, y2 || 0);
  }
  unapply(ctx) {
    var {
      x: x2,
      y: y2
    } = this.point;
    ctx.translate(-1 * x2 || 0, -1 * y2 || 0);
  }
  applyToPoint(point) {
    var {
      x: x2,
      y: y2
    } = this.point;
    point.applyTransform([1, 0, 0, 1, x2 || 0, y2 || 0]);
  }
}

class Rotate {
  constructor(document2, rotate, transformOrigin) {
    this.type = "rotate";
    this.angle = null;
    this.originX = null;
    this.originY = null;
    this.cx = 0;
    this.cy = 0;
    var numbers = toNumbers(rotate);
    this.angle = new Property(document2, "angle", numbers[0]);
    this.originX = transformOrigin[0];
    this.originY = transformOrigin[1];
    this.cx = numbers[1] || 0;
    this.cy = numbers[2] || 0;
  }
  apply(ctx) {
    var {
      cx,
      cy,
      originX,
      originY,
      angle
    } = this;
    var tx = cx + originX.getPixels("x");
    var ty = cy + originY.getPixels("y");
    ctx.translate(tx, ty);
    ctx.rotate(angle.getRadians());
    ctx.translate(-tx, -ty);
  }
  unapply(ctx) {
    var {
      cx,
      cy,
      originX,
      originY,
      angle
    } = this;
    var tx = cx + originX.getPixels("x");
    var ty = cy + originY.getPixels("y");
    ctx.translate(tx, ty);
    ctx.rotate(-1 * angle.getRadians());
    ctx.translate(-tx, -ty);
  }
  applyToPoint(point) {
    var {
      cx,
      cy,
      angle
    } = this;
    var rad = angle.getRadians();
    point.applyTransform([
      1,
      0,
      0,
      1,
      cx || 0,
      cy || 0
    ]);
    point.applyTransform([Math.cos(rad), Math.sin(rad), -Math.sin(rad), Math.cos(rad), 0, 0]);
    point.applyTransform([
      1,
      0,
      0,
      1,
      -cx || 0,
      -cy || 0
    ]);
  }
}

class Scale {
  constructor(_2, scale, transformOrigin) {
    this.type = "scale";
    this.scale = null;
    this.originX = null;
    this.originY = null;
    var scaleSize = Point.parseScale(scale);
    if (scaleSize.x === 0 || scaleSize.y === 0) {
      scaleSize.x = PSEUDO_ZERO;
      scaleSize.y = PSEUDO_ZERO;
    }
    this.scale = scaleSize;
    this.originX = transformOrigin[0];
    this.originY = transformOrigin[1];
  }
  apply(ctx) {
    var {
      scale: {
        x: x2,
        y: y2
      },
      originX,
      originY
    } = this;
    var tx = originX.getPixels("x");
    var ty = originY.getPixels("y");
    ctx.translate(tx, ty);
    ctx.scale(x2, y2 || x2);
    ctx.translate(-tx, -ty);
  }
  unapply(ctx) {
    var {
      scale: {
        x: x2,
        y: y2
      },
      originX,
      originY
    } = this;
    var tx = originX.getPixels("x");
    var ty = originY.getPixels("y");
    ctx.translate(tx, ty);
    ctx.scale(1 / x2, 1 / y2 || x2);
    ctx.translate(-tx, -ty);
  }
  applyToPoint(point) {
    var {
      x: x2,
      y: y2
    } = this.scale;
    point.applyTransform([x2 || 0, 0, 0, y2 || 0, 0, 0]);
  }
}

class Matrix {
  constructor(_2, matrix, transformOrigin) {
    this.type = "matrix";
    this.matrix = [];
    this.originX = null;
    this.originY = null;
    this.matrix = toNumbers(matrix);
    this.originX = transformOrigin[0];
    this.originY = transformOrigin[1];
  }
  apply(ctx) {
    var {
      originX,
      originY,
      matrix
    } = this;
    var tx = originX.getPixels("x");
    var ty = originY.getPixels("y");
    ctx.translate(tx, ty);
    ctx.transform(matrix[0], matrix[1], matrix[2], matrix[3], matrix[4], matrix[5]);
    ctx.translate(-tx, -ty);
  }
  unapply(ctx) {
    var {
      originX,
      originY,
      matrix
    } = this;
    var a2 = matrix[0];
    var b = matrix[2];
    var c2 = matrix[4];
    var d = matrix[1];
    var e2 = matrix[3];
    var f2 = matrix[5];
    var g = 0;
    var h2 = 0;
    var i4 = 1;
    var det = 1 / (a2 * (e2 * i4 - f2 * h2) - b * (d * i4 - f2 * g) + c2 * (d * h2 - e2 * g));
    var tx = originX.getPixels("x");
    var ty = originY.getPixels("y");
    ctx.translate(tx, ty);
    ctx.transform(det * (e2 * i4 - f2 * h2), det * (f2 * g - d * i4), det * (c2 * h2 - b * i4), det * (a2 * i4 - c2 * g), det * (b * f2 - c2 * e2), det * (c2 * d - a2 * f2));
    ctx.translate(-tx, -ty);
  }
  applyToPoint(point) {
    point.applyTransform(this.matrix);
  }
}
function parseTransforms(transform) {
  return compressSpaces(transform).trim().replace(/\)([a-zA-Z])/g, ") $1").replace(/\)(\s?,\s?)/g, ") ").split(/\s(?=[a-z])/);
}
function parseTransform(transform) {
  var [type, value] = transform.split("(");
  return [type.trim(), value.trim().replace(")", "")];
}

class Transform2 {
  constructor(document2, transform, transformOrigin) {
    this.document = document2;
    this.transforms = [];
    var data = parseTransforms(transform);
    data.forEach((transform2) => {
      if (transform2 === "none") {
        return;
      }
      var [type, value] = parseTransform(transform2);
      var TransformType = Transform2.transformTypes[type];
      if (typeof TransformType !== "undefined") {
        this.transforms.push(new TransformType(this.document, value, transformOrigin));
      }
    });
  }
  static fromElement(document2, element) {
    var transformStyle = element.getStyle("transform", false, true);
    var [transformOriginXProperty, transformOriginYProperty = transformOriginXProperty] = element.getStyle("transform-origin", false, true).split();
    var transformOrigin = [transformOriginXProperty, transformOriginYProperty];
    if (transformStyle.hasValue()) {
      return new Transform2(document2, transformStyle.getString(), transformOrigin);
    }
    return null;
  }
  apply(ctx) {
    var {
      transforms
    } = this;
    var len = transforms.length;
    for (var i4 = 0;i4 < len; i4++) {
      transforms[i4].apply(ctx);
    }
  }
  unapply(ctx) {
    var {
      transforms
    } = this;
    var len = transforms.length;
    for (var i4 = len - 1;i4 >= 0; i4--) {
      transforms[i4].unapply(ctx);
    }
  }
  applyToPoint(point) {
    var {
      transforms
    } = this;
    var len = transforms.length;
    for (var i4 = 0;i4 < len; i4++) {
      transforms[i4].applyToPoint(point);
    }
  }
}

class Element {
  constructor(document2, node2) {
    var captureTextNodes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    this.document = document2;
    this.node = node2;
    this.captureTextNodes = captureTextNodes;
    this.attributes = Object.create(null);
    this.styles = Object.create(null);
    this.stylesSpecificity = Object.create(null);
    this.animationFrozen = false;
    this.animationFrozenValue = "";
    this.parent = null;
    this.children = [];
    if (!node2 || node2.nodeType !== 1) {
      return;
    }
    Array.from(node2.attributes).forEach((attribute) => {
      var nodeName = normalizeAttributeName(attribute.nodeName);
      this.attributes[nodeName] = new Property(document2, nodeName, attribute.value);
    });
    this.addStylesFromStyleDefinition();
    if (this.getAttribute("style").hasValue()) {
      var styles = this.getAttribute("style").getString().split(";").map((_2) => _2.trim());
      styles.forEach((style2) => {
        if (!style2) {
          return;
        }
        var [name, value] = style2.split(":").map((_2) => _2.trim());
        this.styles[name] = new Property(document2, name, value);
      });
    }
    var {
      definitions
    } = document2;
    var id = this.getAttribute("id");
    if (id.hasValue()) {
      if (!definitions[id.getString()]) {
        definitions[id.getString()] = this;
      }
    }
    Array.from(node2.childNodes).forEach((childNode) => {
      if (childNode.nodeType === 1) {
        this.addChild(childNode);
      } else if (captureTextNodes && (childNode.nodeType === 3 || childNode.nodeType === 4)) {
        var textNode = document2.createTextNode(childNode);
        if (textNode.getText().length > 0) {
          this.addChild(textNode);
        }
      }
    });
  }
  getAttribute(name) {
    var createIfNotExists = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    var attr = this.attributes[name];
    if (!attr && createIfNotExists) {
      var _attr = new Property(this.document, name, "");
      this.attributes[name] = _attr;
      return _attr;
    }
    return attr || Property.empty(this.document);
  }
  getHrefAttribute() {
    for (var key in this.attributes) {
      if (key === "href" || key.endsWith(":href")) {
        return this.attributes[key];
      }
    }
    return Property.empty(this.document);
  }
  getStyle(name) {
    var createIfNotExists = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    var skipAncestors = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    var style2 = this.styles[name];
    if (style2) {
      return style2;
    }
    var attr = this.getAttribute(name);
    if (attr !== null && attr !== undefined && attr.hasValue()) {
      this.styles[name] = attr;
      return attr;
    }
    if (!skipAncestors) {
      var {
        parent
      } = this;
      if (parent) {
        var parentStyle = parent.getStyle(name);
        if (parentStyle !== null && parentStyle !== undefined && parentStyle.hasValue()) {
          return parentStyle;
        }
      }
    }
    if (createIfNotExists) {
      var _style = new Property(this.document, name, "");
      this.styles[name] = _style;
      return _style;
    }
    return style2 || Property.empty(this.document);
  }
  render(ctx) {
    if (this.getStyle("display").getString() === "none" || this.getStyle("visibility").getString() === "hidden") {
      return;
    }
    ctx.save();
    if (this.getStyle("mask").hasValue()) {
      var mask = this.getStyle("mask").getDefinition();
      if (mask) {
        this.applyEffects(ctx);
        mask.apply(ctx, this);
      }
    } else if (this.getStyle("filter").getValue("none") !== "none") {
      var filter = this.getStyle("filter").getDefinition();
      if (filter) {
        this.applyEffects(ctx);
        filter.apply(ctx, this);
      }
    } else {
      this.setContext(ctx);
      this.renderChildren(ctx);
      this.clearContext(ctx);
    }
    ctx.restore();
  }
  setContext(_2) {}
  applyEffects(ctx) {
    var transform = Transform2.fromElement(this.document, this);
    if (transform) {
      transform.apply(ctx);
    }
    var clipPathStyleProp = this.getStyle("clip-path", false, true);
    if (clipPathStyleProp.hasValue()) {
      var clip = clipPathStyleProp.getDefinition();
      if (clip) {
        clip.apply(ctx);
      }
    }
  }
  clearContext(_2) {}
  renderChildren(ctx) {
    this.children.forEach((child) => {
      child.render(ctx);
    });
  }
  addChild(childNode) {
    var child = childNode instanceof Element ? childNode : this.document.createElement(childNode);
    child.parent = this;
    if (!Element.ignoreChildTypes.includes(child.type)) {
      this.children.push(child);
    }
  }
  matchesSelector(selector) {
    var _node$getAttribute;
    var {
      node: node2
    } = this;
    if (typeof node2.matches === "function") {
      return node2.matches(selector);
    }
    var styleClasses = (_node$getAttribute = node2.getAttribute) === null || _node$getAttribute === undefined ? undefined : _node$getAttribute.call(node2, "class");
    if (!styleClasses || styleClasses === "") {
      return false;
    }
    return styleClasses.split(" ").some((styleClass) => ".".concat(styleClass) === selector);
  }
  addStylesFromStyleDefinition() {
    var {
      styles,
      stylesSpecificity
    } = this.document;
    for (var selector in styles) {
      if (!selector.startsWith("@") && this.matchesSelector(selector)) {
        var style2 = styles[selector];
        var specificity = stylesSpecificity[selector];
        if (style2) {
          for (var name in style2) {
            var existingSpecificity = this.stylesSpecificity[name];
            if (typeof existingSpecificity === "undefined") {
              existingSpecificity = "000";
            }
            if (specificity >= existingSpecificity) {
              this.styles[name] = style2[name];
              this.stylesSpecificity[name] = specificity;
            }
          }
        }
      }
    }
  }
  removeStyles(element, ignoreStyles) {
    var toRestore = ignoreStyles.reduce((toRestore2, name) => {
      var styleProp = element.getStyle(name);
      if (!styleProp.hasValue()) {
        return toRestore2;
      }
      var value = styleProp.getString();
      styleProp.setValue("");
      return [...toRestore2, [name, value]];
    }, []);
    return toRestore;
  }
  restoreStyles(element, styles) {
    styles.forEach((_ref) => {
      var [name, value] = _ref;
      element.getStyle(name, true).setValue(value);
    });
  }
  isFirstChild() {
    var _this$parent;
    return ((_this$parent = this.parent) === null || _this$parent === undefined ? undefined : _this$parent.children.indexOf(this)) === 0;
  }
}
function wrapFontFamily(fontFamily) {
  var trimmed = fontFamily.trim();
  return /^('|")/.test(trimmed) ? trimmed : '"'.concat(trimmed, '"');
}
function prepareFontFamily(fontFamily) {
  return typeof process === "undefined" ? fontFamily : fontFamily.trim().split(",").map(wrapFontFamily).join(",");
}
function prepareFontStyle(fontStyle) {
  if (!fontStyle) {
    return "";
  }
  var targetFontStyle = fontStyle.trim().toLowerCase();
  switch (targetFontStyle) {
    case "normal":
    case "italic":
    case "oblique":
    case "inherit":
    case "initial":
    case "unset":
      return targetFontStyle;
    default:
      if (/^oblique\s+(-|)\d+deg$/.test(targetFontStyle)) {
        return targetFontStyle;
      }
      return "";
  }
}
function prepareFontWeight(fontWeight) {
  if (!fontWeight) {
    return "";
  }
  var targetFontWeight = fontWeight.trim().toLowerCase();
  switch (targetFontWeight) {
    case "normal":
    case "bold":
    case "lighter":
    case "bolder":
    case "inherit":
    case "initial":
    case "unset":
      return targetFontWeight;
    default:
      if (/^[\d.]+$/.test(targetFontWeight)) {
        return targetFontWeight;
      }
      return "";
  }
}

class Font {
  constructor(fontStyle, fontVariant, fontWeight, fontSize, fontFamily, inherit) {
    var inheritFont = inherit ? typeof inherit === "string" ? Font.parse(inherit) : inherit : {};
    this.fontFamily = fontFamily || inheritFont.fontFamily;
    this.fontSize = fontSize || inheritFont.fontSize;
    this.fontStyle = fontStyle || inheritFont.fontStyle;
    this.fontWeight = fontWeight || inheritFont.fontWeight;
    this.fontVariant = fontVariant || inheritFont.fontVariant;
  }
  static parse() {
    var font = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
    var inherit = arguments.length > 1 ? arguments[1] : undefined;
    var fontStyle = "";
    var fontVariant = "";
    var fontWeight = "";
    var fontSize = "";
    var fontFamily = "";
    var parts = compressSpaces(font).trim().split(" ");
    var set = {
      fontSize: false,
      fontStyle: false,
      fontWeight: false,
      fontVariant: false
    };
    parts.forEach((part) => {
      switch (true) {
        case (!set.fontStyle && Font.styles.includes(part)):
          if (part !== "inherit") {
            fontStyle = part;
          }
          set.fontStyle = true;
          break;
        case (!set.fontVariant && Font.variants.includes(part)):
          if (part !== "inherit") {
            fontVariant = part;
          }
          set.fontStyle = true;
          set.fontVariant = true;
          break;
        case (!set.fontWeight && Font.weights.includes(part)):
          if (part !== "inherit") {
            fontWeight = part;
          }
          set.fontStyle = true;
          set.fontVariant = true;
          set.fontWeight = true;
          break;
        case !set.fontSize:
          if (part !== "inherit") {
            [fontSize] = part.split("/");
          }
          set.fontStyle = true;
          set.fontVariant = true;
          set.fontWeight = true;
          set.fontSize = true;
          break;
        default:
          if (part !== "inherit") {
            fontFamily += part;
          }
      }
    });
    return new Font(fontStyle, fontVariant, fontWeight, fontSize, fontFamily, inherit);
  }
  toString() {
    return [
      prepareFontStyle(this.fontStyle),
      this.fontVariant,
      prepareFontWeight(this.fontWeight),
      this.fontSize,
      prepareFontFamily(this.fontFamily)
    ].join(" ").trim();
  }
}

class BoundingBox {
  constructor() {
    var x1 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Number.NaN;
    var y1 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Number.NaN;
    var x2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Number.NaN;
    var y2 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Number.NaN;
    this.x1 = x1;
    this.y1 = y1;
    this.x2 = x2;
    this.y2 = y2;
    this.addPoint(x1, y1);
    this.addPoint(x2, y2);
  }
  get x() {
    return this.x1;
  }
  get y() {
    return this.y1;
  }
  get width() {
    return this.x2 - this.x1;
  }
  get height() {
    return this.y2 - this.y1;
  }
  addPoint(x2, y2) {
    if (typeof x2 !== "undefined") {
      if (isNaN(this.x1) || isNaN(this.x2)) {
        this.x1 = x2;
        this.x2 = x2;
      }
      if (x2 < this.x1) {
        this.x1 = x2;
      }
      if (x2 > this.x2) {
        this.x2 = x2;
      }
    }
    if (typeof y2 !== "undefined") {
      if (isNaN(this.y1) || isNaN(this.y2)) {
        this.y1 = y2;
        this.y2 = y2;
      }
      if (y2 < this.y1) {
        this.y1 = y2;
      }
      if (y2 > this.y2) {
        this.y2 = y2;
      }
    }
  }
  addX(x2) {
    this.addPoint(x2, null);
  }
  addY(y2) {
    this.addPoint(null, y2);
  }
  addBoundingBox(boundingBox) {
    if (!boundingBox) {
      return;
    }
    var {
      x1,
      y1,
      x2,
      y2
    } = boundingBox;
    this.addPoint(x1, y1);
    this.addPoint(x2, y2);
  }
  sumCubic(t2, p0, p1, p2, p3) {
    return Math.pow(1 - t2, 3) * p0 + 3 * Math.pow(1 - t2, 2) * t2 * p1 + 3 * (1 - t2) * Math.pow(t2, 2) * p2 + Math.pow(t2, 3) * p3;
  }
  bezierCurveAdd(forX, p0, p1, p2, p3) {
    var b = 6 * p0 - 12 * p1 + 6 * p2;
    var a2 = -3 * p0 + 9 * p1 - 9 * p2 + 3 * p3;
    var c2 = 3 * p1 - 3 * p0;
    if (a2 === 0) {
      if (b === 0) {
        return;
      }
      var t2 = -c2 / b;
      if (0 < t2 && t2 < 1) {
        if (forX) {
          this.addX(this.sumCubic(t2, p0, p1, p2, p3));
        } else {
          this.addY(this.sumCubic(t2, p0, p1, p2, p3));
        }
      }
      return;
    }
    var b2ac = Math.pow(b, 2) - 4 * c2 * a2;
    if (b2ac < 0) {
      return;
    }
    var t1 = (-b + Math.sqrt(b2ac)) / (2 * a2);
    if (0 < t1 && t1 < 1) {
      if (forX) {
        this.addX(this.sumCubic(t1, p0, p1, p2, p3));
      } else {
        this.addY(this.sumCubic(t1, p0, p1, p2, p3));
      }
    }
    var t22 = (-b - Math.sqrt(b2ac)) / (2 * a2);
    if (0 < t22 && t22 < 1) {
      if (forX) {
        this.addX(this.sumCubic(t22, p0, p1, p2, p3));
      } else {
        this.addY(this.sumCubic(t22, p0, p1, p2, p3));
      }
    }
  }
  addBezierCurve(p0x, p0y, p1x, p1y, p2x, p2y, p3x, p3y) {
    this.addPoint(p0x, p0y);
    this.addPoint(p3x, p3y);
    this.bezierCurveAdd(true, p0x, p1x, p2x, p3x);
    this.bezierCurveAdd(false, p0y, p1y, p2y, p3y);
  }
  addQuadraticCurve(p0x, p0y, p1x, p1y, p2x, p2y) {
    var cp1x = p0x + 2 / 3 * (p1x - p0x);
    var cp1y = p0y + 2 / 3 * (p1y - p0y);
    var cp2x = cp1x + 1 / 3 * (p2x - p0x);
    var cp2y = cp1y + 1 / 3 * (p2y - p0y);
    this.addBezierCurve(p0x, p0y, cp1x, cp2x, cp1y, cp2y, p2x, p2y);
  }
  isPointInBox(x2, y2) {
    var {
      x1,
      y1,
      x2: x22,
      y2: y22
    } = this;
    return x1 <= x2 && x2 <= x22 && y1 <= y2 && y2 <= y22;
  }
}
function ownKeys$2(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread$2(target) {
  for (var i4 = 1;i4 < arguments.length; i4++) {
    var source = arguments[i4] != null ? arguments[i4] : {};
    if (i4 % 2) {
      ownKeys$2(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$2(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}

class SVGFontLoader {
  constructor(document2) {
    this.document = document2;
    this.loaded = false;
    document2.fonts.push(this);
  }
  load(fontFamily, url) {
    var _this = this;
    return _asyncToGenerator(function* () {
      try {
        var {
          document: document2
        } = _this;
        var svgDocument = yield document2.canvg.parser.load(url);
        var fonts = svgDocument.getElementsByTagName("font");
        Array.from(fonts).forEach((fontNode) => {
          var font = document2.createElement(fontNode);
          document2.definitions[fontFamily] = font;
        });
      } catch (err2) {
        console.error('Error while loading font "'.concat(url, '":'), err2);
      }
      _this.loaded = true;
    })();
  }
}
function imGet(img, x2, y2, width, _height, rgba) {
  return img[y2 * width * 4 + x2 * 4 + rgba];
}
function imSet(img, x2, y2, width, _height, rgba, val) {
  img[y2 * width * 4 + x2 * 4 + rgba] = val;
}
function m2(matrix, i4, v2) {
  var mi = matrix[i4];
  return mi * v2;
}
function c2(a2, m1, m22, m3) {
  return m1 + Math.cos(a2) * m22 + Math.sin(a2) * m3;
}
function ownKeys$1(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread$1(target) {
  for (var i4 = 1;i4 < arguments.length; i4++) {
    var source = arguments[i4] != null ? arguments[i4] : {};
    if (i4 % 2) {
      ownKeys$1(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$1(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function createCanvas(width, height) {
  var canvas = document.createElement("canvas");
  canvas.width = width;
  canvas.height = height;
  return canvas;
}
function createImage(_x) {
  return _createImage.apply(this, arguments);
}
function _createImage() {
  _createImage = _asyncToGenerator(function* (src) {
    var anonymousCrossOrigin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    var image = document.createElement("img");
    if (anonymousCrossOrigin) {
      image.crossOrigin = "Anonymous";
    }
    return new Promise((resolve, reject) => {
      image.onload = () => {
        resolve(image);
      };
      image.onerror = (_event, _source, _lineno, _colno, error) => {
        reject(error);
      };
      image.src = src;
    });
  });
  return _createImage.apply(this, arguments);
}

class Document2 {
  constructor(canvg) {
    var {
      rootEmSize = 12,
      emSize = 12,
      createCanvas: createCanvas2 = Document2.createCanvas,
      createImage: createImage2 = Document2.createImage,
      anonymousCrossOrigin
    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    this.canvg = canvg;
    this.definitions = Object.create(null);
    this.styles = Object.create(null);
    this.stylesSpecificity = Object.create(null);
    this.images = [];
    this.fonts = [];
    this.emSizeStack = [];
    this.uniqueId = 0;
    this.screen = canvg.screen;
    this.rootEmSize = rootEmSize;
    this.emSize = emSize;
    this.createCanvas = createCanvas2;
    this.createImage = this.bindCreateImage(createImage2, anonymousCrossOrigin);
    this.screen.wait(this.isImagesLoaded.bind(this));
    this.screen.wait(this.isFontsLoaded.bind(this));
  }
  bindCreateImage(createImage2, anonymousCrossOrigin) {
    if (typeof anonymousCrossOrigin === "boolean") {
      return (source, forceAnonymousCrossOrigin) => createImage2(source, typeof forceAnonymousCrossOrigin === "boolean" ? forceAnonymousCrossOrigin : anonymousCrossOrigin);
    }
    return createImage2;
  }
  get window() {
    return this.screen.window;
  }
  get fetch() {
    return this.screen.fetch;
  }
  get ctx() {
    return this.screen.ctx;
  }
  get emSize() {
    var {
      emSizeStack
    } = this;
    return emSizeStack[emSizeStack.length - 1];
  }
  set emSize(value) {
    var {
      emSizeStack
    } = this;
    emSizeStack.push(value);
  }
  popEmSize() {
    var {
      emSizeStack
    } = this;
    emSizeStack.pop();
  }
  getUniqueId() {
    return "canvg".concat(++this.uniqueId);
  }
  isImagesLoaded() {
    return this.images.every((_2) => _2.loaded);
  }
  isFontsLoaded() {
    return this.fonts.every((_2) => _2.loaded);
  }
  createDocumentElement(document2) {
    var documentElement = this.createElement(document2.documentElement);
    documentElement.root = true;
    documentElement.addStylesFromStyleDefinition();
    this.documentElement = documentElement;
    return documentElement;
  }
  createElement(node2) {
    var elementType = node2.nodeName.replace(/^[^:]+:/, "");
    var ElementType = Document2.elementTypes[elementType];
    if (typeof ElementType !== "undefined") {
      return new ElementType(this, node2);
    }
    return new UnknownElement(this, node2);
  }
  createTextNode(node2) {
    return new TextNode2(this, node2);
  }
  setViewBox(config) {
    this.screen.setViewBox(_objectSpread$1({
      document: this
    }, config));
  }
}
function ownKeys(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread(target) {
  for (var i4 = 1;i4 < arguments.length; i4++) {
    var source = arguments[i4] != null ? arguments[i4] : {};
    if (i4 % 2) {
      ownKeys(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}

class Canvg {
  constructor(ctx, svg) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    this.parser = new Parser(options);
    this.screen = new Screen(ctx, options);
    this.options = options;
    var document2 = new Document2(this, options);
    var documentElement = document2.createDocumentElement(svg);
    this.document = document2;
    this.documentElement = documentElement;
  }
  static from(ctx, svg) {
    var _arguments = arguments;
    return _asyncToGenerator(function* () {
      var options = _arguments.length > 2 && _arguments[2] !== undefined ? _arguments[2] : {};
      var parser = new Parser(options);
      var svgDocument = yield parser.parse(svg);
      return new Canvg(ctx, svgDocument, options);
    })();
  }
  static fromString(ctx, svg) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var parser = new Parser(options);
    var svgDocument = parser.parseFromString(svg);
    return new Canvg(ctx, svgDocument, options);
  }
  fork(ctx, svg) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    return Canvg.from(ctx, svg, _objectSpread(_objectSpread({}, this.options), options));
  }
  forkString(ctx, svg) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    return Canvg.fromString(ctx, svg, _objectSpread(_objectSpread({}, this.options), options));
  }
  ready() {
    return this.screen.ready();
  }
  isReady() {
    return this.screen.isReady();
  }
  render() {
    var _arguments2 = arguments, _this = this;
    return _asyncToGenerator(function* () {
      var options = _arguments2.length > 0 && _arguments2[0] !== undefined ? _arguments2[0] : {};
      _this.start(_objectSpread({
        enableRedraw: true,
        ignoreAnimation: true,
        ignoreMouse: true
      }, options));
      yield _this.ready();
      _this.stop();
    })();
  }
  start() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var {
      documentElement,
      screen,
      options: baseOptions
    } = this;
    screen.start(documentElement, _objectSpread(_objectSpread({
      enableRedraw: true
    }, baseOptions), options));
  }
  stop() {
    this.screen.stop();
  }
  resize(width) {
    var height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : width;
    var preserveAspectRatio = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    this.documentElement.resize(width, height, preserveAspectRatio);
  }
}
var import_es_promise, import_es_string_match, import_es_string_replace, import_es_string_starts_with, import_es_array_iterator, import_web_dom_collections_iterator, import_es_array_reduce, import_es_string_ends_with, import_es_string_split, import_raf, import_es_string_trim, import_rgbcolor, import_es_array_index_of, import_es_string_includes, import_es_array_reverse, import_es_regexp_to_string, index, allUppercase, attributeRegex, idRegex, classRegex, pseudoElementRegex, pseudoClassWithBracketsRegex, pseudoClassRegex, elementRegex, PSEUDO_ZERO = 0.00000001, defaultWindow, defaultFetch$1, defaultFetch, DefaultDOMParser, Skew, SkewX, SkewY, UnknownElement, PathParser, RenderedElement, PathElement, GlyphElement, TextElement, TSpanElement, TextNode2, SVGElement, RectElement, CircleElement, EllipseElement, LineElement, PolylineElement, PolygonElement, PatternElement, MarkerElement, DefsElement, GElement, GradientElement, LinearGradientElement, RadialGradientElement, StopElement, AnimateElement, AnimateColorElement, AnimateTransformElement, FontElement, FontFaceElement, MissingGlyphElement, TRefElement, AElement, TextPathElement, dataUriRegex, ImageElement, SymbolElement, StyleElement, UseElement, FeColorMatrixElement, MaskElement, noop = () => {}, ClipPathElement, FilterElement, FeDropShadowElement, FeMorphologyElement, FeCompositeElement, FeGaussianBlurElement, TitleElement, DescElement, elements;
var init_index_es = __esm(() => {
  import_es_promise = __toESM(require_es_promise(), 1);
  init_asyncToGenerator();
  import_es_string_match = __toESM(require_es_string_match(), 1);
  import_es_string_replace = __toESM(require_es_string_replace(), 1);
  import_es_string_starts_with = __toESM(require_es_string_starts_with(), 1);
  import_es_array_iterator = __toESM(require_es_array_iterator(), 1);
  import_web_dom_collections_iterator = __toESM(require_web_dom_collections_iterator(), 1);
  init_defineProperty();
  import_es_array_reduce = __toESM(require_es_array_reduce(), 1);
  import_es_string_ends_with = __toESM(require_es_string_ends_with(), 1);
  import_es_string_split = __toESM(require_es_string_split(), 1);
  import_raf = __toESM(require_raf(), 1);
  import_es_string_trim = __toESM(require_es_string_trim(), 1);
  import_rgbcolor = __toESM(require_rgbcolor(), 1);
  import_es_array_index_of = __toESM(require_es_array_index_of(), 1);
  import_es_string_includes = __toESM(require_es_string_includes(), 1);
  import_es_array_reverse = __toESM(require_es_array_reverse(), 1);
  init_SVGPathData_module();
  import_es_regexp_to_string = __toESM(require_es_regexp_to_string(), 1);
  init_stackblur_es();
  index = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    offscreen,
    node
  });
  allUppercase = /^[A-Z-]+$/;
  attributeRegex = /(\[[^\]]+\])/g;
  idRegex = /(#[^\s+>~.[:]+)/g;
  classRegex = /(\.[^\s+>~.[:]+)/g;
  pseudoElementRegex = /(::[^\s+>~.[:]+|:first-line|:first-letter|:before|:after)/gi;
  pseudoClassWithBracketsRegex = /(:[\w-]+\([^)]*\))/gi;
  pseudoClassRegex = /(:[^\s+>~.[:]+)/g;
  elementRegex = /([^\s+>~.[:]+)/g;
  Property.textBaselineMapping = {
    baseline: "alphabetic",
    "before-edge": "top",
    "text-before-edge": "top",
    middle: "middle",
    central: "middle",
    "after-edge": "bottom",
    "text-after-edge": "bottom",
    ideographic: "ideographic",
    alphabetic: "alphabetic",
    hanging: "hanging",
    mathematical: "alphabetic"
  };
  defaultWindow = typeof window !== "undefined" ? window : null;
  defaultFetch$1 = typeof fetch !== "undefined" ? fetch.bind(undefined) : null;
  Screen.defaultWindow = defaultWindow;
  Screen.defaultFetch = defaultFetch$1;
  ({
    defaultFetch
  } = Screen);
  DefaultDOMParser = typeof DOMParser !== "undefined" ? DOMParser : null;
  Skew = class Skew extends Matrix {
    constructor(document2, skew, transformOrigin) {
      super(document2, skew, transformOrigin);
      this.type = "skew";
      this.angle = null;
      this.angle = new Property(document2, "angle", skew);
    }
  };
  SkewX = class SkewX extends Skew {
    constructor(document2, skew, transformOrigin) {
      super(document2, skew, transformOrigin);
      this.type = "skewX";
      this.matrix = [1, 0, Math.tan(this.angle.getRadians()), 1, 0, 0];
    }
  };
  SkewY = class SkewY extends Skew {
    constructor(document2, skew, transformOrigin) {
      super(document2, skew, transformOrigin);
      this.type = "skewY";
      this.matrix = [1, Math.tan(this.angle.getRadians()), 0, 1, 0, 0];
    }
  };
  Transform2.transformTypes = {
    translate: Translate,
    rotate: Rotate,
    scale: Scale,
    matrix: Matrix,
    skewX: SkewX,
    skewY: SkewY
  };
  Element.ignoreChildTypes = ["title"];
  UnknownElement = class UnknownElement extends Element {
    constructor(document2, node2, captureTextNodes) {
      super(document2, node2, captureTextNodes);
    }
  };
  Font.styles = "normal|italic|oblique|inherit";
  Font.variants = "normal|small-caps|inherit";
  Font.weights = "normal|bold|bolder|lighter|100|200|300|400|500|600|700|800|900|inherit";
  PathParser = class PathParser extends _ {
    constructor(path) {
      super(path.replace(/([+\-.])\s+/gm, "$1").replace(/[^MmZzLlHhVvCcSsQqTtAae\d\s.,+-].*/g, ""));
      this.control = null;
      this.start = null;
      this.current = null;
      this.command = null;
      this.commands = this.commands;
      this.i = -1;
      this.previousCommand = null;
      this.points = [];
      this.angles = [];
    }
    reset() {
      this.i = -1;
      this.command = null;
      this.previousCommand = null;
      this.start = new Point(0, 0);
      this.control = new Point(0, 0);
      this.current = new Point(0, 0);
      this.points = [];
      this.angles = [];
    }
    isEnd() {
      var {
        i: i4,
        commands: commands2
      } = this;
      return i4 >= commands2.length - 1;
    }
    next() {
      var command2 = this.commands[++this.i];
      this.previousCommand = this.command;
      this.command = command2;
      return command2;
    }
    getPoint() {
      var xProp = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "x";
      var yProp = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "y";
      var point = new Point(this.command[xProp], this.command[yProp]);
      return this.makeAbsolute(point);
    }
    getAsControlPoint(xProp, yProp) {
      var point = this.getPoint(xProp, yProp);
      this.control = point;
      return point;
    }
    getAsCurrentPoint(xProp, yProp) {
      var point = this.getPoint(xProp, yProp);
      this.current = point;
      return point;
    }
    getReflectedControlPoint() {
      var previousCommand = this.previousCommand.type;
      if (previousCommand !== _.CURVE_TO && previousCommand !== _.SMOOTH_CURVE_TO && previousCommand !== _.QUAD_TO && previousCommand !== _.SMOOTH_QUAD_TO) {
        return this.current;
      }
      var {
        current: {
          x: cx,
          y: cy
        },
        control: {
          x: ox,
          y: oy
        }
      } = this;
      var point = new Point(2 * cx - ox, 2 * cy - oy);
      return point;
    }
    makeAbsolute(point) {
      if (this.command.relative) {
        var {
          x: x2,
          y: y2
        } = this.current;
        point.x += x2;
        point.y += y2;
      }
      return point;
    }
    addMarker(point, from2, priorTo) {
      var {
        points,
        angles
      } = this;
      if (priorTo && angles.length > 0 && !angles[angles.length - 1]) {
        angles[angles.length - 1] = points[points.length - 1].angleTo(priorTo);
      }
      this.addMarkerAngle(point, from2 ? from2.angleTo(point) : null);
    }
    addMarkerAngle(point, angle) {
      this.points.push(point);
      this.angles.push(angle);
    }
    getMarkerPoints() {
      return this.points;
    }
    getMarkerAngles() {
      var {
        angles
      } = this;
      var len = angles.length;
      for (var i4 = 0;i4 < len; i4++) {
        if (!angles[i4]) {
          for (var j = i4 + 1;j < len; j++) {
            if (angles[j]) {
              angles[i4] = angles[j];
              break;
            }
          }
        }
      }
      return angles;
    }
  };
  RenderedElement = class RenderedElement extends Element {
    constructor() {
      super(...arguments);
      this.modifiedEmSizeStack = false;
    }
    calculateOpacity() {
      var opacity = 1;
      var element = this;
      while (element) {
        var opacityStyle = element.getStyle("opacity", false, true);
        if (opacityStyle.hasValue(true)) {
          opacity *= opacityStyle.getNumber();
        }
        element = element.parent;
      }
      return opacity;
    }
    setContext(ctx) {
      var fromMeasure = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      if (!fromMeasure) {
        var fillStyleProp = this.getStyle("fill");
        var fillOpacityStyleProp = this.getStyle("fill-opacity");
        var strokeStyleProp = this.getStyle("stroke");
        var strokeOpacityProp = this.getStyle("stroke-opacity");
        if (fillStyleProp.isUrlDefinition()) {
          var fillStyle = fillStyleProp.getFillStyleDefinition(this, fillOpacityStyleProp);
          if (fillStyle) {
            ctx.fillStyle = fillStyle;
          }
        } else if (fillStyleProp.hasValue()) {
          if (fillStyleProp.getString() === "currentColor") {
            fillStyleProp.setValue(this.getStyle("color").getColor());
          }
          var _fillStyle = fillStyleProp.getColor();
          if (_fillStyle !== "inherit") {
            ctx.fillStyle = _fillStyle === "none" ? "rgba(0,0,0,0)" : _fillStyle;
          }
        }
        if (fillOpacityStyleProp.hasValue()) {
          var _fillStyle2 = new Property(this.document, "fill", ctx.fillStyle).addOpacity(fillOpacityStyleProp).getColor();
          ctx.fillStyle = _fillStyle2;
        }
        if (strokeStyleProp.isUrlDefinition()) {
          var strokeStyle = strokeStyleProp.getFillStyleDefinition(this, strokeOpacityProp);
          if (strokeStyle) {
            ctx.strokeStyle = strokeStyle;
          }
        } else if (strokeStyleProp.hasValue()) {
          if (strokeStyleProp.getString() === "currentColor") {
            strokeStyleProp.setValue(this.getStyle("color").getColor());
          }
          var _strokeStyle = strokeStyleProp.getString();
          if (_strokeStyle !== "inherit") {
            ctx.strokeStyle = _strokeStyle === "none" ? "rgba(0,0,0,0)" : _strokeStyle;
          }
        }
        if (strokeOpacityProp.hasValue()) {
          var _strokeStyle2 = new Property(this.document, "stroke", ctx.strokeStyle).addOpacity(strokeOpacityProp).getString();
          ctx.strokeStyle = _strokeStyle2;
        }
        var strokeWidthStyleProp = this.getStyle("stroke-width");
        if (strokeWidthStyleProp.hasValue()) {
          var newLineWidth = strokeWidthStyleProp.getPixels();
          ctx.lineWidth = !newLineWidth ? PSEUDO_ZERO : newLineWidth;
        }
        var strokeLinecapStyleProp = this.getStyle("stroke-linecap");
        var strokeLinejoinStyleProp = this.getStyle("stroke-linejoin");
        var strokeMiterlimitProp = this.getStyle("stroke-miterlimit");
        var strokeDasharrayStyleProp = this.getStyle("stroke-dasharray");
        var strokeDashoffsetProp = this.getStyle("stroke-dashoffset");
        if (strokeLinecapStyleProp.hasValue()) {
          ctx.lineCap = strokeLinecapStyleProp.getString();
        }
        if (strokeLinejoinStyleProp.hasValue()) {
          ctx.lineJoin = strokeLinejoinStyleProp.getString();
        }
        if (strokeMiterlimitProp.hasValue()) {
          ctx.miterLimit = strokeMiterlimitProp.getNumber();
        }
        if (strokeDasharrayStyleProp.hasValue() && strokeDasharrayStyleProp.getString() !== "none") {
          var gaps = toNumbers(strokeDasharrayStyleProp.getString());
          if (typeof ctx.setLineDash !== "undefined") {
            ctx.setLineDash(gaps);
          } else if (typeof ctx.webkitLineDash !== "undefined") {
            ctx.webkitLineDash = gaps;
          } else if (typeof ctx.mozDash !== "undefined" && !(gaps.length === 1 && gaps[0] === 0)) {
            ctx.mozDash = gaps;
          }
          var offset = strokeDashoffsetProp.getPixels();
          if (typeof ctx.lineDashOffset !== "undefined") {
            ctx.lineDashOffset = offset;
          } else if (typeof ctx.webkitLineDashOffset !== "undefined") {
            ctx.webkitLineDashOffset = offset;
          } else if (typeof ctx.mozDashOffset !== "undefined") {
            ctx.mozDashOffset = offset;
          }
        }
      }
      this.modifiedEmSizeStack = false;
      if (typeof ctx.font !== "undefined") {
        var fontStyleProp = this.getStyle("font");
        var fontStyleStyleProp = this.getStyle("font-style");
        var fontVariantStyleProp = this.getStyle("font-variant");
        var fontWeightStyleProp = this.getStyle("font-weight");
        var fontSizeStyleProp = this.getStyle("font-size");
        var fontFamilyStyleProp = this.getStyle("font-family");
        var font = new Font(fontStyleStyleProp.getString(), fontVariantStyleProp.getString(), fontWeightStyleProp.getString(), fontSizeStyleProp.hasValue() ? "".concat(fontSizeStyleProp.getPixels(true), "px") : "", fontFamilyStyleProp.getString(), Font.parse(fontStyleProp.getString(), ctx.font));
        fontStyleStyleProp.setValue(font.fontStyle);
        fontVariantStyleProp.setValue(font.fontVariant);
        fontWeightStyleProp.setValue(font.fontWeight);
        fontSizeStyleProp.setValue(font.fontSize);
        fontFamilyStyleProp.setValue(font.fontFamily);
        ctx.font = font.toString();
        if (fontSizeStyleProp.isPixels()) {
          this.document.emSize = fontSizeStyleProp.getPixels();
          this.modifiedEmSizeStack = true;
        }
      }
      if (!fromMeasure) {
        this.applyEffects(ctx);
        ctx.globalAlpha = this.calculateOpacity();
      }
    }
    clearContext(ctx) {
      super.clearContext(ctx);
      if (this.modifiedEmSizeStack) {
        this.document.popEmSize();
      }
    }
  };
  PathElement = class PathElement extends RenderedElement {
    constructor(document2, node2, captureTextNodes) {
      super(document2, node2, captureTextNodes);
      this.type = "path";
      this.pathParser = null;
      this.pathParser = new PathParser(this.getAttribute("d").getString());
    }
    path(ctx) {
      var {
        pathParser
      } = this;
      var boundingBox = new BoundingBox;
      pathParser.reset();
      if (ctx) {
        ctx.beginPath();
      }
      while (!pathParser.isEnd()) {
        switch (pathParser.next().type) {
          case PathParser.MOVE_TO:
            this.pathM(ctx, boundingBox);
            break;
          case PathParser.LINE_TO:
            this.pathL(ctx, boundingBox);
            break;
          case PathParser.HORIZ_LINE_TO:
            this.pathH(ctx, boundingBox);
            break;
          case PathParser.VERT_LINE_TO:
            this.pathV(ctx, boundingBox);
            break;
          case PathParser.CURVE_TO:
            this.pathC(ctx, boundingBox);
            break;
          case PathParser.SMOOTH_CURVE_TO:
            this.pathS(ctx, boundingBox);
            break;
          case PathParser.QUAD_TO:
            this.pathQ(ctx, boundingBox);
            break;
          case PathParser.SMOOTH_QUAD_TO:
            this.pathT(ctx, boundingBox);
            break;
          case PathParser.ARC:
            this.pathA(ctx, boundingBox);
            break;
          case PathParser.CLOSE_PATH:
            this.pathZ(ctx, boundingBox);
            break;
        }
      }
      return boundingBox;
    }
    getBoundingBox(_2) {
      return this.path();
    }
    getMarkers() {
      var {
        pathParser
      } = this;
      var points = pathParser.getMarkerPoints();
      var angles = pathParser.getMarkerAngles();
      var markers = points.map((point, i4) => [point, angles[i4]]);
      return markers;
    }
    renderChildren(ctx) {
      this.path(ctx);
      this.document.screen.mouse.checkPath(this, ctx);
      var fillRuleStyleProp = this.getStyle("fill-rule");
      if (ctx.fillStyle !== "") {
        if (fillRuleStyleProp.getString("inherit") !== "inherit") {
          ctx.fill(fillRuleStyleProp.getString());
        } else {
          ctx.fill();
        }
      }
      if (ctx.strokeStyle !== "") {
        if (this.getAttribute("vector-effect").getString() === "non-scaling-stroke") {
          ctx.save();
          ctx.setTransform(1, 0, 0, 1, 0, 0);
          ctx.stroke();
          ctx.restore();
        } else {
          ctx.stroke();
        }
      }
      var markers = this.getMarkers();
      if (markers) {
        var markersLastIndex = markers.length - 1;
        var markerStartStyleProp = this.getStyle("marker-start");
        var markerMidStyleProp = this.getStyle("marker-mid");
        var markerEndStyleProp = this.getStyle("marker-end");
        if (markerStartStyleProp.isUrlDefinition()) {
          var marker = markerStartStyleProp.getDefinition();
          var [point, angle] = markers[0];
          marker.render(ctx, point, angle);
        }
        if (markerMidStyleProp.isUrlDefinition()) {
          var _marker = markerMidStyleProp.getDefinition();
          for (var i4 = 1;i4 < markersLastIndex; i4++) {
            var [_point, _angle] = markers[i4];
            _marker.render(ctx, _point, _angle);
          }
        }
        if (markerEndStyleProp.isUrlDefinition()) {
          var _marker2 = markerEndStyleProp.getDefinition();
          var [_point2, _angle2] = markers[markersLastIndex];
          _marker2.render(ctx, _point2, _angle2);
        }
      }
    }
    static pathM(pathParser) {
      var point = pathParser.getAsCurrentPoint();
      pathParser.start = pathParser.current;
      return {
        point
      };
    }
    pathM(ctx, boundingBox) {
      var {
        pathParser
      } = this;
      var {
        point
      } = PathElement.pathM(pathParser);
      var {
        x: x2,
        y: y2
      } = point;
      pathParser.addMarker(point);
      boundingBox.addPoint(x2, y2);
      if (ctx) {
        ctx.moveTo(x2, y2);
      }
    }
    static pathL(pathParser) {
      var {
        current
      } = pathParser;
      var point = pathParser.getAsCurrentPoint();
      return {
        current,
        point
      };
    }
    pathL(ctx, boundingBox) {
      var {
        pathParser
      } = this;
      var {
        current,
        point
      } = PathElement.pathL(pathParser);
      var {
        x: x2,
        y: y2
      } = point;
      pathParser.addMarker(point, current);
      boundingBox.addPoint(x2, y2);
      if (ctx) {
        ctx.lineTo(x2, y2);
      }
    }
    static pathH(pathParser) {
      var {
        current,
        command: command2
      } = pathParser;
      var point = new Point((command2.relative ? current.x : 0) + command2.x, current.y);
      pathParser.current = point;
      return {
        current,
        point
      };
    }
    pathH(ctx, boundingBox) {
      var {
        pathParser
      } = this;
      var {
        current,
        point
      } = PathElement.pathH(pathParser);
      var {
        x: x2,
        y: y2
      } = point;
      pathParser.addMarker(point, current);
      boundingBox.addPoint(x2, y2);
      if (ctx) {
        ctx.lineTo(x2, y2);
      }
    }
    static pathV(pathParser) {
      var {
        current,
        command: command2
      } = pathParser;
      var point = new Point(current.x, (command2.relative ? current.y : 0) + command2.y);
      pathParser.current = point;
      return {
        current,
        point
      };
    }
    pathV(ctx, boundingBox) {
      var {
        pathParser
      } = this;
      var {
        current,
        point
      } = PathElement.pathV(pathParser);
      var {
        x: x2,
        y: y2
      } = point;
      pathParser.addMarker(point, current);
      boundingBox.addPoint(x2, y2);
      if (ctx) {
        ctx.lineTo(x2, y2);
      }
    }
    static pathC(pathParser) {
      var {
        current
      } = pathParser;
      var point = pathParser.getPoint("x1", "y1");
      var controlPoint = pathParser.getAsControlPoint("x2", "y2");
      var currentPoint = pathParser.getAsCurrentPoint();
      return {
        current,
        point,
        controlPoint,
        currentPoint
      };
    }
    pathC(ctx, boundingBox) {
      var {
        pathParser
      } = this;
      var {
        current,
        point,
        controlPoint,
        currentPoint
      } = PathElement.pathC(pathParser);
      pathParser.addMarker(currentPoint, controlPoint, point);
      boundingBox.addBezierCurve(current.x, current.y, point.x, point.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);
      if (ctx) {
        ctx.bezierCurveTo(point.x, point.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);
      }
    }
    static pathS(pathParser) {
      var {
        current
      } = pathParser;
      var point = pathParser.getReflectedControlPoint();
      var controlPoint = pathParser.getAsControlPoint("x2", "y2");
      var currentPoint = pathParser.getAsCurrentPoint();
      return {
        current,
        point,
        controlPoint,
        currentPoint
      };
    }
    pathS(ctx, boundingBox) {
      var {
        pathParser
      } = this;
      var {
        current,
        point,
        controlPoint,
        currentPoint
      } = PathElement.pathS(pathParser);
      pathParser.addMarker(currentPoint, controlPoint, point);
      boundingBox.addBezierCurve(current.x, current.y, point.x, point.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);
      if (ctx) {
        ctx.bezierCurveTo(point.x, point.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);
      }
    }
    static pathQ(pathParser) {
      var {
        current
      } = pathParser;
      var controlPoint = pathParser.getAsControlPoint("x1", "y1");
      var currentPoint = pathParser.getAsCurrentPoint();
      return {
        current,
        controlPoint,
        currentPoint
      };
    }
    pathQ(ctx, boundingBox) {
      var {
        pathParser
      } = this;
      var {
        current,
        controlPoint,
        currentPoint
      } = PathElement.pathQ(pathParser);
      pathParser.addMarker(currentPoint, controlPoint, controlPoint);
      boundingBox.addQuadraticCurve(current.x, current.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);
      if (ctx) {
        ctx.quadraticCurveTo(controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);
      }
    }
    static pathT(pathParser) {
      var {
        current
      } = pathParser;
      var controlPoint = pathParser.getReflectedControlPoint();
      pathParser.control = controlPoint;
      var currentPoint = pathParser.getAsCurrentPoint();
      return {
        current,
        controlPoint,
        currentPoint
      };
    }
    pathT(ctx, boundingBox) {
      var {
        pathParser
      } = this;
      var {
        current,
        controlPoint,
        currentPoint
      } = PathElement.pathT(pathParser);
      pathParser.addMarker(currentPoint, controlPoint, controlPoint);
      boundingBox.addQuadraticCurve(current.x, current.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);
      if (ctx) {
        ctx.quadraticCurveTo(controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);
      }
    }
    static pathA(pathParser) {
      var {
        current,
        command: command2
      } = pathParser;
      var {
        rX,
        rY,
        xRot,
        lArcFlag,
        sweepFlag
      } = command2;
      var xAxisRotation = xRot * (Math.PI / 180);
      var currentPoint = pathParser.getAsCurrentPoint();
      var currp = new Point(Math.cos(xAxisRotation) * (current.x - currentPoint.x) / 2 + Math.sin(xAxisRotation) * (current.y - currentPoint.y) / 2, -Math.sin(xAxisRotation) * (current.x - currentPoint.x) / 2 + Math.cos(xAxisRotation) * (current.y - currentPoint.y) / 2);
      var l2 = Math.pow(currp.x, 2) / Math.pow(rX, 2) + Math.pow(currp.y, 2) / Math.pow(rY, 2);
      if (l2 > 1) {
        rX *= Math.sqrt(l2);
        rY *= Math.sqrt(l2);
      }
      var s2 = (lArcFlag === sweepFlag ? -1 : 1) * Math.sqrt((Math.pow(rX, 2) * Math.pow(rY, 2) - Math.pow(rX, 2) * Math.pow(currp.y, 2) - Math.pow(rY, 2) * Math.pow(currp.x, 2)) / (Math.pow(rX, 2) * Math.pow(currp.y, 2) + Math.pow(rY, 2) * Math.pow(currp.x, 2)));
      if (isNaN(s2)) {
        s2 = 0;
      }
      var cpp = new Point(s2 * rX * currp.y / rY, s2 * -rY * currp.x / rX);
      var centp = new Point((current.x + currentPoint.x) / 2 + Math.cos(xAxisRotation) * cpp.x - Math.sin(xAxisRotation) * cpp.y, (current.y + currentPoint.y) / 2 + Math.sin(xAxisRotation) * cpp.x + Math.cos(xAxisRotation) * cpp.y);
      var a1 = vectorsAngle([1, 0], [(currp.x - cpp.x) / rX, (currp.y - cpp.y) / rY]);
      var u2 = [(currp.x - cpp.x) / rX, (currp.y - cpp.y) / rY];
      var v2 = [(-currp.x - cpp.x) / rX, (-currp.y - cpp.y) / rY];
      var ad = vectorsAngle(u2, v2);
      if (vectorsRatio(u2, v2) <= -1) {
        ad = Math.PI;
      }
      if (vectorsRatio(u2, v2) >= 1) {
        ad = 0;
      }
      return {
        currentPoint,
        rX,
        rY,
        sweepFlag,
        xAxisRotation,
        centp,
        a1,
        ad
      };
    }
    pathA(ctx, boundingBox) {
      var {
        pathParser
      } = this;
      var {
        currentPoint,
        rX,
        rY,
        sweepFlag,
        xAxisRotation,
        centp,
        a1,
        ad
      } = PathElement.pathA(pathParser);
      var dir = 1 - sweepFlag ? 1 : -1;
      var ah = a1 + dir * (ad / 2);
      var halfWay = new Point(centp.x + rX * Math.cos(ah), centp.y + rY * Math.sin(ah));
      pathParser.addMarkerAngle(halfWay, ah - dir * Math.PI / 2);
      pathParser.addMarkerAngle(currentPoint, ah - dir * Math.PI);
      boundingBox.addPoint(currentPoint.x, currentPoint.y);
      if (ctx && !isNaN(a1) && !isNaN(ad)) {
        var r2 = rX > rY ? rX : rY;
        var sx = rX > rY ? 1 : rX / rY;
        var sy = rX > rY ? rY / rX : 1;
        ctx.translate(centp.x, centp.y);
        ctx.rotate(xAxisRotation);
        ctx.scale(sx, sy);
        ctx.arc(0, 0, r2, a1, a1 + ad, Boolean(1 - sweepFlag));
        ctx.scale(1 / sx, 1 / sy);
        ctx.rotate(-xAxisRotation);
        ctx.translate(-centp.x, -centp.y);
      }
    }
    static pathZ(pathParser) {
      pathParser.current = pathParser.start;
    }
    pathZ(ctx, boundingBox) {
      PathElement.pathZ(this.pathParser);
      if (ctx) {
        if (boundingBox.x1 !== boundingBox.x2 && boundingBox.y1 !== boundingBox.y2) {
          ctx.closePath();
        }
      }
    }
  };
  GlyphElement = class GlyphElement extends PathElement {
    constructor(document2, node2, captureTextNodes) {
      super(document2, node2, captureTextNodes);
      this.type = "glyph";
      this.horizAdvX = this.getAttribute("horiz-adv-x").getNumber();
      this.unicode = this.getAttribute("unicode").getString();
      this.arabicForm = this.getAttribute("arabic-form").getString();
    }
  };
  TextElement = class TextElement extends RenderedElement {
    constructor(document2, node2, captureTextNodes) {
      super(document2, node2, new.target === TextElement ? true : captureTextNodes);
      this.type = "text";
      this.x = 0;
      this.y = 0;
      this.measureCache = -1;
    }
    setContext(ctx) {
      var fromMeasure = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      super.setContext(ctx, fromMeasure);
      var textBaseline = this.getStyle("dominant-baseline").getTextBaseline() || this.getStyle("alignment-baseline").getTextBaseline();
      if (textBaseline) {
        ctx.textBaseline = textBaseline;
      }
    }
    initializeCoordinates() {
      this.x = 0;
      this.y = 0;
      this.leafTexts = [];
      this.textChunkStart = 0;
      this.minX = Number.POSITIVE_INFINITY;
      this.maxX = Number.NEGATIVE_INFINITY;
    }
    getBoundingBox(ctx) {
      if (this.type !== "text") {
        return this.getTElementBoundingBox(ctx);
      }
      this.initializeCoordinates();
      this.adjustChildCoordinatesRecursive(ctx);
      var boundingBox = null;
      this.children.forEach((_2, i4) => {
        var childBoundingBox = this.getChildBoundingBox(ctx, this, this, i4);
        if (!boundingBox) {
          boundingBox = childBoundingBox;
        } else {
          boundingBox.addBoundingBox(childBoundingBox);
        }
      });
      return boundingBox;
    }
    getFontSize() {
      var {
        document: document2,
        parent
      } = this;
      var inheritFontSize = Font.parse(document2.ctx.font).fontSize;
      var fontSize = parent.getStyle("font-size").getNumber(inheritFontSize);
      return fontSize;
    }
    getTElementBoundingBox(ctx) {
      var fontSize = this.getFontSize();
      return new BoundingBox(this.x, this.y - fontSize, this.x + this.measureText(ctx), this.y);
    }
    getGlyph(font, text, i4) {
      var char = text[i4];
      var glyph = null;
      if (font.isArabic) {
        var len = text.length;
        var prevChar = text[i4 - 1];
        var nextChar = text[i4 + 1];
        var arabicForm = "isolated";
        if ((i4 === 0 || prevChar === " ") && i4 < len - 1 && nextChar !== " ") {
          arabicForm = "terminal";
        }
        if (i4 > 0 && prevChar !== " " && i4 < len - 1 && nextChar !== " ") {
          arabicForm = "medial";
        }
        if (i4 > 0 && prevChar !== " " && (i4 === len - 1 || nextChar === " ")) {
          arabicForm = "initial";
        }
        if (typeof font.glyphs[char] !== "undefined") {
          var maybeGlyph = font.glyphs[char];
          glyph = maybeGlyph instanceof GlyphElement ? maybeGlyph : maybeGlyph[arabicForm];
        }
      } else {
        glyph = font.glyphs[char];
      }
      if (!glyph) {
        glyph = font.missingGlyph;
      }
      return glyph;
    }
    getText() {
      return "";
    }
    getTextFromNode(node2) {
      var textNode = node2 || this.node;
      var childNodes = Array.from(textNode.parentNode.childNodes);
      var index2 = childNodes.indexOf(textNode);
      var lastIndex = childNodes.length - 1;
      var text = compressSpaces(textNode.textContent || "");
      if (index2 === 0) {
        text = trimLeft(text);
      }
      if (index2 === lastIndex) {
        text = trimRight(text);
      }
      return text;
    }
    renderChildren(ctx) {
      if (this.type !== "text") {
        this.renderTElementChildren(ctx);
        return;
      }
      this.initializeCoordinates();
      this.adjustChildCoordinatesRecursive(ctx);
      this.children.forEach((_2, i4) => {
        this.renderChild(ctx, this, this, i4);
      });
      var {
        mouse
      } = this.document.screen;
      if (mouse.isWorking()) {
        mouse.checkBoundingBox(this, this.getBoundingBox(ctx));
      }
    }
    renderTElementChildren(ctx) {
      var {
        document: document2,
        parent
      } = this;
      var renderText = this.getText();
      var customFont = parent.getStyle("font-family").getDefinition();
      if (customFont) {
        var {
          unitsPerEm
        } = customFont.fontFace;
        var ctxFont = Font.parse(document2.ctx.font);
        var fontSize = parent.getStyle("font-size").getNumber(ctxFont.fontSize);
        var fontStyle = parent.getStyle("font-style").getString(ctxFont.fontStyle);
        var scale = fontSize / unitsPerEm;
        var text = customFont.isRTL ? renderText.split("").reverse().join("") : renderText;
        var dx = toNumbers(parent.getAttribute("dx").getString());
        var len = text.length;
        for (var i4 = 0;i4 < len; i4++) {
          var glyph = this.getGlyph(customFont, text, i4);
          ctx.translate(this.x, this.y);
          ctx.scale(scale, -scale);
          var lw = ctx.lineWidth;
          ctx.lineWidth = ctx.lineWidth * unitsPerEm / fontSize;
          if (fontStyle === "italic") {
            ctx.transform(1, 0, 0.4, 1, 0, 0);
          }
          glyph.render(ctx);
          if (fontStyle === "italic") {
            ctx.transform(1, 0, -0.4, 1, 0, 0);
          }
          ctx.lineWidth = lw;
          ctx.scale(1 / scale, -1 / scale);
          ctx.translate(-this.x, -this.y);
          this.x += fontSize * (glyph.horizAdvX || customFont.horizAdvX) / unitsPerEm;
          if (typeof dx[i4] !== "undefined" && !isNaN(dx[i4])) {
            this.x += dx[i4];
          }
        }
        return;
      }
      var {
        x: x2,
        y: y2
      } = this;
      if (ctx.fillStyle) {
        ctx.fillText(renderText, x2, y2);
      }
      if (ctx.strokeStyle) {
        ctx.strokeText(renderText, x2, y2);
      }
    }
    applyAnchoring() {
      if (this.textChunkStart >= this.leafTexts.length) {
        return;
      }
      var firstElement = this.leafTexts[this.textChunkStart];
      var textAnchor = firstElement.getStyle("text-anchor").getString("start");
      var isRTL = false;
      var shift2 = 0;
      if (textAnchor === "start" && !isRTL || textAnchor === "end" && isRTL) {
        shift2 = firstElement.x - this.minX;
      } else if (textAnchor === "end" && !isRTL || textAnchor === "start" && isRTL) {
        shift2 = firstElement.x - this.maxX;
      } else {
        shift2 = firstElement.x - (this.minX + this.maxX) / 2;
      }
      for (var i4 = this.textChunkStart;i4 < this.leafTexts.length; i4++) {
        this.leafTexts[i4].x += shift2;
      }
      this.minX = Number.POSITIVE_INFINITY;
      this.maxX = Number.NEGATIVE_INFINITY;
      this.textChunkStart = this.leafTexts.length;
    }
    adjustChildCoordinatesRecursive(ctx) {
      this.children.forEach((_2, i4) => {
        this.adjustChildCoordinatesRecursiveCore(ctx, this, this, i4);
      });
      this.applyAnchoring();
    }
    adjustChildCoordinatesRecursiveCore(ctx, textParent, parent, i4) {
      var child = parent.children[i4];
      if (child.children.length > 0) {
        child.children.forEach((_2, i5) => {
          textParent.adjustChildCoordinatesRecursiveCore(ctx, textParent, child, i5);
        });
      } else {
        this.adjustChildCoordinates(ctx, textParent, parent, i4);
      }
    }
    adjustChildCoordinates(ctx, textParent, parent, i4) {
      var child = parent.children[i4];
      if (typeof child.measureText !== "function") {
        return child;
      }
      ctx.save();
      child.setContext(ctx, true);
      var xAttr = child.getAttribute("x");
      var yAttr = child.getAttribute("y");
      var dxAttr = child.getAttribute("dx");
      var dyAttr = child.getAttribute("dy");
      var customFont = child.getStyle("font-family").getDefinition();
      var isRTL = Boolean(customFont) && customFont.isRTL;
      if (i4 === 0) {
        if (!xAttr.hasValue()) {
          xAttr.setValue(child.getInheritedAttribute("x"));
        }
        if (!yAttr.hasValue()) {
          yAttr.setValue(child.getInheritedAttribute("y"));
        }
        if (!dxAttr.hasValue()) {
          dxAttr.setValue(child.getInheritedAttribute("dx"));
        }
        if (!dyAttr.hasValue()) {
          dyAttr.setValue(child.getInheritedAttribute("dy"));
        }
      }
      var width = child.measureText(ctx);
      if (isRTL) {
        textParent.x -= width;
      }
      if (xAttr.hasValue()) {
        textParent.applyAnchoring();
        child.x = xAttr.getPixels("x");
        if (dxAttr.hasValue()) {
          child.x += dxAttr.getPixels("x");
        }
      } else {
        if (dxAttr.hasValue()) {
          textParent.x += dxAttr.getPixels("x");
        }
        child.x = textParent.x;
      }
      textParent.x = child.x;
      if (!isRTL) {
        textParent.x += width;
      }
      if (yAttr.hasValue()) {
        child.y = yAttr.getPixels("y");
        if (dyAttr.hasValue()) {
          child.y += dyAttr.getPixels("y");
        }
      } else {
        if (dyAttr.hasValue()) {
          textParent.y += dyAttr.getPixels("y");
        }
        child.y = textParent.y;
      }
      textParent.y = child.y;
      textParent.leafTexts.push(child);
      textParent.minX = Math.min(textParent.minX, child.x, child.x + width);
      textParent.maxX = Math.max(textParent.maxX, child.x, child.x + width);
      child.clearContext(ctx);
      ctx.restore();
      return child;
    }
    getChildBoundingBox(ctx, textParent, parent, i4) {
      var child = parent.children[i4];
      if (typeof child.getBoundingBox !== "function") {
        return null;
      }
      var boundingBox = child.getBoundingBox(ctx);
      if (!boundingBox) {
        return null;
      }
      child.children.forEach((_2, i5) => {
        var childBoundingBox = textParent.getChildBoundingBox(ctx, textParent, child, i5);
        boundingBox.addBoundingBox(childBoundingBox);
      });
      return boundingBox;
    }
    renderChild(ctx, textParent, parent, i4) {
      var child = parent.children[i4];
      child.render(ctx);
      child.children.forEach((_2, i5) => {
        textParent.renderChild(ctx, textParent, child, i5);
      });
    }
    measureText(ctx) {
      var {
        measureCache
      } = this;
      if (~measureCache) {
        return measureCache;
      }
      var renderText = this.getText();
      var measure = this.measureTargetText(ctx, renderText);
      this.measureCache = measure;
      return measure;
    }
    measureTargetText(ctx, targetText) {
      if (!targetText.length) {
        return 0;
      }
      var {
        parent
      } = this;
      var customFont = parent.getStyle("font-family").getDefinition();
      if (customFont) {
        var fontSize = this.getFontSize();
        var text = customFont.isRTL ? targetText.split("").reverse().join("") : targetText;
        var dx = toNumbers(parent.getAttribute("dx").getString());
        var len = text.length;
        var _measure = 0;
        for (var i4 = 0;i4 < len; i4++) {
          var glyph = this.getGlyph(customFont, text, i4);
          _measure += (glyph.horizAdvX || customFont.horizAdvX) * fontSize / customFont.fontFace.unitsPerEm;
          if (typeof dx[i4] !== "undefined" && !isNaN(dx[i4])) {
            _measure += dx[i4];
          }
        }
        return _measure;
      }
      if (!ctx.measureText) {
        return targetText.length * 10;
      }
      ctx.save();
      this.setContext(ctx, true);
      var {
        width: measure
      } = ctx.measureText(targetText);
      this.clearContext(ctx);
      ctx.restore();
      return measure;
    }
    getInheritedAttribute(name) {
      var current = this;
      while (current instanceof TextElement && current.isFirstChild()) {
        var parentAttr = current.parent.getAttribute(name);
        if (parentAttr.hasValue(true)) {
          return parentAttr.getValue("0");
        }
        current = current.parent;
      }
      return null;
    }
  };
  TSpanElement = class TSpanElement extends TextElement {
    constructor(document2, node2, captureTextNodes) {
      super(document2, node2, new.target === TSpanElement ? true : captureTextNodes);
      this.type = "tspan";
      this.text = this.children.length > 0 ? "" : this.getTextFromNode();
    }
    getText() {
      return this.text;
    }
  };
  TextNode2 = class TextNode2 extends TSpanElement {
    constructor() {
      super(...arguments);
      this.type = "textNode";
    }
  };
  SVGElement = class SVGElement extends RenderedElement {
    constructor() {
      super(...arguments);
      this.type = "svg";
      this.root = false;
    }
    setContext(ctx) {
      var _this$node$parentNode;
      var {
        document: document2
      } = this;
      var {
        screen,
        window: window2
      } = document2;
      var canvas = ctx.canvas;
      screen.setDefaults(ctx);
      if (canvas.style && typeof ctx.font !== "undefined" && window2 && typeof window2.getComputedStyle !== "undefined") {
        ctx.font = window2.getComputedStyle(canvas).getPropertyValue("font");
        var fontSizeProp = new Property(document2, "fontSize", Font.parse(ctx.font).fontSize);
        if (fontSizeProp.hasValue()) {
          document2.rootEmSize = fontSizeProp.getPixels("y");
          document2.emSize = document2.rootEmSize;
        }
      }
      if (!this.getAttribute("x").hasValue()) {
        this.getAttribute("x", true).setValue(0);
      }
      if (!this.getAttribute("y").hasValue()) {
        this.getAttribute("y", true).setValue(0);
      }
      var {
        width,
        height
      } = screen.viewPort;
      if (!this.getStyle("width").hasValue()) {
        this.getStyle("width", true).setValue("100%");
      }
      if (!this.getStyle("height").hasValue()) {
        this.getStyle("height", true).setValue("100%");
      }
      if (!this.getStyle("color").hasValue()) {
        this.getStyle("color", true).setValue("black");
      }
      var refXAttr = this.getAttribute("refX");
      var refYAttr = this.getAttribute("refY");
      var viewBoxAttr = this.getAttribute("viewBox");
      var viewBox = viewBoxAttr.hasValue() ? toNumbers(viewBoxAttr.getString()) : null;
      var clip = !this.root && this.getStyle("overflow").getValue("hidden") !== "visible";
      var minX = 0;
      var minY = 0;
      var clipX = 0;
      var clipY = 0;
      if (viewBox) {
        minX = viewBox[0];
        minY = viewBox[1];
      }
      if (!this.root) {
        width = this.getStyle("width").getPixels("x");
        height = this.getStyle("height").getPixels("y");
        if (this.type === "marker") {
          clipX = minX;
          clipY = minY;
          minX = 0;
          minY = 0;
        }
      }
      screen.viewPort.setCurrent(width, height);
      if (this.node && (!this.parent || ((_this$node$parentNode = this.node.parentNode) === null || _this$node$parentNode === undefined ? undefined : _this$node$parentNode.nodeName) === "foreignObject") && this.getStyle("transform", false, true).hasValue() && !this.getStyle("transform-origin", false, true).hasValue()) {
        this.getStyle("transform-origin", true, true).setValue("50% 50%");
      }
      super.setContext(ctx);
      ctx.translate(this.getAttribute("x").getPixels("x"), this.getAttribute("y").getPixels("y"));
      if (viewBox) {
        width = viewBox[2];
        height = viewBox[3];
      }
      document2.setViewBox({
        ctx,
        aspectRatio: this.getAttribute("preserveAspectRatio").getString(),
        width: screen.viewPort.width,
        desiredWidth: width,
        height: screen.viewPort.height,
        desiredHeight: height,
        minX,
        minY,
        refX: refXAttr.getValue(),
        refY: refYAttr.getValue(),
        clip,
        clipX,
        clipY
      });
      if (viewBox) {
        screen.viewPort.removeCurrent();
        screen.viewPort.setCurrent(width, height);
      }
    }
    clearContext(ctx) {
      super.clearContext(ctx);
      this.document.screen.viewPort.removeCurrent();
    }
    resize(width) {
      var height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : width;
      var preserveAspectRatio = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      var widthAttr = this.getAttribute("width", true);
      var heightAttr = this.getAttribute("height", true);
      var viewBoxAttr = this.getAttribute("viewBox");
      var styleAttr = this.getAttribute("style");
      var originWidth = widthAttr.getNumber(0);
      var originHeight = heightAttr.getNumber(0);
      if (preserveAspectRatio) {
        if (typeof preserveAspectRatio === "string") {
          this.getAttribute("preserveAspectRatio", true).setValue(preserveAspectRatio);
        } else {
          var preserveAspectRatioAttr = this.getAttribute("preserveAspectRatio");
          if (preserveAspectRatioAttr.hasValue()) {
            preserveAspectRatioAttr.setValue(preserveAspectRatioAttr.getString().replace(/^\s*(\S.*\S)\s*$/, "$1"));
          }
        }
      }
      widthAttr.setValue(width);
      heightAttr.setValue(height);
      if (!viewBoxAttr.hasValue()) {
        viewBoxAttr.setValue("0 0 ".concat(originWidth || width, " ").concat(originHeight || height));
      }
      if (styleAttr.hasValue()) {
        var widthStyle = this.getStyle("width");
        var heightStyle = this.getStyle("height");
        if (widthStyle.hasValue()) {
          widthStyle.setValue("".concat(width, "px"));
        }
        if (heightStyle.hasValue()) {
          heightStyle.setValue("".concat(height, "px"));
        }
      }
    }
  };
  RectElement = class RectElement extends PathElement {
    constructor() {
      super(...arguments);
      this.type = "rect";
    }
    path(ctx) {
      var x2 = this.getAttribute("x").getPixels("x");
      var y2 = this.getAttribute("y").getPixels("y");
      var width = this.getStyle("width", false, true).getPixels("x");
      var height = this.getStyle("height", false, true).getPixels("y");
      var rxAttr = this.getAttribute("rx");
      var ryAttr = this.getAttribute("ry");
      var rx = rxAttr.getPixels("x");
      var ry = ryAttr.getPixels("y");
      if (rxAttr.hasValue() && !ryAttr.hasValue()) {
        ry = rx;
      }
      if (ryAttr.hasValue() && !rxAttr.hasValue()) {
        rx = ry;
      }
      rx = Math.min(rx, width / 2);
      ry = Math.min(ry, height / 2);
      if (ctx) {
        var KAPPA = 4 * ((Math.sqrt(2) - 1) / 3);
        ctx.beginPath();
        if (height > 0 && width > 0) {
          ctx.moveTo(x2 + rx, y2);
          ctx.lineTo(x2 + width - rx, y2);
          ctx.bezierCurveTo(x2 + width - rx + KAPPA * rx, y2, x2 + width, y2 + ry - KAPPA * ry, x2 + width, y2 + ry);
          ctx.lineTo(x2 + width, y2 + height - ry);
          ctx.bezierCurveTo(x2 + width, y2 + height - ry + KAPPA * ry, x2 + width - rx + KAPPA * rx, y2 + height, x2 + width - rx, y2 + height);
          ctx.lineTo(x2 + rx, y2 + height);
          ctx.bezierCurveTo(x2 + rx - KAPPA * rx, y2 + height, x2, y2 + height - ry + KAPPA * ry, x2, y2 + height - ry);
          ctx.lineTo(x2, y2 + ry);
          ctx.bezierCurveTo(x2, y2 + ry - KAPPA * ry, x2 + rx - KAPPA * rx, y2, x2 + rx, y2);
          ctx.closePath();
        }
      }
      return new BoundingBox(x2, y2, x2 + width, y2 + height);
    }
    getMarkers() {
      return null;
    }
  };
  CircleElement = class CircleElement extends PathElement {
    constructor() {
      super(...arguments);
      this.type = "circle";
    }
    path(ctx) {
      var cx = this.getAttribute("cx").getPixels("x");
      var cy = this.getAttribute("cy").getPixels("y");
      var r2 = this.getAttribute("r").getPixels();
      if (ctx && r2 > 0) {
        ctx.beginPath();
        ctx.arc(cx, cy, r2, 0, Math.PI * 2, false);
        ctx.closePath();
      }
      return new BoundingBox(cx - r2, cy - r2, cx + r2, cy + r2);
    }
    getMarkers() {
      return null;
    }
  };
  EllipseElement = class EllipseElement extends PathElement {
    constructor() {
      super(...arguments);
      this.type = "ellipse";
    }
    path(ctx) {
      var KAPPA = 4 * ((Math.sqrt(2) - 1) / 3);
      var rx = this.getAttribute("rx").getPixels("x");
      var ry = this.getAttribute("ry").getPixels("y");
      var cx = this.getAttribute("cx").getPixels("x");
      var cy = this.getAttribute("cy").getPixels("y");
      if (ctx && rx > 0 && ry > 0) {
        ctx.beginPath();
        ctx.moveTo(cx + rx, cy);
        ctx.bezierCurveTo(cx + rx, cy + KAPPA * ry, cx + KAPPA * rx, cy + ry, cx, cy + ry);
        ctx.bezierCurveTo(cx - KAPPA * rx, cy + ry, cx - rx, cy + KAPPA * ry, cx - rx, cy);
        ctx.bezierCurveTo(cx - rx, cy - KAPPA * ry, cx - KAPPA * rx, cy - ry, cx, cy - ry);
        ctx.bezierCurveTo(cx + KAPPA * rx, cy - ry, cx + rx, cy - KAPPA * ry, cx + rx, cy);
        ctx.closePath();
      }
      return new BoundingBox(cx - rx, cy - ry, cx + rx, cy + ry);
    }
    getMarkers() {
      return null;
    }
  };
  LineElement = class LineElement extends PathElement {
    constructor() {
      super(...arguments);
      this.type = "line";
    }
    getPoints() {
      return [new Point(this.getAttribute("x1").getPixels("x"), this.getAttribute("y1").getPixels("y")), new Point(this.getAttribute("x2").getPixels("x"), this.getAttribute("y2").getPixels("y"))];
    }
    path(ctx) {
      var [{
        x: x0,
        y: y0
      }, {
        x: x1,
        y: y1
      }] = this.getPoints();
      if (ctx) {
        ctx.beginPath();
        ctx.moveTo(x0, y0);
        ctx.lineTo(x1, y1);
      }
      return new BoundingBox(x0, y0, x1, y1);
    }
    getMarkers() {
      var [p0, p1] = this.getPoints();
      var a2 = p0.angleTo(p1);
      return [[p0, a2], [p1, a2]];
    }
  };
  PolylineElement = class PolylineElement extends PathElement {
    constructor(document2, node2, captureTextNodes) {
      super(document2, node2, captureTextNodes);
      this.type = "polyline";
      this.points = [];
      this.points = Point.parsePath(this.getAttribute("points").getString());
    }
    path(ctx) {
      var {
        points
      } = this;
      var [{
        x: x0,
        y: y0
      }] = points;
      var boundingBox = new BoundingBox(x0, y0);
      if (ctx) {
        ctx.beginPath();
        ctx.moveTo(x0, y0);
      }
      points.forEach((_ref) => {
        var {
          x: x2,
          y: y2
        } = _ref;
        boundingBox.addPoint(x2, y2);
        if (ctx) {
          ctx.lineTo(x2, y2);
        }
      });
      return boundingBox;
    }
    getMarkers() {
      var {
        points
      } = this;
      var lastIndex = points.length - 1;
      var markers = [];
      points.forEach((point, i4) => {
        if (i4 === lastIndex) {
          return;
        }
        markers.push([point, point.angleTo(points[i4 + 1])]);
      });
      if (markers.length > 0) {
        markers.push([points[points.length - 1], markers[markers.length - 1][1]]);
      }
      return markers;
    }
  };
  PolygonElement = class PolygonElement extends PolylineElement {
    constructor() {
      super(...arguments);
      this.type = "polygon";
    }
    path(ctx) {
      var boundingBox = super.path(ctx);
      var [{
        x: x2,
        y: y2
      }] = this.points;
      if (ctx) {
        ctx.lineTo(x2, y2);
        ctx.closePath();
      }
      return boundingBox;
    }
  };
  PatternElement = class PatternElement extends Element {
    constructor() {
      super(...arguments);
      this.type = "pattern";
    }
    createPattern(ctx, _2, parentOpacityProp) {
      var width = this.getStyle("width").getPixels("x", true);
      var height = this.getStyle("height").getPixels("y", true);
      var patternSvg = new SVGElement(this.document, null);
      patternSvg.attributes.viewBox = new Property(this.document, "viewBox", this.getAttribute("viewBox").getValue());
      patternSvg.attributes.width = new Property(this.document, "width", "".concat(width, "px"));
      patternSvg.attributes.height = new Property(this.document, "height", "".concat(height, "px"));
      patternSvg.attributes.transform = new Property(this.document, "transform", this.getAttribute("patternTransform").getValue());
      patternSvg.children = this.children;
      var patternCanvas = this.document.createCanvas(width, height);
      var patternCtx = patternCanvas.getContext("2d");
      var xAttr = this.getAttribute("x");
      var yAttr = this.getAttribute("y");
      if (xAttr.hasValue() && yAttr.hasValue()) {
        patternCtx.translate(xAttr.getPixels("x", true), yAttr.getPixels("y", true));
      }
      if (parentOpacityProp.hasValue()) {
        this.styles["fill-opacity"] = parentOpacityProp;
      } else {
        Reflect.deleteProperty(this.styles, "fill-opacity");
      }
      for (var x2 = -1;x2 <= 1; x2++) {
        for (var y2 = -1;y2 <= 1; y2++) {
          patternCtx.save();
          patternSvg.attributes.x = new Property(this.document, "x", x2 * patternCanvas.width);
          patternSvg.attributes.y = new Property(this.document, "y", y2 * patternCanvas.height);
          patternSvg.render(patternCtx);
          patternCtx.restore();
        }
      }
      var pattern = ctx.createPattern(patternCanvas, "repeat");
      return pattern;
    }
  };
  MarkerElement = class MarkerElement extends Element {
    constructor() {
      super(...arguments);
      this.type = "marker";
    }
    render(ctx, point, angle) {
      if (!point) {
        return;
      }
      var {
        x: x2,
        y: y2
      } = point;
      var orient = this.getAttribute("orient").getString("auto");
      var markerUnits = this.getAttribute("markerUnits").getString("strokeWidth");
      ctx.translate(x2, y2);
      if (orient === "auto") {
        ctx.rotate(angle);
      }
      if (markerUnits === "strokeWidth") {
        ctx.scale(ctx.lineWidth, ctx.lineWidth);
      }
      ctx.save();
      var markerSvg = new SVGElement(this.document, null);
      markerSvg.type = this.type;
      markerSvg.attributes.viewBox = new Property(this.document, "viewBox", this.getAttribute("viewBox").getValue());
      markerSvg.attributes.refX = new Property(this.document, "refX", this.getAttribute("refX").getValue());
      markerSvg.attributes.refY = new Property(this.document, "refY", this.getAttribute("refY").getValue());
      markerSvg.attributes.width = new Property(this.document, "width", this.getAttribute("markerWidth").getValue());
      markerSvg.attributes.height = new Property(this.document, "height", this.getAttribute("markerHeight").getValue());
      markerSvg.attributes.overflow = new Property(this.document, "overflow", this.getAttribute("overflow").getValue());
      markerSvg.attributes.fill = new Property(this.document, "fill", this.getAttribute("fill").getColor("black"));
      markerSvg.attributes.stroke = new Property(this.document, "stroke", this.getAttribute("stroke").getValue("none"));
      markerSvg.children = this.children;
      markerSvg.render(ctx);
      ctx.restore();
      if (markerUnits === "strokeWidth") {
        ctx.scale(1 / ctx.lineWidth, 1 / ctx.lineWidth);
      }
      if (orient === "auto") {
        ctx.rotate(-angle);
      }
      ctx.translate(-x2, -y2);
    }
  };
  DefsElement = class DefsElement extends Element {
    constructor() {
      super(...arguments);
      this.type = "defs";
    }
    render() {}
  };
  GElement = class GElement extends RenderedElement {
    constructor() {
      super(...arguments);
      this.type = "g";
    }
    getBoundingBox(ctx) {
      var boundingBox = new BoundingBox;
      this.children.forEach((child) => {
        boundingBox.addBoundingBox(child.getBoundingBox(ctx));
      });
      return boundingBox;
    }
  };
  GradientElement = class GradientElement extends Element {
    constructor(document2, node2, captureTextNodes) {
      super(document2, node2, captureTextNodes);
      this.attributesToInherit = ["gradientUnits"];
      this.stops = [];
      var {
        stops,
        children
      } = this;
      children.forEach((child) => {
        if (child.type === "stop") {
          stops.push(child);
        }
      });
    }
    getGradientUnits() {
      return this.getAttribute("gradientUnits").getString("objectBoundingBox");
    }
    createGradient(ctx, element, parentOpacityProp) {
      var stopsContainer = this;
      if (this.getHrefAttribute().hasValue()) {
        stopsContainer = this.getHrefAttribute().getDefinition();
        this.inheritStopContainer(stopsContainer);
      }
      var {
        stops
      } = stopsContainer;
      var gradient = this.getGradient(ctx, element);
      if (!gradient) {
        return this.addParentOpacity(parentOpacityProp, stops[stops.length - 1].color);
      }
      stops.forEach((stop) => {
        gradient.addColorStop(stop.offset, this.addParentOpacity(parentOpacityProp, stop.color));
      });
      if (this.getAttribute("gradientTransform").hasValue()) {
        var {
          document: document2
        } = this;
        var {
          MAX_VIRTUAL_PIXELS,
          viewPort
        } = document2.screen;
        var [rootView] = viewPort.viewPorts;
        var rect = new RectElement(document2, null);
        rect.attributes.x = new Property(document2, "x", -MAX_VIRTUAL_PIXELS / 3);
        rect.attributes.y = new Property(document2, "y", -MAX_VIRTUAL_PIXELS / 3);
        rect.attributes.width = new Property(document2, "width", MAX_VIRTUAL_PIXELS);
        rect.attributes.height = new Property(document2, "height", MAX_VIRTUAL_PIXELS);
        var group = new GElement(document2, null);
        group.attributes.transform = new Property(document2, "transform", this.getAttribute("gradientTransform").getValue());
        group.children = [rect];
        var patternSvg = new SVGElement(document2, null);
        patternSvg.attributes.x = new Property(document2, "x", 0);
        patternSvg.attributes.y = new Property(document2, "y", 0);
        patternSvg.attributes.width = new Property(document2, "width", rootView.width);
        patternSvg.attributes.height = new Property(document2, "height", rootView.height);
        patternSvg.children = [group];
        var patternCanvas = document2.createCanvas(rootView.width, rootView.height);
        var patternCtx = patternCanvas.getContext("2d");
        patternCtx.fillStyle = gradient;
        patternSvg.render(patternCtx);
        return patternCtx.createPattern(patternCanvas, "no-repeat");
      }
      return gradient;
    }
    inheritStopContainer(stopsContainer) {
      this.attributesToInherit.forEach((attributeToInherit) => {
        if (!this.getAttribute(attributeToInherit).hasValue() && stopsContainer.getAttribute(attributeToInherit).hasValue()) {
          this.getAttribute(attributeToInherit, true).setValue(stopsContainer.getAttribute(attributeToInherit).getValue());
        }
      });
    }
    addParentOpacity(parentOpacityProp, color) {
      if (parentOpacityProp.hasValue()) {
        var colorProp = new Property(this.document, "color", color);
        return colorProp.addOpacity(parentOpacityProp).getColor();
      }
      return color;
    }
  };
  LinearGradientElement = class LinearGradientElement extends GradientElement {
    constructor(document2, node2, captureTextNodes) {
      super(document2, node2, captureTextNodes);
      this.type = "linearGradient";
      this.attributesToInherit.push("x1", "y1", "x2", "y2");
    }
    getGradient(ctx, element) {
      var isBoundingBoxUnits = this.getGradientUnits() === "objectBoundingBox";
      var boundingBox = isBoundingBoxUnits ? element.getBoundingBox(ctx) : null;
      if (isBoundingBoxUnits && !boundingBox) {
        return null;
      }
      if (!this.getAttribute("x1").hasValue() && !this.getAttribute("y1").hasValue() && !this.getAttribute("x2").hasValue() && !this.getAttribute("y2").hasValue()) {
        this.getAttribute("x1", true).setValue(0);
        this.getAttribute("y1", true).setValue(0);
        this.getAttribute("x2", true).setValue(1);
        this.getAttribute("y2", true).setValue(0);
      }
      var x1 = isBoundingBoxUnits ? boundingBox.x + boundingBox.width * this.getAttribute("x1").getNumber() : this.getAttribute("x1").getPixels("x");
      var y1 = isBoundingBoxUnits ? boundingBox.y + boundingBox.height * this.getAttribute("y1").getNumber() : this.getAttribute("y1").getPixels("y");
      var x2 = isBoundingBoxUnits ? boundingBox.x + boundingBox.width * this.getAttribute("x2").getNumber() : this.getAttribute("x2").getPixels("x");
      var y2 = isBoundingBoxUnits ? boundingBox.y + boundingBox.height * this.getAttribute("y2").getNumber() : this.getAttribute("y2").getPixels("y");
      if (x1 === x2 && y1 === y2) {
        return null;
      }
      return ctx.createLinearGradient(x1, y1, x2, y2);
    }
  };
  RadialGradientElement = class RadialGradientElement extends GradientElement {
    constructor(document2, node2, captureTextNodes) {
      super(document2, node2, captureTextNodes);
      this.type = "radialGradient";
      this.attributesToInherit.push("cx", "cy", "r", "fx", "fy", "fr");
    }
    getGradient(ctx, element) {
      var isBoundingBoxUnits = this.getGradientUnits() === "objectBoundingBox";
      var boundingBox = element.getBoundingBox(ctx);
      if (isBoundingBoxUnits && !boundingBox) {
        return null;
      }
      if (!this.getAttribute("cx").hasValue()) {
        this.getAttribute("cx", true).setValue("50%");
      }
      if (!this.getAttribute("cy").hasValue()) {
        this.getAttribute("cy", true).setValue("50%");
      }
      if (!this.getAttribute("r").hasValue()) {
        this.getAttribute("r", true).setValue("50%");
      }
      var cx = isBoundingBoxUnits ? boundingBox.x + boundingBox.width * this.getAttribute("cx").getNumber() : this.getAttribute("cx").getPixels("x");
      var cy = isBoundingBoxUnits ? boundingBox.y + boundingBox.height * this.getAttribute("cy").getNumber() : this.getAttribute("cy").getPixels("y");
      var fx = cx;
      var fy = cy;
      if (this.getAttribute("fx").hasValue()) {
        fx = isBoundingBoxUnits ? boundingBox.x + boundingBox.width * this.getAttribute("fx").getNumber() : this.getAttribute("fx").getPixels("x");
      }
      if (this.getAttribute("fy").hasValue()) {
        fy = isBoundingBoxUnits ? boundingBox.y + boundingBox.height * this.getAttribute("fy").getNumber() : this.getAttribute("fy").getPixels("y");
      }
      var r2 = isBoundingBoxUnits ? (boundingBox.width + boundingBox.height) / 2 * this.getAttribute("r").getNumber() : this.getAttribute("r").getPixels();
      var fr = this.getAttribute("fr").getPixels();
      return ctx.createRadialGradient(fx, fy, fr, cx, cy, r2);
    }
  };
  StopElement = class StopElement extends Element {
    constructor(document2, node2, captureTextNodes) {
      super(document2, node2, captureTextNodes);
      this.type = "stop";
      var offset = Math.max(0, Math.min(1, this.getAttribute("offset").getNumber()));
      var stopOpacity = this.getStyle("stop-opacity");
      var stopColor = this.getStyle("stop-color", true);
      if (stopColor.getString() === "") {
        stopColor.setValue("#000");
      }
      if (stopOpacity.hasValue()) {
        stopColor = stopColor.addOpacity(stopOpacity);
      }
      this.offset = offset;
      this.color = stopColor.getColor();
    }
  };
  AnimateElement = class AnimateElement extends Element {
    constructor(document2, node2, captureTextNodes) {
      super(document2, node2, captureTextNodes);
      this.type = "animate";
      this.duration = 0;
      this.initialValue = null;
      this.initialUnits = "";
      this.removed = false;
      this.frozen = false;
      document2.screen.animations.push(this);
      this.begin = this.getAttribute("begin").getMilliseconds();
      this.maxDuration = this.begin + this.getAttribute("dur").getMilliseconds();
      this.from = this.getAttribute("from");
      this.to = this.getAttribute("to");
      this.values = new Property(document2, "values", null);
      var valuesAttr = this.getAttribute("values");
      if (valuesAttr.hasValue()) {
        this.values.setValue(valuesAttr.getString().split(";"));
      }
    }
    getProperty() {
      var attributeType = this.getAttribute("attributeType").getString();
      var attributeName = this.getAttribute("attributeName").getString();
      if (attributeType === "CSS") {
        return this.parent.getStyle(attributeName, true);
      }
      return this.parent.getAttribute(attributeName, true);
    }
    calcValue() {
      var {
        initialUnits
      } = this;
      var {
        progress,
        from: from2,
        to
      } = this.getProgress();
      var newValue = from2.getNumber() + (to.getNumber() - from2.getNumber()) * progress;
      if (initialUnits === "%") {
        newValue *= 100;
      }
      return "".concat(newValue).concat(initialUnits);
    }
    update(delta) {
      var {
        parent
      } = this;
      var prop = this.getProperty();
      if (!this.initialValue) {
        this.initialValue = prop.getString();
        this.initialUnits = prop.getUnits();
      }
      if (this.duration > this.maxDuration) {
        var fill = this.getAttribute("fill").getString("remove");
        if (this.getAttribute("repeatCount").getString() === "indefinite" || this.getAttribute("repeatDur").getString() === "indefinite") {
          this.duration = 0;
        } else if (fill === "freeze" && !this.frozen) {
          this.frozen = true;
          parent.animationFrozen = true;
          parent.animationFrozenValue = prop.getString();
        } else if (fill === "remove" && !this.removed) {
          this.removed = true;
          prop.setValue(parent.animationFrozen ? parent.animationFrozenValue : this.initialValue);
          return true;
        }
        return false;
      }
      this.duration += delta;
      var updated = false;
      if (this.begin < this.duration) {
        var newValue = this.calcValue();
        var typeAttr = this.getAttribute("type");
        if (typeAttr.hasValue()) {
          var type = typeAttr.getString();
          newValue = "".concat(type, "(").concat(newValue, ")");
        }
        prop.setValue(newValue);
        updated = true;
      }
      return updated;
    }
    getProgress() {
      var {
        document: document2,
        values
      } = this;
      var result = {
        progress: (this.duration - this.begin) / (this.maxDuration - this.begin)
      };
      if (values.hasValue()) {
        var p2 = result.progress * (values.getValue().length - 1);
        var lb = Math.floor(p2);
        var ub = Math.ceil(p2);
        result.from = new Property(document2, "from", parseFloat(values.getValue()[lb]));
        result.to = new Property(document2, "to", parseFloat(values.getValue()[ub]));
        result.progress = (p2 - lb) / (ub - lb);
      } else {
        result.from = this.from;
        result.to = this.to;
      }
      return result;
    }
  };
  AnimateColorElement = class AnimateColorElement extends AnimateElement {
    constructor() {
      super(...arguments);
      this.type = "animateColor";
    }
    calcValue() {
      var {
        progress,
        from: from2,
        to
      } = this.getProgress();
      var colorFrom = new import_rgbcolor.default(from2.getColor());
      var colorTo = new import_rgbcolor.default(to.getColor());
      if (colorFrom.ok && colorTo.ok) {
        var r2 = colorFrom.r + (colorTo.r - colorFrom.r) * progress;
        var g = colorFrom.g + (colorTo.g - colorFrom.g) * progress;
        var b = colorFrom.b + (colorTo.b - colorFrom.b) * progress;
        return "rgb(".concat(Math.floor(r2), ", ").concat(Math.floor(g), ", ").concat(Math.floor(b), ")");
      }
      return this.getAttribute("from").getColor();
    }
  };
  AnimateTransformElement = class AnimateTransformElement extends AnimateElement {
    constructor() {
      super(...arguments);
      this.type = "animateTransform";
    }
    calcValue() {
      var {
        progress,
        from: from2,
        to
      } = this.getProgress();
      var transformFrom = toNumbers(from2.getString());
      var transformTo = toNumbers(to.getString());
      var newValue = transformFrom.map((from3, i4) => {
        var to2 = transformTo[i4];
        return from3 + (to2 - from3) * progress;
      }).join(" ");
      return newValue;
    }
  };
  FontElement = class FontElement extends Element {
    constructor(document2, node2, captureTextNodes) {
      super(document2, node2, captureTextNodes);
      this.type = "font";
      this.glyphs = Object.create(null);
      this.horizAdvX = this.getAttribute("horiz-adv-x").getNumber();
      var {
        definitions
      } = document2;
      var {
        children
      } = this;
      for (var child of children) {
        switch (child.type) {
          case "font-face": {
            this.fontFace = child;
            var fontFamilyStyle = child.getStyle("font-family");
            if (fontFamilyStyle.hasValue()) {
              definitions[fontFamilyStyle.getString()] = this;
            }
            break;
          }
          case "missing-glyph":
            this.missingGlyph = child;
            break;
          case "glyph": {
            var glyph = child;
            if (glyph.arabicForm) {
              this.isRTL = true;
              this.isArabic = true;
              if (typeof this.glyphs[glyph.unicode] === "undefined") {
                this.glyphs[glyph.unicode] = Object.create(null);
              }
              this.glyphs[glyph.unicode][glyph.arabicForm] = glyph;
            } else {
              this.glyphs[glyph.unicode] = glyph;
            }
            break;
          }
        }
      }
    }
    render() {}
  };
  FontFaceElement = class FontFaceElement extends Element {
    constructor(document2, node2, captureTextNodes) {
      super(document2, node2, captureTextNodes);
      this.type = "font-face";
      this.ascent = this.getAttribute("ascent").getNumber();
      this.descent = this.getAttribute("descent").getNumber();
      this.unitsPerEm = this.getAttribute("units-per-em").getNumber();
    }
  };
  MissingGlyphElement = class MissingGlyphElement extends PathElement {
    constructor() {
      super(...arguments);
      this.type = "missing-glyph";
      this.horizAdvX = 0;
    }
  };
  TRefElement = class TRefElement extends TextElement {
    constructor() {
      super(...arguments);
      this.type = "tref";
    }
    getText() {
      var element = this.getHrefAttribute().getDefinition();
      if (element) {
        var firstChild = element.children[0];
        if (firstChild) {
          return firstChild.getText();
        }
      }
      return "";
    }
  };
  AElement = class AElement extends TextElement {
    constructor(document2, node2, captureTextNodes) {
      super(document2, node2, captureTextNodes);
      this.type = "a";
      var {
        childNodes
      } = node2;
      var firstChild = childNodes[0];
      var hasText = childNodes.length > 0 && Array.from(childNodes).every((node3) => node3.nodeType === 3);
      this.hasText = hasText;
      this.text = hasText ? this.getTextFromNode(firstChild) : "";
    }
    getText() {
      return this.text;
    }
    renderChildren(ctx) {
      if (this.hasText) {
        super.renderChildren(ctx);
        var {
          document: document2,
          x: x2,
          y: y2
        } = this;
        var {
          mouse
        } = document2.screen;
        var fontSize = new Property(document2, "fontSize", Font.parse(document2.ctx.font).fontSize);
        if (mouse.isWorking()) {
          mouse.checkBoundingBox(this, new BoundingBox(x2, y2 - fontSize.getPixels("y"), x2 + this.measureText(ctx), y2));
        }
      } else if (this.children.length > 0) {
        var g = new GElement(this.document, null);
        g.children = this.children;
        g.parent = this;
        g.render(ctx);
      }
    }
    onClick() {
      var {
        window: window2
      } = this.document;
      if (window2) {
        window2.open(this.getHrefAttribute().getString());
      }
    }
    onMouseMove() {
      var ctx = this.document.ctx;
      ctx.canvas.style.cursor = "pointer";
    }
  };
  TextPathElement = class TextPathElement extends TextElement {
    constructor(document2, node2, captureTextNodes) {
      super(document2, node2, captureTextNodes);
      this.type = "textPath";
      this.textWidth = 0;
      this.textHeight = 0;
      this.pathLength = -1;
      this.glyphInfo = null;
      this.letterSpacingCache = [];
      this.measuresCache = new Map([["", 0]]);
      var pathElement = this.getHrefAttribute().getDefinition();
      this.text = this.getTextFromNode();
      this.dataArray = this.parsePathData(pathElement);
    }
    getText() {
      return this.text;
    }
    path(ctx) {
      var {
        dataArray
      } = this;
      if (ctx) {
        ctx.beginPath();
      }
      dataArray.forEach((_ref) => {
        var {
          type,
          points
        } = _ref;
        switch (type) {
          case PathParser.LINE_TO:
            if (ctx) {
              ctx.lineTo(points[0], points[1]);
            }
            break;
          case PathParser.MOVE_TO:
            if (ctx) {
              ctx.moveTo(points[0], points[1]);
            }
            break;
          case PathParser.CURVE_TO:
            if (ctx) {
              ctx.bezierCurveTo(points[0], points[1], points[2], points[3], points[4], points[5]);
            }
            break;
          case PathParser.QUAD_TO:
            if (ctx) {
              ctx.quadraticCurveTo(points[0], points[1], points[2], points[3]);
            }
            break;
          case PathParser.ARC: {
            var [cx, cy, rx, ry, theta, dTheta, psi, fs] = points;
            var r2 = rx > ry ? rx : ry;
            var scaleX = rx > ry ? 1 : rx / ry;
            var scaleY = rx > ry ? ry / rx : 1;
            if (ctx) {
              ctx.translate(cx, cy);
              ctx.rotate(psi);
              ctx.scale(scaleX, scaleY);
              ctx.arc(0, 0, r2, theta, theta + dTheta, Boolean(1 - fs));
              ctx.scale(1 / scaleX, 1 / scaleY);
              ctx.rotate(-psi);
              ctx.translate(-cx, -cy);
            }
            break;
          }
          case PathParser.CLOSE_PATH:
            if (ctx) {
              ctx.closePath();
            }
            break;
        }
      });
    }
    renderChildren(ctx) {
      this.setTextData(ctx);
      ctx.save();
      var textDecoration = this.parent.getStyle("text-decoration").getString();
      var fontSize = this.getFontSize();
      var {
        glyphInfo
      } = this;
      var fill = ctx.fillStyle;
      if (textDecoration === "underline") {
        ctx.beginPath();
      }
      glyphInfo.forEach((glyph, i4) => {
        var {
          p0,
          p1,
          rotation,
          text: partialText
        } = glyph;
        ctx.save();
        ctx.translate(p0.x, p0.y);
        ctx.rotate(rotation);
        if (ctx.fillStyle) {
          ctx.fillText(partialText, 0, 0);
        }
        if (ctx.strokeStyle) {
          ctx.strokeText(partialText, 0, 0);
        }
        ctx.restore();
        if (textDecoration === "underline") {
          if (i4 === 0) {
            ctx.moveTo(p0.x, p0.y + fontSize / 8);
          }
          ctx.lineTo(p1.x, p1.y + fontSize / 5);
        }
      });
      if (textDecoration === "underline") {
        ctx.lineWidth = fontSize / 20;
        ctx.strokeStyle = fill;
        ctx.stroke();
        ctx.closePath();
      }
      ctx.restore();
    }
    getLetterSpacingAt() {
      var idx = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      return this.letterSpacingCache[idx] || 0;
    }
    findSegmentToFitChar(ctx, anchor, textFullWidth, fullPathWidth, spacesNumber, inputOffset, dy, c2, charI) {
      var offset = inputOffset;
      var glyphWidth = this.measureText(ctx, c2);
      if (c2 === " " && anchor === "justify" && textFullWidth < fullPathWidth) {
        glyphWidth += (fullPathWidth - textFullWidth) / spacesNumber;
      }
      if (charI > -1) {
        offset += this.getLetterSpacingAt(charI);
      }
      var splineStep = this.textHeight / 20;
      var p0 = this.getEquidistantPointOnPath(offset, splineStep, 0);
      var p1 = this.getEquidistantPointOnPath(offset + glyphWidth, splineStep, 0);
      var segment = {
        p0,
        p1
      };
      var rotation = p0 && p1 ? Math.atan2(p1.y - p0.y, p1.x - p0.x) : 0;
      if (dy) {
        var dyX = Math.cos(Math.PI / 2 + rotation) * dy;
        var dyY = Math.cos(-rotation) * dy;
        segment.p0 = _objectSpread$2(_objectSpread$2({}, p0), {}, {
          x: p0.x + dyX,
          y: p0.y + dyY
        });
        segment.p1 = _objectSpread$2(_objectSpread$2({}, p1), {}, {
          x: p1.x + dyX,
          y: p1.y + dyY
        });
      }
      offset += glyphWidth;
      return {
        offset,
        segment,
        rotation
      };
    }
    measureText(ctx, text) {
      var {
        measuresCache
      } = this;
      var targetText = text || this.getText();
      if (measuresCache.has(targetText)) {
        return measuresCache.get(targetText);
      }
      var measure = this.measureTargetText(ctx, targetText);
      measuresCache.set(targetText, measure);
      return measure;
    }
    setTextData(ctx) {
      if (this.glyphInfo) {
        return;
      }
      var renderText = this.getText();
      var chars = renderText.split("");
      var spacesNumber = renderText.split(" ").length - 1;
      var dx = this.parent.getAttribute("dx").split().map((_2) => _2.getPixels("x"));
      var dy = this.parent.getAttribute("dy").getPixels("y");
      var anchor = this.parent.getStyle("text-anchor").getString("start");
      var thisSpacing = this.getStyle("letter-spacing");
      var parentSpacing = this.parent.getStyle("letter-spacing");
      var letterSpacing = 0;
      if (!thisSpacing.hasValue() || thisSpacing.getValue() === "inherit") {
        letterSpacing = parentSpacing.getPixels();
      } else if (thisSpacing.hasValue()) {
        if (thisSpacing.getValue() !== "initial" && thisSpacing.getValue() !== "unset") {
          letterSpacing = thisSpacing.getPixels();
        }
      }
      var letterSpacingCache = [];
      var textLen = renderText.length;
      this.letterSpacingCache = letterSpacingCache;
      for (var i4 = 0;i4 < textLen; i4++) {
        letterSpacingCache.push(typeof dx[i4] !== "undefined" ? dx[i4] : letterSpacing);
      }
      var dxSum = letterSpacingCache.reduce((acc, cur, i5) => i5 === 0 ? 0 : acc + cur || 0, 0);
      var textWidth = this.measureText(ctx);
      var textFullWidth = Math.max(textWidth + dxSum, 0);
      this.textWidth = textWidth;
      this.textHeight = this.getFontSize();
      this.glyphInfo = [];
      var fullPathWidth = this.getPathLength();
      var startOffset = this.getStyle("startOffset").getNumber(0) * fullPathWidth;
      var offset = 0;
      if (anchor === "middle" || anchor === "center") {
        offset = -textFullWidth / 2;
      }
      if (anchor === "end" || anchor === "right") {
        offset = -textFullWidth;
      }
      offset += startOffset;
      chars.forEach((char, i5) => {
        var {
          offset: nextOffset,
          segment,
          rotation
        } = this.findSegmentToFitChar(ctx, anchor, textFullWidth, fullPathWidth, spacesNumber, offset, dy, char, i5);
        offset = nextOffset;
        if (!segment.p0 || !segment.p1) {
          return;
        }
        this.glyphInfo.push({
          text: chars[i5],
          p0: segment.p0,
          p1: segment.p1,
          rotation
        });
      });
    }
    parsePathData(path) {
      this.pathLength = -1;
      if (!path) {
        return [];
      }
      var pathCommands = [];
      var {
        pathParser
      } = path;
      pathParser.reset();
      while (!pathParser.isEnd()) {
        var {
          current
        } = pathParser;
        var startX = current ? current.x : 0;
        var startY = current ? current.y : 0;
        var command2 = pathParser.next();
        var nextCommandType = command2.type;
        var points = [];
        switch (command2.type) {
          case PathParser.MOVE_TO:
            this.pathM(pathParser, points);
            break;
          case PathParser.LINE_TO:
            nextCommandType = this.pathL(pathParser, points);
            break;
          case PathParser.HORIZ_LINE_TO:
            nextCommandType = this.pathH(pathParser, points);
            break;
          case PathParser.VERT_LINE_TO:
            nextCommandType = this.pathV(pathParser, points);
            break;
          case PathParser.CURVE_TO:
            this.pathC(pathParser, points);
            break;
          case PathParser.SMOOTH_CURVE_TO:
            nextCommandType = this.pathS(pathParser, points);
            break;
          case PathParser.QUAD_TO:
            this.pathQ(pathParser, points);
            break;
          case PathParser.SMOOTH_QUAD_TO:
            nextCommandType = this.pathT(pathParser, points);
            break;
          case PathParser.ARC:
            points = this.pathA(pathParser);
            break;
          case PathParser.CLOSE_PATH:
            PathElement.pathZ(pathParser);
            break;
        }
        if (command2.type !== PathParser.CLOSE_PATH) {
          pathCommands.push({
            type: nextCommandType,
            points,
            start: {
              x: startX,
              y: startY
            },
            pathLength: this.calcLength(startX, startY, nextCommandType, points)
          });
        } else {
          pathCommands.push({
            type: PathParser.CLOSE_PATH,
            points: [],
            pathLength: 0
          });
        }
      }
      return pathCommands;
    }
    pathM(pathParser, points) {
      var {
        x: x2,
        y: y2
      } = PathElement.pathM(pathParser).point;
      points.push(x2, y2);
    }
    pathL(pathParser, points) {
      var {
        x: x2,
        y: y2
      } = PathElement.pathL(pathParser).point;
      points.push(x2, y2);
      return PathParser.LINE_TO;
    }
    pathH(pathParser, points) {
      var {
        x: x2,
        y: y2
      } = PathElement.pathH(pathParser).point;
      points.push(x2, y2);
      return PathParser.LINE_TO;
    }
    pathV(pathParser, points) {
      var {
        x: x2,
        y: y2
      } = PathElement.pathV(pathParser).point;
      points.push(x2, y2);
      return PathParser.LINE_TO;
    }
    pathC(pathParser, points) {
      var {
        point,
        controlPoint,
        currentPoint
      } = PathElement.pathC(pathParser);
      points.push(point.x, point.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);
    }
    pathS(pathParser, points) {
      var {
        point,
        controlPoint,
        currentPoint
      } = PathElement.pathS(pathParser);
      points.push(point.x, point.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);
      return PathParser.CURVE_TO;
    }
    pathQ(pathParser, points) {
      var {
        controlPoint,
        currentPoint
      } = PathElement.pathQ(pathParser);
      points.push(controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);
    }
    pathT(pathParser, points) {
      var {
        controlPoint,
        currentPoint
      } = PathElement.pathT(pathParser);
      points.push(controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);
      return PathParser.QUAD_TO;
    }
    pathA(pathParser) {
      var {
        rX,
        rY,
        sweepFlag,
        xAxisRotation,
        centp,
        a1,
        ad
      } = PathElement.pathA(pathParser);
      if (sweepFlag === 0 && ad > 0) {
        ad -= 2 * Math.PI;
      }
      if (sweepFlag === 1 && ad < 0) {
        ad += 2 * Math.PI;
      }
      return [centp.x, centp.y, rX, rY, a1, ad, xAxisRotation, sweepFlag];
    }
    calcLength(x2, y2, commandType, points) {
      var len = 0;
      var p1 = null;
      var p2 = null;
      var t2 = 0;
      switch (commandType) {
        case PathParser.LINE_TO:
          return this.getLineLength(x2, y2, points[0], points[1]);
        case PathParser.CURVE_TO:
          len = 0;
          p1 = this.getPointOnCubicBezier(0, x2, y2, points[0], points[1], points[2], points[3], points[4], points[5]);
          for (t2 = 0.01;t2 <= 1; t2 += 0.01) {
            p2 = this.getPointOnCubicBezier(t2, x2, y2, points[0], points[1], points[2], points[3], points[4], points[5]);
            len += this.getLineLength(p1.x, p1.y, p2.x, p2.y);
            p1 = p2;
          }
          return len;
        case PathParser.QUAD_TO:
          len = 0;
          p1 = this.getPointOnQuadraticBezier(0, x2, y2, points[0], points[1], points[2], points[3]);
          for (t2 = 0.01;t2 <= 1; t2 += 0.01) {
            p2 = this.getPointOnQuadraticBezier(t2, x2, y2, points[0], points[1], points[2], points[3]);
            len += this.getLineLength(p1.x, p1.y, p2.x, p2.y);
            p1 = p2;
          }
          return len;
        case PathParser.ARC: {
          len = 0;
          var start = points[4];
          var dTheta = points[5];
          var end = points[4] + dTheta;
          var inc = Math.PI / 180;
          if (Math.abs(start - end) < inc) {
            inc = Math.abs(start - end);
          }
          p1 = this.getPointOnEllipticalArc(points[0], points[1], points[2], points[3], start, 0);
          if (dTheta < 0) {
            for (t2 = start - inc;t2 > end; t2 -= inc) {
              p2 = this.getPointOnEllipticalArc(points[0], points[1], points[2], points[3], t2, 0);
              len += this.getLineLength(p1.x, p1.y, p2.x, p2.y);
              p1 = p2;
            }
          } else {
            for (t2 = start + inc;t2 < end; t2 += inc) {
              p2 = this.getPointOnEllipticalArc(points[0], points[1], points[2], points[3], t2, 0);
              len += this.getLineLength(p1.x, p1.y, p2.x, p2.y);
              p1 = p2;
            }
          }
          p2 = this.getPointOnEllipticalArc(points[0], points[1], points[2], points[3], end, 0);
          len += this.getLineLength(p1.x, p1.y, p2.x, p2.y);
          return len;
        }
      }
      return 0;
    }
    getPointOnLine(dist, p1x, p1y, p2x, p2y) {
      var fromX = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : p1x;
      var fromY = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : p1y;
      var m2 = (p2y - p1y) / (p2x - p1x + PSEUDO_ZERO);
      var run2 = Math.sqrt(dist * dist / (1 + m2 * m2));
      if (p2x < p1x) {
        run2 *= -1;
      }
      var rise = m2 * run2;
      var pt = null;
      if (p2x === p1x) {
        pt = {
          x: fromX,
          y: fromY + rise
        };
      } else if ((fromY - p1y) / (fromX - p1x + PSEUDO_ZERO) === m2) {
        pt = {
          x: fromX + run2,
          y: fromY + rise
        };
      } else {
        var ix = 0;
        var iy = 0;
        var len = this.getLineLength(p1x, p1y, p2x, p2y);
        if (len < PSEUDO_ZERO) {
          return null;
        }
        var u2 = (fromX - p1x) * (p2x - p1x) + (fromY - p1y) * (p2y - p1y);
        u2 /= len * len;
        ix = p1x + u2 * (p2x - p1x);
        iy = p1y + u2 * (p2y - p1y);
        var pRise = this.getLineLength(fromX, fromY, ix, iy);
        var pRun = Math.sqrt(dist * dist - pRise * pRise);
        run2 = Math.sqrt(pRun * pRun / (1 + m2 * m2));
        if (p2x < p1x) {
          run2 *= -1;
        }
        rise = m2 * run2;
        pt = {
          x: ix + run2,
          y: iy + rise
        };
      }
      return pt;
    }
    getPointOnPath(distance) {
      var fullLen = this.getPathLength();
      var cumulativePathLength = 0;
      var p2 = null;
      if (distance < -0.00005 || distance - 0.00005 > fullLen) {
        return null;
      }
      var {
        dataArray
      } = this;
      for (var command2 of dataArray) {
        if (command2 && (command2.pathLength < 0.00005 || cumulativePathLength + command2.pathLength + 0.00005 < distance)) {
          cumulativePathLength += command2.pathLength;
          continue;
        }
        var delta = distance - cumulativePathLength;
        var currentT = 0;
        switch (command2.type) {
          case PathParser.LINE_TO:
            p2 = this.getPointOnLine(delta, command2.start.x, command2.start.y, command2.points[0], command2.points[1], command2.start.x, command2.start.y);
            break;
          case PathParser.ARC: {
            var start = command2.points[4];
            var dTheta = command2.points[5];
            var end = command2.points[4] + dTheta;
            currentT = start + delta / command2.pathLength * dTheta;
            if (dTheta < 0 && currentT < end || dTheta >= 0 && currentT > end) {
              break;
            }
            p2 = this.getPointOnEllipticalArc(command2.points[0], command2.points[1], command2.points[2], command2.points[3], currentT, command2.points[6]);
            break;
          }
          case PathParser.CURVE_TO:
            currentT = delta / command2.pathLength;
            if (currentT > 1) {
              currentT = 1;
            }
            p2 = this.getPointOnCubicBezier(currentT, command2.start.x, command2.start.y, command2.points[0], command2.points[1], command2.points[2], command2.points[3], command2.points[4], command2.points[5]);
            break;
          case PathParser.QUAD_TO:
            currentT = delta / command2.pathLength;
            if (currentT > 1) {
              currentT = 1;
            }
            p2 = this.getPointOnQuadraticBezier(currentT, command2.start.x, command2.start.y, command2.points[0], command2.points[1], command2.points[2], command2.points[3]);
            break;
        }
        if (p2) {
          return p2;
        }
        break;
      }
      return null;
    }
    getLineLength(x1, y1, x2, y2) {
      return Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
    }
    getPathLength() {
      if (this.pathLength === -1) {
        this.pathLength = this.dataArray.reduce((length, command2) => command2.pathLength > 0 ? length + command2.pathLength : length, 0);
      }
      return this.pathLength;
    }
    getPointOnCubicBezier(pct, p1x, p1y, p2x, p2y, p3x, p3y, p4x, p4y) {
      var x2 = p4x * CB1(pct) + p3x * CB2(pct) + p2x * CB3(pct) + p1x * CB4(pct);
      var y2 = p4y * CB1(pct) + p3y * CB2(pct) + p2y * CB3(pct) + p1y * CB4(pct);
      return {
        x: x2,
        y: y2
      };
    }
    getPointOnQuadraticBezier(pct, p1x, p1y, p2x, p2y, p3x, p3y) {
      var x2 = p3x * QB1(pct) + p2x * QB2(pct) + p1x * QB3(pct);
      var y2 = p3y * QB1(pct) + p2y * QB2(pct) + p1y * QB3(pct);
      return {
        x: x2,
        y: y2
      };
    }
    getPointOnEllipticalArc(cx, cy, rx, ry, theta, psi) {
      var cosPsi = Math.cos(psi);
      var sinPsi = Math.sin(psi);
      var pt = {
        x: rx * Math.cos(theta),
        y: ry * Math.sin(theta)
      };
      return {
        x: cx + (pt.x * cosPsi - pt.y * sinPsi),
        y: cy + (pt.x * sinPsi + pt.y * cosPsi)
      };
    }
    buildEquidistantCache(inputStep, inputPrecision) {
      var fullLen = this.getPathLength();
      var precision = inputPrecision || 0.25;
      var step = inputStep || fullLen / 100;
      if (!this.equidistantCache || this.equidistantCache.step !== step || this.equidistantCache.precision !== precision) {
        this.equidistantCache = {
          step,
          precision,
          points: []
        };
        var s2 = 0;
        for (var l2 = 0;l2 <= fullLen; l2 += precision) {
          var p0 = this.getPointOnPath(l2);
          var p1 = this.getPointOnPath(l2 + precision);
          if (!p0 || !p1) {
            continue;
          }
          s2 += this.getLineLength(p0.x, p0.y, p1.x, p1.y);
          if (s2 >= step) {
            this.equidistantCache.points.push({
              x: p0.x,
              y: p0.y,
              distance: l2
            });
            s2 -= step;
          }
        }
      }
    }
    getEquidistantPointOnPath(targetDistance, step, precision) {
      this.buildEquidistantCache(step, precision);
      if (targetDistance < 0 || targetDistance - this.getPathLength() > 0.00005) {
        return null;
      }
      var idx = Math.round(targetDistance / this.getPathLength() * (this.equidistantCache.points.length - 1));
      return this.equidistantCache.points[idx] || null;
    }
  };
  dataUriRegex = /^\s*data:(([^/,;]+\/[^/,;]+)(?:;([^,;=]+=[^,;=]+))?)?(?:;(base64))?,(.*)$/i;
  ImageElement = class ImageElement extends RenderedElement {
    constructor(document2, node2, captureTextNodes) {
      super(document2, node2, captureTextNodes);
      this.type = "image";
      this.loaded = false;
      var href = this.getHrefAttribute().getString();
      if (!href) {
        return;
      }
      var isSvg = href.endsWith(".svg") || /^\s*data:image\/svg\+xml/i.test(href);
      document2.images.push(this);
      if (!isSvg) {
        this.loadImage(href);
      } else {
        this.loadSvg(href);
      }
      this.isSvg = isSvg;
    }
    loadImage(href) {
      var _this = this;
      return _asyncToGenerator(function* () {
        try {
          var image = yield _this.document.createImage(href);
          _this.image = image;
        } catch (err2) {
          console.error('Error while loading image "'.concat(href, '":'), err2);
        }
        _this.loaded = true;
      })();
    }
    loadSvg(href) {
      var _this2 = this;
      return _asyncToGenerator(function* () {
        var match = dataUriRegex.exec(href);
        if (match) {
          var data = match[5];
          if (match[4] === "base64") {
            _this2.image = atob(data);
          } else {
            _this2.image = decodeURIComponent(data);
          }
        } else {
          try {
            var response = yield _this2.document.fetch(href);
            var svg = yield response.text();
            _this2.image = svg;
          } catch (err2) {
            console.error('Error while loading image "'.concat(href, '":'), err2);
          }
        }
        _this2.loaded = true;
      })();
    }
    renderChildren(ctx) {
      var {
        document: document2,
        image,
        loaded
      } = this;
      var x2 = this.getAttribute("x").getPixels("x");
      var y2 = this.getAttribute("y").getPixels("y");
      var width = this.getStyle("width").getPixels("x");
      var height = this.getStyle("height").getPixels("y");
      if (!loaded || !image || !width || !height) {
        return;
      }
      ctx.save();
      ctx.translate(x2, y2);
      if (this.isSvg) {
        var subDocument = document2.canvg.forkString(ctx, this.image, {
          ignoreMouse: true,
          ignoreAnimation: true,
          ignoreDimensions: true,
          ignoreClear: true,
          offsetX: 0,
          offsetY: 0,
          scaleWidth: width,
          scaleHeight: height
        });
        subDocument.document.documentElement.parent = this;
        subDocument.render();
      } else {
        var _image = this.image;
        document2.setViewBox({
          ctx,
          aspectRatio: this.getAttribute("preserveAspectRatio").getString(),
          width,
          desiredWidth: _image.width,
          height,
          desiredHeight: _image.height
        });
        if (this.loaded) {
          if (typeof _image.complete === "undefined" || _image.complete) {
            ctx.drawImage(_image, 0, 0);
          }
        }
      }
      ctx.restore();
    }
    getBoundingBox() {
      var x2 = this.getAttribute("x").getPixels("x");
      var y2 = this.getAttribute("y").getPixels("y");
      var width = this.getStyle("width").getPixels("x");
      var height = this.getStyle("height").getPixels("y");
      return new BoundingBox(x2, y2, x2 + width, y2 + height);
    }
  };
  SymbolElement = class SymbolElement extends RenderedElement {
    constructor() {
      super(...arguments);
      this.type = "symbol";
    }
    render(_2) {}
  };
  StyleElement = class StyleElement extends Element {
    constructor(document2, node2, captureTextNodes) {
      super(document2, node2, captureTextNodes);
      this.type = "style";
      var css = compressSpaces(Array.from(node2.childNodes).map((_2) => _2.textContent).join("").replace(/(\/\*([^*]|[\r\n]|(\*+([^*/]|[\r\n])))*\*+\/)|(^[\s]*\/\/.*)/gm, "").replace(/@import.*;/g, ""));
      var cssDefs = css.split("}");
      cssDefs.forEach((_2) => {
        var def = _2.trim();
        if (!def) {
          return;
        }
        var cssParts = def.split("{");
        var cssClasses = cssParts[0].split(",");
        var cssProps = cssParts[1].split(";");
        cssClasses.forEach((_3) => {
          var cssClass = _3.trim();
          if (!cssClass) {
            return;
          }
          var props = document2.styles[cssClass] || {};
          cssProps.forEach((cssProp) => {
            var prop = cssProp.indexOf(":");
            var name = cssProp.substr(0, prop).trim();
            var value = cssProp.substr(prop + 1, cssProp.length - prop).trim();
            if (name && value) {
              props[name] = new Property(document2, name, value);
            }
          });
          document2.styles[cssClass] = props;
          document2.stylesSpecificity[cssClass] = getSelectorSpecificity(cssClass);
          if (cssClass === "@font-face") {
            var fontFamily = props["font-family"].getString().replace(/"|'/g, "");
            var srcs = props.src.getString().split(",");
            srcs.forEach((src) => {
              if (src.indexOf('format("svg")') > 0) {
                var url = parseExternalUrl(src);
                if (url) {
                  new SVGFontLoader(document2).load(fontFamily, url);
                }
              }
            });
          }
        });
      });
    }
  };
  StyleElement.parseExternalUrl = parseExternalUrl;
  UseElement = class UseElement extends RenderedElement {
    constructor() {
      super(...arguments);
      this.type = "use";
    }
    setContext(ctx) {
      super.setContext(ctx);
      var xAttr = this.getAttribute("x");
      var yAttr = this.getAttribute("y");
      if (xAttr.hasValue()) {
        ctx.translate(xAttr.getPixels("x"), 0);
      }
      if (yAttr.hasValue()) {
        ctx.translate(0, yAttr.getPixels("y"));
      }
    }
    path(ctx) {
      var {
        element
      } = this;
      if (element) {
        element.path(ctx);
      }
    }
    renderChildren(ctx) {
      var {
        document: document2,
        element
      } = this;
      if (element) {
        var tempSvg = element;
        if (element.type === "symbol") {
          tempSvg = new SVGElement(document2, null);
          tempSvg.attributes.viewBox = new Property(document2, "viewBox", element.getAttribute("viewBox").getString());
          tempSvg.attributes.preserveAspectRatio = new Property(document2, "preserveAspectRatio", element.getAttribute("preserveAspectRatio").getString());
          tempSvg.attributes.overflow = new Property(document2, "overflow", element.getAttribute("overflow").getString());
          tempSvg.children = element.children;
          element.styles.opacity = new Property(document2, "opacity", this.calculateOpacity());
        }
        if (tempSvg.type === "svg") {
          var widthStyle = this.getStyle("width", false, true);
          var heightStyle = this.getStyle("height", false, true);
          if (widthStyle.hasValue()) {
            tempSvg.attributes.width = new Property(document2, "width", widthStyle.getString());
          }
          if (heightStyle.hasValue()) {
            tempSvg.attributes.height = new Property(document2, "height", heightStyle.getString());
          }
        }
        var oldParent = tempSvg.parent;
        tempSvg.parent = this;
        tempSvg.render(ctx);
        tempSvg.parent = oldParent;
      }
    }
    getBoundingBox(ctx) {
      var {
        element
      } = this;
      if (element) {
        return element.getBoundingBox(ctx);
      }
      return null;
    }
    elementTransform() {
      var {
        document: document2,
        element
      } = this;
      return Transform2.fromElement(document2, element);
    }
    get element() {
      if (!this.cachedElement) {
        this.cachedElement = this.getHrefAttribute().getDefinition();
      }
      return this.cachedElement;
    }
  };
  FeColorMatrixElement = class FeColorMatrixElement extends Element {
    constructor(document2, node2, captureTextNodes) {
      super(document2, node2, captureTextNodes);
      this.type = "feColorMatrix";
      var matrix = toNumbers(this.getAttribute("values").getString());
      switch (this.getAttribute("type").getString("matrix")) {
        case "saturate": {
          var s2 = matrix[0];
          matrix = [0.213 + 0.787 * s2, 0.715 - 0.715 * s2, 0.072 - 0.072 * s2, 0, 0, 0.213 - 0.213 * s2, 0.715 + 0.285 * s2, 0.072 - 0.072 * s2, 0, 0, 0.213 - 0.213 * s2, 0.715 - 0.715 * s2, 0.072 + 0.928 * s2, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1];
          break;
        }
        case "hueRotate": {
          var a2 = matrix[0] * Math.PI / 180;
          matrix = [c2(a2, 0.213, 0.787, -0.213), c2(a2, 0.715, -0.715, -0.715), c2(a2, 0.072, -0.072, 0.928), 0, 0, c2(a2, 0.213, -0.213, 0.143), c2(a2, 0.715, 0.285, 0.14), c2(a2, 0.072, -0.072, -0.283), 0, 0, c2(a2, 0.213, -0.213, -0.787), c2(a2, 0.715, -0.715, 0.715), c2(a2, 0.072, 0.928, 0.072), 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1];
          break;
        }
        case "luminanceToAlpha":
          matrix = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.2125, 0.7154, 0.0721, 0, 0, 0, 0, 0, 0, 1];
          break;
      }
      this.matrix = matrix;
      this.includeOpacity = this.getAttribute("includeOpacity").hasValue();
    }
    apply(ctx, _x, _y, width, height) {
      var {
        includeOpacity,
        matrix
      } = this;
      var srcData = ctx.getImageData(0, 0, width, height);
      for (var y2 = 0;y2 < height; y2++) {
        for (var x2 = 0;x2 < width; x2++) {
          var r2 = imGet(srcData.data, x2, y2, width, height, 0);
          var g = imGet(srcData.data, x2, y2, width, height, 1);
          var b = imGet(srcData.data, x2, y2, width, height, 2);
          var a2 = imGet(srcData.data, x2, y2, width, height, 3);
          var nr = m2(matrix, 0, r2) + m2(matrix, 1, g) + m2(matrix, 2, b) + m2(matrix, 3, a2) + m2(matrix, 4, 1);
          var ng = m2(matrix, 5, r2) + m2(matrix, 6, g) + m2(matrix, 7, b) + m2(matrix, 8, a2) + m2(matrix, 9, 1);
          var nb = m2(matrix, 10, r2) + m2(matrix, 11, g) + m2(matrix, 12, b) + m2(matrix, 13, a2) + m2(matrix, 14, 1);
          var na = m2(matrix, 15, r2) + m2(matrix, 16, g) + m2(matrix, 17, b) + m2(matrix, 18, a2) + m2(matrix, 19, 1);
          if (includeOpacity) {
            nr = 0;
            ng = 0;
            nb = 0;
            na *= a2 / 255;
          }
          imSet(srcData.data, x2, y2, width, height, 0, nr);
          imSet(srcData.data, x2, y2, width, height, 1, ng);
          imSet(srcData.data, x2, y2, width, height, 2, nb);
          imSet(srcData.data, x2, y2, width, height, 3, na);
        }
      }
      ctx.clearRect(0, 0, width, height);
      ctx.putImageData(srcData, 0, 0);
    }
  };
  MaskElement = class MaskElement extends Element {
    constructor() {
      super(...arguments);
      this.type = "mask";
    }
    apply(ctx, element) {
      var {
        document: document2
      } = this;
      var x2 = this.getAttribute("x").getPixels("x");
      var y2 = this.getAttribute("y").getPixels("y");
      var width = this.getStyle("width").getPixels("x");
      var height = this.getStyle("height").getPixels("y");
      if (!width && !height) {
        var boundingBox = new BoundingBox;
        this.children.forEach((child) => {
          boundingBox.addBoundingBox(child.getBoundingBox(ctx));
        });
        x2 = Math.floor(boundingBox.x1);
        y2 = Math.floor(boundingBox.y1);
        width = Math.floor(boundingBox.width);
        height = Math.floor(boundingBox.height);
      }
      var ignoredStyles = this.removeStyles(element, MaskElement.ignoreStyles);
      var maskCanvas = document2.createCanvas(x2 + width, y2 + height);
      var maskCtx = maskCanvas.getContext("2d");
      document2.screen.setDefaults(maskCtx);
      this.renderChildren(maskCtx);
      new FeColorMatrixElement(document2, {
        nodeType: 1,
        childNodes: [],
        attributes: [{
          nodeName: "type",
          value: "luminanceToAlpha"
        }, {
          nodeName: "includeOpacity",
          value: "true"
        }]
      }).apply(maskCtx, 0, 0, x2 + width, y2 + height);
      var tmpCanvas = document2.createCanvas(x2 + width, y2 + height);
      var tmpCtx = tmpCanvas.getContext("2d");
      document2.screen.setDefaults(tmpCtx);
      element.render(tmpCtx);
      tmpCtx.globalCompositeOperation = "destination-in";
      tmpCtx.fillStyle = maskCtx.createPattern(maskCanvas, "no-repeat");
      tmpCtx.fillRect(0, 0, x2 + width, y2 + height);
      ctx.fillStyle = tmpCtx.createPattern(tmpCanvas, "no-repeat");
      ctx.fillRect(0, 0, x2 + width, y2 + height);
      this.restoreStyles(element, ignoredStyles);
    }
    render(_2) {}
  };
  MaskElement.ignoreStyles = ["mask", "transform", "clip-path"];
  ClipPathElement = class ClipPathElement extends Element {
    constructor() {
      super(...arguments);
      this.type = "clipPath";
    }
    apply(ctx) {
      var {
        document: document2
      } = this;
      var contextProto = Reflect.getPrototypeOf(ctx);
      var {
        beginPath,
        closePath
      } = ctx;
      if (contextProto) {
        contextProto.beginPath = noop;
        contextProto.closePath = noop;
      }
      Reflect.apply(beginPath, ctx, []);
      this.children.forEach((child) => {
        if (typeof child.path === "undefined") {
          return;
        }
        var transform = typeof child.elementTransform !== "undefined" ? child.elementTransform() : null;
        if (!transform) {
          transform = Transform2.fromElement(document2, child);
        }
        if (transform) {
          transform.apply(ctx);
        }
        child.path(ctx);
        if (contextProto) {
          contextProto.closePath = closePath;
        }
        if (transform) {
          transform.unapply(ctx);
        }
      });
      Reflect.apply(closePath, ctx, []);
      ctx.clip();
      if (contextProto) {
        contextProto.beginPath = beginPath;
        contextProto.closePath = closePath;
      }
    }
    render(_2) {}
  };
  FilterElement = class FilterElement extends Element {
    constructor() {
      super(...arguments);
      this.type = "filter";
    }
    apply(ctx, element) {
      var {
        document: document2,
        children
      } = this;
      var boundingBox = element.getBoundingBox(ctx);
      if (!boundingBox) {
        return;
      }
      var px = 0;
      var py = 0;
      children.forEach((child) => {
        var efd = child.extraFilterDistance || 0;
        px = Math.max(px, efd);
        py = Math.max(py, efd);
      });
      var width = Math.floor(boundingBox.width);
      var height = Math.floor(boundingBox.height);
      var tmpCanvasWidth = width + 2 * px;
      var tmpCanvasHeight = height + 2 * py;
      if (tmpCanvasWidth < 1 || tmpCanvasHeight < 1) {
        return;
      }
      var x2 = Math.floor(boundingBox.x);
      var y2 = Math.floor(boundingBox.y);
      var ignoredStyles = this.removeStyles(element, FilterElement.ignoreStyles);
      var tmpCanvas = document2.createCanvas(tmpCanvasWidth, tmpCanvasHeight);
      var tmpCtx = tmpCanvas.getContext("2d");
      document2.screen.setDefaults(tmpCtx);
      tmpCtx.translate(-x2 + px, -y2 + py);
      element.render(tmpCtx);
      children.forEach((child) => {
        if (typeof child.apply === "function") {
          child.apply(tmpCtx, 0, 0, tmpCanvasWidth, tmpCanvasHeight);
        }
      });
      ctx.drawImage(tmpCanvas, 0, 0, tmpCanvasWidth, tmpCanvasHeight, x2 - px, y2 - py, tmpCanvasWidth, tmpCanvasHeight);
      this.restoreStyles(element, ignoredStyles);
    }
    render(_2) {}
  };
  FilterElement.ignoreStyles = ["filter", "transform", "clip-path"];
  FeDropShadowElement = class FeDropShadowElement extends Element {
    constructor(document2, node2, captureTextNodes) {
      super(document2, node2, captureTextNodes);
      this.type = "feDropShadow";
      this.addStylesFromStyleDefinition();
    }
    apply(_2, _x, _y, _width, _height) {}
  };
  FeMorphologyElement = class FeMorphologyElement extends Element {
    constructor() {
      super(...arguments);
      this.type = "feMorphology";
    }
    apply(_2, _x, _y, _width, _height) {}
  };
  FeCompositeElement = class FeCompositeElement extends Element {
    constructor() {
      super(...arguments);
      this.type = "feComposite";
    }
    apply(_2, _x, _y, _width, _height) {}
  };
  FeGaussianBlurElement = class FeGaussianBlurElement extends Element {
    constructor(document2, node2, captureTextNodes) {
      super(document2, node2, captureTextNodes);
      this.type = "feGaussianBlur";
      this.blurRadius = Math.floor(this.getAttribute("stdDeviation").getNumber());
      this.extraFilterDistance = this.blurRadius;
    }
    apply(ctx, x2, y2, width, height) {
      var {
        document: document2,
        blurRadius
      } = this;
      var body = document2.window ? document2.window.document.body : null;
      var canvas = ctx.canvas;
      canvas.id = document2.getUniqueId();
      if (body) {
        canvas.style.display = "none";
        body.appendChild(canvas);
      }
      processCanvasRGBA(canvas, x2, y2, width, height, blurRadius);
      if (body) {
        body.removeChild(canvas);
      }
    }
  };
  TitleElement = class TitleElement extends Element {
    constructor() {
      super(...arguments);
      this.type = "title";
    }
  };
  DescElement = class DescElement extends Element {
    constructor() {
      super(...arguments);
      this.type = "desc";
    }
  };
  elements = {
    svg: SVGElement,
    rect: RectElement,
    circle: CircleElement,
    ellipse: EllipseElement,
    line: LineElement,
    polyline: PolylineElement,
    polygon: PolygonElement,
    path: PathElement,
    pattern: PatternElement,
    marker: MarkerElement,
    defs: DefsElement,
    linearGradient: LinearGradientElement,
    radialGradient: RadialGradientElement,
    stop: StopElement,
    animate: AnimateElement,
    animateColor: AnimateColorElement,
    animateTransform: AnimateTransformElement,
    font: FontElement,
    "font-face": FontFaceElement,
    "missing-glyph": MissingGlyphElement,
    glyph: GlyphElement,
    text: TextElement,
    tspan: TSpanElement,
    tref: TRefElement,
    a: AElement,
    textPath: TextPathElement,
    image: ImageElement,
    g: GElement,
    symbol: SymbolElement,
    style: StyleElement,
    use: UseElement,
    mask: MaskElement,
    clipPath: ClipPathElement,
    filter: FilterElement,
    feDropShadow: FeDropShadowElement,
    feMorphology: FeMorphologyElement,
    feComposite: FeCompositeElement,
    feColorMatrix: FeColorMatrixElement,
    feGaussianBlur: FeGaussianBlurElement,
    title: TitleElement,
    desc: DescElement
  };
  Document2.createCanvas = createCanvas;
  Document2.createImage = createImage;
  Document2.elementTypes = elements;
});

// node_modules/jspdf/dist/jspdf.es.min.js
var exports_jspdf_es_min = {};
__export(exports_jspdf_es_min, {
  jsPDF: () => E,
  default: () => jspdf_es_min_default,
  TilingPattern: () => M,
  ShadingPattern: () => B,
  GState: () => j,
  AcroFormTextField: () => Nt,
  AcroFormRadioButton: () => bt,
  AcroFormPushButton: () => vt,
  AcroFormPasswordField: () => Lt,
  AcroFormListBox: () => dt,
  AcroFormEditBox: () => gt,
  AcroFormComboBox: () => pt,
  AcroFormChoiceField: () => ft,
  AcroFormCheckBox: () => wt,
  AcroFormButton: () => mt,
  AcroFormAppearance: () => At,
  AcroForm: () => St
});
function i4() {
  n2.console && typeof n2.console.log == "function" && n2.console.log.apply(n2.console, arguments);
}
function o2(t2, e2, r2) {
  var n3 = new XMLHttpRequest;
  n3.open("GET", t2), n3.responseType = "blob", n3.onload = function() {
    l2(n3.response, e2, r2);
  }, n3.onerror = function() {
    a2.error("could not download file");
  }, n3.send();
}
function s2(t2) {
  var e2 = new XMLHttpRequest;
  e2.open("HEAD", t2, false);
  try {
    e2.send();
  } catch (t3) {}
  return e2.status >= 200 && e2.status <= 299;
}
function c3(t2) {
  try {
    t2.dispatchEvent(new MouseEvent("click"));
  } catch (r2) {
    var e2 = document.createEvent("MouseEvents");
    e2.initMouseEvent("click", true, true, window, 0, 0, 0, 80, 20, false, false, false, false, 0, null), t2.dispatchEvent(e2);
  }
}
function f2(t2) {
  var e2;
  t2 = t2 || "", this.ok = false, t2.charAt(0) == "#" && (t2 = t2.substr(1, 6));
  t2 = { aliceblue: "f0f8ff", antiquewhite: "faebd7", aqua: "00ffff", aquamarine: "7fffd4", azure: "f0ffff", beige: "f5f5dc", bisque: "ffe4c4", black: "000000", blanchedalmond: "ffebcd", blue: "0000ff", blueviolet: "8a2be2", brown: "a52a2a", burlywood: "deb887", cadetblue: "5f9ea0", chartreuse: "7fff00", chocolate: "d2691e", coral: "ff7f50", cornflowerblue: "6495ed", cornsilk: "fff8dc", crimson: "dc143c", cyan: "00ffff", darkblue: "00008b", darkcyan: "008b8b", darkgoldenrod: "b8860b", darkgray: "a9a9a9", darkgreen: "006400", darkkhaki: "bdb76b", darkmagenta: "8b008b", darkolivegreen: "556b2f", darkorange: "ff8c00", darkorchid: "9932cc", darkred: "8b0000", darksalmon: "e9967a", darkseagreen: "8fbc8f", darkslateblue: "483d8b", darkslategray: "2f4f4f", darkturquoise: "00ced1", darkviolet: "9400d3", deeppink: "ff1493", deepskyblue: "00bfff", dimgray: "696969", dodgerblue: "1e90ff", feldspar: "d19275", firebrick: "b22222", floralwhite: "fffaf0", forestgreen: "228b22", fuchsia: "ff00ff", gainsboro: "dcdcdc", ghostwhite: "f8f8ff", gold: "ffd700", goldenrod: "daa520", gray: "808080", green: "008000", greenyellow: "adff2f", honeydew: "f0fff0", hotpink: "ff69b4", indianred: "cd5c5c", indigo: "4b0082", ivory: "fffff0", khaki: "f0e68c", lavender: "e6e6fa", lavenderblush: "fff0f5", lawngreen: "7cfc00", lemonchiffon: "fffacd", lightblue: "add8e6", lightcoral: "f08080", lightcyan: "e0ffff", lightgoldenrodyellow: "fafad2", lightgrey: "d3d3d3", lightgreen: "90ee90", lightpink: "ffb6c1", lightsalmon: "ffa07a", lightseagreen: "20b2aa", lightskyblue: "87cefa", lightslateblue: "8470ff", lightslategray: "778899", lightsteelblue: "b0c4de", lightyellow: "ffffe0", lime: "00ff00", limegreen: "32cd32", linen: "faf0e6", magenta: "ff00ff", maroon: "800000", mediumaquamarine: "66cdaa", mediumblue: "0000cd", mediumorchid: "ba55d3", mediumpurple: "9370d8", mediumseagreen: "3cb371", mediumslateblue: "7b68ee", mediumspringgreen: "00fa9a", mediumturquoise: "48d1cc", mediumvioletred: "c71585", midnightblue: "191970", mintcream: "f5fffa", mistyrose: "ffe4e1", moccasin: "ffe4b5", navajowhite: "ffdead", navy: "000080", oldlace: "fdf5e6", olive: "808000", olivedrab: "6b8e23", orange: "ffa500", orangered: "ff4500", orchid: "da70d6", palegoldenrod: "eee8aa", palegreen: "98fb98", paleturquoise: "afeeee", palevioletred: "d87093", papayawhip: "ffefd5", peachpuff: "ffdab9", peru: "cd853f", pink: "ffc0cb", plum: "dda0dd", powderblue: "b0e0e6", purple: "800080", red: "ff0000", rosybrown: "bc8f8f", royalblue: "4169e1", saddlebrown: "8b4513", salmon: "fa8072", sandybrown: "f4a460", seagreen: "2e8b57", seashell: "fff5ee", sienna: "a0522d", silver: "c0c0c0", skyblue: "87ceeb", slateblue: "6a5acd", slategray: "708090", snow: "fffafa", springgreen: "00ff7f", steelblue: "4682b4", tan: "d2b48c", teal: "008080", thistle: "d8bfd8", tomato: "ff6347", turquoise: "40e0d0", violet: "ee82ee", violetred: "d02090", wheat: "f5deb3", white: "ffffff", whitesmoke: "f5f5f5", yellow: "ffff00", yellowgreen: "9acd32" }[t2 = (t2 = t2.replace(/ /g, "")).toLowerCase()] || t2;
  for (var r2 = [{ re: /^rgb\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})\)$/, example: ["rgb(123, 234, 45)", "rgb(255,234,245)"], process: function(t3) {
    return [parseInt(t3[1]), parseInt(t3[2]), parseInt(t3[3])];
  } }, { re: /^(\w{2})(\w{2})(\w{2})$/, example: ["#00ff00", "336699"], process: function(t3) {
    return [parseInt(t3[1], 16), parseInt(t3[2], 16), parseInt(t3[3], 16)];
  } }, { re: /^(\w{1})(\w{1})(\w{1})$/, example: ["#fb0", "f0f"], process: function(t3) {
    return [parseInt(t3[1] + t3[1], 16), parseInt(t3[2] + t3[2], 16), parseInt(t3[3] + t3[3], 16)];
  } }], n3 = 0;n3 < r2.length; n3++) {
    var i5 = r2[n3].re, a3 = r2[n3].process, o3 = i5.exec(t2);
    o3 && (e2 = a3(o3), this.r = e2[0], this.g = e2[1], this.b = e2[2], this.ok = true);
  }
  this.r = this.r < 0 || isNaN(this.r) ? 0 : this.r > 255 ? 255 : this.r, this.g = this.g < 0 || isNaN(this.g) ? 0 : this.g > 255 ? 255 : this.g, this.b = this.b < 0 || isNaN(this.b) ? 0 : this.b > 255 ? 255 : this.b, this.toRGB = function() {
    return "rgb(" + this.r + ", " + this.g + ", " + this.b + ")";
  }, this.toHex = function() {
    var t3 = this.r.toString(16), e3 = this.g.toString(16), r3 = this.b.toString(16);
    return t3.length == 1 && (t3 = "0" + t3), e3.length == 1 && (e3 = "0" + e3), r3.length == 1 && (r3 = "0" + r3), "#" + t3 + e3 + r3;
  };
}
function d(t2, e2) {
  var r2 = t2[0], n3 = t2[1], i5 = t2[2], a3 = t2[3];
  r2 = g(r2, n3, i5, a3, e2[0], 7, -680876936), a3 = g(a3, r2, n3, i5, e2[1], 12, -389564586), i5 = g(i5, a3, r2, n3, e2[2], 17, 606105819), n3 = g(n3, i5, a3, r2, e2[3], 22, -1044525330), r2 = g(r2, n3, i5, a3, e2[4], 7, -176418897), a3 = g(a3, r2, n3, i5, e2[5], 12, 1200080426), i5 = g(i5, a3, r2, n3, e2[6], 17, -1473231341), n3 = g(n3, i5, a3, r2, e2[7], 22, -45705983), r2 = g(r2, n3, i5, a3, e2[8], 7, 1770035416), a3 = g(a3, r2, n3, i5, e2[9], 12, -1958414417), i5 = g(i5, a3, r2, n3, e2[10], 17, -42063), n3 = g(n3, i5, a3, r2, e2[11], 22, -1990404162), r2 = g(r2, n3, i5, a3, e2[12], 7, 1804603682), a3 = g(a3, r2, n3, i5, e2[13], 12, -40341101), i5 = g(i5, a3, r2, n3, e2[14], 17, -1502002290), r2 = m3(r2, n3 = g(n3, i5, a3, r2, e2[15], 22, 1236535329), i5, a3, e2[1], 5, -165796510), a3 = m3(a3, r2, n3, i5, e2[6], 9, -1069501632), i5 = m3(i5, a3, r2, n3, e2[11], 14, 643717713), n3 = m3(n3, i5, a3, r2, e2[0], 20, -373897302), r2 = m3(r2, n3, i5, a3, e2[5], 5, -701558691), a3 = m3(a3, r2, n3, i5, e2[10], 9, 38016083), i5 = m3(i5, a3, r2, n3, e2[15], 14, -660478335), n3 = m3(n3, i5, a3, r2, e2[4], 20, -405537848), r2 = m3(r2, n3, i5, a3, e2[9], 5, 568446438), a3 = m3(a3, r2, n3, i5, e2[14], 9, -1019803690), i5 = m3(i5, a3, r2, n3, e2[3], 14, -187363961), n3 = m3(n3, i5, a3, r2, e2[8], 20, 1163531501), r2 = m3(r2, n3, i5, a3, e2[13], 5, -1444681467), a3 = m3(a3, r2, n3, i5, e2[2], 9, -51403784), i5 = m3(i5, a3, r2, n3, e2[7], 14, 1735328473), r2 = v2(r2, n3 = m3(n3, i5, a3, r2, e2[12], 20, -1926607734), i5, a3, e2[5], 4, -378558), a3 = v2(a3, r2, n3, i5, e2[8], 11, -2022574463), i5 = v2(i5, a3, r2, n3, e2[11], 16, 1839030562), n3 = v2(n3, i5, a3, r2, e2[14], 23, -35309556), r2 = v2(r2, n3, i5, a3, e2[1], 4, -1530992060), a3 = v2(a3, r2, n3, i5, e2[4], 11, 1272893353), i5 = v2(i5, a3, r2, n3, e2[7], 16, -155497632), n3 = v2(n3, i5, a3, r2, e2[10], 23, -1094730640), r2 = v2(r2, n3, i5, a3, e2[13], 4, 681279174), a3 = v2(a3, r2, n3, i5, e2[0], 11, -358537222), i5 = v2(i5, a3, r2, n3, e2[3], 16, -722521979), n3 = v2(n3, i5, a3, r2, e2[6], 23, 76029189), r2 = v2(r2, n3, i5, a3, e2[9], 4, -640364487), a3 = v2(a3, r2, n3, i5, e2[12], 11, -421815835), i5 = v2(i5, a3, r2, n3, e2[15], 16, 530742520), r2 = b(r2, n3 = v2(n3, i5, a3, r2, e2[2], 23, -995338651), i5, a3, e2[0], 6, -198630844), a3 = b(a3, r2, n3, i5, e2[7], 10, 1126891415), i5 = b(i5, a3, r2, n3, e2[14], 15, -1416354905), n3 = b(n3, i5, a3, r2, e2[5], 21, -57434055), r2 = b(r2, n3, i5, a3, e2[12], 6, 1700485571), a3 = b(a3, r2, n3, i5, e2[3], 10, -1894986606), i5 = b(i5, a3, r2, n3, e2[10], 15, -1051523), n3 = b(n3, i5, a3, r2, e2[1], 21, -2054922799), r2 = b(r2, n3, i5, a3, e2[8], 6, 1873313359), a3 = b(a3, r2, n3, i5, e2[15], 10, -30611744), i5 = b(i5, a3, r2, n3, e2[6], 15, -1560198380), n3 = b(n3, i5, a3, r2, e2[13], 21, 1309151649), r2 = b(r2, n3, i5, a3, e2[4], 6, -145523070), a3 = b(a3, r2, n3, i5, e2[11], 10, -1120210379), i5 = b(i5, a3, r2, n3, e2[2], 15, 718787259), n3 = b(n3, i5, a3, r2, e2[9], 21, -343485551), t2[0] = _2(r2, t2[0]), t2[1] = _2(n3, t2[1]), t2[2] = _2(i5, t2[2]), t2[3] = _2(a3, t2[3]);
}
function p2(t2, e2, r2, n3, i5, a3) {
  return e2 = _2(_2(e2, t2), _2(n3, a3)), _2(e2 << i5 | e2 >>> 32 - i5, r2);
}
function g(t2, e2, r2, n3, i5, a3, o3) {
  return p2(e2 & r2 | ~e2 & n3, t2, e2, i5, a3, o3);
}
function m3(t2, e2, r2, n3, i5, a3, o3) {
  return p2(e2 & n3 | r2 & ~n3, t2, e2, i5, a3, o3);
}
function v2(t2, e2, r2, n3, i5, a3, o3) {
  return p2(e2 ^ r2 ^ n3, t2, e2, i5, a3, o3);
}
function b(t2, e2, r2, n3, i5, a3, o3) {
  return p2(r2 ^ (e2 | ~n3), t2, e2, i5, a3, o3);
}
function y2(t2) {
  var e2, r2 = t2.length, n3 = [1732584193, -271733879, -1732584194, 271733878];
  for (e2 = 64;e2 <= t2.length; e2 += 64)
    d(n3, w(t2.substring(e2 - 64, e2)));
  t2 = t2.substring(e2 - 64);
  var i5 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
  for (e2 = 0;e2 < t2.length; e2++)
    i5[e2 >> 2] |= t2.charCodeAt(e2) << (e2 % 4 << 3);
  if (i5[e2 >> 2] |= 128 << (e2 % 4 << 3), e2 > 55)
    for (d(n3, i5), e2 = 0;e2 < 16; e2++)
      i5[e2] = 0;
  return i5[14] = 8 * r2, d(n3, i5), n3;
}
function w(t2) {
  var e2, r2 = [];
  for (e2 = 0;e2 < 64; e2 += 4)
    r2[e2 >> 2] = t2.charCodeAt(e2) + (t2.charCodeAt(e2 + 1) << 8) + (t2.charCodeAt(e2 + 2) << 16) + (t2.charCodeAt(e2 + 3) << 24);
  return r2;
}
function L(t2) {
  for (var e2 = "", r2 = 0;r2 < 4; r2++)
    e2 += N2[t2 >> 8 * r2 + 4 & 15] + N2[t2 >> 8 * r2 & 15];
  return e2;
}
function A(t2) {
  return String.fromCharCode((255 & t2) >> 0, (65280 & t2) >> 8, (16711680 & t2) >> 16, (4278190080 & t2) >> 24);
}
function x2(t2) {
  return y2(t2).map(A).join("");
}
function _2(t2, e2) {
  if (S) {
    var r2 = (65535 & t2) + (65535 & e2);
    return (t2 >> 16) + (e2 >> 16) + (r2 >> 16) << 16 | 65535 & r2;
  }
  return t2 + e2 & 4294967295;
}
function P(t2, e2) {
  var r2, n3, i5, a3;
  if (t2 !== r2) {
    for (var o3 = (i5 = t2, a3 = 1 + (256 / t2.length >> 0), new Array(a3 + 1).join(i5)), s3 = [], c4 = 0;c4 < 256; c4++)
      s3[c4] = c4;
    var u3 = 0;
    for (c4 = 0;c4 < 256; c4++) {
      var h3 = s3[c4];
      u3 = (u3 + h3 + o3.charCodeAt(c4)) % 256, s3[c4] = s3[u3], s3[u3] = h3;
    }
    r2 = t2, n3 = s3;
  } else
    s3 = n3;
  var l3 = e2.length, f3 = 0, d2 = 0, p3 = "";
  for (c4 = 0;c4 < l3; c4++)
    d2 = (d2 + (h3 = s3[f3 = (f3 + 1) % 256])) % 256, s3[f3] = s3[d2], s3[d2] = h3, o3 = s3[(s3[f3] + s3[d2]) % 256], p3 += String.fromCharCode(e2.charCodeAt(c4) ^ o3);
  return p3;
}
function I(t2, e2, r2, n3) {
  this.v = 1, this.r = 2;
  var i5 = 192;
  t2.forEach(function(t3) {
    if (k.perm !== undefined)
      throw new Error("Invalid permission: " + t3);
    i5 += k[t3];
  }), this.padding = "(N^NuAd\x00NV\x01\b..\x00h>/\fdSiz";
  var a3 = (e2 + this.padding).substr(0, 32), o3 = (r2 + this.padding).substr(0, 32);
  this.O = this.processOwnerPassword(a3, o3), this.P = -(1 + (255 ^ i5)), this.encryptionKey = x2(a3 + this.O + this.lsbFirstWord(this.P) + this.hexToBytes(n3)).substr(0, 5), this.U = P(this.encryptionKey, this.padding);
}
function F(t2) {
  if (/[^\u0000-\u00ff]/.test(t2))
    throw new Error("Invalid PDF Name Object: " + t2 + ", Only accept ASCII characters.");
  for (var e2 = "", r2 = t2.length, n3 = 0;n3 < r2; n3++) {
    var i5 = t2.charCodeAt(n3);
    if (i5 < 33 || i5 === 35 || i5 === 37 || i5 === 40 || i5 === 41 || i5 === 47 || i5 === 60 || i5 === 62 || i5 === 91 || i5 === 93 || i5 === 123 || i5 === 125 || i5 > 126)
      e2 += "#" + ("0" + i5.toString(16)).slice(-2);
    else
      e2 += t2[n3];
  }
  return e2;
}
function C(e2) {
  if (_typeof(e2) !== "object")
    throw new Error("Invalid Context passed to initialize PubSub (jsPDF-module)");
  var r2 = {};
  this.subscribe = function(t2, e3, n3) {
    if (n3 = n3 || false, typeof t2 != "string" || typeof e3 != "function" || typeof n3 != "boolean")
      throw new Error("Invalid arguments passed to PubSub.subscribe (jsPDF-module)");
    r2.hasOwnProperty(t2) || (r2[t2] = {});
    var i5 = Math.random().toString(35);
    return r2[t2][i5] = [e3, !!n3], i5;
  }, this.unsubscribe = function(t2) {
    for (var e3 in r2)
      if (r2[e3][t2])
        return delete r2[e3][t2], Object.keys(r2[e3]).length === 0 && delete r2[e3], true;
    return false;
  }, this.publish = function(t2) {
    if (r2.hasOwnProperty(t2)) {
      var i5 = Array.prototype.slice.call(arguments, 1), o3 = [];
      for (var s3 in r2[t2]) {
        var c4 = r2[t2][s3];
        try {
          c4[0].apply(e2, i5);
        } catch (t3) {
          n2.console && a2.error("jsPDF PubSub Error", t3.message, t3);
        }
        c4[1] && o3.push(s3);
      }
      o3.length && o3.forEach(this.unsubscribe);
    }
  }, this.getTopics = function() {
    return r2;
  };
}
function j(t2) {
  if (!(this instanceof j))
    return new j(t2);
  var e2 = "opacity,stroke-opacity".split(",");
  for (var r2 in t2)
    t2.hasOwnProperty(r2) && e2.indexOf(r2) >= 0 && (this[r2] = t2[r2]);
  this.id = "", this.objectNumber = -1;
}
function O2(t2, e2) {
  this.gState = t2, this.matrix = e2, this.id = "", this.objectNumber = -1;
}
function B(t2, e2, r2, n3, i5) {
  if (!(this instanceof B))
    return new B(t2, e2, r2, n3, i5);
  this.type = t2 === "axial" ? 2 : 3, this.coords = e2, this.colors = r2, O2.call(this, n3, i5);
}
function M(t2, e2, r2, n3, i5) {
  if (!(this instanceof M))
    return new M(t2, e2, r2, n3, i5);
  this.boundingBox = t2, this.xStep = e2, this.yStep = r2, this.stream = "", this.cloneIndex = 0, O2.call(this, n3, i5);
}
function E(e2) {
  var r2, i5 = typeof arguments[0] == "string" ? arguments[0] : "p", o3 = arguments[1], s3 = arguments[2], c4 = arguments[3], u3 = [], d2 = 1, p3 = 16, g2 = "S", m4 = null;
  _typeof(e2 = e2 || {}) === "object" && (i5 = e2.orientation, o3 = e2.unit || o3, s3 = e2.format || s3, c4 = e2.compress || e2.compressPdf || c4, (m4 = e2.encryption || null) !== null && (m4.userPassword = m4.userPassword || "", m4.ownerPassword = m4.ownerPassword || "", m4.userPermissions = m4.userPermissions || []), d2 = typeof e2.userUnit == "number" ? Math.abs(e2.userUnit) : 1, e2.precision !== undefined && (r2 = e2.precision), e2.floatPrecision !== undefined && (p3 = e2.floatPrecision), g2 = e2.defaultPathOperation || "S"), u3 = e2.filters || (c4 === true ? ["FlateEncode"] : u3), o3 = o3 || "mm", i5 = ("" + (i5 || "P")).toLowerCase();
  var v3 = e2.putOnlyUsedFonts || false, b2 = {}, y3 = { internal: {}, __private__: {} };
  y3.__private__.PubSub = C;
  var w2 = "1.3", N3 = y3.__private__.getPdfVersion = function() {
    return w2;
  };
  y3.__private__.setPdfVersion = function(t2) {
    w2 = t2;
  };
  var L2 = { a0: [2383.94, 3370.39], a1: [1683.78, 2383.94], a2: [1190.55, 1683.78], a3: [841.89, 1190.55], a4: [595.28, 841.89], a5: [419.53, 595.28], a6: [297.64, 419.53], a7: [209.76, 297.64], a8: [147.4, 209.76], a9: [104.88, 147.4], a10: [73.7, 104.88], b0: [2834.65, 4008.19], b1: [2004.09, 2834.65], b2: [1417.32, 2004.09], b3: [1000.63, 1417.32], b4: [708.66, 1000.63], b5: [498.9, 708.66], b6: [354.33, 498.9], b7: [249.45, 354.33], b8: [175.75, 249.45], b9: [124.72, 175.75], b10: [87.87, 124.72], c0: [2599.37, 3676.54], c1: [1836.85, 2599.37], c2: [1298.27, 1836.85], c3: [918.43, 1298.27], c4: [649.13, 918.43], c5: [459.21, 649.13], c6: [323.15, 459.21], c7: [229.61, 323.15], c8: [161.57, 229.61], c9: [113.39, 161.57], c10: [79.37, 113.39], dl: [311.81, 623.62], letter: [612, 792], "government-letter": [576, 756], legal: [612, 1008], "junior-legal": [576, 360], ledger: [1224, 792], tabloid: [792, 1224], "credit-card": [153, 243] };
  y3.__private__.getPageFormats = function() {
    return L2;
  };
  var A2 = y3.__private__.getPageFormat = function(t2) {
    return L2[t2];
  };
  s3 = s3 || "a4";
  var x3 = { COMPAT: "compat", ADVANCED: "advanced" }, S2 = x3.COMPAT;
  function _3() {
    this.saveGraphicsState(), lt(new Vt(_t, 0, 0, -_t, 0, Rr() * _t).toString() + " cm"), this.setFontSize(this.getFontSize() / _t), g2 = "n", S2 = x3.ADVANCED;
  }
  function P2() {
    this.restoreGraphicsState(), g2 = "S", S2 = x3.COMPAT;
  }
  var k2 = y3.__private__.combineFontStyleAndFontWeight = function(t2, e3) {
    if (t2 == "bold" && e3 == "normal" || t2 == "bold" && e3 == 400 || t2 == "normal" && e3 == "italic" || t2 == "bold" && e3 == "italic")
      throw new Error("Invalid Combination of fontweight and fontstyle");
    return e3 && (t2 = e3 == 400 || e3 === "normal" ? t2 === "italic" ? "italic" : "normal" : e3 != 700 && e3 !== "bold" || t2 !== "normal" ? (e3 == 700 ? "bold" : e3) + "" + t2 : "bold"), t2;
  };
  y3.advancedAPI = function(t2) {
    var e3 = S2 === x3.COMPAT;
    return e3 && _3.call(this), typeof t2 != "function" || (t2(this), e3 && P2.call(this)), this;
  }, y3.compatAPI = function(t2) {
    var e3 = S2 === x3.ADVANCED;
    return e3 && P2.call(this), typeof t2 != "function" || (t2(this), e3 && _3.call(this)), this;
  }, y3.isAdvancedAPI = function() {
    return S2 === x3.ADVANCED;
  };
  var O3, q = function(t2) {
    if (S2 !== x3.ADVANCED)
      throw new Error(t2 + " is only available in 'advanced' API mode. You need to call advancedAPI() first.");
  }, D = y3.roundToPrecision = y3.__private__.roundToPrecision = function(t2, e3) {
    var n3 = r2 || e3;
    if (isNaN(t2) || isNaN(n3))
      throw new Error("Invalid argument passed to jsPDF.roundToPrecision");
    return t2.toFixed(n3).replace(/0+$/, "");
  };
  O3 = y3.hpf = y3.__private__.hpf = typeof p3 == "number" ? function(t2) {
    if (isNaN(t2))
      throw new Error("Invalid argument passed to jsPDF.hpf");
    return D(t2, p3);
  } : p3 === "smart" ? function(t2) {
    if (isNaN(t2))
      throw new Error("Invalid argument passed to jsPDF.hpf");
    return D(t2, t2 > -1 && t2 < 1 ? 16 : 5);
  } : function(t2) {
    if (isNaN(t2))
      throw new Error("Invalid argument passed to jsPDF.hpf");
    return D(t2, 16);
  };
  var R = y3.f2 = y3.__private__.f2 = function(t2) {
    if (isNaN(t2))
      throw new Error("Invalid argument passed to jsPDF.f2");
    return D(t2, 2);
  }, T2 = y3.__private__.f3 = function(t2) {
    if (isNaN(t2))
      throw new Error("Invalid argument passed to jsPDF.f3");
    return D(t2, 3);
  }, U = y3.scale = y3.__private__.scale = function(t2) {
    if (isNaN(t2))
      throw new Error("Invalid argument passed to jsPDF.scale");
    return S2 === x3.COMPAT ? t2 * _t : S2 === x3.ADVANCED ? t2 : undefined;
  }, z = function(t2) {
    return S2 === x3.COMPAT ? Rr() - t2 : S2 === x3.ADVANCED ? t2 : undefined;
  }, H = function(t2) {
    return U(z(t2));
  };
  y3.__private__.setPrecision = y3.setPrecision = function(t2) {
    typeof parseInt(t2, 10) == "number" && (r2 = parseInt(t2, 10));
  };
  var W, V = "00000000000000000000000000000000", G = y3.__private__.getFileId = function() {
    return V;
  }, Y = y3.__private__.setFileId = function(t2) {
    return V = t2 !== undefined && /^[a-fA-F0-9]{32}$/.test(t2) ? t2.toUpperCase() : V.split("").map(function() {
      return "ABCDEF0123456789".charAt(Math.floor(16 * Math.random()));
    }).join(""), m4 !== null && (Ye = new I(m4.userPermissions, m4.userPassword, m4.ownerPassword, V)), V;
  };
  y3.setFileId = function(t2) {
    return Y(t2), this;
  }, y3.getFileId = function() {
    return G();
  };
  var J = y3.__private__.convertDateToPDFDate = function(t2) {
    var e3 = t2.getTimezoneOffset(), r3 = e3 < 0 ? "+" : "-", n3 = Math.floor(Math.abs(e3 / 60)), i6 = Math.abs(e3 % 60), a3 = [r3, Q(n3), "'", Q(i6), "'"].join("");
    return ["D:", t2.getFullYear(), Q(t2.getMonth() + 1), Q(t2.getDate()), Q(t2.getHours()), Q(t2.getMinutes()), Q(t2.getSeconds()), a3].join("");
  }, X = y3.__private__.convertPDFDateToDate = function(t2) {
    var e3 = parseInt(t2.substr(2, 4), 10), r3 = parseInt(t2.substr(6, 2), 10) - 1, n3 = parseInt(t2.substr(8, 2), 10), i6 = parseInt(t2.substr(10, 2), 10), a3 = parseInt(t2.substr(12, 2), 10), o4 = parseInt(t2.substr(14, 2), 10);
    return new Date(e3, r3, n3, i6, a3, o4, 0);
  }, K = y3.__private__.setCreationDate = function(t2) {
    var e3;
    if (t2 === undefined && (t2 = new Date), t2 instanceof Date)
      e3 = J(t2);
    else {
      if (!/^D:(20[0-2][0-9]|203[0-7]|19[7-9][0-9])(0[0-9]|1[0-2])([0-2][0-9]|3[0-1])(0[0-9]|1[0-9]|2[0-3])(0[0-9]|[1-5][0-9])(0[0-9]|[1-5][0-9])(\+0[0-9]|\+1[0-4]|-0[0-9]|-1[0-1])'(0[0-9]|[1-5][0-9])'?$/.test(t2))
        throw new Error("Invalid argument passed to jsPDF.setCreationDate");
      e3 = t2;
    }
    return W = e3;
  }, Z = y3.__private__.getCreationDate = function(t2) {
    var e3 = W;
    return t2 === "jsDate" && (e3 = X(W)), e3;
  };
  y3.setCreationDate = function(t2) {
    return K(t2), this;
  }, y3.getCreationDate = function(t2) {
    return Z(t2);
  };
  var $, Q = y3.__private__.padd2 = function(t2) {
    return ("0" + parseInt(t2)).slice(-2);
  }, tt = y3.__private__.padd2Hex = function(t2) {
    return ("00" + (t2 = t2.toString())).substr(t2.length);
  }, et2 = 0, rt = [], nt = [], it = 0, at = [], ot = [], st = false, ct = nt, ut = function() {
    et2 = 0, it = 0, nt = [], rt = [], at = [], Qt = Kt(), te = Kt();
  };
  y3.__private__.setCustomOutputDestination = function(t2) {
    st = true, ct = t2;
  };
  var ht = function(t2) {
    st || (ct = t2);
  };
  y3.__private__.resetCustomOutputDestination = function() {
    st = false, ct = nt;
  };
  var lt = y3.__private__.out = function(t2) {
    return t2 = t2.toString(), it += t2.length + 1, ct.push(t2), ct;
  }, ft = y3.__private__.write = function(t2) {
    return lt(arguments.length === 1 ? t2.toString() : Array.prototype.join.call(arguments, " "));
  }, dt = y3.__private__.getArrayBuffer = function(t2) {
    for (var e3 = t2.length, r3 = new ArrayBuffer(e3), n3 = new Uint8Array(r3);e3--; )
      n3[e3] = t2.charCodeAt(e3);
    return r3;
  }, pt = [["Helvetica", "helvetica", "normal", "WinAnsiEncoding"], ["Helvetica-Bold", "helvetica", "bold", "WinAnsiEncoding"], ["Helvetica-Oblique", "helvetica", "italic", "WinAnsiEncoding"], ["Helvetica-BoldOblique", "helvetica", "bolditalic", "WinAnsiEncoding"], ["Courier", "courier", "normal", "WinAnsiEncoding"], ["Courier-Bold", "courier", "bold", "WinAnsiEncoding"], ["Courier-Oblique", "courier", "italic", "WinAnsiEncoding"], ["Courier-BoldOblique", "courier", "bolditalic", "WinAnsiEncoding"], ["Times-Roman", "times", "normal", "WinAnsiEncoding"], ["Times-Bold", "times", "bold", "WinAnsiEncoding"], ["Times-Italic", "times", "italic", "WinAnsiEncoding"], ["Times-BoldItalic", "times", "bolditalic", "WinAnsiEncoding"], ["ZapfDingbats", "zapfdingbats", "normal", null], ["Symbol", "symbol", "normal", null]];
  y3.__private__.getStandardFonts = function() {
    return pt;
  };
  var gt = e2.fontSize || 16;
  y3.__private__.setFontSize = y3.setFontSize = function(t2) {
    return gt = S2 === x3.ADVANCED ? t2 / _t : t2, this;
  };
  var mt, vt = y3.__private__.getFontSize = y3.getFontSize = function() {
    return S2 === x3.COMPAT ? gt : gt * _t;
  }, bt = e2.R2L || false;
  y3.__private__.setR2L = y3.setR2L = function(t2) {
    return bt = t2, this;
  }, y3.__private__.getR2L = y3.getR2L = function() {
    return bt;
  };
  var yt, wt = y3.__private__.setZoomMode = function(t2) {
    var e3 = [undefined, null, "fullwidth", "fullheight", "fullpage", "original"];
    if (/^(?:\d+\.\d*|\d*\.\d+|\d+)%$/.test(t2))
      mt = t2;
    else if (isNaN(t2)) {
      if (e3.indexOf(t2) === -1)
        throw new Error('zoom must be Integer (e.g. 2), a percentage Value (e.g. 300%) or fullwidth, fullheight, fullpage, original. "' + t2 + '" is not recognized.');
      mt = t2;
    } else
      mt = parseInt(t2, 10);
  };
  y3.__private__.getZoomMode = function() {
    return mt;
  };
  var Nt, Lt = y3.__private__.setPageMode = function(t2) {
    if ([undefined, null, "UseNone", "UseOutlines", "UseThumbs", "FullScreen"].indexOf(t2) == -1)
      throw new Error('Page mode must be one of UseNone, UseOutlines, UseThumbs, or FullScreen. "' + t2 + '" is not recognized.');
    yt = t2;
  };
  y3.__private__.getPageMode = function() {
    return yt;
  };
  var At = y3.__private__.setLayoutMode = function(t2) {
    if ([undefined, null, "continuous", "single", "twoleft", "tworight", "two"].indexOf(t2) == -1)
      throw new Error('Layout mode must be one of continuous, single, twoleft, tworight. "' + t2 + '" is not recognized.');
    Nt = t2;
  };
  y3.__private__.getLayoutMode = function() {
    return Nt;
  }, y3.__private__.setDisplayMode = y3.setDisplayMode = function(t2, e3, r3) {
    return wt(t2), At(e3), Lt(r3), this;
  };
  var xt = { title: "", subject: "", author: "", keywords: "", creator: "" };
  y3.__private__.getDocumentProperty = function(t2) {
    if (Object.keys(xt).indexOf(t2) === -1)
      throw new Error("Invalid argument passed to jsPDF.getDocumentProperty");
    return xt[t2];
  }, y3.__private__.getDocumentProperties = function() {
    return xt;
  }, y3.__private__.setDocumentProperties = y3.setProperties = y3.setDocumentProperties = function(t2) {
    for (var e3 in xt)
      xt.hasOwnProperty(e3) && t2[e3] && (xt[e3] = t2[e3]);
    return this;
  }, y3.__private__.setDocumentProperty = function(t2, e3) {
    if (Object.keys(xt).indexOf(t2) === -1)
      throw new Error("Invalid arguments passed to jsPDF.setDocumentProperty");
    return xt[t2] = e3;
  };
  var St, _t, Pt, kt, It, Ft = {}, Ct = {}, jt = [], Ot = {}, Bt = {}, Mt = {}, Et = {}, qt = null, Dt = 0, Rt = [], Tt = new C(y3), Ut = e2.hotfixes || [], zt = {}, Ht = {}, Wt = [], Vt = function t(e3, r3, n3, i6, a3, o4) {
    if (!(this instanceof t))
      return new t(e3, r3, n3, i6, a3, o4);
    isNaN(e3) && (e3 = 1), isNaN(r3) && (r3 = 0), isNaN(n3) && (n3 = 0), isNaN(i6) && (i6 = 1), isNaN(a3) && (a3 = 0), isNaN(o4) && (o4 = 0), this._matrix = [e3, r3, n3, i6, a3, o4];
  };
  Object.defineProperty(Vt.prototype, "sx", { get: function() {
    return this._matrix[0];
  }, set: function(t2) {
    this._matrix[0] = t2;
  } }), Object.defineProperty(Vt.prototype, "shy", { get: function() {
    return this._matrix[1];
  }, set: function(t2) {
    this._matrix[1] = t2;
  } }), Object.defineProperty(Vt.prototype, "shx", { get: function() {
    return this._matrix[2];
  }, set: function(t2) {
    this._matrix[2] = t2;
  } }), Object.defineProperty(Vt.prototype, "sy", { get: function() {
    return this._matrix[3];
  }, set: function(t2) {
    this._matrix[3] = t2;
  } }), Object.defineProperty(Vt.prototype, "tx", { get: function() {
    return this._matrix[4];
  }, set: function(t2) {
    this._matrix[4] = t2;
  } }), Object.defineProperty(Vt.prototype, "ty", { get: function() {
    return this._matrix[5];
  }, set: function(t2) {
    this._matrix[5] = t2;
  } }), Object.defineProperty(Vt.prototype, "a", { get: function() {
    return this._matrix[0];
  }, set: function(t2) {
    this._matrix[0] = t2;
  } }), Object.defineProperty(Vt.prototype, "b", { get: function() {
    return this._matrix[1];
  }, set: function(t2) {
    this._matrix[1] = t2;
  } }), Object.defineProperty(Vt.prototype, "c", { get: function() {
    return this._matrix[2];
  }, set: function(t2) {
    this._matrix[2] = t2;
  } }), Object.defineProperty(Vt.prototype, "d", { get: function() {
    return this._matrix[3];
  }, set: function(t2) {
    this._matrix[3] = t2;
  } }), Object.defineProperty(Vt.prototype, "e", { get: function() {
    return this._matrix[4];
  }, set: function(t2) {
    this._matrix[4] = t2;
  } }), Object.defineProperty(Vt.prototype, "f", { get: function() {
    return this._matrix[5];
  }, set: function(t2) {
    this._matrix[5] = t2;
  } }), Object.defineProperty(Vt.prototype, "rotation", { get: function() {
    return Math.atan2(this.shx, this.sx);
  } }), Object.defineProperty(Vt.prototype, "scaleX", { get: function() {
    return this.decompose().scale.sx;
  } }), Object.defineProperty(Vt.prototype, "scaleY", { get: function() {
    return this.decompose().scale.sy;
  } }), Object.defineProperty(Vt.prototype, "isIdentity", { get: function() {
    return this.sx === 1 && (this.shy === 0 && (this.shx === 0 && (this.sy === 1 && (this.tx === 0 && this.ty === 0))));
  } }), Vt.prototype.join = function(t2) {
    return [this.sx, this.shy, this.shx, this.sy, this.tx, this.ty].map(O3).join(t2);
  }, Vt.prototype.multiply = function(t2) {
    var e3 = t2.sx * this.sx + t2.shy * this.shx, r3 = t2.sx * this.shy + t2.shy * this.sy, n3 = t2.shx * this.sx + t2.sy * this.shx, i6 = t2.shx * this.shy + t2.sy * this.sy, a3 = t2.tx * this.sx + t2.ty * this.shx + this.tx, o4 = t2.tx * this.shy + t2.ty * this.sy + this.ty;
    return new Vt(e3, r3, n3, i6, a3, o4);
  }, Vt.prototype.decompose = function() {
    var t2 = this.sx, e3 = this.shy, r3 = this.shx, n3 = this.sy, i6 = this.tx, a3 = this.ty, o4 = Math.sqrt(t2 * t2 + e3 * e3), s4 = (t2 /= o4) * r3 + (e3 /= o4) * n3;
    r3 -= t2 * s4, n3 -= e3 * s4;
    var c5 = Math.sqrt(r3 * r3 + n3 * n3);
    return s4 /= c5, t2 * (n3 /= c5) < e3 * (r3 /= c5) && (t2 = -t2, e3 = -e3, s4 = -s4, o4 = -o4), { scale: new Vt(o4, 0, 0, c5, 0, 0), translate: new Vt(1, 0, 0, 1, i6, a3), rotate: new Vt(t2, e3, -e3, t2, 0, 0), skew: new Vt(1, 0, s4, 1, 0, 0) };
  }, Vt.prototype.toString = function(t2) {
    return this.join(" ");
  }, Vt.prototype.inversed = function() {
    var t2 = this.sx, e3 = this.shy, r3 = this.shx, n3 = this.sy, i6 = this.tx, a3 = this.ty, o4 = 1 / (t2 * n3 - e3 * r3), s4 = n3 * o4, c5 = -e3 * o4, u4 = -r3 * o4, h3 = t2 * o4;
    return new Vt(s4, c5, u4, h3, -s4 * i6 - u4 * a3, -c5 * i6 - h3 * a3);
  }, Vt.prototype.applyToPoint = function(t2) {
    var e3 = t2.x * this.sx + t2.y * this.shx + this.tx, r3 = t2.x * this.shy + t2.y * this.sy + this.ty;
    return new Cr(e3, r3);
  }, Vt.prototype.applyToRectangle = function(t2) {
    var e3 = this.applyToPoint(t2), r3 = this.applyToPoint(new Cr(t2.x + t2.w, t2.y + t2.h));
    return new jr(e3.x, e3.y, r3.x - e3.x, r3.y - e3.y);
  }, Vt.prototype.clone = function() {
    var t2 = this.sx, e3 = this.shy, r3 = this.shx, n3 = this.sy, i6 = this.tx, a3 = this.ty;
    return new Vt(t2, e3, r3, n3, i6, a3);
  }, y3.Matrix = Vt;
  var Gt = y3.matrixMult = function(t2, e3) {
    return e3.multiply(t2);
  }, Yt = new Vt(1, 0, 0, 1, 0, 0);
  y3.unitMatrix = y3.identityMatrix = Yt;
  var Jt = function(t2, e3) {
    if (!Bt[t2]) {
      var r3 = (e3 instanceof B ? "Sh" : "P") + (Object.keys(Ot).length + 1).toString(10);
      e3.id = r3, Bt[t2] = r3, Ot[r3] = e3, Tt.publish("addPattern", e3);
    }
  };
  y3.ShadingPattern = B, y3.TilingPattern = M, y3.addShadingPattern = function(t2, e3) {
    return q("addShadingPattern()"), Jt(t2, e3), this;
  }, y3.beginTilingPattern = function(t2) {
    q("beginTilingPattern()"), Br(t2.boundingBox[0], t2.boundingBox[1], t2.boundingBox[2] - t2.boundingBox[0], t2.boundingBox[3] - t2.boundingBox[1], t2.matrix);
  }, y3.endTilingPattern = function(t2, e3) {
    q("endTilingPattern()"), e3.stream = ot[$].join(`
`), Jt(t2, e3), Tt.publish("endTilingPattern", e3), Wt.pop().restore();
  };
  var Xt = y3.__private__.newObject = function() {
    var t2 = Kt();
    return Zt(t2, true), t2;
  }, Kt = y3.__private__.newObjectDeferred = function() {
    return et2++, rt[et2] = function() {
      return it;
    }, et2;
  }, Zt = function(t2, e3) {
    return e3 = typeof e3 == "boolean" && e3, rt[t2] = it, e3 && lt(t2 + " 0 obj"), t2;
  }, $t = y3.__private__.newAdditionalObject = function() {
    var t2 = { objId: Kt(), content: "" };
    return at.push(t2), t2;
  }, Qt = Kt(), te = Kt(), ee = y3.__private__.decodeColorString = function(t2) {
    var e3 = t2.split(" ");
    if (e3.length !== 2 || e3[1] !== "g" && e3[1] !== "G") {
      if (e3.length === 5 && (e3[4] === "k" || e3[4] === "K")) {
        e3 = [(1 - e3[0]) * (1 - e3[3]), (1 - e3[1]) * (1 - e3[3]), (1 - e3[2]) * (1 - e3[3]), "r"];
      }
    } else {
      var r3 = parseFloat(e3[0]);
      e3 = [r3, r3, r3, "r"];
    }
    for (var n3 = "#", i6 = 0;i6 < 3; i6++)
      n3 += ("0" + Math.floor(255 * parseFloat(e3[i6])).toString(16)).slice(-2);
    return n3;
  }, re = y3.__private__.encodeColorString = function(e3) {
    var r3;
    typeof e3 == "string" && (e3 = { ch1: e3 });
    var { ch1: n3, ch2: i6, ch3: a3, ch4: o4 } = e3, s4 = e3.pdfColorType === "draw" ? ["G", "RG", "K"] : ["g", "rg", "k"];
    if (typeof n3 == "string" && n3.charAt(0) !== "#") {
      var c5 = new f2(n3);
      if (c5.ok)
        n3 = c5.toHex();
      else if (!/^\d*\.?\d*$/.test(n3))
        throw new Error('Invalid color "' + n3 + '" passed to jsPDF.encodeColorString.');
    }
    if (typeof n3 == "string" && /^#[0-9A-Fa-f]{3}$/.test(n3) && (n3 = "#" + n3[1] + n3[1] + n3[2] + n3[2] + n3[3] + n3[3]), typeof n3 == "string" && /^#[0-9A-Fa-f]{6}$/.test(n3)) {
      var u4 = parseInt(n3.substr(1), 16);
      n3 = u4 >> 16 & 255, i6 = u4 >> 8 & 255, a3 = 255 & u4;
    }
    if (i6 === undefined || o4 === undefined && n3 === i6 && i6 === a3)
      if (typeof n3 == "string")
        r3 = n3 + " " + s4[0];
      else
        switch (e3.precision) {
          case 2:
            r3 = R(n3 / 255) + " " + s4[0];
            break;
          case 3:
          default:
            r3 = T2(n3 / 255) + " " + s4[0];
        }
    else if (o4 === undefined || _typeof(o4) === "object") {
      if (o4 && !isNaN(o4.a) && o4.a === 0)
        return r3 = ["1.", "1.", "1.", s4[1]].join(" ");
      if (typeof n3 == "string")
        r3 = [n3, i6, a3, s4[1]].join(" ");
      else
        switch (e3.precision) {
          case 2:
            r3 = [R(n3 / 255), R(i6 / 255), R(a3 / 255), s4[1]].join(" ");
            break;
          default:
          case 3:
            r3 = [T2(n3 / 255), T2(i6 / 255), T2(a3 / 255), s4[1]].join(" ");
        }
    } else if (typeof n3 == "string")
      r3 = [n3, i6, a3, o4, s4[2]].join(" ");
    else
      switch (e3.precision) {
        case 2:
          r3 = [R(n3), R(i6), R(a3), R(o4), s4[2]].join(" ");
          break;
        case 3:
        default:
          r3 = [T2(n3), T2(i6), T2(a3), T2(o4), s4[2]].join(" ");
      }
    return r3;
  }, ne = y3.__private__.getFilters = function() {
    return u3;
  }, ie3 = y3.__private__.putStream = function(t2) {
    var e3 = (t2 = t2 || {}).data || "", r3 = t2.filters || ne(), n3 = t2.alreadyAppliedFilters || [], i6 = t2.addLength1 || false, a3 = e3.length, o4 = t2.objectId, s4 = function(t3) {
      return t3;
    };
    if (m4 !== null && o4 === undefined)
      throw new Error("ObjectId must be passed to putStream for file encryption");
    m4 !== null && (s4 = Ye.encryptor(o4, 0));
    var c5 = {};
    r3 === true && (r3 = ["FlateEncode"]);
    var u4 = t2.additionalKeyValues || [], h3 = (c5 = E.API.processDataByFilters !== undefined ? E.API.processDataByFilters(e3, r3) : { data: e3, reverseChain: [] }).reverseChain + (Array.isArray(n3) ? n3.join(" ") : n3.toString());
    if (c5.data.length !== 0 && (u4.push({ key: "Length", value: c5.data.length }), i6 === true && u4.push({ key: "Length1", value: a3 })), h3.length != 0)
      if (h3.split("/").length - 1 == 1)
        u4.push({ key: "Filter", value: h3 });
      else {
        u4.push({ key: "Filter", value: "[" + h3 + "]" });
        for (var l3 = 0;l3 < u4.length; l3 += 1)
          if (u4[l3].key === "DecodeParms") {
            for (var f3 = [], d3 = 0;d3 < c5.reverseChain.split("/").length - 1; d3 += 1)
              f3.push("null");
            f3.push(u4[l3].value), u4[l3].value = "[" + f3.join(" ") + "]";
          }
      }
    lt("<<");
    for (var p4 = 0;p4 < u4.length; p4++)
      lt("/" + u4[p4].key + " " + u4[p4].value);
    lt(">>"), c5.data.length !== 0 && (lt("stream"), lt(s4(c5.data)), lt("endstream"));
  }, ae = y3.__private__.putPage = function(t2) {
    var { number: e3, data: r3, objId: n3, contentsObjId: i6 } = t2;
    Zt(n3, true), lt("<</Type /Page"), lt("/Parent " + t2.rootDictionaryObjId + " 0 R"), lt("/Resources " + t2.resourceDictionaryObjId + " 0 R"), lt("/MediaBox [" + parseFloat(O3(t2.mediaBox.bottomLeftX)) + " " + parseFloat(O3(t2.mediaBox.bottomLeftY)) + " " + O3(t2.mediaBox.topRightX) + " " + O3(t2.mediaBox.topRightY) + "]"), t2.cropBox !== null && lt("/CropBox [" + O3(t2.cropBox.bottomLeftX) + " " + O3(t2.cropBox.bottomLeftY) + " " + O3(t2.cropBox.topRightX) + " " + O3(t2.cropBox.topRightY) + "]"), t2.bleedBox !== null && lt("/BleedBox [" + O3(t2.bleedBox.bottomLeftX) + " " + O3(t2.bleedBox.bottomLeftY) + " " + O3(t2.bleedBox.topRightX) + " " + O3(t2.bleedBox.topRightY) + "]"), t2.trimBox !== null && lt("/TrimBox [" + O3(t2.trimBox.bottomLeftX) + " " + O3(t2.trimBox.bottomLeftY) + " " + O3(t2.trimBox.topRightX) + " " + O3(t2.trimBox.topRightY) + "]"), t2.artBox !== null && lt("/ArtBox [" + O3(t2.artBox.bottomLeftX) + " " + O3(t2.artBox.bottomLeftY) + " " + O3(t2.artBox.topRightX) + " " + O3(t2.artBox.topRightY) + "]"), typeof t2.userUnit == "number" && t2.userUnit !== 1 && lt("/UserUnit " + t2.userUnit), Tt.publish("putPage", { objId: n3, pageContext: Rt[e3], pageNumber: e3, page: r3 }), lt("/Contents " + i6 + " 0 R"), lt(">>"), lt("endobj");
    var a3 = r3.join(`
`);
    return S2 === x3.ADVANCED && (a3 += `
Q`), Zt(i6, true), ie3({ data: a3, filters: ne(), objectId: i6 }), lt("endobj"), n3;
  }, oe = y3.__private__.putPages = function() {
    var t2, e3, r3 = [];
    for (t2 = 1;t2 <= Dt; t2++)
      Rt[t2].objId = Kt(), Rt[t2].contentsObjId = Kt();
    for (t2 = 1;t2 <= Dt; t2++)
      r3.push(ae({ number: t2, data: ot[t2], objId: Rt[t2].objId, contentsObjId: Rt[t2].contentsObjId, mediaBox: Rt[t2].mediaBox, cropBox: Rt[t2].cropBox, bleedBox: Rt[t2].bleedBox, trimBox: Rt[t2].trimBox, artBox: Rt[t2].artBox, userUnit: Rt[t2].userUnit, rootDictionaryObjId: Qt, resourceDictionaryObjId: te }));
    Zt(Qt, true), lt("<</Type /Pages");
    var n3 = "/Kids [";
    for (e3 = 0;e3 < Dt; e3++)
      n3 += r3[e3] + " 0 R ";
    lt(n3 + "]"), lt("/Count " + Dt), lt(">>"), lt("endobj"), Tt.publish("postPutPages");
  }, se = function(t2) {
    Tt.publish("putFont", { font: t2, out: lt, newObject: Xt, putStream: ie3 }), t2.isAlreadyPutted !== true && (t2.objectNumber = Xt(), lt("<<"), lt("/Type /Font"), lt("/BaseFont /" + F(t2.postScriptName)), lt("/Subtype /Type1"), typeof t2.encoding == "string" && lt("/Encoding /" + t2.encoding), lt("/FirstChar 32"), lt("/LastChar 255"), lt(">>"), lt("endobj"));
  }, ce = function() {
    for (var t2 in Ft)
      Ft.hasOwnProperty(t2) && (v3 === false || v3 === true && b2.hasOwnProperty(t2)) && se(Ft[t2]);
  }, ue = function(t2) {
    t2.objectNumber = Xt();
    var e3 = [];
    e3.push({ key: "Type", value: "/XObject" }), e3.push({ key: "Subtype", value: "/Form" }), e3.push({ key: "BBox", value: "[" + [O3(t2.x), O3(t2.y), O3(t2.x + t2.width), O3(t2.y + t2.height)].join(" ") + "]" }), e3.push({ key: "Matrix", value: "[" + t2.matrix.toString() + "]" });
    var r3 = t2.pages[1].join(`
`);
    ie3({ data: r3, additionalKeyValues: e3, objectId: t2.objectNumber }), lt("endobj");
  }, he = function() {
    for (var t2 in zt)
      zt.hasOwnProperty(t2) && ue(zt[t2]);
  }, le = function(t2, e3) {
    var r3, n3 = [], i6 = 1 / (e3 - 1);
    for (r3 = 0;r3 < 1; r3 += i6)
      n3.push(r3);
    if (n3.push(1), t2[0].offset != 0) {
      var a3 = { offset: 0, color: t2[0].color };
      t2.unshift(a3);
    }
    if (t2[t2.length - 1].offset != 1) {
      var o4 = { offset: 1, color: t2[t2.length - 1].color };
      t2.push(o4);
    }
    for (var s4 = "", c5 = 0, u4 = 0;u4 < n3.length; u4++) {
      for (r3 = n3[u4];r3 > t2[c5 + 1].offset; )
        c5++;
      var h3 = t2[c5].offset, l3 = (r3 - h3) / (t2[c5 + 1].offset - h3), f3 = t2[c5].color, d3 = t2[c5 + 1].color;
      s4 += tt(Math.round((1 - l3) * f3[0] + l3 * d3[0]).toString(16)) + tt(Math.round((1 - l3) * f3[1] + l3 * d3[1]).toString(16)) + tt(Math.round((1 - l3) * f3[2] + l3 * d3[2]).toString(16));
    }
    return s4.trim();
  }, fe = function(t2, e3) {
    e3 || (e3 = 21);
    var r3 = Xt(), n3 = le(t2.colors, e3), i6 = [];
    i6.push({ key: "FunctionType", value: "0" }), i6.push({ key: "Domain", value: "[0.0 1.0]" }), i6.push({ key: "Size", value: "[" + e3 + "]" }), i6.push({ key: "BitsPerSample", value: "8" }), i6.push({ key: "Range", value: "[0.0 1.0 0.0 1.0 0.0 1.0]" }), i6.push({ key: "Decode", value: "[0.0 1.0 0.0 1.0 0.0 1.0]" }), ie3({ data: n3, additionalKeyValues: i6, alreadyAppliedFilters: ["/ASCIIHexDecode"], objectId: r3 }), lt("endobj"), t2.objectNumber = Xt(), lt("<< /ShadingType " + t2.type), lt("/ColorSpace /DeviceRGB");
    var a3 = "/Coords [" + O3(parseFloat(t2.coords[0])) + " " + O3(parseFloat(t2.coords[1])) + " ";
    t2.type === 2 ? a3 += O3(parseFloat(t2.coords[2])) + " " + O3(parseFloat(t2.coords[3])) : a3 += O3(parseFloat(t2.coords[2])) + " " + O3(parseFloat(t2.coords[3])) + " " + O3(parseFloat(t2.coords[4])) + " " + O3(parseFloat(t2.coords[5])), lt(a3 += "]"), t2.matrix && lt("/Matrix [" + t2.matrix.toString() + "]"), lt("/Function " + r3 + " 0 R"), lt("/Extend [true true]"), lt(">>"), lt("endobj");
  }, de = function(t2, e3) {
    var r3 = Kt(), n3 = Xt();
    e3.push({ resourcesOid: r3, objectOid: n3 }), t2.objectNumber = n3;
    var i6 = [];
    i6.push({ key: "Type", value: "/Pattern" }), i6.push({ key: "PatternType", value: "1" }), i6.push({ key: "PaintType", value: "1" }), i6.push({ key: "TilingType", value: "1" }), i6.push({ key: "BBox", value: "[" + t2.boundingBox.map(O3).join(" ") + "]" }), i6.push({ key: "XStep", value: O3(t2.xStep) }), i6.push({ key: "YStep", value: O3(t2.yStep) }), i6.push({ key: "Resources", value: r3 + " 0 R" }), t2.matrix && i6.push({ key: "Matrix", value: "[" + t2.matrix.toString() + "]" }), ie3({ data: t2.stream, additionalKeyValues: i6, objectId: t2.objectNumber }), lt("endobj");
  }, pe = function(t2) {
    var e3;
    for (e3 in Ot)
      Ot.hasOwnProperty(e3) && (Ot[e3] instanceof B ? fe(Ot[e3]) : Ot[e3] instanceof M && de(Ot[e3], t2));
  }, ge = function(t2) {
    for (var e3 in t2.objectNumber = Xt(), lt("<<"), t2)
      switch (e3) {
        case "opacity":
          lt("/ca " + R(t2[e3]));
          break;
        case "stroke-opacity":
          lt("/CA " + R(t2[e3]));
      }
    lt(">>"), lt("endobj");
  }, me = function() {
    var t2;
    for (t2 in Mt)
      Mt.hasOwnProperty(t2) && ge(Mt[t2]);
  }, ve = function() {
    for (var t2 in lt("/XObject <<"), zt)
      zt.hasOwnProperty(t2) && zt[t2].objectNumber >= 0 && lt("/" + t2 + " " + zt[t2].objectNumber + " 0 R");
    Tt.publish("putXobjectDict"), lt(">>");
  }, be = function() {
    Ye.oid = Xt(), lt("<<"), lt("/Filter /Standard"), lt("/V " + Ye.v), lt("/R " + Ye.r), lt("/U <" + Ye.toHexString(Ye.U) + ">"), lt("/O <" + Ye.toHexString(Ye.O) + ">"), lt("/P " + Ye.P), lt(">>"), lt("endobj");
  }, ye = function() {
    for (var t2 in lt("/Font <<"), Ft)
      Ft.hasOwnProperty(t2) && (v3 === false || v3 === true && b2.hasOwnProperty(t2)) && lt("/" + t2 + " " + Ft[t2].objectNumber + " 0 R");
    lt(">>");
  }, we = function() {
    if (Object.keys(Ot).length > 0) {
      for (var t2 in lt("/Shading <<"), Ot)
        Ot.hasOwnProperty(t2) && Ot[t2] instanceof B && Ot[t2].objectNumber >= 0 && lt("/" + t2 + " " + Ot[t2].objectNumber + " 0 R");
      Tt.publish("putShadingPatternDict"), lt(">>");
    }
  }, Ne = function(t2) {
    if (Object.keys(Ot).length > 0) {
      for (var e3 in lt("/Pattern <<"), Ot)
        Ot.hasOwnProperty(e3) && Ot[e3] instanceof y3.TilingPattern && Ot[e3].objectNumber >= 0 && Ot[e3].objectNumber < t2 && lt("/" + e3 + " " + Ot[e3].objectNumber + " 0 R");
      Tt.publish("putTilingPatternDict"), lt(">>");
    }
  }, Le = function() {
    if (Object.keys(Mt).length > 0) {
      var t2;
      for (t2 in lt("/ExtGState <<"), Mt)
        Mt.hasOwnProperty(t2) && Mt[t2].objectNumber >= 0 && lt("/" + t2 + " " + Mt[t2].objectNumber + " 0 R");
      Tt.publish("putGStateDict"), lt(">>");
    }
  }, Ae = function(t2) {
    Zt(t2.resourcesOid, true), lt("<<"), lt("/ProcSet [/PDF /Text /ImageB /ImageC /ImageI]"), ye(), we(), Ne(t2.objectOid), Le(), ve(), lt(">>"), lt("endobj");
  }, xe = function() {
    var t2 = [];
    ce(), me(), he(), pe(t2), Tt.publish("putResources"), t2.forEach(Ae), Ae({ resourcesOid: te, objectOid: Number.MAX_SAFE_INTEGER }), Tt.publish("postPutResources");
  }, Se = function() {
    Tt.publish("putAdditionalObjects");
    for (var t2 = 0;t2 < at.length; t2++) {
      var e3 = at[t2];
      Zt(e3.objId, true), lt(e3.content), lt("endobj");
    }
    Tt.publish("postPutAdditionalObjects");
  }, _e = function(t2) {
    Ct[t2.fontName] = Ct[t2.fontName] || {}, Ct[t2.fontName][t2.fontStyle] = t2.id;
  }, Pe = function(t2, e3, r3, n3, i6) {
    var a3 = { id: "F" + (Object.keys(Ft).length + 1).toString(10), postScriptName: t2, fontName: e3, fontStyle: r3, encoding: n3, isStandardFont: i6 || false, metadata: {} };
    return Tt.publish("addFont", { font: a3, instance: this }), Ft[a3.id] = a3, _e(a3), a3.id;
  }, ke = function(t2) {
    for (var e3 = 0, r3 = pt.length;e3 < r3; e3++) {
      var n3 = Pe.call(this, t2[e3][0], t2[e3][1], t2[e3][2], pt[e3][3], true);
      v3 === false && (b2[n3] = true);
      var i6 = t2[e3][0].split("-");
      _e({ id: n3, fontName: i6[0], fontStyle: i6[1] || "" });
    }
    Tt.publish("addFonts", { fonts: Ft, dictionary: Ct });
  }, Ie = function(t2) {
    return t2.foo = function() {
      try {
        return t2.apply(this, arguments);
      } catch (t3) {
        var e3 = t3.stack || "";
        ~e3.indexOf(" at ") && (e3 = e3.split(" at ")[1]);
        var r3 = "Error in function " + e3.split(`
`)[0].split("<")[0] + ": " + t3.message;
        if (!n2.console)
          throw new Error(r3);
        n2.console.error(r3, t3), n2.alert && alert(r3);
      }
    }, t2.foo.bar = t2, t2.foo;
  }, Fe = function(t2, e3) {
    var r3, n3, i6, a3, o4, s4, c5, u4, h3;
    if (i6 = (e3 = e3 || {}).sourceEncoding || "Unicode", o4 = e3.outputEncoding, (e3.autoencode || o4) && Ft[St].metadata && Ft[St].metadata[i6] && Ft[St].metadata[i6].encoding && (a3 = Ft[St].metadata[i6].encoding, !o4 && Ft[St].encoding && (o4 = Ft[St].encoding), !o4 && a3.codePages && (o4 = a3.codePages[0]), typeof o4 == "string" && (o4 = a3[o4]), o4)) {
      for (c5 = false, s4 = [], r3 = 0, n3 = t2.length;r3 < n3; r3++)
        (u4 = o4[t2.charCodeAt(r3)]) ? s4.push(String.fromCharCode(u4)) : s4.push(t2[r3]), s4[r3].charCodeAt(0) >> 8 && (c5 = true);
      t2 = s4.join("");
    }
    for (r3 = t2.length;c5 === undefined && r3 !== 0; )
      t2.charCodeAt(r3 - 1) >> 8 && (c5 = true), r3--;
    if (!c5)
      return t2;
    for (s4 = e3.noBOM ? [] : [254, 255], r3 = 0, n3 = t2.length;r3 < n3; r3++) {
      if ((h3 = (u4 = t2.charCodeAt(r3)) >> 8) >> 8)
        throw new Error("Character at position " + r3 + " of string '" + t2 + "' exceeds 16bits. Cannot be encoded into UCS-2 BE");
      s4.push(h3), s4.push(u4 - (h3 << 8));
    }
    return String.fromCharCode.apply(undefined, s4);
  }, Ce = y3.__private__.pdfEscape = y3.pdfEscape = function(t2, e3) {
    return Fe(t2, e3).replace(/\\/g, "\\\\").replace(/\(/g, "\\(").replace(/\)/g, "\\)");
  }, je = y3.__private__.beginPage = function(t2) {
    ot[++Dt] = [], Rt[Dt] = { objId: 0, contentsObjId: 0, userUnit: Number(d2), artBox: null, bleedBox: null, cropBox: null, trimBox: null, mediaBox: { bottomLeftX: 0, bottomLeftY: 0, topRightX: Number(t2[0]), topRightY: Number(t2[1]) } }, Me(Dt), ht(ot[$]);
  }, Oe = function(t2, e3) {
    var r3, n3, o4;
    switch (i5 = e3 || i5, typeof t2 == "string" && (r3 = A2(t2.toLowerCase()), Array.isArray(r3) && (n3 = r3[0], o4 = r3[1])), Array.isArray(t2) && (n3 = t2[0] * _t, o4 = t2[1] * _t), isNaN(n3) && (n3 = s3[0], o4 = s3[1]), (n3 > 14400 || o4 > 14400) && (a2.warn("A page in a PDF can not be wider or taller than 14400 userUnit. jsPDF limits the width/height to 14400"), n3 = Math.min(14400, n3), o4 = Math.min(14400, o4)), s3 = [n3, o4], i5.substr(0, 1)) {
      case "l":
        o4 > n3 && (s3 = [o4, n3]);
        break;
      case "p":
        n3 > o4 && (s3 = [o4, n3]);
    }
    je(s3), pr(fr), lt(Lr), kr !== 0 && lt(kr + " J"), Ir !== 0 && lt(Ir + " j"), Tt.publish("addPage", { pageNumber: Dt });
  }, Be = function(t2) {
    t2 > 0 && t2 <= Dt && (ot.splice(t2, 1), Rt.splice(t2, 1), Dt--, $ > Dt && ($ = Dt), this.setPage($));
  }, Me = function(t2) {
    t2 > 0 && t2 <= Dt && ($ = t2);
  }, Ee = y3.__private__.getNumberOfPages = y3.getNumberOfPages = function() {
    return ot.length - 1;
  }, qe = function(t2, e3, r3) {
    var n3, i6 = undefined;
    return r3 = r3 || {}, t2 = t2 !== undefined ? t2 : Ft[St].fontName, e3 = e3 !== undefined ? e3 : Ft[St].fontStyle, n3 = t2.toLowerCase(), Ct[n3] !== undefined && Ct[n3][e3] !== undefined ? i6 = Ct[n3][e3] : Ct[t2] !== undefined && Ct[t2][e3] !== undefined ? i6 = Ct[t2][e3] : r3.disableWarning === false && a2.warn("Unable to look up font label for font '" + t2 + "', '" + e3 + "'. Refer to getFontList() for available fonts."), i6 || r3.noFallback || (i6 = Ct.times[e3]) == null && (i6 = Ct.times.normal), i6;
  }, De = y3.__private__.putInfo = function() {
    var t2 = Xt(), e3 = function(t3) {
      return t3;
    };
    for (var r3 in m4 !== null && (e3 = Ye.encryptor(t2, 0)), lt("<<"), lt("/Producer (" + Ce(e3("jsPDF " + E.version)) + ")"), xt)
      xt.hasOwnProperty(r3) && xt[r3] && lt("/" + r3.substr(0, 1).toUpperCase() + r3.substr(1) + " (" + Ce(e3(xt[r3])) + ")");
    lt("/CreationDate (" + Ce(e3(W)) + ")"), lt(">>"), lt("endobj");
  }, Re = y3.__private__.putCatalog = function(t2) {
    var e3 = (t2 = t2 || {}).rootDictionaryObjId || Qt;
    switch (Xt(), lt("<<"), lt("/Type /Catalog"), lt("/Pages " + e3 + " 0 R"), mt || (mt = "fullwidth"), mt) {
      case "fullwidth":
        lt("/OpenAction [3 0 R /FitH null]");
        break;
      case "fullheight":
        lt("/OpenAction [3 0 R /FitV null]");
        break;
      case "fullpage":
        lt("/OpenAction [3 0 R /Fit]");
        break;
      case "original":
        lt("/OpenAction [3 0 R /XYZ null null 1]");
        break;
      default:
        var r3 = "" + mt;
        r3.substr(r3.length - 1) === "%" && (mt = parseInt(mt) / 100), typeof mt == "number" && lt("/OpenAction [3 0 R /XYZ null null " + R(mt) + "]");
    }
    switch (Nt || (Nt = "continuous"), Nt) {
      case "continuous":
        lt("/PageLayout /OneColumn");
        break;
      case "single":
        lt("/PageLayout /SinglePage");
        break;
      case "two":
      case "twoleft":
        lt("/PageLayout /TwoColumnLeft");
        break;
      case "tworight":
        lt("/PageLayout /TwoColumnRight");
    }
    yt && lt("/PageMode /" + yt), Tt.publish("putCatalog"), lt(">>"), lt("endobj");
  }, Te = y3.__private__.putTrailer = function() {
    lt("trailer"), lt("<<"), lt("/Size " + (et2 + 1)), lt("/Root " + et2 + " 0 R"), lt("/Info " + (et2 - 1) + " 0 R"), m4 !== null && lt("/Encrypt " + Ye.oid + " 0 R"), lt("/ID [ <" + V + "> <" + V + "> ]"), lt(">>");
  }, Ue = y3.__private__.putHeader = function() {
    lt("%PDF-" + w2), lt("%");
  }, ze = y3.__private__.putXRef = function() {
    var t2 = "0000000000";
    lt("xref"), lt("0 " + (et2 + 1)), lt("0000000000 65535 f ");
    for (var e3 = 1;e3 <= et2; e3++) {
      typeof rt[e3] == "function" ? lt((t2 + rt[e3]()).slice(-10) + " 00000 n ") : rt[e3] !== undefined ? lt((t2 + rt[e3]).slice(-10) + " 00000 n ") : lt("0000000000 00000 n ");
    }
  }, He = y3.__private__.buildDocument = function() {
    ut(), ht(nt), Tt.publish("buildDocument"), Ue(), oe(), Se(), xe(), m4 !== null && be(), De(), Re();
    var t2 = it;
    return ze(), Te(), lt("startxref"), lt("" + t2), lt("%%EOF"), ht(ot[$]), nt.join(`
`);
  }, We = y3.__private__.getBlob = function(t2) {
    return new Blob([dt(t2)], { type: "application/pdf" });
  }, Ve = y3.output = y3.__private__.output = Ie(function(t2, e3) {
    switch (typeof (e3 = e3 || {}) == "string" ? e3 = { filename: e3 } : e3.filename = e3.filename || "generated.pdf", t2) {
      case undefined:
        return He();
      case "save":
        y3.save(e3.filename);
        break;
      case "arraybuffer":
        return dt(He());
      case "blob":
        return We(He());
      case "bloburi":
      case "bloburl":
        if (n2.URL !== undefined && typeof n2.URL.createObjectURL == "function")
          return n2.URL && n2.URL.createObjectURL(We(He())) || undefined;
        a2.warn("bloburl is not supported by your system, because URL.createObjectURL is not supported by your browser.");
        break;
      case "datauristring":
      case "dataurlstring":
        var r3 = "", i6 = He();
        try {
          r3 = h2(i6);
        } catch (t3) {
          r3 = h2(unescape(encodeURIComponent(i6)));
        }
        return "data:application/pdf;filename=" + e3.filename + ";base64," + r3;
      case "pdfobjectnewwindow":
        if (Object.prototype.toString.call(n2) === "[object Window]") {
          var o4 = "https://cdnjs.cloudflare.com/ajax/libs/pdfobject/2.1.1/pdfobject.min.js", s4 = ' integrity="sha512-4ze/a9/4jqu+tX9dfOqJYSvyYd5M6qum/3HpCLr+/Jqf0whc37VUbkpNGHR7/8pSnCFw47T1fmIpwBV7UySh3g==" crossorigin="anonymous"';
          e3.pdfObjectUrl && (o4 = e3.pdfObjectUrl, s4 = "");
          var c5 = '<html><style>html, body { padding: 0; margin: 0; } iframe { width: 100%; height: 100%; border: 0;}  </style><body><script src="' + o4 + '"' + s4 + '></script><script >PDFObject.embed("' + this.output("dataurlstring") + '", ' + JSON.stringify(e3) + ");</script></body></html>", u4 = n2.open();
          return u4 !== null && u4.document.write(c5), u4;
        }
        throw new Error("The option pdfobjectnewwindow just works in a browser-environment.");
      case "pdfjsnewwindow":
        if (Object.prototype.toString.call(n2) === "[object Window]") {
          var l3 = '<html><style>html, body { padding: 0; margin: 0; } iframe { width: 100%; height: 100%; border: 0;}  </style><body><iframe id="pdfViewer" src="' + (e3.pdfJsUrl || "examples/PDF.js/web/viewer.html") + "?file=&downloadName=" + e3.filename + '" width="500px" height="400px" /></body></html>', f3 = n2.open();
          if (f3 !== null) {
            f3.document.write(l3);
            var d3 = this;
            f3.document.documentElement.querySelector("#pdfViewer").onload = function() {
              f3.document.title = e3.filename, f3.document.documentElement.querySelector("#pdfViewer").contentWindow.PDFViewerApplication.open(d3.output("bloburl"));
            };
          }
          return f3;
        }
        throw new Error("The option pdfjsnewwindow just works in a browser-environment.");
      case "dataurlnewwindow":
        if (Object.prototype.toString.call(n2) !== "[object Window]")
          throw new Error("The option dataurlnewwindow just works in a browser-environment.");
        var p4 = '<html><style>html, body { padding: 0; margin: 0; } iframe { width: 100%; height: 100%; border: 0;}  </style><body><iframe src="' + this.output("datauristring", e3) + '"></iframe></body></html>', g3 = n2.open();
        if (g3 !== null && (g3.document.write(p4), g3.document.title = e3.filename), g3 || typeof safari == "undefined")
          return g3;
        break;
      case "datauri":
      case "dataurl":
        return n2.document.location.href = this.output("datauristring", e3);
      default:
        return null;
    }
  }), Ge = function(t2) {
    return Array.isArray(Ut) === true && Ut.indexOf(t2) > -1;
  };
  switch (o3) {
    case "pt":
      _t = 1;
      break;
    case "mm":
      _t = 72 / 25.4;
      break;
    case "cm":
      _t = 72 / 2.54;
      break;
    case "in":
      _t = 72;
      break;
    case "px":
      _t = Ge("px_scaling") == 1 ? 0.75 : 96 / 72;
      break;
    case "pc":
    case "em":
      _t = 12;
      break;
    case "ex":
      _t = 6;
      break;
    default:
      if (typeof o3 != "number")
        throw new Error("Invalid unit: " + o3);
      _t = o3;
  }
  var Ye = null;
  K(), Y();
  var Je = function(t2) {
    return m4 !== null ? Ye.encryptor(t2, 0) : function(t3) {
      return t3;
    };
  }, Xe = y3.__private__.getPageInfo = y3.getPageInfo = function(t2) {
    if (isNaN(t2) || t2 % 1 != 0)
      throw new Error("Invalid argument passed to jsPDF.getPageInfo");
    return { objId: Rt[t2].objId, pageNumber: t2, pageContext: Rt[t2] };
  }, Ke = y3.__private__.getPageInfoByObjId = function(t2) {
    if (isNaN(t2) || t2 % 1 != 0)
      throw new Error("Invalid argument passed to jsPDF.getPageInfoByObjId");
    for (var e3 in Rt)
      if (Rt[e3].objId === t2)
        break;
    return Xe(e3);
  }, Ze = y3.__private__.getCurrentPageInfo = y3.getCurrentPageInfo = function() {
    return { objId: Rt[$].objId, pageNumber: $, pageContext: Rt[$] };
  };
  y3.addPage = function() {
    return Oe.apply(this, arguments), this;
  }, y3.setPage = function() {
    return Me.apply(this, arguments), ht.call(this, ot[$]), this;
  }, y3.insertPage = function(t2) {
    return this.addPage(), this.movePage($, t2), this;
  }, y3.movePage = function(t2, e3) {
    var r3, n3;
    if (t2 > e3) {
      r3 = ot[t2], n3 = Rt[t2];
      for (var i6 = t2;i6 > e3; i6--)
        ot[i6] = ot[i6 - 1], Rt[i6] = Rt[i6 - 1];
      ot[e3] = r3, Rt[e3] = n3, this.setPage(e3);
    } else if (t2 < e3) {
      r3 = ot[t2], n3 = Rt[t2];
      for (var a3 = t2;a3 < e3; a3++)
        ot[a3] = ot[a3 + 1], Rt[a3] = Rt[a3 + 1];
      ot[e3] = r3, Rt[e3] = n3, this.setPage(e3);
    }
    return this;
  }, y3.deletePage = function() {
    return Be.apply(this, arguments), this;
  }, y3.__private__.text = y3.text = function(e3, r3, n3, i6, a3) {
    var o4, s4, c5, u4, h3, l3, f3, d3, p4, g3 = (i6 = i6 || {}).scope || this;
    if (typeof e3 == "number" && typeof r3 == "number" && (typeof n3 == "string" || Array.isArray(n3))) {
      var m5 = n3;
      n3 = r3, r3 = e3, e3 = m5;
    }
    if (arguments[3] instanceof Vt == false ? (c5 = arguments[4], u4 = arguments[5], _typeof(f3 = arguments[3]) === "object" && f3 !== null || (typeof c5 == "string" && (u4 = c5, c5 = null), typeof f3 == "string" && (u4 = f3, f3 = null), typeof f3 == "number" && (c5 = f3, f3 = null), i6 = { flags: f3, angle: c5, align: u4 })) : (q("The transform parameter of text() with a Matrix value"), p4 = a3), isNaN(r3) || isNaN(n3) || e3 == null)
      throw new Error("Invalid arguments passed to jsPDF.text");
    if (e3.length === 0)
      return g3;
    var v4 = "", y4 = false, w3 = typeof i6.lineHeightFactor == "number" ? i6.lineHeightFactor : lr, N4 = g3.internal.scaleFactor;
    function L3(t2) {
      return t2 = t2.split("\t").join(Array(i6.TabLen || 9).join(" ")), Ce(t2, f3);
    }
    function A3(t2) {
      for (var e4, r4 = t2.concat(), n4 = [], i7 = r4.length;i7--; )
        typeof (e4 = r4.shift()) == "string" ? n4.push(e4) : Array.isArray(t2) && (e4.length === 1 || e4[1] === undefined && e4[2] === undefined) ? n4.push(e4[0]) : n4.push([e4[0], e4[1], e4[2]]);
      return n4;
    }
    function _4(t2, e4) {
      var r4;
      if (typeof t2 == "string")
        r4 = e4(t2)[0];
      else if (Array.isArray(t2)) {
        for (var n4, i7, a4 = t2.concat(), o5 = [], s5 = a4.length;s5--; )
          typeof (n4 = a4.shift()) == "string" ? o5.push(e4(n4)[0]) : Array.isArray(n4) && typeof n4[0] == "string" && (i7 = e4(n4[0], n4[1], n4[2]), o5.push([i7[0], i7[1], i7[2]]));
        r4 = o5;
      }
      return r4;
    }
    var P3 = false, k3 = true;
    if (typeof e3 == "string")
      P3 = true;
    else if (Array.isArray(e3)) {
      var I2 = e3.concat();
      s4 = [];
      for (var F2, C2 = I2.length;C2--; )
        (typeof (F2 = I2.shift()) != "string" || Array.isArray(F2) && typeof F2[0] != "string") && (k3 = false);
      P3 = k3;
    }
    if (P3 === false)
      throw new Error('Type of text must be string or Array. "' + e3 + '" is not recognized.');
    typeof e3 == "string" && (e3 = e3.match(/[\r?\n]/) ? e3.split(/\r\n|\r|\n/g) : [e3]);
    var j2 = gt / g3.internal.scaleFactor, B2 = j2 * (w3 - 1);
    switch (i6.baseline) {
      case "bottom":
        n3 -= B2;
        break;
      case "top":
        n3 += j2 - B2;
        break;
      case "hanging":
        n3 += j2 - 2 * B2;
        break;
      case "middle":
        n3 += j2 / 2 - B2;
    }
    if ((l3 = i6.maxWidth || 0) > 0 && (typeof e3 == "string" ? e3 = g3.splitTextToSize(e3, l3) : Object.prototype.toString.call(e3) === "[object Array]" && (e3 = e3.reduce(function(t2, e4) {
      return t2.concat(g3.splitTextToSize(e4, l3));
    }, []))), o4 = { text: e3, x: r3, y: n3, options: i6, mutex: { pdfEscape: Ce, activeFontKey: St, fonts: Ft, activeFontSize: gt } }, Tt.publish("preProcessText", o4), e3 = o4.text, c5 = (i6 = o4.options).angle, p4 instanceof Vt == false && c5 && typeof c5 == "number") {
      c5 *= Math.PI / 180, i6.rotationDirection === 0 && (c5 = -c5), S2 === x3.ADVANCED && (c5 = -c5);
      var M2 = Math.cos(c5), E2 = Math.sin(c5);
      p4 = new Vt(M2, E2, -E2, M2, 0, 0);
    } else
      c5 && c5 instanceof Vt && (p4 = c5);
    S2 !== x3.ADVANCED || p4 || (p4 = Yt), (h3 = i6.charSpace || _r) !== undefined && (v4 += O3(U(h3)) + ` Tc
`, this.setCharSpace(this.getCharSpace() || 0)), (d3 = i6.horizontalScale) !== undefined && (v4 += O3(100 * d3) + ` Tz
`);
    i6.lang;
    var D2 = -1, R2 = i6.renderingMode !== undefined ? i6.renderingMode : i6.stroke, T3 = g3.internal.getCurrentPageInfo().pageContext;
    switch (R2) {
      case 0:
      case false:
      case "fill":
        D2 = 0;
        break;
      case 1:
      case true:
      case "stroke":
        D2 = 1;
        break;
      case 2:
      case "fillThenStroke":
        D2 = 2;
        break;
      case 3:
      case "invisible":
        D2 = 3;
        break;
      case 4:
      case "fillAndAddForClipping":
        D2 = 4;
        break;
      case 5:
      case "strokeAndAddPathForClipping":
        D2 = 5;
        break;
      case 6:
      case "fillThenStrokeAndAddToPathForClipping":
        D2 = 6;
        break;
      case 7:
      case "addToPathForClipping":
        D2 = 7;
    }
    var z2 = T3.usedRenderingMode !== undefined ? T3.usedRenderingMode : -1;
    D2 !== -1 ? v4 += D2 + ` Tr
` : z2 !== -1 && (v4 += `0 Tr
`), D2 !== -1 && (T3.usedRenderingMode = D2), u4 = i6.align || "left";
    var H2, W2 = gt * w3, V2 = g3.internal.pageSize.getWidth(), G2 = Ft[St];
    h3 = i6.charSpace || _r, l3 = i6.maxWidth || 0, f3 = Object.assign({ autoencode: true, noBOM: true }, i6.flags);
    var Y2 = [], J2 = function(t2) {
      return g3.getStringUnitWidth(t2, { font: G2, charSpace: h3, fontSize: gt, doKerning: false }) * gt / N4;
    };
    if (Object.prototype.toString.call(e3) === "[object Array]") {
      var X2;
      s4 = A3(e3), u4 !== "left" && (H2 = s4.map(J2));
      var K2, Z2 = 0;
      if (u4 === "right") {
        r3 -= H2[0], e3 = [], C2 = s4.length;
        for (var $2 = 0;$2 < C2; $2++)
          $2 === 0 ? (K2 = br(r3), X2 = yr(n3)) : (K2 = U(Z2 - H2[$2]), X2 = -W2), e3.push([s4[$2], K2, X2]), Z2 = H2[$2];
      } else if (u4 === "center") {
        r3 -= H2[0] / 2, e3 = [], C2 = s4.length;
        for (var Q2 = 0;Q2 < C2; Q2++)
          Q2 === 0 ? (K2 = br(r3), X2 = yr(n3)) : (K2 = U((Z2 - H2[Q2]) / 2), X2 = -W2), e3.push([s4[Q2], K2, X2]), Z2 = H2[Q2];
      } else if (u4 === "left") {
        e3 = [], C2 = s4.length;
        for (var tt2 = 0;tt2 < C2; tt2++)
          e3.push(s4[tt2]);
      } else if (u4 === "justify" && G2.encoding === "Identity-H") {
        e3 = [], C2 = s4.length, l3 = l3 !== 0 ? l3 : V2;
        for (var et3 = 0, rt2 = 0;rt2 < C2; rt2++)
          if (X2 = rt2 === 0 ? yr(n3) : -W2, K2 = rt2 === 0 ? br(r3) : et3, rt2 < C2 - 1) {
            var nt2 = U((l3 - H2[rt2]) / (s4[rt2].split(" ").length - 1)), it2 = s4[rt2].split(" ");
            e3.push([it2[0] + " ", K2, X2]), et3 = 0;
            for (var at2 = 1;at2 < it2.length; at2++) {
              var ot2 = (J2(it2[at2 - 1] + " " + it2[at2]) - J2(it2[at2])) * N4 + nt2;
              at2 == it2.length - 1 ? e3.push([it2[at2], ot2, 0]) : e3.push([it2[at2] + " ", ot2, 0]), et3 -= ot2;
            }
          } else
            e3.push([s4[rt2], K2, X2]);
        e3.push(["", et3, 0]);
      } else {
        if (u4 !== "justify")
          throw new Error('Unrecognized alignment option, use "left", "center", "right" or "justify".');
        e3 = [], C2 = s4.length, l3 = l3 !== 0 ? l3 : V2;
        for (rt2 = 0;rt2 < C2; rt2++)
          X2 = rt2 === 0 ? yr(n3) : -W2, K2 = rt2 === 0 ? br(r3) : 0, rt2 < C2 - 1 ? Y2.push(O3(U((l3 - H2[rt2]) / (s4[rt2].split(" ").length - 1)))) : Y2.push(0), e3.push([s4[rt2], K2, X2]);
      }
    }
    var st2 = typeof i6.R2L == "boolean" ? i6.R2L : bt;
    st2 === true && (e3 = _4(e3, function(t2, e4, r4) {
      return [t2.split("").reverse().join(""), e4, r4];
    })), o4 = { text: e3, x: r3, y: n3, options: i6, mutex: { pdfEscape: Ce, activeFontKey: St, fonts: Ft, activeFontSize: gt } }, Tt.publish("postProcessText", o4), e3 = o4.text, y4 = o4.mutex.isHex || false;
    var ct2 = Ft[St].encoding;
    ct2 !== "WinAnsiEncoding" && ct2 !== "StandardEncoding" || (e3 = _4(e3, function(t2, e4, r4) {
      return [L3(t2), e4, r4];
    })), s4 = A3(e3), e3 = [];
    for (var ut2, ht2, ft2, dt2 = 0, pt2 = 1, mt2 = Array.isArray(s4[0]) ? pt2 : dt2, vt2 = "", yt2 = function(t2, e4, r4) {
      var n4 = "";
      return r4 instanceof Vt ? (r4 = typeof i6.angle == "number" ? Gt(r4, new Vt(1, 0, 0, 1, t2, e4)) : Gt(new Vt(1, 0, 0, 1, t2, e4), r4), S2 === x3.ADVANCED && (r4 = Gt(new Vt(1, 0, 0, -1, 0, 0), r4)), n4 = r4.join(" ") + ` Tm
`) : n4 = O3(t2) + " " + O3(e4) + ` Td
`, n4;
    }, wt2 = 0;wt2 < s4.length; wt2++) {
      switch (vt2 = "", mt2) {
        case pt2:
          ft2 = (y4 ? "<" : "(") + s4[wt2][0] + (y4 ? ">" : ")"), ut2 = parseFloat(s4[wt2][1]), ht2 = parseFloat(s4[wt2][2]);
          break;
        case dt2:
          ft2 = (y4 ? "<" : "(") + s4[wt2] + (y4 ? ">" : ")"), ut2 = br(r3), ht2 = yr(n3);
      }
      Y2 !== undefined && Y2[wt2] !== undefined && (vt2 = Y2[wt2] + ` Tw
`), wt2 === 0 ? e3.push(vt2 + yt2(ut2, ht2, p4) + ft2) : mt2 === dt2 ? e3.push(vt2 + ft2) : mt2 === pt2 && e3.push(vt2 + yt2(ut2, ht2, p4) + ft2);
    }
    e3 = mt2 === dt2 ? e3.join(` Tj
T* `) : e3.join(` Tj
`), e3 += ` Tj
`;
    var Nt2 = `BT
/`;
    return Nt2 += St + " " + gt + ` Tf
`, Nt2 += O3(gt * w3) + ` TL
`, Nt2 += xr + `
`, Nt2 += v4, Nt2 += e3, lt(Nt2 += "ET"), b2[St] = true, g3;
  };
  var $e = y3.__private__.clip = y3.clip = function(t2) {
    return lt(t2 === "evenodd" ? "W*" : "W"), this;
  };
  y3.clipEvenOdd = function() {
    return $e("evenodd");
  }, y3.__private__.discardPath = y3.discardPath = function() {
    return lt("n"), this;
  };
  var Qe = y3.__private__.isValidStyle = function(t2) {
    var e3 = false;
    return [undefined, null, "S", "D", "F", "DF", "FD", "f", "f*", "B", "B*", "n"].indexOf(t2) !== -1 && (e3 = true), e3;
  };
  y3.__private__.setDefaultPathOperation = y3.setDefaultPathOperation = function(t2) {
    return Qe(t2) && (g2 = t2), this;
  };
  var tr = y3.__private__.getStyle = y3.getStyle = function(t2) {
    var e3 = g2;
    switch (t2) {
      case "D":
      case "S":
        e3 = "S";
        break;
      case "F":
        e3 = "f";
        break;
      case "FD":
      case "DF":
        e3 = "B";
        break;
      case "f":
      case "f*":
      case "B":
      case "B*":
        e3 = t2;
    }
    return e3;
  }, er = y3.close = function() {
    return lt("h"), this;
  };
  y3.stroke = function() {
    return lt("S"), this;
  }, y3.fill = function(t2) {
    return rr("f", t2), this;
  }, y3.fillEvenOdd = function(t2) {
    return rr("f*", t2), this;
  }, y3.fillStroke = function(t2) {
    return rr("B", t2), this;
  }, y3.fillStrokeEvenOdd = function(t2) {
    return rr("B*", t2), this;
  };
  var rr = function(e3, r3) {
    _typeof(r3) === "object" ? ar(r3, e3) : lt(e3);
  }, nr = function(t2) {
    t2 === null || S2 === x3.ADVANCED && t2 === undefined || (t2 = tr(t2), lt(t2));
  };
  function ir(t2, e3, r3, n3, i6) {
    var a3 = new M(e3 || this.boundingBox, r3 || this.xStep, n3 || this.yStep, this.gState, i6 || this.matrix);
    a3.stream = this.stream;
    var o4 = t2 + "$$" + this.cloneIndex++ + "$$";
    return Jt(o4, a3), a3;
  }
  var ar = function(t2, e3) {
    var r3 = Bt[t2.key], n3 = Ot[r3];
    if (n3 instanceof B)
      lt("q"), lt(or(e3)), n3.gState && y3.setGState(n3.gState), lt(t2.matrix.toString() + " cm"), lt("/" + r3 + " sh"), lt("Q");
    else if (n3 instanceof M) {
      var i6 = new Vt(1, 0, 0, -1, 0, Rr());
      t2.matrix && (i6 = i6.multiply(t2.matrix || Yt), r3 = ir.call(n3, t2.key, t2.boundingBox, t2.xStep, t2.yStep, i6).id), lt("q"), lt("/Pattern cs"), lt("/" + r3 + " scn"), n3.gState && y3.setGState(n3.gState), lt(e3), lt("Q");
    }
  }, or = function(t2) {
    switch (t2) {
      case "f":
      case "F":
        return "W n";
      case "f*":
        return "W* n";
      case "B":
        return "W S";
      case "B*":
        return "W* S";
      case "S":
        return "W S";
      case "n":
        return "W n";
    }
  }, sr = y3.moveTo = function(t2, e3) {
    return lt(O3(U(t2)) + " " + O3(H(e3)) + " m"), this;
  }, cr = y3.lineTo = function(t2, e3) {
    return lt(O3(U(t2)) + " " + O3(H(e3)) + " l"), this;
  }, ur = y3.curveTo = function(t2, e3, r3, n3, i6, a3) {
    return lt([O3(U(t2)), O3(H(e3)), O3(U(r3)), O3(H(n3)), O3(U(i6)), O3(H(a3)), "c"].join(" ")), this;
  };
  y3.__private__.line = y3.line = function(t2, e3, r3, n3, i6) {
    if (isNaN(t2) || isNaN(e3) || isNaN(r3) || isNaN(n3) || !Qe(i6))
      throw new Error("Invalid arguments passed to jsPDF.line");
    return S2 === x3.COMPAT ? this.lines([[r3 - t2, n3 - e3]], t2, e3, [1, 1], i6 || "S") : this.lines([[r3 - t2, n3 - e3]], t2, e3, [1, 1]).stroke();
  }, y3.__private__.lines = y3.lines = function(t2, e3, r3, n3, i6, a3) {
    var o4, s4, c5, u4, h3, l3, f3, d3, p4, g3, m5, v4;
    if (typeof t2 == "number" && (v4 = r3, r3 = e3, e3 = t2, t2 = v4), n3 = n3 || [1, 1], a3 = a3 || false, isNaN(e3) || isNaN(r3) || !Array.isArray(t2) || !Array.isArray(n3) || !Qe(i6) || typeof a3 != "boolean")
      throw new Error("Invalid arguments passed to jsPDF.lines");
    for (sr(e3, r3), o4 = n3[0], s4 = n3[1], u4 = t2.length, g3 = e3, m5 = r3, c5 = 0;c5 < u4; c5++)
      (h3 = t2[c5]).length === 2 ? (g3 = h3[0] * o4 + g3, m5 = h3[1] * s4 + m5, cr(g3, m5)) : (l3 = h3[0] * o4 + g3, f3 = h3[1] * s4 + m5, d3 = h3[2] * o4 + g3, p4 = h3[3] * s4 + m5, g3 = h3[4] * o4 + g3, m5 = h3[5] * s4 + m5, ur(l3, f3, d3, p4, g3, m5));
    return a3 && er(), nr(i6), this;
  }, y3.path = function(t2) {
    for (var e3 = 0;e3 < t2.length; e3++) {
      var r3 = t2[e3], n3 = r3.c;
      switch (r3.op) {
        case "m":
          sr(n3[0], n3[1]);
          break;
        case "l":
          cr(n3[0], n3[1]);
          break;
        case "c":
          ur.apply(this, n3);
          break;
        case "h":
          er();
      }
    }
    return this;
  }, y3.__private__.rect = y3.rect = function(t2, e3, r3, n3, i6) {
    if (isNaN(t2) || isNaN(e3) || isNaN(r3) || isNaN(n3) || !Qe(i6))
      throw new Error("Invalid arguments passed to jsPDF.rect");
    return S2 === x3.COMPAT && (n3 = -n3), lt([O3(U(t2)), O3(H(e3)), O3(U(r3)), O3(U(n3)), "re"].join(" ")), nr(i6), this;
  }, y3.__private__.triangle = y3.triangle = function(t2, e3, r3, n3, i6, a3, o4) {
    if (isNaN(t2) || isNaN(e3) || isNaN(r3) || isNaN(n3) || isNaN(i6) || isNaN(a3) || !Qe(o4))
      throw new Error("Invalid arguments passed to jsPDF.triangle");
    return this.lines([[r3 - t2, n3 - e3], [i6 - r3, a3 - n3], [t2 - i6, e3 - a3]], t2, e3, [1, 1], o4, true), this;
  }, y3.__private__.roundedRect = y3.roundedRect = function(t2, e3, r3, n3, i6, a3, o4) {
    if (isNaN(t2) || isNaN(e3) || isNaN(r3) || isNaN(n3) || isNaN(i6) || isNaN(a3) || !Qe(o4))
      throw new Error("Invalid arguments passed to jsPDF.roundedRect");
    var s4 = 4 / 3 * (Math.SQRT2 - 1);
    return i6 = Math.min(i6, 0.5 * r3), a3 = Math.min(a3, 0.5 * n3), this.lines([[r3 - 2 * i6, 0], [i6 * s4, 0, i6, a3 - a3 * s4, i6, a3], [0, n3 - 2 * a3], [0, a3 * s4, -i6 * s4, a3, -i6, a3], [2 * i6 - r3, 0], [-i6 * s4, 0, -i6, -a3 * s4, -i6, -a3], [0, 2 * a3 - n3], [0, -a3 * s4, i6 * s4, -a3, i6, -a3]], t2 + i6, e3, [1, 1], o4, true), this;
  }, y3.__private__.ellipse = y3.ellipse = function(t2, e3, r3, n3, i6) {
    if (isNaN(t2) || isNaN(e3) || isNaN(r3) || isNaN(n3) || !Qe(i6))
      throw new Error("Invalid arguments passed to jsPDF.ellipse");
    var a3 = 4 / 3 * (Math.SQRT2 - 1) * r3, o4 = 4 / 3 * (Math.SQRT2 - 1) * n3;
    return sr(t2 + r3, e3), ur(t2 + r3, e3 - o4, t2 + a3, e3 - n3, t2, e3 - n3), ur(t2 - a3, e3 - n3, t2 - r3, e3 - o4, t2 - r3, e3), ur(t2 - r3, e3 + o4, t2 - a3, e3 + n3, t2, e3 + n3), ur(t2 + a3, e3 + n3, t2 + r3, e3 + o4, t2 + r3, e3), nr(i6), this;
  }, y3.__private__.circle = y3.circle = function(t2, e3, r3, n3) {
    if (isNaN(t2) || isNaN(e3) || isNaN(r3) || !Qe(n3))
      throw new Error("Invalid arguments passed to jsPDF.circle");
    return this.ellipse(t2, e3, r3, r3, n3);
  }, y3.setFont = function(t2, e3, r3) {
    return r3 && (e3 = k2(e3, r3)), St = qe(t2, e3, { disableWarning: false }), this;
  };
  var hr = y3.__private__.getFont = y3.getFont = function() {
    return Ft[qe.apply(y3, arguments)];
  };
  y3.__private__.getFontList = y3.getFontList = function() {
    var t2, e3, r3 = {};
    for (t2 in Ct)
      if (Ct.hasOwnProperty(t2))
        for (e3 in r3[t2] = [], Ct[t2])
          Ct[t2].hasOwnProperty(e3) && r3[t2].push(e3);
    return r3;
  }, y3.addFont = function(t2, e3, r3, n3, i6) {
    var a3 = ["StandardEncoding", "MacRomanEncoding", "Identity-H", "WinAnsiEncoding"];
    return arguments[3] && a3.indexOf(arguments[3]) !== -1 ? i6 = arguments[3] : arguments[3] && a3.indexOf(arguments[3]) == -1 && (r3 = k2(r3, n3)), i6 = i6 || "Identity-H", Pe.call(this, t2, e3, r3, i6);
  };
  var lr, fr = e2.lineWidth || 0.200025, dr = y3.__private__.getLineWidth = y3.getLineWidth = function() {
    return fr;
  }, pr = y3.__private__.setLineWidth = y3.setLineWidth = function(t2) {
    return fr = t2, lt(O3(U(t2)) + " w"), this;
  };
  y3.__private__.setLineDash = E.API.setLineDash = E.API.setLineDashPattern = function(t2, e3) {
    if (t2 = t2 || [], e3 = e3 || 0, isNaN(e3) || !Array.isArray(t2))
      throw new Error("Invalid arguments passed to jsPDF.setLineDash");
    return t2 = t2.map(function(t3) {
      return O3(U(t3));
    }).join(" "), e3 = O3(U(e3)), lt("[" + t2 + "] " + e3 + " d"), this;
  };
  var gr = y3.__private__.getLineHeight = y3.getLineHeight = function() {
    return gt * lr;
  };
  y3.__private__.getLineHeight = y3.getLineHeight = function() {
    return gt * lr;
  };
  var mr = y3.__private__.setLineHeightFactor = y3.setLineHeightFactor = function(t2) {
    return typeof (t2 = t2 || 1.15) == "number" && (lr = t2), this;
  }, vr = y3.__private__.getLineHeightFactor = y3.getLineHeightFactor = function() {
    return lr;
  };
  mr(e2.lineHeight);
  var br = y3.__private__.getHorizontalCoordinate = function(t2) {
    return U(t2);
  }, yr = y3.__private__.getVerticalCoordinate = function(t2) {
    return S2 === x3.ADVANCED ? t2 : Rt[$].mediaBox.topRightY - Rt[$].mediaBox.bottomLeftY - U(t2);
  }, wr = y3.__private__.getHorizontalCoordinateString = y3.getHorizontalCoordinateString = function(t2) {
    return O3(br(t2));
  }, Nr = y3.__private__.getVerticalCoordinateString = y3.getVerticalCoordinateString = function(t2) {
    return O3(yr(t2));
  }, Lr = e2.strokeColor || "0 G";
  y3.__private__.getStrokeColor = y3.getDrawColor = function() {
    return ee(Lr);
  }, y3.__private__.setStrokeColor = y3.setDrawColor = function(t2, e3, r3, n3) {
    return Lr = re({ ch1: t2, ch2: e3, ch3: r3, ch4: n3, pdfColorType: "draw", precision: 2 }), lt(Lr), this;
  };
  var Ar = e2.fillColor || "0 g";
  y3.__private__.getFillColor = y3.getFillColor = function() {
    return ee(Ar);
  }, y3.__private__.setFillColor = y3.setFillColor = function(t2, e3, r3, n3) {
    return Ar = re({ ch1: t2, ch2: e3, ch3: r3, ch4: n3, pdfColorType: "fill", precision: 2 }), lt(Ar), this;
  };
  var xr = e2.textColor || "0 g", Sr = y3.__private__.getTextColor = y3.getTextColor = function() {
    return ee(xr);
  };
  y3.__private__.setTextColor = y3.setTextColor = function(t2, e3, r3, n3) {
    return xr = re({ ch1: t2, ch2: e3, ch3: r3, ch4: n3, pdfColorType: "text", precision: 3 }), this;
  };
  var _r = e2.charSpace, Pr = y3.__private__.getCharSpace = y3.getCharSpace = function() {
    return parseFloat(_r || 0);
  };
  y3.__private__.setCharSpace = y3.setCharSpace = function(t2) {
    if (isNaN(t2))
      throw new Error("Invalid argument passed to jsPDF.setCharSpace");
    return _r = t2, this;
  };
  var kr = 0;
  y3.CapJoinStyles = { 0: 0, butt: 0, but: 0, miter: 0, 1: 1, round: 1, rounded: 1, circle: 1, 2: 2, projecting: 2, project: 2, square: 2, bevel: 2 }, y3.__private__.setLineCap = y3.setLineCap = function(t2) {
    var e3 = y3.CapJoinStyles[t2];
    if (e3 === undefined)
      throw new Error("Line cap style of '" + t2 + "' is not recognized. See or extend .CapJoinStyles property for valid styles");
    return kr = e3, lt(e3 + " J"), this;
  };
  var Ir = 0;
  y3.__private__.setLineJoin = y3.setLineJoin = function(t2) {
    var e3 = y3.CapJoinStyles[t2];
    if (e3 === undefined)
      throw new Error("Line join style of '" + t2 + "' is not recognized. See or extend .CapJoinStyles property for valid styles");
    return Ir = e3, lt(e3 + " j"), this;
  }, y3.__private__.setLineMiterLimit = y3.__private__.setMiterLimit = y3.setLineMiterLimit = y3.setMiterLimit = function(t2) {
    if (t2 = t2 || 0, isNaN(t2))
      throw new Error("Invalid argument passed to jsPDF.setLineMiterLimit");
    return lt(O3(U(t2)) + " M"), this;
  }, y3.GState = j, y3.setGState = function(t2) {
    (t2 = typeof t2 == "string" ? Mt[Et[t2]] : Fr(null, t2)).equals(qt) || (lt("/" + t2.id + " gs"), qt = t2);
  };
  var Fr = function(t2, e3) {
    if (!t2 || !Et[t2]) {
      var r3 = false;
      for (var n3 in Mt)
        if (Mt.hasOwnProperty(n3) && Mt[n3].equals(e3)) {
          r3 = true;
          break;
        }
      if (r3)
        e3 = Mt[n3];
      else {
        var i6 = "GS" + (Object.keys(Mt).length + 1).toString(10);
        Mt[i6] = e3, e3.id = i6;
      }
      return t2 && (Et[t2] = e3.id), Tt.publish("addGState", e3), e3;
    }
  };
  y3.addGState = function(t2, e3) {
    return Fr(t2, e3), this;
  }, y3.saveGraphicsState = function() {
    return lt("q"), jt.push({ key: St, size: gt, color: xr }), this;
  }, y3.restoreGraphicsState = function() {
    lt("Q");
    var t2 = jt.pop();
    return St = t2.key, gt = t2.size, xr = t2.color, qt = null, this;
  }, y3.setCurrentTransformationMatrix = function(t2) {
    return lt(t2.toString() + " cm"), this;
  }, y3.comment = function(t2) {
    return lt("#" + t2), this;
  };
  var Cr = function(t2, e3) {
    var r3 = t2 || 0;
    Object.defineProperty(this, "x", { enumerable: true, get: function() {
      return r3;
    }, set: function(t3) {
      isNaN(t3) || (r3 = parseFloat(t3));
    } });
    var n3 = e3 || 0;
    Object.defineProperty(this, "y", { enumerable: true, get: function() {
      return n3;
    }, set: function(t3) {
      isNaN(t3) || (n3 = parseFloat(t3));
    } });
    var i6 = "pt";
    return Object.defineProperty(this, "type", { enumerable: true, get: function() {
      return i6;
    }, set: function(t3) {
      i6 = t3.toString();
    } }), this;
  }, jr = function(t2, e3, r3, n3) {
    Cr.call(this, t2, e3), this.type = "rect";
    var i6 = r3 || 0;
    Object.defineProperty(this, "w", { enumerable: true, get: function() {
      return i6;
    }, set: function(t3) {
      isNaN(t3) || (i6 = parseFloat(t3));
    } });
    var a3 = n3 || 0;
    return Object.defineProperty(this, "h", { enumerable: true, get: function() {
      return a3;
    }, set: function(t3) {
      isNaN(t3) || (a3 = parseFloat(t3));
    } }), this;
  }, Or = function() {
    this.page = Dt, this.currentPage = $, this.pages = ot.slice(0), this.pagesContext = Rt.slice(0), this.x = Pt, this.y = kt, this.matrix = It, this.width = qr($), this.height = Rr($), this.outputDestination = ct, this.id = "", this.objectNumber = -1;
  };
  Or.prototype.restore = function() {
    Dt = this.page, $ = this.currentPage, Rt = this.pagesContext, ot = this.pages, Pt = this.x, kt = this.y, It = this.matrix, Dr($, this.width), Tr($, this.height), ct = this.outputDestination;
  };
  var Br = function(t2, e3, r3, n3, i6) {
    Wt.push(new Or), Dt = $ = 0, ot = [], Pt = t2, kt = e3, It = i6, je([r3, n3]);
  }, Mr = function(t2) {
    if (Ht[t2])
      Wt.pop().restore();
    else {
      var e3 = new Or, r3 = "Xo" + (Object.keys(zt).length + 1).toString(10);
      e3.id = r3, Ht[t2] = r3, zt[r3] = e3, Tt.publish("addFormObject", e3), Wt.pop().restore();
    }
  };
  for (var Er in y3.beginFormObject = function(t2, e3, r3, n3, i6) {
    return Br(t2, e3, r3, n3, i6), this;
  }, y3.endFormObject = function(t2) {
    return Mr(t2), this;
  }, y3.doFormObject = function(t2, e3) {
    var r3 = zt[Ht[t2]];
    return lt("q"), lt(e3.toString() + " cm"), lt("/" + r3.id + " Do"), lt("Q"), this;
  }, y3.getFormObject = function(t2) {
    var e3 = zt[Ht[t2]];
    return { x: e3.x, y: e3.y, width: e3.width, height: e3.height, matrix: e3.matrix };
  }, y3.save = function(t2, e3) {
    return t2 = t2 || "generated.pdf", (e3 = e3 || {}).returnPromise = e3.returnPromise || false, e3.returnPromise === false ? (l2(We(He()), t2), typeof l2.unload == "function" && n2.setTimeout && setTimeout(l2.unload, 911), this) : new Promise(function(e4, r3) {
      try {
        var i6 = l2(We(He()), t2);
        typeof l2.unload == "function" && n2.setTimeout && setTimeout(l2.unload, 911), e4(i6);
      } catch (t3) {
        r3(t3.message);
      }
    });
  }, E.API)
    E.API.hasOwnProperty(Er) && (Er === "events" && E.API.events.length ? function(t2, e3) {
      var r3, n3, i6;
      for (i6 = e3.length - 1;i6 !== -1; i6--)
        r3 = e3[i6][0], n3 = e3[i6][1], t2.subscribe.apply(t2, [r3].concat(typeof n3 == "function" ? [n3] : n3));
    }(Tt, E.API.events) : y3[Er] = E.API[Er]);
  var qr = y3.getPageWidth = function(t2) {
    return (Rt[t2 = t2 || $].mediaBox.topRightX - Rt[t2].mediaBox.bottomLeftX) / _t;
  }, Dr = y3.setPageWidth = function(t2, e3) {
    Rt[t2].mediaBox.topRightX = e3 * _t + Rt[t2].mediaBox.bottomLeftX;
  }, Rr = y3.getPageHeight = function(t2) {
    return (Rt[t2 = t2 || $].mediaBox.topRightY - Rt[t2].mediaBox.bottomLeftY) / _t;
  }, Tr = y3.setPageHeight = function(t2, e3) {
    Rt[t2].mediaBox.topRightY = e3 * _t + Rt[t2].mediaBox.bottomLeftY;
  };
  return y3.internal = { pdfEscape: Ce, getStyle: tr, getFont: hr, getFontSize: vt, getCharSpace: Pr, getTextColor: Sr, getLineHeight: gr, getLineHeightFactor: vr, getLineWidth: dr, write: ft, getHorizontalCoordinate: br, getVerticalCoordinate: yr, getCoordinateString: wr, getVerticalCoordinateString: Nr, collections: {}, newObject: Xt, newAdditionalObject: $t, newObjectDeferred: Kt, newObjectDeferredBegin: Zt, getFilters: ne, putStream: ie3, events: Tt, scaleFactor: _t, pageSize: { getWidth: function() {
    return qr($);
  }, setWidth: function(t2) {
    Dr($, t2);
  }, getHeight: function() {
    return Rr($);
  }, setHeight: function(t2) {
    Tr($, t2);
  } }, encryptionOptions: m4, encryption: Ye, getEncryptor: Je, output: Ve, getNumberOfPages: Ee, pages: ot, out: lt, f2: R, f3: T2, getPageInfo: Xe, getPageInfoByObjId: Ke, getCurrentPageInfo: Ze, getPDFVersion: N3, Point: Cr, Rectangle: jr, Matrix: Vt, hasHotfix: Ge }, Object.defineProperty(y3.internal.pageSize, "width", { get: function() {
    return qr($);
  }, set: function(t2) {
    Dr($, t2);
  }, enumerable: true, configurable: true }), Object.defineProperty(y3.internal.pageSize, "height", { get: function() {
    return Rr($);
  }, set: function(t2) {
    Tr($, t2);
  }, enumerable: true, configurable: true }), ke.call(y3, pt), St = "F1", Oe(s3, i5), Tt.publish("initialized"), y3;
}
function _t(t3) {
  return t3.reduce(function(t4, e2, r2) {
    return t4[e2] = r2, t4;
  }, {});
}
function jt(t3) {
  var e2 = t3.family.replace(/"|'/g, "").toLowerCase(), r2 = function(t4) {
    return Pt[t4 = t4 || "normal"] ? t4 : "normal";
  }(t3.style), n3 = function(t4) {
    if (!t4)
      return 400;
    if (typeof t4 == "number")
      return t4 >= 100 && t4 <= 900 && t4 % 100 == 0 ? t4 : 400;
    if (/^\d00$/.test(t4))
      return parseInt(t4);
    switch (t4) {
      case "bold":
        return 700;
      case "normal":
      default:
        return 400;
    }
  }(t3.weight), i5 = function(t4) {
    return typeof It[t4 = t4 || "normal"] == "number" ? t4 : "normal";
  }(t3.stretch);
  return { family: e2, style: r2, weight: n3, stretch: i5, src: t3.src || [], ref: t3.ref || { name: e2, style: [i5, r2, n3].join(" ") } };
}
function Ot(t3, e2, r2, n3) {
  var i5;
  for (i5 = r2;i5 >= 0 && i5 < e2.length; i5 += n3)
    if (t3[e2[i5]])
      return t3[e2[i5]];
  for (i5 = r2;i5 >= 0 && i5 < e2.length; i5 -= n3)
    if (t3[e2[i5]])
      return t3[e2[i5]];
}
function Et(t3) {
  return [t3.stretch, t3.style, t3.weight, t3.family].join(" ");
}
function qt(t3, e2, r2) {
  for (var n3 = (r2 = r2 || {}).defaultFontFamily || "times", i5 = Object.assign({}, Bt, r2.genericFontFamilies || {}), a3 = null, o3 = null, s3 = 0;s3 < e2.length; ++s3)
    if (i5[(a3 = jt(e2[s3])).family] && (a3.family = i5[a3.family]), t3.hasOwnProperty(a3.family)) {
      o3 = t3[a3.family];
      break;
    }
  if (!(o3 = o3 || t3[n3]))
    throw new Error("Could not find a font-family for the rule '" + Et(a3) + "' and default family '" + n3 + "'.");
  if (o3 = function(t4, e3) {
    if (e3[t4])
      return e3[t4];
    var r3 = It[t4], n4 = r3 <= It.normal ? -1 : 1, i6 = Ot(e3, kt, r3, n4);
    if (!i6)
      throw new Error("Could not find a matching font-stretch value for " + t4);
    return i6;
  }(a3.stretch, o3), o3 = function(t4, e3) {
    if (e3[t4])
      return e3[t4];
    for (var r3 = Pt[t4], n4 = 0;n4 < r3.length; ++n4)
      if (e3[r3[n4]])
        return e3[r3[n4]];
    throw new Error("Could not find a matching font-style for " + t4);
  }(a3.style, o3), !(o3 = function(t4, e3) {
    if (e3[t4])
      return e3[t4];
    if (t4 === 400 && e3[500])
      return e3[500];
    if (t4 === 500 && e3[400])
      return e3[400];
    var r3 = Ct[t4], n4 = Ot(e3, Ft, r3, t4 < 400 ? -1 : 1);
    if (!n4)
      throw new Error("Could not find a matching font-weight for value " + t4);
    return n4;
  }(a3.weight, o3)))
    throw new Error("Failed to resolve a font for the rule '" + Et(a3) + "'.");
  return o3;
}
function Dt(t3) {
  return t3.trimLeft();
}
function Rt(t3, e2) {
  for (var r2 = 0;r2 < t3.length; ) {
    if (t3.charAt(r2) === e2)
      return [t3.substring(0, r2), t3.substring(r2 + 1)];
    r2 += 1;
  }
  return null;
}
function Tt(t3) {
  var e2 = t3.match(/^(-[a-z_]|[a-z_])[a-z0-9_-]*/i);
  return e2 === null ? null : [e2[0], t3.substring(e2[0].length)];
}
function Zt(t3) {
  var e2 = 0;
  if (t3[e2++] !== 71 || t3[e2++] !== 73 || t3[e2++] !== 70 || t3[e2++] !== 56 || (t3[e2++] + 1 & 253) != 56 || t3[e2++] !== 97)
    throw new Error("Invalid GIF 87a/89a header.");
  var r2 = t3[e2++] | t3[e2++] << 8, n3 = t3[e2++] | t3[e2++] << 8, i5 = t3[e2++], a3 = i5 >> 7, o3 = 1 << (7 & i5) + 1;
  t3[e2++];
  t3[e2++];
  var s3 = null, c4 = null;
  a3 && (s3 = e2, c4 = o3, e2 += 3 * o3);
  var u3 = true, h3 = [], l3 = 0, f3 = null, d2 = 0, p3 = null;
  for (this.width = r2, this.height = n3;u3 && e2 < t3.length; )
    switch (t3[e2++]) {
      case 33:
        switch (t3[e2++]) {
          case 255:
            if (t3[e2] !== 11 || t3[e2 + 1] == 78 && t3[e2 + 2] == 69 && t3[e2 + 3] == 84 && t3[e2 + 4] == 83 && t3[e2 + 5] == 67 && t3[e2 + 6] == 65 && t3[e2 + 7] == 80 && t3[e2 + 8] == 69 && t3[e2 + 9] == 50 && t3[e2 + 10] == 46 && t3[e2 + 11] == 48 && t3[e2 + 12] == 3 && t3[e2 + 13] == 1 && t3[e2 + 16] == 0)
              e2 += 14, p3 = t3[e2++] | t3[e2++] << 8, e2++;
            else
              for (e2 += 12;; ) {
                if (!((P2 = t3[e2++]) >= 0))
                  throw Error("Invalid block size");
                if (P2 === 0)
                  break;
                e2 += P2;
              }
            break;
          case 249:
            if (t3[e2++] !== 4 || t3[e2 + 4] !== 0)
              throw new Error("Invalid graphics extension block.");
            var g2 = t3[e2++];
            l3 = t3[e2++] | t3[e2++] << 8, f3 = t3[e2++], (1 & g2) == 0 && (f3 = null), d2 = g2 >> 2 & 7, e2++;
            break;
          case 254:
            for (;; ) {
              if (!((P2 = t3[e2++]) >= 0))
                throw Error("Invalid block size");
              if (P2 === 0)
                break;
              e2 += P2;
            }
            break;
          default:
            throw new Error("Unknown graphic control label: 0x" + t3[e2 - 1].toString(16));
        }
        break;
      case 44:
        var m4 = t3[e2++] | t3[e2++] << 8, v3 = t3[e2++] | t3[e2++] << 8, b2 = t3[e2++] | t3[e2++] << 8, y3 = t3[e2++] | t3[e2++] << 8, w2 = t3[e2++], N3 = w2 >> 6 & 1, L2 = 1 << (7 & w2) + 1, A2 = s3, x3 = c4, S2 = false;
        if (w2 >> 7) {
          S2 = true;
          A2 = e2, x3 = L2, e2 += 3 * L2;
        }
        var _3 = e2;
        for (e2++;; ) {
          var P2;
          if (!((P2 = t3[e2++]) >= 0))
            throw Error("Invalid block size");
          if (P2 === 0)
            break;
          e2 += P2;
        }
        h3.push({ x: m4, y: v3, width: b2, height: y3, has_local_palette: S2, palette_offset: A2, palette_size: x3, data_offset: _3, data_length: e2 - _3, transparent_index: f3, interlaced: !!N3, delay: l3, disposal: d2 });
        break;
      case 59:
        u3 = false;
        break;
      default:
        throw new Error("Unknown gif block: 0x" + t3[e2 - 1].toString(16));
    }
  this.numFrames = function() {
    return h3.length;
  }, this.loopCount = function() {
    return p3;
  }, this.frameInfo = function(t4) {
    if (t4 < 0 || t4 >= h3.length)
      throw new Error("Frame index out of range.");
    return h3[t4];
  }, this.decodeAndBlitFrameBGRA = function(e3, n4) {
    var i6 = this.frameInfo(e3), a4 = i6.width * i6.height, o4 = new Uint8Array(a4);
    $t(t3, i6.data_offset, o4, a4);
    var { palette_offset: s4, transparent_index: c5 } = i6;
    c5 === null && (c5 = 256);
    var u4 = i6.width, h4 = r2 - u4, l4 = u4, f4 = 4 * (i6.y * r2 + i6.x), d3 = 4 * ((i6.y + i6.height) * r2 + i6.x), p4 = f4, g3 = 4 * h4;
    i6.interlaced === true && (g3 += 4 * r2 * 7);
    for (var m5 = 8, v4 = 0, b3 = o4.length;v4 < b3; ++v4) {
      var y4 = o4[v4];
      if (l4 === 0 && (l4 = u4, (p4 += g3) >= d3 && (g3 = 4 * h4 + 4 * r2 * (m5 - 1), p4 = f4 + (u4 + h4) * (m5 << 1), m5 >>= 1)), y4 === c5)
        p4 += 4;
      else {
        var w3 = t3[s4 + 3 * y4], N4 = t3[s4 + 3 * y4 + 1], L3 = t3[s4 + 3 * y4 + 2];
        n4[p4++] = L3, n4[p4++] = N4, n4[p4++] = w3, n4[p4++] = 255;
      }
      --l4;
    }
  }, this.decodeAndBlitFrameRGBA = function(e3, n4) {
    var i6 = this.frameInfo(e3), a4 = i6.width * i6.height, o4 = new Uint8Array(a4);
    $t(t3, i6.data_offset, o4, a4);
    var { palette_offset: s4, transparent_index: c5 } = i6;
    c5 === null && (c5 = 256);
    var u4 = i6.width, h4 = r2 - u4, l4 = u4, f4 = 4 * (i6.y * r2 + i6.x), d3 = 4 * ((i6.y + i6.height) * r2 + i6.x), p4 = f4, g3 = 4 * h4;
    i6.interlaced === true && (g3 += 4 * r2 * 7);
    for (var m5 = 8, v4 = 0, b3 = o4.length;v4 < b3; ++v4) {
      var y4 = o4[v4];
      if (l4 === 0 && (l4 = u4, (p4 += g3) >= d3 && (g3 = 4 * h4 + 4 * r2 * (m5 - 1), p4 = f4 + (u4 + h4) * (m5 << 1), m5 >>= 1)), y4 === c5)
        p4 += 4;
      else {
        var w3 = t3[s4 + 3 * y4], N4 = t3[s4 + 3 * y4 + 1], L3 = t3[s4 + 3 * y4 + 2];
        n4[p4++] = w3, n4[p4++] = N4, n4[p4++] = L3, n4[p4++] = 255;
      }
      --l4;
    }
  };
}
function $t(t3, e2, r2, n3) {
  for (var i5 = t3[e2++], o3 = 1 << i5, s3 = o3 + 1, c4 = s3 + 1, u3 = i5 + 1, h3 = (1 << u3) - 1, l3 = 0, f3 = 0, d2 = 0, p3 = t3[e2++], g2 = new Int32Array(4096), m4 = null;; ) {
    for (;l3 < 16 && p3 !== 0; )
      f3 |= t3[e2++] << l3, l3 += 8, p3 === 1 ? p3 = t3[e2++] : --p3;
    if (l3 < u3)
      break;
    var v3 = f3 & h3;
    if (f3 >>= u3, l3 -= u3, v3 !== o3) {
      if (v3 === s3)
        break;
      for (var b2 = v3 < c4 ? v3 : m4, y3 = 0, w2 = b2;w2 > o3; )
        w2 = g2[w2] >> 8, ++y3;
      var N3 = w2;
      if (d2 + y3 + (b2 !== v3 ? 1 : 0) > n3)
        return void a2.log("Warning, gif stream longer than expected.");
      r2[d2++] = N3;
      var L2 = d2 += y3;
      for (b2 !== v3 && (r2[d2++] = N3), w2 = b2;y3--; )
        w2 = g2[w2], r2[--L2] = 255 & w2, w2 >>= 8;
      m4 !== null && c4 < 4096 && (g2[c4++] = m4 << 8 | N3, c4 >= h3 + 1 && u3 < 12 && (++u3, h3 = h3 << 1 | 1)), m4 = v3;
    } else
      c4 = s3 + 1, h3 = (1 << (u3 = i5 + 1)) - 1, m4 = null;
  }
  return d2 !== n3 && a2.log("Warning, gif stream shorter than expected."), r2;
}
function Qt(t3) {
  var e2, r2, n3, i5, a3, o3 = Math.floor, s3 = new Array(64), c4 = new Array(64), u3 = new Array(64), h3 = new Array(64), l3 = new Array(65535), f3 = new Array(65535), d2 = new Array(64), p3 = new Array(64), g2 = [], m4 = 0, v3 = 7, b2 = new Array(64), y3 = new Array(64), w2 = new Array(64), N3 = new Array(256), L2 = new Array(2048), A2 = [0, 1, 5, 6, 14, 15, 27, 28, 2, 4, 7, 13, 16, 26, 29, 42, 3, 8, 12, 17, 25, 30, 41, 43, 9, 11, 18, 24, 31, 40, 44, 53, 10, 19, 23, 32, 39, 45, 52, 54, 20, 22, 33, 38, 46, 51, 55, 60, 21, 34, 37, 47, 50, 56, 59, 61, 35, 36, 48, 49, 57, 58, 62, 63], x3 = [0, 0, 1, 5, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0], S2 = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], _3 = [0, 0, 2, 1, 3, 3, 2, 4, 3, 5, 5, 4, 4, 0, 0, 1, 125], P2 = [1, 2, 3, 0, 4, 17, 5, 18, 33, 49, 65, 6, 19, 81, 97, 7, 34, 113, 20, 50, 129, 145, 161, 8, 35, 66, 177, 193, 21, 82, 209, 240, 36, 51, 98, 114, 130, 9, 10, 22, 23, 24, 25, 26, 37, 38, 39, 40, 41, 42, 52, 53, 54, 55, 56, 57, 58, 67, 68, 69, 70, 71, 72, 73, 74, 83, 84, 85, 86, 87, 88, 89, 90, 99, 100, 101, 102, 103, 104, 105, 106, 115, 116, 117, 118, 119, 120, 121, 122, 131, 132, 133, 134, 135, 136, 137, 138, 146, 147, 148, 149, 150, 151, 152, 153, 154, 162, 163, 164, 165, 166, 167, 168, 169, 170, 178, 179, 180, 181, 182, 183, 184, 185, 186, 194, 195, 196, 197, 198, 199, 200, 201, 202, 210, 211, 212, 213, 214, 215, 216, 217, 218, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250], k2 = [0, 0, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0], I2 = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], F2 = [0, 0, 2, 1, 2, 4, 4, 3, 4, 7, 5, 4, 4, 0, 1, 2, 119], C2 = [0, 1, 2, 3, 17, 4, 5, 33, 49, 6, 18, 65, 81, 7, 97, 113, 19, 34, 50, 129, 8, 20, 66, 145, 161, 177, 193, 9, 35, 51, 82, 240, 21, 98, 114, 209, 10, 22, 36, 52, 225, 37, 241, 23, 24, 25, 26, 38, 39, 40, 41, 42, 53, 54, 55, 56, 57, 58, 67, 68, 69, 70, 71, 72, 73, 74, 83, 84, 85, 86, 87, 88, 89, 90, 99, 100, 101, 102, 103, 104, 105, 106, 115, 116, 117, 118, 119, 120, 121, 122, 130, 131, 132, 133, 134, 135, 136, 137, 138, 146, 147, 148, 149, 150, 151, 152, 153, 154, 162, 163, 164, 165, 166, 167, 168, 169, 170, 178, 179, 180, 181, 182, 183, 184, 185, 186, 194, 195, 196, 197, 198, 199, 200, 201, 202, 210, 211, 212, 213, 214, 215, 216, 217, 218, 226, 227, 228, 229, 230, 231, 232, 233, 234, 242, 243, 244, 245, 246, 247, 248, 249, 250];
  function j2(t4, e3) {
    for (var r3 = 0, n4 = 0, i6 = new Array, a4 = 1;a4 <= 16; a4++) {
      for (var o4 = 1;o4 <= t4[a4]; o4++)
        i6[e3[n4]] = [], i6[e3[n4]][0] = r3, i6[e3[n4]][1] = a4, n4++, r3++;
      r3 *= 2;
    }
    return i6;
  }
  function O3(t4) {
    for (var e3 = t4[0], r3 = t4[1] - 1;r3 >= 0; )
      e3 & 1 << r3 && (m4 |= 1 << v3), r3--, --v3 < 0 && (m4 == 255 ? (B2(255), B2(0)) : B2(m4), v3 = 7, m4 = 0);
  }
  function B2(t4) {
    g2.push(t4);
  }
  function M2(t4) {
    B2(t4 >> 8 & 255), B2(255 & t4);
  }
  function E2(t4, e3, r3, n4, i6) {
    for (var a4, o4 = i6[0], s4 = i6[240], c5 = function(t5, e4) {
      var r4, n5, i7, a5, o5, s5, c6, u5, h5, l4, f4 = 0;
      for (h5 = 0;h5 < 8; ++h5) {
        r4 = t5[f4], n5 = t5[f4 + 1], i7 = t5[f4 + 2], a5 = t5[f4 + 3], o5 = t5[f4 + 4], s5 = t5[f4 + 5], c6 = t5[f4 + 6];
        var p4 = r4 + (u5 = t5[f4 + 7]), g4 = r4 - u5, m6 = n5 + c6, v5 = n5 - c6, b4 = i7 + s5, y5 = i7 - s5, w4 = a5 + o5, N4 = a5 - o5, L3 = p4 + w4, A3 = p4 - w4, x4 = m6 + b4, S3 = m6 - b4;
        t5[f4] = L3 + x4, t5[f4 + 4] = L3 - x4;
        var _4 = 0.707106781 * (S3 + A3);
        t5[f4 + 2] = A3 + _4, t5[f4 + 6] = A3 - _4;
        var P3 = 0.382683433 * ((L3 = N4 + y5) - (S3 = v5 + g4)), k3 = 0.5411961 * L3 + P3, I3 = 1.306562965 * S3 + P3, F3 = 0.707106781 * (x4 = y5 + v5), C3 = g4 + F3, j3 = g4 - F3;
        t5[f4 + 5] = j3 + k3, t5[f4 + 3] = j3 - k3, t5[f4 + 1] = C3 + I3, t5[f4 + 7] = C3 - I3, f4 += 8;
      }
      for (f4 = 0, h5 = 0;h5 < 8; ++h5) {
        r4 = t5[f4], n5 = t5[f4 + 8], i7 = t5[f4 + 16], a5 = t5[f4 + 24], o5 = t5[f4 + 32], s5 = t5[f4 + 40], c6 = t5[f4 + 48];
        var O4 = r4 + (u5 = t5[f4 + 56]), B3 = r4 - u5, M3 = n5 + c6, E3 = n5 - c6, q3 = i7 + s5, D2 = i7 - s5, R2 = a5 + o5, T3 = a5 - o5, U2 = O4 + R2, z2 = O4 - R2, H2 = M3 + q3, W2 = M3 - q3;
        t5[f4] = U2 + H2, t5[f4 + 32] = U2 - H2;
        var V2 = 0.707106781 * (W2 + z2);
        t5[f4 + 16] = z2 + V2, t5[f4 + 48] = z2 - V2;
        var G2 = 0.382683433 * ((U2 = T3 + D2) - (W2 = E3 + B3)), Y2 = 0.5411961 * U2 + G2, J2 = 1.306562965 * W2 + G2, X2 = 0.707106781 * (H2 = D2 + E3), K2 = B3 + X2, Z2 = B3 - X2;
        t5[f4 + 40] = Z2 + Y2, t5[f4 + 24] = Z2 - Y2, t5[f4 + 8] = K2 + J2, t5[f4 + 56] = K2 - J2, f4++;
      }
      for (h5 = 0;h5 < 64; ++h5)
        l4 = t5[h5] * e4[h5], d2[h5] = l4 > 0 ? l4 + 0.5 | 0 : l4 - 0.5 | 0;
      return d2;
    }(t4, e3), u4 = 0;u4 < 64; ++u4)
      p3[A2[u4]] = c5[u4];
    var h4 = p3[0] - r3;
    r3 = p3[0], h4 == 0 ? O3(n4[0]) : (O3(n4[f3[a4 = 32767 + h4]]), O3(l3[a4]));
    for (var g3 = 63;g3 > 0 && p3[g3] == 0; )
      g3--;
    if (g3 == 0)
      return O3(o4), r3;
    for (var m5, v4 = 1;v4 <= g3; ) {
      for (var b3 = v4;p3[v4] == 0 && v4 <= g3; )
        ++v4;
      var y4 = v4 - b3;
      if (y4 >= 16) {
        m5 = y4 >> 4;
        for (var w3 = 1;w3 <= m5; ++w3)
          O3(s4);
        y4 &= 15;
      }
      a4 = 32767 + p3[v4], O3(i6[(y4 << 4) + f3[a4]]), O3(l3[a4]), v4++;
    }
    return g3 != 63 && O3(o4), r3;
  }
  function q2(t4) {
    (t4 = Math.min(Math.max(t4, 1), 100), a3 != t4) && (function(t5) {
      for (var e3 = [16, 11, 10, 16, 24, 40, 51, 61, 12, 12, 14, 19, 26, 58, 60, 55, 14, 13, 16, 24, 40, 57, 69, 56, 14, 17, 22, 29, 51, 87, 80, 62, 18, 22, 37, 56, 68, 109, 103, 77, 24, 35, 55, 64, 81, 104, 113, 92, 49, 64, 78, 87, 103, 121, 120, 101, 72, 92, 95, 98, 112, 100, 103, 99], r3 = 0;r3 < 64; r3++) {
        var n4 = o3((e3[r3] * t5 + 50) / 100);
        n4 = Math.min(Math.max(n4, 1), 255), s3[A2[r3]] = n4;
      }
      for (var i6 = [17, 18, 24, 47, 99, 99, 99, 99, 18, 21, 26, 66, 99, 99, 99, 99, 24, 26, 56, 99, 99, 99, 99, 99, 47, 66, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99], a4 = 0;a4 < 64; a4++) {
        var l4 = o3((i6[a4] * t5 + 50) / 100);
        l4 = Math.min(Math.max(l4, 1), 255), c4[A2[a4]] = l4;
      }
      for (var f4 = [1, 1.387039845, 1.306562965, 1.175875602, 1, 0.785694958, 0.5411961, 0.275899379], d3 = 0, p4 = 0;p4 < 8; p4++)
        for (var g3 = 0;g3 < 8; g3++)
          u3[d3] = 1 / (s3[A2[d3]] * f4[p4] * f4[g3] * 8), h3[d3] = 1 / (c4[A2[d3]] * f4[p4] * f4[g3] * 8), d3++;
    }(t4 < 50 ? Math.floor(5000 / t4) : Math.floor(200 - 2 * t4)), a3 = t4);
  }
  this.encode = function(t4, a4) {
    a4 && q2(a4), g2 = new Array, m4 = 0, v3 = 7, M2(65496), M2(65504), M2(16), B2(74), B2(70), B2(73), B2(70), B2(0), B2(1), B2(1), B2(0), M2(1), M2(1), B2(0), B2(0), function() {
      M2(65499), M2(132), B2(0);
      for (var t5 = 0;t5 < 64; t5++)
        B2(s3[t5]);
      B2(1);
      for (var e3 = 0;e3 < 64; e3++)
        B2(c4[e3]);
    }(), function(t5, e3) {
      M2(65472), M2(17), B2(8), M2(e3), M2(t5), B2(3), B2(1), B2(17), B2(0), B2(2), B2(17), B2(1), B2(3), B2(17), B2(1);
    }(t4.width, t4.height), function() {
      M2(65476), M2(418), B2(0);
      for (var t5 = 0;t5 < 16; t5++)
        B2(x3[t5 + 1]);
      for (var e3 = 0;e3 <= 11; e3++)
        B2(S2[e3]);
      B2(16);
      for (var r3 = 0;r3 < 16; r3++)
        B2(_3[r3 + 1]);
      for (var n4 = 0;n4 <= 161; n4++)
        B2(P2[n4]);
      B2(1);
      for (var i6 = 0;i6 < 16; i6++)
        B2(k2[i6 + 1]);
      for (var a5 = 0;a5 <= 11; a5++)
        B2(I2[a5]);
      B2(17);
      for (var o5 = 0;o5 < 16; o5++)
        B2(F2[o5 + 1]);
      for (var s4 = 0;s4 <= 161; s4++)
        B2(C2[s4]);
    }(), M2(65498), M2(12), B2(3), B2(1), B2(0), B2(2), B2(17), B2(3), B2(17), B2(0), B2(63), B2(0);
    var o4 = 0, l4 = 0, f4 = 0;
    m4 = 0, v3 = 7, this.encode.displayName = "_encode_";
    for (var d3, p4, N4, A3, j3, D2, R2, T3, U2, z2 = t4.data, H2 = t4.width, W2 = t4.height, V2 = 4 * H2, G2 = 0;G2 < W2; ) {
      for (d3 = 0;d3 < V2; ) {
        for (j3 = V2 * G2 + d3, R2 = -1, T3 = 0, U2 = 0;U2 < 64; U2++)
          D2 = j3 + (T3 = U2 >> 3) * V2 + (R2 = 4 * (7 & U2)), G2 + T3 >= W2 && (D2 -= V2 * (G2 + 1 + T3 - W2)), d3 + R2 >= V2 && (D2 -= d3 + R2 - V2 + 4), p4 = z2[D2++], N4 = z2[D2++], A3 = z2[D2++], b2[U2] = (L2[p4] + L2[N4 + 256 >> 0] + L2[A3 + 512 >> 0] >> 16) - 128, y3[U2] = (L2[p4 + 768 >> 0] + L2[N4 + 1024 >> 0] + L2[A3 + 1280 >> 0] >> 16) - 128, w2[U2] = (L2[p4 + 1280 >> 0] + L2[N4 + 1536 >> 0] + L2[A3 + 1792 >> 0] >> 16) - 128;
        o4 = E2(b2, u3, o4, e2, n3), l4 = E2(y3, h3, l4, r2, i5), f4 = E2(w2, h3, f4, r2, i5), d3 += 32;
      }
      G2 += 8;
    }
    if (v3 >= 0) {
      var Y2 = [];
      Y2[1] = v3 + 1, Y2[0] = (1 << v3 + 1) - 1, O3(Y2);
    }
    return M2(65497), new Uint8Array(g2);
  }, t3 = t3 || 50, function() {
    for (var t4 = String.fromCharCode, e3 = 0;e3 < 256; e3++)
      N3[e3] = t4(e3);
  }(), e2 = j2(x3, S2), r2 = j2(k2, I2), n3 = j2(_3, P2), i5 = j2(F2, C2), function() {
    for (var t4 = 1, e3 = 2, r3 = 1;r3 <= 15; r3++) {
      for (var n4 = t4;n4 < e3; n4++)
        f3[32767 + n4] = r3, l3[32767 + n4] = [], l3[32767 + n4][1] = r3, l3[32767 + n4][0] = n4;
      for (var i6 = -(e3 - 1);i6 <= -t4; i6++)
        f3[32767 + i6] = r3, l3[32767 + i6] = [], l3[32767 + i6][1] = r3, l3[32767 + i6][0] = e3 - 1 + i6;
      t4 <<= 1, e3 <<= 1;
    }
  }(), function() {
    for (var t4 = 0;t4 < 256; t4++)
      L2[t4] = 19595 * t4, L2[t4 + 256 >> 0] = 38470 * t4, L2[t4 + 512 >> 0] = 7471 * t4 + 32768, L2[t4 + 768 >> 0] = -11059 * t4, L2[t4 + 1024 >> 0] = -21709 * t4, L2[t4 + 1280 >> 0] = 32768 * t4 + 8421375, L2[t4 + 1536 >> 0] = -27439 * t4, L2[t4 + 1792 >> 0] = -5329 * t4;
  }(), q2(t3);
}
function te(t3, e2) {
  if (this.pos = 0, this.buffer = t3, this.datav = new DataView(t3.buffer), this.is_with_alpha = !!e2, this.bottom_up = true, this.flag = String.fromCharCode(this.buffer[0]) + String.fromCharCode(this.buffer[1]), this.pos += 2, ["BM", "BA", "CI", "CP", "IC", "PT"].indexOf(this.flag) === -1)
    throw new Error("Invalid BMP File");
  this.parseHeader(), this.parseBGR();
}
function ee(t3) {
  function e2(t4) {
    if (!t4)
      throw Error("assert :P");
  }
  function r2(t4, e3, r3) {
    for (var n4 = 0;4 > n4; n4++)
      if (t4[e3 + n4] != r3.charCodeAt(n4))
        return true;
    return false;
  }
  function n3(t4, e3, r3, n4, i6) {
    for (var a4 = 0;a4 < i6; a4++)
      t4[e3 + a4] = r3[n4 + a4];
  }
  function i5(t4, e3, r3, n4) {
    for (var i6 = 0;i6 < n4; i6++)
      t4[e3 + i6] = r3;
  }
  function a3(t4) {
    return new Int32Array(t4);
  }
  function o3(t4, e3) {
    for (var r3 = [], n4 = 0;n4 < t4; n4++)
      r3.push(new e3);
    return r3;
  }
  function s3(t4, e3) {
    var r3 = [];
    return function t(r4, n4, i6) {
      for (var a4 = i6[n4], o4 = 0;o4 < a4 && (r4.push(i6.length > n4 + 1 ? [] : new e3), !(i6.length < n4 + 1)); o4++)
        t(r4[o4], n4 + 1, i6);
    }(r3, 0, t4), r3;
  }
  var c4 = function() {
    var t4 = this;
    function c5(t5, e3) {
      for (var r3 = 1 << e3 - 1 >>> 0;t5 & r3; )
        r3 >>>= 1;
      return r3 ? (t5 & r3 - 1) + r3 : t5;
    }
    function u4(t5, r3, n4, i6, a4) {
      e2(!(i6 % n4));
      do {
        t5[r3 + (i6 -= n4)] = a4;
      } while (0 < i6);
    }
    function h4(t5, r3, n4, i6, o4) {
      if (e2(2328 >= o4), 512 >= o4)
        var s4 = a3(512);
      else if ((s4 = a3(o4)) == null)
        return 0;
      return function(t6, r4, n5, i7, o5, s5) {
        var h5, f5, d4 = r4, p5 = 1 << n5, g4 = a3(16), m6 = a3(16);
        for (e2(o5 != 0), e2(i7 != null), e2(t6 != null), e2(0 < n5), f5 = 0;f5 < o5; ++f5) {
          if (15 < i7[f5])
            return 0;
          ++g4[i7[f5]];
        }
        if (g4[0] == o5)
          return 0;
        for (m6[1] = 0, h5 = 1;15 > h5; ++h5) {
          if (g4[h5] > 1 << h5)
            return 0;
          m6[h5 + 1] = m6[h5] + g4[h5];
        }
        for (f5 = 0;f5 < o5; ++f5)
          h5 = i7[f5], 0 < i7[f5] && (s5[m6[h5]++] = f5);
        if (m6[15] == 1)
          return (i7 = new l4).g = 0, i7.value = s5[0], u4(t6, d4, 1, p5, i7), p5;
        var v5, b4 = -1, y5 = p5 - 1, w4 = 0, N5 = 1, L4 = 1, A4 = 1 << n5;
        for (f5 = 0, h5 = 1, o5 = 2;h5 <= n5; ++h5, o5 <<= 1) {
          if (N5 += L4 <<= 1, 0 > (L4 -= g4[h5]))
            return 0;
          for (;0 < g4[h5]; --g4[h5])
            (i7 = new l4).g = h5, i7.value = s5[f5++], u4(t6, d4 + w4, o5, A4, i7), w4 = c5(w4, h5);
        }
        for (h5 = n5 + 1, o5 = 2;15 >= h5; ++h5, o5 <<= 1) {
          if (N5 += L4 <<= 1, 0 > (L4 -= g4[h5]))
            return 0;
          for (;0 < g4[h5]; --g4[h5]) {
            if (i7 = new l4, (w4 & y5) != b4) {
              for (d4 += A4, v5 = 1 << (b4 = h5) - n5;15 > b4 && !(0 >= (v5 -= g4[b4])); )
                ++b4, v5 <<= 1;
              p5 += A4 = 1 << (v5 = b4 - n5), t6[r4 + (b4 = w4 & y5)].g = v5 + n5, t6[r4 + b4].value = d4 - r4 - b4;
            }
            i7.g = h5 - n5, i7.value = s5[f5++], u4(t6, d4 + (w4 >> n5), o5, A4, i7), w4 = c5(w4, h5);
          }
        }
        return N5 != 2 * m6[15] - 1 ? 0 : p5;
      }(t5, r3, n4, i6, o4, s4);
    }
    function l4() {
      this.value = this.g = 0;
    }
    function f4() {
      this.value = this.g = 0;
    }
    function d3() {
      this.G = o3(5, l4), this.H = a3(5), this.jc = this.Qb = this.qb = this.nd = 0, this.pd = o3(Dr, f4);
    }
    function p4(t5, r3, n4, i6) {
      e2(t5 != null), e2(r3 != null), e2(2147483648 > i6), t5.Ca = 254, t5.I = 0, t5.b = -8, t5.Ka = 0, t5.oa = r3, t5.pa = n4, t5.Jd = r3, t5.Yc = n4 + i6, t5.Zc = 4 <= i6 ? n4 + i6 - 4 + 1 : n4, _3(t5);
    }
    function g3(t5, e3) {
      for (var r3 = 0;0 < e3--; )
        r3 |= k2(t5, 128) << e3;
      return r3;
    }
    function m5(t5, e3) {
      var r3 = g3(t5, e3);
      return P2(t5) ? -r3 : r3;
    }
    function v4(t5, r3, n4, i6) {
      var a4, o4 = 0;
      for (e2(t5 != null), e2(r3 != null), e2(4294967288 > i6), t5.Sb = i6, t5.Ra = 0, t5.u = 0, t5.h = 0, 4 < i6 && (i6 = 4), a4 = 0;a4 < i6; ++a4)
        o4 += r3[n4 + a4] << 8 * a4;
      t5.Ra = o4, t5.bb = i6, t5.oa = r3, t5.pa = n4;
    }
    function b3(t5) {
      for (;8 <= t5.u && t5.bb < t5.Sb; )
        t5.Ra >>>= 8, t5.Ra += t5.oa[t5.pa + t5.bb] << Ur - 8 >>> 0, ++t5.bb, t5.u -= 8;
      A3(t5) && (t5.h = 1, t5.u = 0);
    }
    function y4(t5, r3) {
      if (e2(0 <= r3), !t5.h && r3 <= Tr) {
        var n4 = L3(t5) & Rr[r3];
        return t5.u += r3, b3(t5), n4;
      }
      return t5.h = 1, t5.u = 0;
    }
    function w3() {
      this.b = this.Ca = this.I = 0, this.oa = [], this.pa = 0, this.Jd = [], this.Yc = 0, this.Zc = [], this.Ka = 0;
    }
    function N4() {
      this.Ra = 0, this.oa = [], this.h = this.u = this.bb = this.Sb = this.pa = 0;
    }
    function L3(t5) {
      return t5.Ra >>> (t5.u & Ur - 1) >>> 0;
    }
    function A3(t5) {
      return e2(t5.bb <= t5.Sb), t5.h || t5.bb == t5.Sb && t5.u > Ur;
    }
    function x3(t5, e3) {
      t5.u = e3, t5.h = A3(t5);
    }
    function S2(t5) {
      t5.u >= zr && (e2(t5.u >= zr), b3(t5));
    }
    function _3(t5) {
      e2(t5 != null && t5.oa != null), t5.pa < t5.Zc ? (t5.I = (t5.oa[t5.pa++] | t5.I << 8) >>> 0, t5.b += 8) : (e2(t5 != null && t5.oa != null), t5.pa < t5.Yc ? (t5.b += 8, t5.I = t5.oa[t5.pa++] | t5.I << 8) : t5.Ka ? t5.b = 0 : (t5.I <<= 8, t5.b += 8, t5.Ka = 1));
    }
    function P2(t5) {
      return g3(t5, 1);
    }
    function k2(t5, e3) {
      var r3 = t5.Ca;
      0 > t5.b && _3(t5);
      var n4 = t5.b, i6 = r3 * e3 >>> 8, a4 = (t5.I >>> n4 > i6) + 0;
      for (a4 ? (r3 -= i6, t5.I -= i6 + 1 << n4 >>> 0) : r3 = i6 + 1, n4 = r3, i6 = 0;256 <= n4; )
        i6 += 8, n4 >>= 8;
      return n4 = 7 ^ i6 + Hr[n4], t5.b -= n4, t5.Ca = (r3 << n4) - 1, a4;
    }
    function I2(t5, e3, r3) {
      t5[e3 + 0] = r3 >> 24 & 255, t5[e3 + 1] = r3 >> 16 & 255, t5[e3 + 2] = r3 >> 8 & 255, t5[e3 + 3] = r3 >> 0 & 255;
    }
    function F2(t5, e3) {
      return t5[e3 + 0] << 0 | t5[e3 + 1] << 8;
    }
    function C2(t5, e3) {
      return F2(t5, e3) | t5[e3 + 2] << 16;
    }
    function j2(t5, e3) {
      return F2(t5, e3) | F2(t5, e3 + 2) << 16;
    }
    function O3(t5, r3) {
      var n4 = 1 << r3;
      return e2(t5 != null), e2(0 < r3), t5.X = a3(n4), t5.X == null ? 0 : (t5.Mb = 32 - r3, t5.Xa = r3, 1);
    }
    function B2(t5, r3) {
      e2(t5 != null), e2(r3 != null), e2(t5.Xa == r3.Xa), n3(r3.X, 0, t5.X, 0, 1 << r3.Xa);
    }
    function M2() {
      this.X = [], this.Xa = this.Mb = 0;
    }
    function E2(t5, r3, n4, i6) {
      e2(n4 != null), e2(i6 != null);
      var a4 = n4[0], o4 = i6[0];
      return a4 == 0 && (a4 = (t5 * o4 + r3 / 2) / r3), o4 == 0 && (o4 = (r3 * a4 + t5 / 2) / t5), 0 >= a4 || 0 >= o4 ? 0 : (n4[0] = a4, i6[0] = o4, 1);
    }
    function q2(t5, e3) {
      return t5 + (1 << e3) - 1 >>> e3;
    }
    function D2(t5, e3) {
      return ((4278255360 & t5) + (4278255360 & e3) >>> 0 & 4278255360) + ((16711935 & t5) + (16711935 & e3) >>> 0 & 16711935) >>> 0;
    }
    function R2(e3, r3) {
      t4[r3] = function(r4, n4, i6, a4, o4, s4, c6) {
        var u5;
        for (u5 = 0;u5 < o4; ++u5) {
          var h5 = t4[e3](s4[c6 + u5 - 1], i6, a4 + u5);
          s4[c6 + u5] = D2(r4[n4 + u5], h5);
        }
      };
    }
    function T3() {
      this.ud = this.hd = this.jd = 0;
    }
    function U2(t5, e3) {
      return ((4278124286 & (t5 ^ e3)) >>> 1) + (t5 & e3) >>> 0;
    }
    function z2(t5) {
      return 0 <= t5 && 256 > t5 ? t5 : 0 > t5 ? 0 : 255 < t5 ? 255 : undefined;
    }
    function H2(t5, e3) {
      return z2(t5 + (t5 - e3 + 0.5 >> 1));
    }
    function W2(t5, e3, r3) {
      return Math.abs(e3 - r3) - Math.abs(t5 - r3);
    }
    function V2(t5, e3, r3, n4, i6, a4, o4) {
      for (n4 = a4[o4 - 1], r3 = 0;r3 < i6; ++r3)
        a4[o4 + r3] = n4 = D2(t5[e3 + r3], n4);
    }
    function G2(t5, e3, r3, n4, i6) {
      var a4;
      for (a4 = 0;a4 < r3; ++a4) {
        var o4 = t5[e3 + a4], s4 = o4 >> 8 & 255, c6 = 16711935 & (c6 = (c6 = 16711935 & o4) + ((s4 << 16) + s4));
        n4[i6 + a4] = (4278255360 & o4) + c6 >>> 0;
      }
    }
    function Y2(t5, e3) {
      e3.jd = t5 >> 0 & 255, e3.hd = t5 >> 8 & 255, e3.ud = t5 >> 16 & 255;
    }
    function J2(t5, e3, r3, n4, i6, a4) {
      var o4;
      for (o4 = 0;o4 < n4; ++o4) {
        var s4 = e3[r3 + o4], c6 = s4 >>> 8, u5 = s4, h5 = 255 & (h5 = (h5 = s4 >>> 16) + ((t5.jd << 24 >> 24) * (c6 << 24 >> 24) >>> 5));
        u5 = 255 & (u5 = (u5 = u5 + ((t5.hd << 24 >> 24) * (c6 << 24 >> 24) >>> 5)) + ((t5.ud << 24 >> 24) * (h5 << 24 >> 24) >>> 5));
        i6[a4 + o4] = (4278255360 & s4) + (h5 << 16) + u5;
      }
    }
    function X2(e3, r3, n4, i6, a4) {
      t4[r3] = function(t5, e4, r4, n5, o4, s4, c6, u5, h5) {
        for (n5 = c6;n5 < u5; ++n5)
          for (c6 = 0;c6 < h5; ++c6)
            o4[s4++] = a4(r4[i6(t5[e4++])]);
      }, t4[e3] = function(e4, r4, o4, s4, c6, u5, h5) {
        var l5 = 8 >> e4.b, f5 = e4.Ea, d4 = e4.K[0], p5 = e4.w;
        if (8 > l5)
          for (e4 = (1 << e4.b) - 1, p5 = (1 << l5) - 1;r4 < o4; ++r4) {
            var g4, m6 = 0;
            for (g4 = 0;g4 < f5; ++g4)
              g4 & e4 || (m6 = i6(s4[c6++])), u5[h5++] = a4(d4[m6 & p5]), m6 >>= l5;
          }
        else
          t4["VP8LMapColor" + n4](s4, c6, d4, p5, u5, h5, r4, o4, f5);
      };
    }
    function K2(t5, e3, r3, n4, i6) {
      for (r3 = e3 + r3;e3 < r3; ) {
        var a4 = t5[e3++];
        n4[i6++] = a4 >> 16 & 255, n4[i6++] = a4 >> 8 & 255, n4[i6++] = a4 >> 0 & 255;
      }
    }
    function Z2(t5, e3, r3, n4, i6) {
      for (r3 = e3 + r3;e3 < r3; ) {
        var a4 = t5[e3++];
        n4[i6++] = a4 >> 16 & 255, n4[i6++] = a4 >> 8 & 255, n4[i6++] = a4 >> 0 & 255, n4[i6++] = a4 >> 24 & 255;
      }
    }
    function $2(t5, e3, r3, n4, i6) {
      for (r3 = e3 + r3;e3 < r3; ) {
        var a4 = (o4 = t5[e3++]) >> 16 & 240 | o4 >> 12 & 15, o4 = o4 >> 0 & 240 | o4 >> 28 & 15;
        n4[i6++] = a4, n4[i6++] = o4;
      }
    }
    function Q2(t5, e3, r3, n4, i6) {
      for (r3 = e3 + r3;e3 < r3; ) {
        var a4 = (o4 = t5[e3++]) >> 16 & 248 | o4 >> 13 & 7, o4 = o4 >> 5 & 224 | o4 >> 3 & 31;
        n4[i6++] = a4, n4[i6++] = o4;
      }
    }
    function tt2(t5, e3, r3, n4, i6) {
      for (r3 = e3 + r3;e3 < r3; ) {
        var a4 = t5[e3++];
        n4[i6++] = a4 >> 0 & 255, n4[i6++] = a4 >> 8 & 255, n4[i6++] = a4 >> 16 & 255;
      }
    }
    function et3(t5, e3, r3, i6, a4, o4) {
      if (o4 == 0)
        for (r3 = e3 + r3;e3 < r3; )
          I2(i6, ((o4 = t5[e3++])[0] >> 24 | o4[1] >> 8 & 65280 | o4[2] << 8 & 16711680 | o4[3] << 24) >>> 0), a4 += 32;
      else
        n3(i6, a4, t5, e3, r3);
    }
    function rt2(e3, r3) {
      t4[r3][0] = t4[e3 + "0"], t4[r3][1] = t4[e3 + "1"], t4[r3][2] = t4[e3 + "2"], t4[r3][3] = t4[e3 + "3"], t4[r3][4] = t4[e3 + "4"], t4[r3][5] = t4[e3 + "5"], t4[r3][6] = t4[e3 + "6"], t4[r3][7] = t4[e3 + "7"], t4[r3][8] = t4[e3 + "8"], t4[r3][9] = t4[e3 + "9"], t4[r3][10] = t4[e3 + "10"], t4[r3][11] = t4[e3 + "11"], t4[r3][12] = t4[e3 + "12"], t4[r3][13] = t4[e3 + "13"], t4[r3][14] = t4[e3 + "0"], t4[r3][15] = t4[e3 + "0"];
    }
    function nt2(t5) {
      return t5 == Hn || t5 == Wn || t5 == Vn || t5 == Gn;
    }
    function it2() {
      this.eb = [], this.size = this.A = this.fb = 0;
    }
    function at2() {
      this.y = [], this.f = [], this.ea = [], this.F = [], this.Tc = this.Ed = this.Cd = this.Fd = this.lb = this.Db = this.Ab = this.fa = this.J = this.W = this.N = this.O = 0;
    }
    function ot2() {
      this.Rd = this.height = this.width = this.S = 0, this.f = {}, this.f.RGBA = new it2, this.f.kb = new at2, this.sd = null;
    }
    function st2() {
      this.width = [0], this.height = [0], this.Pd = [0], this.Qd = [0], this.format = [0];
    }
    function ct2() {
      this.Id = this.fd = this.Md = this.hb = this.ib = this.da = this.bd = this.cd = this.j = this.v = this.Da = this.Sd = this.ob = 0;
    }
    function ut2(t5) {
      return alert("todo:WebPSamplerProcessPlane"), t5.T;
    }
    function ht2(t5, e3) {
      var r3 = t5.T, i6 = e3.ba.f.RGBA, a4 = i6.eb, o4 = i6.fb + t5.ka * i6.A, s4 = vi[e3.ba.S], c6 = t5.y, u5 = t5.O, h5 = t5.f, l5 = t5.N, f5 = t5.ea, d4 = t5.W, p5 = e3.cc, g4 = e3.dc, m6 = e3.Mc, v5 = e3.Nc, b4 = t5.ka, y5 = t5.ka + t5.T, w4 = t5.U, N5 = w4 + 1 >> 1;
      for (b4 == 0 ? s4(c6, u5, null, null, h5, l5, f5, d4, h5, l5, f5, d4, a4, o4, null, null, w4) : (s4(e3.ec, e3.fc, c6, u5, p5, g4, m6, v5, h5, l5, f5, d4, a4, o4 - i6.A, a4, o4, w4), ++r3);b4 + 2 < y5; b4 += 2)
        p5 = h5, g4 = l5, m6 = f5, v5 = d4, l5 += t5.Rc, d4 += t5.Rc, o4 += 2 * i6.A, s4(c6, (u5 += 2 * t5.fa) - t5.fa, c6, u5, p5, g4, m6, v5, h5, l5, f5, d4, a4, o4 - i6.A, a4, o4, w4);
      return u5 += t5.fa, t5.j + y5 < t5.o ? (n3(e3.ec, e3.fc, c6, u5, w4), n3(e3.cc, e3.dc, h5, l5, N5), n3(e3.Mc, e3.Nc, f5, d4, N5), r3--) : 1 & y5 || s4(c6, u5, null, null, h5, l5, f5, d4, h5, l5, f5, d4, a4, o4 + i6.A, null, null, w4), r3;
    }
    function lt2(t5, r3, n4) {
      var i6 = t5.F, a4 = [t5.J];
      if (i6 != null) {
        var o4 = t5.U, s4 = r3.ba.S, c6 = s4 == Tn || s4 == Vn;
        r3 = r3.ba.f.RGBA;
        var u5 = [0], h5 = t5.ka;
        u5[0] = t5.T, t5.Kb && (h5 == 0 ? --u5[0] : (--h5, a4[0] -= t5.width), t5.j + t5.ka + t5.T == t5.o && (u5[0] = t5.o - t5.j - h5));
        var l5 = r3.eb;
        h5 = r3.fb + h5 * r3.A;
        t5 = Sn(i6, a4[0], t5.width, o4, u5, l5, h5 + (c6 ? 0 : 3), r3.A), e2(n4 == u5), t5 && nt2(s4) && An(l5, h5, c6, o4, u5, r3.A);
      }
      return 0;
    }
    function ft2(t5) {
      var e3 = t5.ma, r3 = e3.ba.S, n4 = 11 > r3, i6 = r3 == qn || r3 == Rn || r3 == Tn || r3 == Un || r3 == 12 || nt2(r3);
      if (e3.memory = null, e3.Ib = null, e3.Jb = null, e3.Nd = null, !Mr(e3.Oa, t5, i6 ? 11 : 12))
        return 0;
      if (i6 && nt2(r3) && br(), t5.da)
        alert("todo:use_scaling");
      else {
        if (n4) {
          if (e3.Ib = ut2, t5.Kb) {
            if (r3 = t5.U + 1 >> 1, e3.memory = a3(t5.U + 2 * r3), e3.memory == null)
              return 0;
            e3.ec = e3.memory, e3.fc = 0, e3.cc = e3.ec, e3.dc = e3.fc + t5.U, e3.Mc = e3.cc, e3.Nc = e3.dc + r3, e3.Ib = ht2, br();
          }
        } else
          alert("todo:EmitYUV");
        i6 && (e3.Jb = lt2, n4 && mr());
      }
      if (n4 && !Ci) {
        for (t5 = 0;256 > t5; ++t5)
          ji[t5] = 89858 * (t5 - 128) + _i >> Si, Mi[t5] = -22014 * (t5 - 128) + _i, Bi[t5] = -45773 * (t5 - 128), Oi[t5] = 113618 * (t5 - 128) + _i >> Si;
        for (t5 = Pi;t5 < ki; ++t5)
          e3 = 76283 * (t5 - 16) + _i >> Si, Ei[t5 - Pi] = Vt2(e3, 255), qi[t5 - Pi] = Vt2(e3 + 8 >> 4, 15);
        Ci = 1;
      }
      return 1;
    }
    function dt2(t5) {
      var { ma: r3, U: n4, T: i6 } = t5;
      return e2(!(1 & t5.ka)), 0 >= n4 || 0 >= i6 ? 0 : (n4 = r3.Ib(t5, r3), r3.Jb != null && r3.Jb(t5, r3, n4), r3.Dc += n4, 1);
    }
    function pt2(t5) {
      t5.ma.memory = null;
    }
    function gt2(t5, e3, r3, n4) {
      return y4(t5, 8) != 47 ? 0 : (e3[0] = y4(t5, 14) + 1, r3[0] = y4(t5, 14) + 1, n4[0] = y4(t5, 1), y4(t5, 3) != 0 ? 0 : !t5.h);
    }
    function mt2(t5, e3) {
      if (4 > t5)
        return t5 + 1;
      var r3 = t5 - 2 >> 1;
      return (2 + (1 & t5) << r3) + y4(e3, r3) + 1;
    }
    function vt2(t5, e3) {
      return 120 < e3 ? e3 - 120 : 1 <= (r3 = ((r3 = $n[e3 - 1]) >> 4) * t5 + (8 - (15 & r3))) ? r3 : 1;
      var r3;
    }
    function bt2(t5, e3, r3) {
      var n4 = L3(r3), i6 = t5[e3 += 255 & n4].g - 8;
      return 0 < i6 && (x3(r3, r3.u + 8), n4 = L3(r3), e3 += t5[e3].value, e3 += n4 & (1 << i6) - 1), x3(r3, r3.u + t5[e3].g), t5[e3].value;
    }
    function yt2(t5, r3, n4) {
      return n4.g += t5.g, n4.value += t5.value << r3 >>> 0, e2(8 >= n4.g), t5.g;
    }
    function wt2(t5, r3, n4) {
      var i6 = t5.xc;
      return e2((r3 = i6 == 0 ? 0 : t5.vc[t5.md * (n4 >> i6) + (r3 >> i6)]) < t5.Wb), t5.Ya[r3];
    }
    function Nt2(t5, r3, i6, a4) {
      var o4 = t5.ab, s4 = t5.c * r3, c6 = t5.C;
      r3 = c6 + r3;
      var u5 = i6, h5 = a4;
      for (a4 = t5.Ta, i6 = t5.Ua;0 < o4--; ) {
        var l5 = t5.gc[o4], f5 = c6, d4 = r3, p5 = u5, g4 = h5, m6 = (h5 = a4, u5 = i6, l5.Ea);
        switch (e2(f5 < d4), e2(d4 <= l5.nc), l5.hc) {
          case 2:
            Gr(p5, g4, (d4 - f5) * m6, h5, u5);
            break;
          case 0:
            var v5 = f5, b4 = d4, y5 = h5, w4 = u5, N5 = (_4 = l5).Ea;
            v5 == 0 && (Wr(p5, g4, null, null, 1, y5, w4), V2(p5, g4 + 1, 0, 0, N5 - 1, y5, w4 + 1), g4 += N5, w4 += N5, ++v5);
            for (var L4 = 1 << _4.b, A4 = L4 - 1, x4 = q2(N5, _4.b), S3 = _4.K, _4 = _4.w + (v5 >> _4.b) * x4;v5 < b4; ) {
              var P3 = S3, k3 = _4, I3 = 1;
              for (Vr(p5, g4, y5, w4 - N5, 1, y5, w4);I3 < N5; ) {
                var F3 = (I3 & ~A4) + L4;
                F3 > N5 && (F3 = N5), (0, Zr[P3[k3++] >> 8 & 15])(p5, g4 + +I3, y5, w4 + I3 - N5, F3 - I3, y5, w4 + I3), I3 = F3;
              }
              g4 += N5, w4 += N5, ++v5 & A4 || (_4 += x4);
            }
            d4 != l5.nc && n3(h5, u5 - m6, h5, u5 + (d4 - f5 - 1) * m6, m6);
            break;
          case 1:
            for (m6 = p5, b4 = g4, N5 = (p5 = l5.Ea) - (w4 = p5 & ~(y5 = (g4 = 1 << l5.b) - 1)), v5 = q2(p5, l5.b), L4 = l5.K, l5 = l5.w + (f5 >> l5.b) * v5;f5 < d4; ) {
              for (A4 = L4, x4 = l5, S3 = new T3, _4 = b4 + w4, P3 = b4 + p5;b4 < _4; )
                Y2(A4[x4++], S3), $r(S3, m6, b4, g4, h5, u5), b4 += g4, u5 += g4;
              b4 < P3 && (Y2(A4[x4++], S3), $r(S3, m6, b4, N5, h5, u5), b4 += N5, u5 += N5), ++f5 & y5 || (l5 += v5);
            }
            break;
          case 3:
            if (p5 == h5 && g4 == u5 && 0 < l5.b) {
              for (b4 = h5, p5 = m6 = u5 + (d4 - f5) * m6 - (w4 = (d4 - f5) * q2(l5.Ea, l5.b)), g4 = h5, y5 = u5, v5 = [], w4 = (N5 = w4) - 1;0 <= w4; --w4)
                v5[w4] = g4[y5 + w4];
              for (w4 = N5 - 1;0 <= w4; --w4)
                b4[p5 + w4] = v5[w4];
              Yr(l5, f5, d4, h5, m6, h5, u5);
            } else
              Yr(l5, f5, d4, p5, g4, h5, u5);
        }
        u5 = a4, h5 = i6;
      }
      h5 != i6 && n3(a4, i6, u5, h5, s4);
    }
    function Lt2(t5, r3) {
      var n4 = t5.V, i6 = t5.Ba + t5.c * t5.C, a4 = r3 - t5.C;
      if (e2(r3 <= t5.l.o), e2(16 >= a4), 0 < a4) {
        var { l: o4, Ta: s4, Ua: c6 } = t5, u5 = o4.width;
        if (Nt2(t5, a4, n4, i6), a4 = c6 = [c6], e2((n4 = t5.C) < (i6 = r3)), e2(o4.v < o4.va), i6 > o4.o && (i6 = o4.o), n4 < o4.j) {
          var h5 = o4.j - n4;
          n4 = o4.j;
          a4[0] += h5 * u5;
        }
        if (n4 >= i6 ? n4 = 0 : (a4[0] += 4 * o4.v, o4.ka = n4 - o4.j, o4.U = o4.va - o4.v, o4.T = i6 - n4, n4 = 1), n4) {
          if (c6 = c6[0], 11 > (n4 = t5.ca).S) {
            var l5 = n4.f.RGBA, f5 = (i6 = n4.S, a4 = o4.U, o4 = o4.T, h5 = l5.eb, l5.A), d4 = o4;
            for (l5 = l5.fb + t5.Ma * l5.A;0 < d4--; ) {
              var p5 = s4, g4 = c6, m6 = a4, v5 = h5, b4 = l5;
              switch (i6) {
                case En:
                  Qr(p5, g4, m6, v5, b4);
                  break;
                case qn:
                  tn(p5, g4, m6, v5, b4);
                  break;
                case Hn:
                  tn(p5, g4, m6, v5, b4), An(v5, b4, 0, m6, 1, 0);
                  break;
                case Dn:
                  nn(p5, g4, m6, v5, b4);
                  break;
                case Rn:
                  et3(p5, g4, m6, v5, b4, 1);
                  break;
                case Wn:
                  et3(p5, g4, m6, v5, b4, 1), An(v5, b4, 0, m6, 1, 0);
                  break;
                case Tn:
                  et3(p5, g4, m6, v5, b4, 0);
                  break;
                case Vn:
                  et3(p5, g4, m6, v5, b4, 0), An(v5, b4, 1, m6, 1, 0);
                  break;
                case Un:
                  en(p5, g4, m6, v5, b4);
                  break;
                case Gn:
                  en(p5, g4, m6, v5, b4), xn(v5, b4, m6, 1, 0);
                  break;
                case zn:
                  rn(p5, g4, m6, v5, b4);
                  break;
                default:
                  e2(0);
              }
              c6 += u5, l5 += f5;
            }
            t5.Ma += o4;
          } else
            alert("todo:EmitRescaledRowsYUVA");
          e2(t5.Ma <= n4.height);
        }
      }
      t5.C = r3, e2(t5.C <= t5.i);
    }
    function At2(t5) {
      var e3;
      if (0 < t5.ua)
        return 0;
      for (e3 = 0;e3 < t5.Wb; ++e3) {
        var r3 = t5.Ya[e3].G, n4 = t5.Ya[e3].H;
        if (0 < r3[1][n4[1] + 0].g || 0 < r3[2][n4[2] + 0].g || 0 < r3[3][n4[3] + 0].g)
          return 0;
      }
      return 1;
    }
    function xt2(t5, r3, n4, i6, a4, o4) {
      if (t5.Z != 0) {
        var { qd: s4, rd: c6 } = t5;
        for (e2(mi[t5.Z] != null);r3 < n4; ++r3)
          mi[t5.Z](s4, c6, i6, a4, i6, a4, o4), s4 = i6, c6 = a4, a4 += o4;
        t5.qd = s4, t5.rd = c6;
      }
    }
    function St2(t5, r3) {
      var n4 = t5.l.ma, i6 = n4.Z == 0 || n4.Z == 1 ? t5.l.j : t5.C;
      i6 = t5.C < i6 ? i6 : t5.C;
      if (e2(r3 <= t5.l.o), r3 > i6) {
        var a4 = t5.l.width, o4 = n4.ca, s4 = n4.tb + a4 * i6, c6 = t5.V, u5 = t5.Ba + t5.c * i6, h5 = t5.gc;
        e2(t5.ab == 1), e2(h5[0].hc == 3), Xr(h5[0], i6, r3, c6, u5, o4, s4), xt2(n4, i6, r3, o4, s4, a4);
      }
      t5.C = t5.Ma = r3;
    }
    function _t2(t5, r3, n4, i6, a4, o4, s4) {
      var c6 = t5.$ / i6, u5 = t5.$ % i6, h5 = t5.m, l5 = t5.s, f5 = n4 + t5.$, d4 = f5;
      a4 = n4 + i6 * a4;
      var p5 = n4 + i6 * o4, g4 = 280 + l5.ua, m6 = t5.Pb ? c6 : 16777216, v5 = 0 < l5.ua ? l5.Wa : null, b4 = l5.wc, y5 = f5 < p5 ? wt2(l5, u5, c6) : null;
      e2(t5.C < o4), e2(p5 <= a4);
      var w4 = false;
      t:
        for (;; ) {
          for (;w4 || f5 < p5; ) {
            var N5 = 0;
            if (c6 >= m6) {
              var _4 = f5 - n4;
              e2((m6 = t5).Pb), m6.wd = m6.m, m6.xd = _4, 0 < m6.s.ua && B2(m6.s.Wa, m6.s.vb), m6 = c6 + ti;
            }
            if (u5 & b4 || (y5 = wt2(l5, u5, c6)), e2(y5 != null), y5.Qb && (r3[f5] = y5.qb, w4 = true), !w4)
              if (S2(h5), y5.jc) {
                N5 = h5, _4 = r3;
                var P3 = f5, k3 = y5.pd[L3(N5) & Dr - 1];
                e2(y5.jc), 256 > k3.g ? (x3(N5, N5.u + k3.g), _4[P3] = k3.value, N5 = 0) : (x3(N5, N5.u + k3.g - 256), e2(256 <= k3.value), N5 = k3.value), N5 == 0 && (w4 = true);
              } else
                N5 = bt2(y5.G[0], y5.H[0], h5);
            if (h5.h)
              break;
            if (w4 || 256 > N5) {
              if (!w4)
                if (y5.nd)
                  r3[f5] = (y5.qb | N5 << 8) >>> 0;
                else {
                  if (S2(h5), w4 = bt2(y5.G[1], y5.H[1], h5), S2(h5), _4 = bt2(y5.G[2], y5.H[2], h5), P3 = bt2(y5.G[3], y5.H[3], h5), h5.h)
                    break;
                  r3[f5] = (P3 << 24 | w4 << 16 | N5 << 8 | _4) >>> 0;
                }
              if (w4 = false, ++f5, ++u5 >= i6 && (u5 = 0, ++c6, s4 != null && c6 <= o4 && !(c6 % 16) && s4(t5, c6), v5 != null))
                for (;d4 < f5; )
                  N5 = r3[d4++], v5.X[(506832829 * N5 & 4294967295) >>> v5.Mb] = N5;
            } else if (280 > N5) {
              if (N5 = mt2(N5 - 256, h5), _4 = bt2(y5.G[4], y5.H[4], h5), S2(h5), _4 = vt2(i6, _4 = mt2(_4, h5)), h5.h)
                break;
              if (f5 - n4 < _4 || a4 - f5 < N5)
                break t;
              for (P3 = 0;P3 < N5; ++P3)
                r3[f5 + P3] = r3[f5 + P3 - _4];
              for (f5 += N5, u5 += N5;u5 >= i6; )
                u5 -= i6, ++c6, s4 != null && c6 <= o4 && !(c6 % 16) && s4(t5, c6);
              if (e2(f5 <= a4), u5 & b4 && (y5 = wt2(l5, u5, c6)), v5 != null)
                for (;d4 < f5; )
                  N5 = r3[d4++], v5.X[(506832829 * N5 & 4294967295) >>> v5.Mb] = N5;
            } else {
              if (!(N5 < g4))
                break t;
              for (w4 = N5 - 280, e2(v5 != null);d4 < f5; )
                N5 = r3[d4++], v5.X[(506832829 * N5 & 4294967295) >>> v5.Mb] = N5;
              N5 = f5, e2(!(w4 >>> (_4 = v5).Xa)), r3[N5] = _4.X[w4], w4 = true;
            }
            w4 || e2(h5.h == A3(h5));
          }
          if (t5.Pb && h5.h && f5 < a4)
            e2(t5.m.h), t5.a = 5, t5.m = t5.wd, t5.$ = t5.xd, 0 < t5.s.ua && B2(t5.s.vb, t5.s.Wa);
          else {
            if (h5.h)
              break t;
            s4 != null && s4(t5, c6 > o4 ? o4 : c6), t5.a = 0, t5.$ = f5 - n4;
          }
          return 1;
        }
      return t5.a = 3, 0;
    }
    function Pt2(t5) {
      e2(t5 != null), t5.vc = null, t5.yc = null, t5.Ya = null;
      var r3 = t5.Wa;
      r3 != null && (r3.X = null), t5.vb = null, e2(t5 != null);
    }
    function kt2() {
      var e3 = new or;
      return e3 == null ? null : (e3.a = 0, e3.xb = gi, rt2("Predictor", "VP8LPredictors"), rt2("Predictor", "VP8LPredictors_C"), rt2("PredictorAdd", "VP8LPredictorsAdd"), rt2("PredictorAdd", "VP8LPredictorsAdd_C"), Gr = G2, $r = J2, Qr = K2, tn = Z2, en = $2, rn = Q2, nn = tt2, t4.VP8LMapColor32b = Jr, t4.VP8LMapColor8b = Kr, e3);
    }
    function It2(t5, r3, n4, s4, c6) {
      var u5 = 1, f5 = [t5], p5 = [r3], g4 = s4.m, m6 = s4.s, v5 = null, b4 = 0;
      t:
        for (;; ) {
          if (n4)
            for (;u5 && y4(g4, 1); ) {
              var w4 = f5, N5 = p5, A4 = s4, _4 = 1, P3 = A4.m, k3 = A4.gc[A4.ab], I3 = y4(P3, 2);
              if (A4.Oc & 1 << I3)
                u5 = 0;
              else {
                switch (A4.Oc |= 1 << I3, k3.hc = I3, k3.Ea = w4[0], k3.nc = N5[0], k3.K = [null], ++A4.ab, e2(4 >= A4.ab), I3) {
                  case 0:
                  case 1:
                    k3.b = y4(P3, 3) + 2, _4 = It2(q2(k3.Ea, k3.b), q2(k3.nc, k3.b), 0, A4, k3.K), k3.K = k3.K[0];
                    break;
                  case 3:
                    var F3, C3 = y4(P3, 8) + 1, j3 = 16 < C3 ? 0 : 4 < C3 ? 1 : 2 < C3 ? 2 : 3;
                    if (w4[0] = q2(k3.Ea, j3), k3.b = j3, F3 = _4 = It2(C3, 1, 0, A4, k3.K)) {
                      var B3, M3 = C3, E3 = k3, R3 = 1 << (8 >> E3.b), T4 = a3(R3);
                      if (T4 == null)
                        F3 = 0;
                      else {
                        var U3 = E3.K[0], z3 = E3.w;
                        for (T4[0] = E3.K[0][0], B3 = 1;B3 < 1 * M3; ++B3)
                          T4[B3] = D2(U3[z3 + B3], T4[B3 - 1]);
                        for (;B3 < 4 * R3; ++B3)
                          T4[B3] = 0;
                        E3.K[0] = null, E3.K[0] = T4, F3 = 1;
                      }
                    }
                    _4 = F3;
                    break;
                  case 2:
                    break;
                  default:
                    e2(0);
                }
                u5 = _4;
              }
            }
          if (f5 = f5[0], p5 = p5[0], u5 && y4(g4, 1) && !(u5 = 1 <= (b4 = y4(g4, 4)) && 11 >= b4)) {
            s4.a = 3;
            break t;
          }
          var H3;
          if (H3 = u5)
            e: {
              var W3, V3, G3, Y3 = s4, J3 = f5, X3 = p5, K3 = b4, Z3 = n4, $3 = Y3.m, Q3 = Y3.s, tt3 = [null], et4 = 1, rt3 = 0, nt3 = Qn[K3];
              r:
                for (;; ) {
                  if (Z3 && y4($3, 1)) {
                    var it3 = y4($3, 3) + 2, at3 = q2(J3, it3), ot3 = q2(X3, it3), st3 = at3 * ot3;
                    if (!It2(at3, ot3, 0, Y3, tt3))
                      break r;
                    for (tt3 = tt3[0], Q3.xc = it3, W3 = 0;W3 < st3; ++W3) {
                      var ct3 = tt3[W3] >> 8 & 65535;
                      tt3[W3] = ct3, ct3 >= et4 && (et4 = ct3 + 1);
                    }
                  }
                  if ($3.h)
                    break r;
                  for (V3 = 0;5 > V3; ++V3) {
                    var ut3 = Xn[V3];
                    !V3 && 0 < K3 && (ut3 += 1 << K3), rt3 < ut3 && (rt3 = ut3);
                  }
                  var ht3 = o3(et4 * nt3, l4), lt3 = et4, ft3 = o3(lt3, d3);
                  if (ft3 == null)
                    var dt3 = null;
                  else
                    e2(65536 >= lt3), dt3 = ft3;
                  var pt3 = a3(rt3);
                  if (dt3 == null || pt3 == null || ht3 == null) {
                    Y3.a = 1;
                    break r;
                  }
                  var gt3 = ht3;
                  for (W3 = G3 = 0;W3 < et4; ++W3) {
                    var mt3 = dt3[W3], vt3 = mt3.G, bt3 = mt3.H, wt3 = 0, Nt3 = 1, Lt3 = 0;
                    for (V3 = 0;5 > V3; ++V3) {
                      ut3 = Xn[V3], vt3[V3] = gt3, bt3[V3] = G3, !V3 && 0 < K3 && (ut3 += 1 << K3);
                      n: {
                        var At3, xt3 = ut3, St3 = Y3, kt3 = pt3, Ft3 = gt3, Ct3 = G3, jt3 = 0, Ot3 = St3.m, Bt3 = y4(Ot3, 1);
                        if (i5(kt3, 0, 0, xt3), Bt3) {
                          var Mt3 = y4(Ot3, 1) + 1, Et3 = y4(Ot3, 1), qt3 = y4(Ot3, Et3 == 0 ? 1 : 8);
                          kt3[qt3] = 1, Mt3 == 2 && (kt3[qt3 = y4(Ot3, 8)] = 1);
                          var Dt3 = 1;
                        } else {
                          var Rt3 = a3(19), Tt3 = y4(Ot3, 4) + 4;
                          if (19 < Tt3) {
                            St3.a = 3;
                            var Ut3 = 0;
                            break n;
                          }
                          for (At3 = 0;At3 < Tt3; ++At3)
                            Rt3[Zn[At3]] = y4(Ot3, 3);
                          var zt3 = undefined, Ht3 = undefined, Wt3 = St3, Vt3 = Rt3, Gt3 = xt3, Yt3 = kt3, Jt3 = 0, Xt3 = Wt3.m, Kt3 = 8, Zt3 = o3(128, l4);
                          i:
                            for (;h4(Zt3, 0, 7, Vt3, 19); ) {
                              if (y4(Xt3, 1)) {
                                var $t3 = 2 + 2 * y4(Xt3, 3);
                                if ((zt3 = 2 + y4(Xt3, $t3)) > Gt3)
                                  break i;
                              } else
                                zt3 = Gt3;
                              for (Ht3 = 0;Ht3 < Gt3 && zt3--; ) {
                                S2(Xt3);
                                var Qt3 = Zt3[0 + (127 & L3(Xt3))];
                                x3(Xt3, Xt3.u + Qt3.g);
                                var te3 = Qt3.value;
                                if (16 > te3)
                                  Yt3[Ht3++] = te3, te3 != 0 && (Kt3 = te3);
                                else {
                                  var ee3 = te3 == 16, re2 = te3 - 16, ne2 = Jn[re2], ie4 = y4(Xt3, Yn[re2]) + ne2;
                                  if (Ht3 + ie4 > Gt3)
                                    break i;
                                  for (var ae2 = ee3 ? Kt3 : 0;0 < ie4--; )
                                    Yt3[Ht3++] = ae2;
                                }
                              }
                              Jt3 = 1;
                              break i;
                            }
                          Jt3 || (Wt3.a = 3), Dt3 = Jt3;
                        }
                        (Dt3 = Dt3 && !Ot3.h) && (jt3 = h4(Ft3, Ct3, 8, kt3, xt3)), Dt3 && jt3 != 0 ? Ut3 = jt3 : (St3.a = 3, Ut3 = 0);
                      }
                      if (Ut3 == 0)
                        break r;
                      if (Nt3 && Kn[V3] == 1 && (Nt3 = gt3[G3].g == 0), wt3 += gt3[G3].g, G3 += Ut3, 3 >= V3) {
                        var oe2, se2 = pt3[0];
                        for (oe2 = 1;oe2 < ut3; ++oe2)
                          pt3[oe2] > se2 && (se2 = pt3[oe2]);
                        Lt3 += se2;
                      }
                    }
                    if (mt3.nd = Nt3, mt3.Qb = 0, Nt3 && (mt3.qb = (vt3[3][bt3[3] + 0].value << 24 | vt3[1][bt3[1] + 0].value << 16 | vt3[2][bt3[2] + 0].value) >>> 0, wt3 == 0 && 256 > vt3[0][bt3[0] + 0].value && (mt3.Qb = 1, mt3.qb += vt3[0][bt3[0] + 0].value << 8)), mt3.jc = !mt3.Qb && 6 > Lt3, mt3.jc) {
                      var ce2, ue2 = mt3;
                      for (ce2 = 0;ce2 < Dr; ++ce2) {
                        var he2 = ce2, le2 = ue2.pd[he2], fe2 = ue2.G[0][ue2.H[0] + he2];
                        256 <= fe2.value ? (le2.g = fe2.g + 256, le2.value = fe2.value) : (le2.g = 0, le2.value = 0, he2 >>= yt2(fe2, 8, le2), he2 >>= yt2(ue2.G[1][ue2.H[1] + he2], 16, le2), he2 >>= yt2(ue2.G[2][ue2.H[2] + he2], 0, le2), yt2(ue2.G[3][ue2.H[3] + he2], 24, le2));
                      }
                    }
                  }
                  Q3.vc = tt3, Q3.Wb = et4, Q3.Ya = dt3, Q3.yc = ht3, H3 = 1;
                  break e;
                }
              H3 = 0;
            }
          if (!(u5 = H3)) {
            s4.a = 3;
            break t;
          }
          if (0 < b4) {
            if (m6.ua = 1 << b4, !O3(m6.Wa, b4)) {
              s4.a = 1, u5 = 0;
              break t;
            }
          } else
            m6.ua = 0;
          var de2 = s4, pe2 = f5, ge2 = p5, me2 = de2.s, ve2 = me2.xc;
          if (de2.c = pe2, de2.i = ge2, me2.md = q2(pe2, ve2), me2.wc = ve2 == 0 ? -1 : (1 << ve2) - 1, n4) {
            s4.xb = pi;
            break t;
          }
          if ((v5 = a3(f5 * p5)) == null) {
            s4.a = 1, u5 = 0;
            break t;
          }
          u5 = (u5 = _t2(s4, v5, 0, f5, p5, p5, null)) && !g4.h;
          break t;
        }
      return u5 ? (c6 != null ? c6[0] = v5 : (e2(v5 == null), e2(n4)), s4.$ = 0, n4 || Pt2(m6)) : Pt2(m6), u5;
    }
    function Ft2(t5, r3) {
      var n4 = t5.c * t5.i, i6 = n4 + r3 + 16 * r3;
      return e2(t5.c <= r3), t5.V = a3(i6), t5.V == null ? (t5.Ta = null, t5.Ua = 0, t5.a = 1, 0) : (t5.Ta = t5.V, t5.Ua = t5.Ba + n4 + r3, 1);
    }
    function Ct2(t5, r3) {
      var n4 = t5.C, i6 = r3 - n4, a4 = t5.V, o4 = t5.Ba + t5.c * n4;
      for (e2(r3 <= t5.l.o);0 < i6; ) {
        var s4 = 16 < i6 ? 16 : i6, c6 = t5.l.ma, u5 = t5.l.width, h5 = u5 * s4, l5 = c6.ca, f5 = c6.tb + u5 * n4, d4 = t5.Ta, p5 = t5.Ua;
        Nt2(t5, s4, a4, o4), _n(d4, p5, l5, f5, h5), xt2(c6, n4, n4 + s4, l5, f5, u5), i6 -= s4, a4 += s4 * t5.c, n4 += s4;
      }
      e2(n4 == r3), t5.C = t5.Ma = r3;
    }
    function jt2() {
      this.ub = this.yd = this.td = this.Rb = 0;
    }
    function Ot2() {
      this.Kd = this.Ld = this.Ud = this.Td = this.i = this.c = 0;
    }
    function Bt2() {
      this.Fb = this.Bb = this.Cb = 0, this.Zb = a3(4), this.Lb = a3(4);
    }
    function Mt2() {
      this.Yb = function() {
        var t5 = [];
        return function t(e3, r3, n4) {
          for (var i6 = n4[r3], a4 = 0;a4 < i6 && (e3.push(n4.length > r3 + 1 ? [] : 0), !(n4.length < r3 + 1)); a4++)
            t(e3[a4], r3 + 1, n4);
        }(t5, 0, [3, 11]), t5;
      }();
    }
    function Et2() {
      this.jb = a3(3), this.Wc = s3([4, 8], Mt2), this.Xc = s3([4, 17], Mt2);
    }
    function qt2() {
      this.Pc = this.wb = this.Tb = this.zd = 0, this.vd = new a3(4), this.od = new a3(4);
    }
    function Dt2() {
      this.ld = this.La = this.dd = this.tc = 0;
    }
    function Rt2() {
      this.Na = this.la = 0;
    }
    function Tt2() {
      this.Sc = [0, 0], this.Eb = [0, 0], this.Qc = [0, 0], this.ia = this.lc = 0;
    }
    function Ut2() {
      this.ad = a3(384), this.Za = 0, this.Ob = a3(16), this.$b = this.Ad = this.ia = this.Gc = this.Hc = this.Dd = 0;
    }
    function zt2() {
      this.uc = this.M = this.Nb = 0, this.wa = Array(new Dt2), this.Y = 0, this.ya = Array(new Ut2), this.aa = 0, this.l = new Gt2;
    }
    function Ht2() {
      this.y = a3(16), this.f = a3(8), this.ea = a3(8);
    }
    function Wt2() {
      this.cb = this.a = 0, this.sc = "", this.m = new w3, this.Od = new jt2, this.Kc = new Ot2, this.ed = new qt2, this.Qa = new Bt2, this.Ic = this.$c = this.Aa = 0, this.D = new zt2, this.Xb = this.Va = this.Hb = this.zb = this.yb = this.Ub = this.za = 0, this.Jc = o3(8, w3), this.ia = 0, this.pb = o3(4, Tt2), this.Pa = new Et2, this.Bd = this.kc = 0, this.Ac = [], this.Bc = 0, this.zc = [0, 0, 0, 0], this.Gd = Array(new Ht2), this.Hd = 0, this.rb = Array(new Rt2), this.sb = 0, this.wa = Array(new Dt2), this.Y = 0, this.oc = [], this.pc = 0, this.sa = [], this.ta = 0, this.qa = [], this.ra = 0, this.Ha = [], this.B = this.R = this.Ia = 0, this.Ec = [], this.M = this.ja = this.Vb = this.Fc = 0, this.ya = Array(new Ut2), this.L = this.aa = 0, this.gd = s3([4, 2], Dt2), this.ga = null, this.Fa = [], this.Cc = this.qc = this.P = 0, this.Gb = [], this.Uc = 0, this.mb = [], this.nb = 0, this.rc = [], this.Ga = this.Vc = 0;
    }
    function Gt2() {
      this.T = this.U = this.ka = this.height = this.width = 0, this.y = [], this.f = [], this.ea = [], this.Rc = this.fa = this.W = this.N = this.O = 0, this.ma = "void", this.put = "VP8IoPutHook", this.ac = "VP8IoSetupHook", this.bc = "VP8IoTeardownHook", this.ha = this.Kb = 0, this.data = [], this.hb = this.ib = this.da = this.o = this.j = this.va = this.v = this.Da = this.ob = this.w = 0, this.F = [], this.J = 0;
    }
    function Yt2() {
      var t5 = new Wt2;
      return t5 != null && (t5.a = 0, t5.sc = "OK", t5.cb = 0, t5.Xb = 0, ni || (ni = Zt2)), t5;
    }
    function Jt2(t5, e3, r3) {
      return t5.a == 0 && (t5.a = e3, t5.sc = r3, t5.cb = 0), 0;
    }
    function Xt2(t5, e3, r3) {
      return 3 <= r3 && t5[e3 + 0] == 157 && t5[e3 + 1] == 1 && t5[e3 + 2] == 42;
    }
    function Kt2(t5, r3) {
      if (t5 == null)
        return 0;
      if (t5.a = 0, t5.sc = "OK", r3 == null)
        return Jt2(t5, 2, "null VP8Io passed to VP8GetHeaders()");
      var { data: n4, w: a4, ha: o4 } = r3;
      if (4 > o4)
        return Jt2(t5, 7, "Truncated header.");
      var s4 = n4[a4 + 0] | n4[a4 + 1] << 8 | n4[a4 + 2] << 16, c6 = t5.Od;
      if (c6.Rb = !(1 & s4), c6.td = s4 >> 1 & 7, c6.yd = s4 >> 4 & 1, c6.ub = s4 >> 5, 3 < c6.td)
        return Jt2(t5, 3, "Incorrect keyframe parameters.");
      if (!c6.yd)
        return Jt2(t5, 4, "Frame not displayable.");
      a4 += 3, o4 -= 3;
      var u5 = t5.Kc;
      if (c6.Rb) {
        if (7 > o4)
          return Jt2(t5, 7, "cannot parse picture header");
        if (!Xt2(n4, a4, o4))
          return Jt2(t5, 3, "Bad code word");
        u5.c = 16383 & (n4[a4 + 4] << 8 | n4[a4 + 3]), u5.Td = n4[a4 + 4] >> 6, u5.i = 16383 & (n4[a4 + 6] << 8 | n4[a4 + 5]), u5.Ud = n4[a4 + 6] >> 6, a4 += 7, o4 -= 7, t5.za = u5.c + 15 >> 4, t5.Ub = u5.i + 15 >> 4, r3.width = u5.c, r3.height = u5.i, r3.Da = 0, r3.j = 0, r3.v = 0, r3.va = r3.width, r3.o = r3.height, r3.da = 0, r3.ib = r3.width, r3.hb = r3.height, r3.U = r3.width, r3.T = r3.height, i5((s4 = t5.Pa).jb, 0, 255, s4.jb.length), e2((s4 = t5.Qa) != null), s4.Cb = 0, s4.Bb = 0, s4.Fb = 1, i5(s4.Zb, 0, 0, s4.Zb.length), i5(s4.Lb, 0, 0, s4.Lb);
      }
      if (c6.ub > o4)
        return Jt2(t5, 7, "bad partition length");
      p4(s4 = t5.m, n4, a4, c6.ub), a4 += c6.ub, o4 -= c6.ub, c6.Rb && (u5.Ld = P2(s4), u5.Kd = P2(s4)), u5 = t5.Qa;
      var h5, l5 = t5.Pa;
      if (e2(s4 != null), e2(u5 != null), u5.Cb = P2(s4), u5.Cb) {
        if (u5.Bb = P2(s4), P2(s4)) {
          for (u5.Fb = P2(s4), h5 = 0;4 > h5; ++h5)
            u5.Zb[h5] = P2(s4) ? m5(s4, 7) : 0;
          for (h5 = 0;4 > h5; ++h5)
            u5.Lb[h5] = P2(s4) ? m5(s4, 6) : 0;
        }
        if (u5.Bb)
          for (h5 = 0;3 > h5; ++h5)
            l5.jb[h5] = P2(s4) ? g3(s4, 8) : 255;
      } else
        u5.Bb = 0;
      if (s4.Ka)
        return Jt2(t5, 3, "cannot parse segment header");
      if ((u5 = t5.ed).zd = P2(s4), u5.Tb = g3(s4, 6), u5.wb = g3(s4, 3), u5.Pc = P2(s4), u5.Pc && P2(s4)) {
        for (l5 = 0;4 > l5; ++l5)
          P2(s4) && (u5.vd[l5] = m5(s4, 6));
        for (l5 = 0;4 > l5; ++l5)
          P2(s4) && (u5.od[l5] = m5(s4, 6));
      }
      if (t5.L = u5.Tb == 0 ? 0 : u5.zd ? 1 : 2, s4.Ka)
        return Jt2(t5, 3, "cannot parse filter header");
      var f5 = o4;
      if (o4 = h5 = a4, a4 = h5 + f5, u5 = f5, t5.Xb = (1 << g3(t5.m, 2)) - 1, f5 < 3 * (l5 = t5.Xb))
        n4 = 7;
      else {
        for (h5 += 3 * l5, u5 -= 3 * l5, f5 = 0;f5 < l5; ++f5) {
          var d4 = n4[o4 + 0] | n4[o4 + 1] << 8 | n4[o4 + 2] << 16;
          d4 > u5 && (d4 = u5), p4(t5.Jc[+f5], n4, h5, d4), h5 += d4, u5 -= d4, o4 += 3;
        }
        p4(t5.Jc[+l5], n4, h5, u5), n4 = h5 < a4 ? 0 : 5;
      }
      if (n4 != 0)
        return Jt2(t5, n4, "cannot parse partitions");
      for (n4 = g3(h5 = t5.m, 7), o4 = P2(h5) ? m5(h5, 4) : 0, a4 = P2(h5) ? m5(h5, 4) : 0, u5 = P2(h5) ? m5(h5, 4) : 0, l5 = P2(h5) ? m5(h5, 4) : 0, h5 = P2(h5) ? m5(h5, 4) : 0, f5 = t5.Qa, d4 = 0;4 > d4; ++d4) {
        if (f5.Cb) {
          var v5 = f5.Zb[d4];
          f5.Fb || (v5 += n4);
        } else {
          if (0 < d4) {
            t5.pb[d4] = t5.pb[0];
            continue;
          }
          v5 = n4;
        }
        var b4 = t5.pb[d4];
        b4.Sc[0] = ei[Vt2(v5 + o4, 127)], b4.Sc[1] = ri[Vt2(v5 + 0, 127)], b4.Eb[0] = 2 * ei[Vt2(v5 + a4, 127)], b4.Eb[1] = 101581 * ri[Vt2(v5 + u5, 127)] >> 16, 8 > b4.Eb[1] && (b4.Eb[1] = 8), b4.Qc[0] = ei[Vt2(v5 + l5, 117)], b4.Qc[1] = ri[Vt2(v5 + h5, 127)], b4.lc = v5 + h5;
      }
      if (!c6.Rb)
        return Jt2(t5, 4, "Not a key frame.");
      for (P2(s4), c6 = t5.Pa, n4 = 0;4 > n4; ++n4) {
        for (o4 = 0;8 > o4; ++o4)
          for (a4 = 0;3 > a4; ++a4)
            for (u5 = 0;11 > u5; ++u5)
              l5 = k2(s4, ui[n4][o4][a4][u5]) ? g3(s4, 8) : si[n4][o4][a4][u5], c6.Wc[n4][o4].Yb[a4][u5] = l5;
        for (o4 = 0;17 > o4; ++o4)
          c6.Xc[n4][o4] = c6.Wc[n4][hi[o4]];
      }
      return t5.kc = P2(s4), t5.kc && (t5.Bd = g3(s4, 8)), t5.cb = 1;
    }
    function Zt2(t5, e3, r3, n4, i6, a4, o4) {
      var s4 = e3[i6].Yb[r3];
      for (r3 = 0;16 > i6; ++i6) {
        if (!k2(t5, s4[r3 + 0]))
          return i6;
        for (;!k2(t5, s4[r3 + 1]); )
          if (s4 = e3[++i6].Yb[0], r3 = 0, i6 == 16)
            return 16;
        var c6 = e3[i6 + 1].Yb;
        if (k2(t5, s4[r3 + 2])) {
          var u5 = t5, h5 = 0;
          if (k2(u5, (f5 = s4)[(l5 = r3) + 3]))
            if (k2(u5, f5[l5 + 6])) {
              for (s4 = 0, l5 = 2 * (h5 = k2(u5, f5[l5 + 8])) + (f5 = k2(u5, f5[l5 + 9 + h5])), h5 = 0, f5 = ii[l5];f5[s4]; ++s4)
                h5 += h5 + k2(u5, f5[s4]);
              h5 += 3 + (8 << l5);
            } else
              k2(u5, f5[l5 + 7]) ? (h5 = 7 + 2 * k2(u5, 165), h5 += k2(u5, 145)) : h5 = 5 + k2(u5, 159);
          else
            h5 = k2(u5, f5[l5 + 4]) ? 3 + k2(u5, f5[l5 + 5]) : 2;
          s4 = c6[2];
        } else
          h5 = 1, s4 = c6[1];
        c6 = o4 + ai[i6], 0 > (u5 = t5).b && _3(u5);
        var l5, f5 = u5.b, d4 = (l5 = u5.Ca >> 1) - (u5.I >> f5) >> 31;
        --u5.b, u5.Ca += d4, u5.Ca |= 1, u5.I -= (l5 + 1 & d4) << f5, a4[c6] = ((h5 ^ d4) - d4) * n4[(0 < i6) + 0];
      }
      return 16;
    }
    function $t2(t5) {
      var e3 = t5.rb[t5.sb - 1];
      e3.la = 0, e3.Na = 0, i5(t5.zc, 0, 0, t5.zc.length), t5.ja = 0;
    }
    function Qt2(t5, r3) {
      if (t5 == null)
        return 0;
      if (r3 == null)
        return Jt2(t5, 2, "NULL VP8Io parameter in VP8Decode().");
      if (!t5.cb && !Kt2(t5, r3))
        return 0;
      if (e2(t5.cb), r3.ac == null || r3.ac(r3)) {
        r3.ob && (t5.L = 0);
        var s4 = Ri[t5.L];
        if (t5.L == 2 ? (t5.yb = 0, t5.zb = 0) : (t5.yb = r3.v - s4 >> 4, t5.zb = r3.j - s4 >> 4, 0 > t5.yb && (t5.yb = 0), 0 > t5.zb && (t5.zb = 0)), t5.Va = r3.o + 15 + s4 >> 4, t5.Hb = r3.va + 15 + s4 >> 4, t5.Hb > t5.za && (t5.Hb = t5.za), t5.Va > t5.Ub && (t5.Va = t5.Ub), 0 < t5.L) {
          var c6 = t5.ed;
          for (s4 = 0;4 > s4; ++s4) {
            var u5;
            if (t5.Qa.Cb) {
              var h5 = t5.Qa.Lb[s4];
              t5.Qa.Fb || (h5 += c6.Tb);
            } else
              h5 = c6.Tb;
            for (u5 = 0;1 >= u5; ++u5) {
              var l5 = t5.gd[s4][u5], f5 = h5;
              if (c6.Pc && (f5 += c6.vd[0], u5 && (f5 += c6.od[0])), 0 < (f5 = 0 > f5 ? 0 : 63 < f5 ? 63 : f5)) {
                var d4 = f5;
                0 < c6.wb && ((d4 = 4 < c6.wb ? d4 >> 2 : d4 >> 1) > 9 - c6.wb && (d4 = 9 - c6.wb)), 1 > d4 && (d4 = 1), l5.dd = d4, l5.tc = 2 * f5 + d4, l5.ld = 40 <= f5 ? 2 : 15 <= f5 ? 1 : 0;
              } else
                l5.tc = 0;
              l5.La = u5;
            }
          }
        }
        s4 = 0;
      } else
        Jt2(t5, 6, "Frame setup failed"), s4 = t5.a;
      if (s4 = s4 == 0) {
        if (s4) {
          t5.$c = 0, 0 < t5.Aa || (t5.Ic = Ui);
          t: {
            s4 = t5.Ic;
            c6 = 4 * (d4 = t5.za);
            var p5 = 32 * d4, g4 = d4 + 1, m6 = 0 < t5.L ? d4 * (0 < t5.Aa ? 2 : 1) : 0, v5 = (t5.Aa == 2 ? 2 : 1) * d4;
            if ((l5 = c6 + 832 + (u5 = 3 * (16 * s4 + Ri[t5.L]) / 2 * p5) + (h5 = t5.Fa != null && 0 < t5.Fa.length ? t5.Kc.c * t5.Kc.i : 0)) != l5)
              s4 = 0;
            else {
              if (l5 > t5.Vb) {
                if (t5.Vb = 0, t5.Ec = a3(l5), t5.Fc = 0, t5.Ec == null) {
                  s4 = Jt2(t5, 1, "no memory during frame initialization.");
                  break t;
                }
                t5.Vb = l5;
              }
              l5 = t5.Ec, f5 = t5.Fc, t5.Ac = l5, t5.Bc = f5, f5 += c6, t5.Gd = o3(p5, Ht2), t5.Hd = 0, t5.rb = o3(g4 + 1, Rt2), t5.sb = 1, t5.wa = m6 ? o3(m6, Dt2) : null, t5.Y = 0, t5.D.Nb = 0, t5.D.wa = t5.wa, t5.D.Y = t5.Y, 0 < t5.Aa && (t5.D.Y += d4), e2(true), t5.oc = l5, t5.pc = f5, f5 += 832, t5.ya = o3(v5, Ut2), t5.aa = 0, t5.D.ya = t5.ya, t5.D.aa = t5.aa, t5.Aa == 2 && (t5.D.aa += d4), t5.R = 16 * d4, t5.B = 8 * d4, d4 = (p5 = Ri[t5.L]) * t5.R, p5 = p5 / 2 * t5.B, t5.sa = l5, t5.ta = f5 + d4, t5.qa = t5.sa, t5.ra = t5.ta + 16 * s4 * t5.R + p5, t5.Ha = t5.qa, t5.Ia = t5.ra + 8 * s4 * t5.B + p5, t5.$c = 0, f5 += u5, t5.mb = h5 ? l5 : null, t5.nb = h5 ? f5 : null, e2(f5 + h5 <= t5.Fc + t5.Vb), $t2(t5), i5(t5.Ac, t5.Bc, 0, c6), s4 = 1;
            }
          }
          if (s4) {
            if (r3.ka = 0, r3.y = t5.sa, r3.O = t5.ta, r3.f = t5.qa, r3.N = t5.ra, r3.ea = t5.Ha, r3.Vd = t5.Ia, r3.fa = t5.R, r3.Rc = t5.B, r3.F = null, r3.J = 0, !Cn) {
              for (s4 = -255;255 >= s4; ++s4)
                Pn[255 + s4] = 0 > s4 ? -s4 : s4;
              for (s4 = -1020;1020 >= s4; ++s4)
                kn[1020 + s4] = -128 > s4 ? -128 : 127 < s4 ? 127 : s4;
              for (s4 = -112;112 >= s4; ++s4)
                In[112 + s4] = -16 > s4 ? -16 : 15 < s4 ? 15 : s4;
              for (s4 = -255;510 >= s4; ++s4)
                Fn[255 + s4] = 0 > s4 ? 0 : 255 < s4 ? 255 : s4;
              Cn = 1;
            }
            an = ue, on = ae, cn = oe, un = se, hn = ce, sn = ie3, ln2 = Je, fn = Xe, dn = $e, pn = Qe, gn = Ke, mn = Ze, vn = tr, bn = er, yn = ze, wn = He, Nn = We, Ln = Ve, fi[0] = xe, fi[1] = le, fi[2] = Le, fi[3] = Ae, fi[4] = Se, fi[5] = Pe, fi[6] = _e, fi[7] = ke, fi[8] = Fe, fi[9] = Ie, li[0] = ve, li[1] = de, li[2] = pe, li[3] = ge, li[4] = be, li[5] = ye, li[6] = we, di[0] = Be, di[1] = fe, di[2] = Ce, di[3] = je, di[4] = Ee, di[5] = Me, di[6] = qe, s4 = 1;
          } else
            s4 = 0;
        }
        s4 && (s4 = function(t6, r4) {
          for (t6.M = 0;t6.M < t6.Va; ++t6.M) {
            var o4, s5 = t6.Jc[t6.M & t6.Xb], c7 = t6.m, u6 = t6;
            for (o4 = 0;o4 < u6.za; ++o4) {
              var h6 = c7, l6 = u6, f6 = l6.Ac, d5 = l6.Bc + 4 * o4, p6 = l6.zc, g5 = l6.ya[l6.aa + o4];
              if (l6.Qa.Bb ? g5.$b = k2(h6, l6.Pa.jb[0]) ? 2 + k2(h6, l6.Pa.jb[2]) : k2(h6, l6.Pa.jb[1]) : g5.$b = 0, l6.kc && (g5.Ad = k2(h6, l6.Bd)), g5.Za = !k2(h6, 145) + 0, g5.Za) {
                var m7 = g5.Ob, v6 = 0;
                for (l6 = 0;4 > l6; ++l6) {
                  var b4, y5 = p6[0 + l6];
                  for (b4 = 0;4 > b4; ++b4) {
                    y5 = ci[f6[d5 + b4]][y5];
                    for (var w4 = oi[k2(h6, y5[0])];0 < w4; )
                      w4 = oi[2 * w4 + k2(h6, y5[w4])];
                    y5 = -w4, f6[d5 + b4] = y5;
                  }
                  n3(m7, v6, f6, d5, 4), v6 += 4, p6[0 + l6] = y5;
                }
              } else
                y5 = k2(h6, 156) ? k2(h6, 128) ? 1 : 3 : k2(h6, 163) ? 2 : 0, g5.Ob[0] = y5, i5(f6, d5, y5, 4), i5(p6, 0, y5, 4);
              g5.Dd = k2(h6, 142) ? k2(h6, 114) ? k2(h6, 183) ? 1 : 3 : 2 : 0;
            }
            if (u6.m.Ka)
              return Jt2(t6, 7, "Premature end-of-partition0 encountered.");
            for (;t6.ja < t6.za; ++t6.ja) {
              if (u6 = s5, h6 = (c7 = t6).rb[c7.sb - 1], f6 = c7.rb[c7.sb + c7.ja], o4 = c7.ya[c7.aa + c7.ja], d5 = c7.kc ? o4.Ad : 0)
                h6.la = f6.la = 0, o4.Za || (h6.Na = f6.Na = 0), o4.Hc = 0, o4.Gc = 0, o4.ia = 0;
              else {
                var N5, L4;
                h6 = f6, f6 = u6, d5 = c7.Pa.Xc, p6 = c7.ya[c7.aa + c7.ja], g5 = c7.pb[p6.$b];
                if (l6 = p6.ad, m7 = 0, v6 = c7.rb[c7.sb - 1], y5 = b4 = 0, i5(l6, m7, 0, 384), p6.Za)
                  var A4 = 0, x4 = d5[3];
                else {
                  w4 = a3(16);
                  var S3 = h6.Na + v6.Na;
                  if (S3 = ni(f6, d5[1], S3, g5.Eb, 0, w4, 0), h6.Na = v6.Na = (0 < S3) + 0, 1 < S3)
                    an(w4, 0, l6, m7);
                  else {
                    var _4 = w4[0] + 3 >> 3;
                    for (w4 = 0;256 > w4; w4 += 16)
                      l6[m7 + w4] = _4;
                  }
                  A4 = 1, x4 = d5[0];
                }
                var P3 = 15 & h6.la, I3 = 15 & v6.la;
                for (w4 = 0;4 > w4; ++w4) {
                  var F3 = 1 & I3;
                  for (_4 = L4 = 0;4 > _4; ++_4)
                    P3 = P3 >> 1 | (F3 = (S3 = ni(f6, x4, S3 = F3 + (1 & P3), g5.Sc, A4, l6, m7)) > A4) << 7, L4 = L4 << 2 | (3 < S3 ? 3 : 1 < S3 ? 2 : l6[m7 + 0] != 0), m7 += 16;
                  P3 >>= 4, I3 = I3 >> 1 | F3 << 7, b4 = (b4 << 8 | L4) >>> 0;
                }
                for (x4 = P3, A4 = I3 >> 4, N5 = 0;4 > N5; N5 += 2) {
                  for (L4 = 0, P3 = h6.la >> 4 + N5, I3 = v6.la >> 4 + N5, w4 = 0;2 > w4; ++w4) {
                    for (F3 = 1 & I3, _4 = 0;2 > _4; ++_4)
                      S3 = F3 + (1 & P3), P3 = P3 >> 1 | (F3 = 0 < (S3 = ni(f6, d5[2], S3, g5.Qc, 0, l6, m7))) << 3, L4 = L4 << 2 | (3 < S3 ? 3 : 1 < S3 ? 2 : l6[m7 + 0] != 0), m7 += 16;
                    P3 >>= 2, I3 = I3 >> 1 | F3 << 5;
                  }
                  y5 |= L4 << 4 * N5, x4 |= P3 << 4 << N5, A4 |= (240 & I3) << N5;
                }
                h6.la = x4, v6.la = A4, p6.Hc = b4, p6.Gc = y5, p6.ia = 43690 & y5 ? 0 : g5.ia, d5 = !(b4 | y5);
              }
              if (0 < c7.L && (c7.wa[c7.Y + c7.ja] = c7.gd[o4.$b][o4.Za], c7.wa[c7.Y + c7.ja].La |= !d5), u6.Ka)
                return Jt2(t6, 7, "Premature end-of-file encountered.");
            }
            if ($t2(t6), c7 = r4, u6 = 1, o4 = (s5 = t6).D, h6 = 0 < s5.L && s5.M >= s5.zb && s5.M <= s5.Va, s5.Aa == 0)
              t: {
                if (o4.M = s5.M, o4.uc = h6, Or(s5, o4), u6 = 1, o4 = (L4 = s5.D).Nb, h6 = (y5 = Ri[s5.L]) * s5.R, f6 = y5 / 2 * s5.B, w4 = 16 * o4 * s5.R, _4 = 8 * o4 * s5.B, d5 = s5.sa, p6 = s5.ta - h6 + w4, g5 = s5.qa, l6 = s5.ra - f6 + _4, m7 = s5.Ha, v6 = s5.Ia - f6 + _4, I3 = (P3 = L4.M) == 0, b4 = P3 >= s5.Va - 1, s5.Aa == 2 && Or(s5, L4), L4.uc)
                  for (F3 = (S3 = s5).D.M, e2(S3.D.uc), L4 = S3.yb;L4 < S3.Hb; ++L4) {
                    A4 = L4, x4 = F3;
                    var C3 = (j3 = (U3 = S3).D).Nb;
                    N5 = U3.R;
                    var j3 = j3.wa[j3.Y + A4], O4 = U3.sa, B3 = U3.ta + 16 * C3 * N5 + 16 * A4, M3 = j3.dd, E3 = j3.tc;
                    if (E3 != 0)
                      if (e2(3 <= E3), U3.L == 1)
                        0 < A4 && wn(O4, B3, N5, E3 + 4), j3.La && Ln(O4, B3, N5, E3), 0 < x4 && yn(O4, B3, N5, E3 + 4), j3.La && Nn(O4, B3, N5, E3);
                      else {
                        var { B: q3, qa: D3 } = U3, R3 = U3.ra + 8 * C3 * q3 + 8 * A4, T4 = U3.Ha, U3 = U3.Ia + 8 * C3 * q3 + 8 * A4;
                        C3 = j3.ld;
                        0 < A4 && (fn(O4, B3, N5, E3 + 4, M3, C3), pn(D3, R3, T4, U3, q3, E3 + 4, M3, C3)), j3.La && (mn(O4, B3, N5, E3, M3, C3), bn(D3, R3, T4, U3, q3, E3, M3, C3)), 0 < x4 && (ln2(O4, B3, N5, E3 + 4, M3, C3), dn(D3, R3, T4, U3, q3, E3 + 4, M3, C3)), j3.La && (gn(O4, B3, N5, E3, M3, C3), vn(D3, R3, T4, U3, q3, E3, M3, C3));
                      }
                  }
                if (s5.ia && alert("todo:DitherRow"), c7.put != null) {
                  if (L4 = 16 * P3, P3 = 16 * (P3 + 1), I3 ? (c7.y = s5.sa, c7.O = s5.ta + w4, c7.f = s5.qa, c7.N = s5.ra + _4, c7.ea = s5.Ha, c7.W = s5.Ia + _4) : (L4 -= y5, c7.y = d5, c7.O = p6, c7.f = g5, c7.N = l6, c7.ea = m7, c7.W = v6), b4 || (P3 -= y5), P3 > c7.o && (P3 = c7.o), c7.F = null, c7.J = null, s5.Fa != null && 0 < s5.Fa.length && L4 < P3 && (c7.J = lr(s5, c7, L4, P3 - L4), c7.F = s5.mb, c7.F == null && c7.F.length == 0)) {
                    u6 = Jt2(s5, 3, "Could not decode alpha data.");
                    break t;
                  }
                  L4 < c7.j && (y5 = c7.j - L4, L4 = c7.j, e2(!(1 & y5)), c7.O += s5.R * y5, c7.N += s5.B * (y5 >> 1), c7.W += s5.B * (y5 >> 1), c7.F != null && (c7.J += c7.width * y5)), L4 < P3 && (c7.O += c7.v, c7.N += c7.v >> 1, c7.W += c7.v >> 1, c7.F != null && (c7.J += c7.v), c7.ka = L4 - c7.j, c7.U = c7.va - c7.v, c7.T = P3 - L4, u6 = c7.put(c7));
                }
                o4 + 1 != s5.Ic || b4 || (n3(s5.sa, s5.ta - h6, d5, p6 + 16 * s5.R, h6), n3(s5.qa, s5.ra - f6, g5, l6 + 8 * s5.B, f6), n3(s5.Ha, s5.Ia - f6, m7, v6 + 8 * s5.B, f6));
              }
            if (!u6)
              return Jt2(t6, 6, "Output aborted.");
          }
          return 1;
        }(t5, r3)), r3.bc != null && r3.bc(r3), s4 &= 1;
      }
      return s4 ? (t5.cb = 0, s4) : 0;
    }
    function te2(t5, e3, r3, n4, i6) {
      i6 = t5[e3 + r3 + 32 * n4] + (i6 >> 3), t5[e3 + r3 + 32 * n4] = -256 & i6 ? 0 > i6 ? 0 : 255 : i6;
    }
    function ee2(t5, e3, r3, n4, i6, a4) {
      te2(t5, e3, 0, r3, n4 + i6), te2(t5, e3, 1, r3, n4 + a4), te2(t5, e3, 2, r3, n4 - a4), te2(t5, e3, 3, r3, n4 - i6);
    }
    function re(t5) {
      return (20091 * t5 >> 16) + t5;
    }
    function ne(t5, e3, r3, n4) {
      var i6, o4 = 0, s4 = a3(16);
      for (i6 = 0;4 > i6; ++i6) {
        var c6 = t5[e3 + 0] + t5[e3 + 8], u5 = t5[e3 + 0] - t5[e3 + 8], h5 = (35468 * t5[e3 + 4] >> 16) - re(t5[e3 + 12]), l5 = re(t5[e3 + 4]) + (35468 * t5[e3 + 12] >> 16);
        s4[o4 + 0] = c6 + l5, s4[o4 + 1] = u5 + h5, s4[o4 + 2] = u5 - h5, s4[o4 + 3] = c6 - l5, o4 += 4, e3++;
      }
      for (i6 = o4 = 0;4 > i6; ++i6)
        c6 = (t5 = s4[o4 + 0] + 4) + s4[o4 + 8], u5 = t5 - s4[o4 + 8], h5 = (35468 * s4[o4 + 4] >> 16) - re(s4[o4 + 12]), te2(r3, n4, 0, 0, c6 + (l5 = re(s4[o4 + 4]) + (35468 * s4[o4 + 12] >> 16))), te2(r3, n4, 1, 0, u5 + h5), te2(r3, n4, 2, 0, u5 - h5), te2(r3, n4, 3, 0, c6 - l5), o4++, n4 += 32;
    }
    function ie3(t5, e3, r3, n4) {
      var i6 = t5[e3 + 0] + 4, a4 = 35468 * t5[e3 + 4] >> 16, o4 = re(t5[e3 + 4]), s4 = 35468 * t5[e3 + 1] >> 16;
      ee2(r3, n4, 0, i6 + o4, t5 = re(t5[e3 + 1]), s4), ee2(r3, n4, 1, i6 + a4, t5, s4), ee2(r3, n4, 2, i6 - a4, t5, s4), ee2(r3, n4, 3, i6 - o4, t5, s4);
    }
    function ae(t5, e3, r3, n4, i6) {
      ne(t5, e3, r3, n4), i6 && ne(t5, e3 + 16, r3, n4 + 4);
    }
    function oe(t5, e3, r3, n4) {
      on(t5, e3 + 0, r3, n4, 1), on(t5, e3 + 32, r3, n4 + 128, 1);
    }
    function se(t5, e3, r3, n4) {
      var i6;
      for (t5 = t5[e3 + 0] + 4, i6 = 0;4 > i6; ++i6)
        for (e3 = 0;4 > e3; ++e3)
          te2(r3, n4, e3, i6, t5);
    }
    function ce(t5, e3, r3, n4) {
      t5[e3 + 0] && un(t5, e3 + 0, r3, n4), t5[e3 + 16] && un(t5, e3 + 16, r3, n4 + 4), t5[e3 + 32] && un(t5, e3 + 32, r3, n4 + 128), t5[e3 + 48] && un(t5, e3 + 48, r3, n4 + 128 + 4);
    }
    function ue(t5, e3, r3, n4) {
      var i6, o4 = a3(16);
      for (i6 = 0;4 > i6; ++i6) {
        var s4 = t5[e3 + 0 + i6] + t5[e3 + 12 + i6], c6 = t5[e3 + 4 + i6] + t5[e3 + 8 + i6], u5 = t5[e3 + 4 + i6] - t5[e3 + 8 + i6], h5 = t5[e3 + 0 + i6] - t5[e3 + 12 + i6];
        o4[0 + i6] = s4 + c6, o4[8 + i6] = s4 - c6, o4[4 + i6] = h5 + u5, o4[12 + i6] = h5 - u5;
      }
      for (i6 = 0;4 > i6; ++i6)
        s4 = (t5 = o4[0 + 4 * i6] + 3) + o4[3 + 4 * i6], c6 = o4[1 + 4 * i6] + o4[2 + 4 * i6], u5 = o4[1 + 4 * i6] - o4[2 + 4 * i6], h5 = t5 - o4[3 + 4 * i6], r3[n4 + 0] = s4 + c6 >> 3, r3[n4 + 16] = h5 + u5 >> 3, r3[n4 + 32] = s4 - c6 >> 3, r3[n4 + 48] = h5 - u5 >> 3, n4 += 64;
    }
    function he(t5, e3, r3) {
      var n4, i6 = e3 - 32, a4 = Bn, o4 = 255 - t5[i6 - 1];
      for (n4 = 0;n4 < r3; ++n4) {
        var s4, c6 = a4, u5 = o4 + t5[e3 - 1];
        for (s4 = 0;s4 < r3; ++s4)
          t5[e3 + s4] = c6[u5 + t5[i6 + s4]];
        e3 += 32;
      }
    }
    function le(t5, e3) {
      he(t5, e3, 4);
    }
    function fe(t5, e3) {
      he(t5, e3, 8);
    }
    function de(t5, e3) {
      he(t5, e3, 16);
    }
    function pe(t5, e3) {
      var r3;
      for (r3 = 0;16 > r3; ++r3)
        n3(t5, e3 + 32 * r3, t5, e3 - 32, 16);
    }
    function ge(t5, e3) {
      var r3;
      for (r3 = 16;0 < r3; --r3)
        i5(t5, e3, t5[e3 - 1], 16), e3 += 32;
    }
    function me(t5, e3, r3) {
      var n4;
      for (n4 = 0;16 > n4; ++n4)
        i5(e3, r3 + 32 * n4, t5, 16);
    }
    function ve(t5, e3) {
      var r3, n4 = 16;
      for (r3 = 0;16 > r3; ++r3)
        n4 += t5[e3 - 1 + 32 * r3] + t5[e3 + r3 - 32];
      me(n4 >> 5, t5, e3);
    }
    function be(t5, e3) {
      var r3, n4 = 8;
      for (r3 = 0;16 > r3; ++r3)
        n4 += t5[e3 - 1 + 32 * r3];
      me(n4 >> 4, t5, e3);
    }
    function ye(t5, e3) {
      var r3, n4 = 8;
      for (r3 = 0;16 > r3; ++r3)
        n4 += t5[e3 + r3 - 32];
      me(n4 >> 4, t5, e3);
    }
    function we(t5, e3) {
      me(128, t5, e3);
    }
    function Ne(t5, e3, r3) {
      return t5 + 2 * e3 + r3 + 2 >> 2;
    }
    function Le(t5, e3) {
      var r3, i6 = e3 - 32;
      i6 = new Uint8Array([Ne(t5[i6 - 1], t5[i6 + 0], t5[i6 + 1]), Ne(t5[i6 + 0], t5[i6 + 1], t5[i6 + 2]), Ne(t5[i6 + 1], t5[i6 + 2], t5[i6 + 3]), Ne(t5[i6 + 2], t5[i6 + 3], t5[i6 + 4])]);
      for (r3 = 0;4 > r3; ++r3)
        n3(t5, e3 + 32 * r3, i6, 0, i6.length);
    }
    function Ae(t5, e3) {
      var r3 = t5[e3 - 1], n4 = t5[e3 - 1 + 32], i6 = t5[e3 - 1 + 64], a4 = t5[e3 - 1 + 96];
      I2(t5, e3 + 0, 16843009 * Ne(t5[e3 - 1 - 32], r3, n4)), I2(t5, e3 + 32, 16843009 * Ne(r3, n4, i6)), I2(t5, e3 + 64, 16843009 * Ne(n4, i6, a4)), I2(t5, e3 + 96, 16843009 * Ne(i6, a4, a4));
    }
    function xe(t5, e3) {
      var r3, n4 = 4;
      for (r3 = 0;4 > r3; ++r3)
        n4 += t5[e3 + r3 - 32] + t5[e3 - 1 + 32 * r3];
      for (n4 >>= 3, r3 = 0;4 > r3; ++r3)
        i5(t5, e3 + 32 * r3, n4, 4);
    }
    function Se(t5, e3) {
      var r3 = t5[e3 - 1 + 0], n4 = t5[e3 - 1 + 32], i6 = t5[e3 - 1 + 64], a4 = t5[e3 - 1 - 32], o4 = t5[e3 + 0 - 32], s4 = t5[e3 + 1 - 32], c6 = t5[e3 + 2 - 32], u5 = t5[e3 + 3 - 32];
      t5[e3 + 0 + 96] = Ne(n4, i6, t5[e3 - 1 + 96]), t5[e3 + 1 + 96] = t5[e3 + 0 + 64] = Ne(r3, n4, i6), t5[e3 + 2 + 96] = t5[e3 + 1 + 64] = t5[e3 + 0 + 32] = Ne(a4, r3, n4), t5[e3 + 3 + 96] = t5[e3 + 2 + 64] = t5[e3 + 1 + 32] = t5[e3 + 0 + 0] = Ne(o4, a4, r3), t5[e3 + 3 + 64] = t5[e3 + 2 + 32] = t5[e3 + 1 + 0] = Ne(s4, o4, a4), t5[e3 + 3 + 32] = t5[e3 + 2 + 0] = Ne(c6, s4, o4), t5[e3 + 3 + 0] = Ne(u5, c6, s4);
    }
    function _e(t5, e3) {
      var r3 = t5[e3 + 1 - 32], n4 = t5[e3 + 2 - 32], i6 = t5[e3 + 3 - 32], a4 = t5[e3 + 4 - 32], o4 = t5[e3 + 5 - 32], s4 = t5[e3 + 6 - 32], c6 = t5[e3 + 7 - 32];
      t5[e3 + 0 + 0] = Ne(t5[e3 + 0 - 32], r3, n4), t5[e3 + 1 + 0] = t5[e3 + 0 + 32] = Ne(r3, n4, i6), t5[e3 + 2 + 0] = t5[e3 + 1 + 32] = t5[e3 + 0 + 64] = Ne(n4, i6, a4), t5[e3 + 3 + 0] = t5[e3 + 2 + 32] = t5[e3 + 1 + 64] = t5[e3 + 0 + 96] = Ne(i6, a4, o4), t5[e3 + 3 + 32] = t5[e3 + 2 + 64] = t5[e3 + 1 + 96] = Ne(a4, o4, s4), t5[e3 + 3 + 64] = t5[e3 + 2 + 96] = Ne(o4, s4, c6), t5[e3 + 3 + 96] = Ne(s4, c6, c6);
    }
    function Pe(t5, e3) {
      var r3 = t5[e3 - 1 + 0], n4 = t5[e3 - 1 + 32], i6 = t5[e3 - 1 + 64], a4 = t5[e3 - 1 - 32], o4 = t5[e3 + 0 - 32], s4 = t5[e3 + 1 - 32], c6 = t5[e3 + 2 - 32], u5 = t5[e3 + 3 - 32];
      t5[e3 + 0 + 0] = t5[e3 + 1 + 64] = a4 + o4 + 1 >> 1, t5[e3 + 1 + 0] = t5[e3 + 2 + 64] = o4 + s4 + 1 >> 1, t5[e3 + 2 + 0] = t5[e3 + 3 + 64] = s4 + c6 + 1 >> 1, t5[e3 + 3 + 0] = c6 + u5 + 1 >> 1, t5[e3 + 0 + 96] = Ne(i6, n4, r3), t5[e3 + 0 + 64] = Ne(n4, r3, a4), t5[e3 + 0 + 32] = t5[e3 + 1 + 96] = Ne(r3, a4, o4), t5[e3 + 1 + 32] = t5[e3 + 2 + 96] = Ne(a4, o4, s4), t5[e3 + 2 + 32] = t5[e3 + 3 + 96] = Ne(o4, s4, c6), t5[e3 + 3 + 32] = Ne(s4, c6, u5);
    }
    function ke(t5, e3) {
      var r3 = t5[e3 + 0 - 32], n4 = t5[e3 + 1 - 32], i6 = t5[e3 + 2 - 32], a4 = t5[e3 + 3 - 32], o4 = t5[e3 + 4 - 32], s4 = t5[e3 + 5 - 32], c6 = t5[e3 + 6 - 32], u5 = t5[e3 + 7 - 32];
      t5[e3 + 0 + 0] = r3 + n4 + 1 >> 1, t5[e3 + 1 + 0] = t5[e3 + 0 + 64] = n4 + i6 + 1 >> 1, t5[e3 + 2 + 0] = t5[e3 + 1 + 64] = i6 + a4 + 1 >> 1, t5[e3 + 3 + 0] = t5[e3 + 2 + 64] = a4 + o4 + 1 >> 1, t5[e3 + 0 + 32] = Ne(r3, n4, i6), t5[e3 + 1 + 32] = t5[e3 + 0 + 96] = Ne(n4, i6, a4), t5[e3 + 2 + 32] = t5[e3 + 1 + 96] = Ne(i6, a4, o4), t5[e3 + 3 + 32] = t5[e3 + 2 + 96] = Ne(a4, o4, s4), t5[e3 + 3 + 64] = Ne(o4, s4, c6), t5[e3 + 3 + 96] = Ne(s4, c6, u5);
    }
    function Ie(t5, e3) {
      var r3 = t5[e3 - 1 + 0], n4 = t5[e3 - 1 + 32], i6 = t5[e3 - 1 + 64], a4 = t5[e3 - 1 + 96];
      t5[e3 + 0 + 0] = r3 + n4 + 1 >> 1, t5[e3 + 2 + 0] = t5[e3 + 0 + 32] = n4 + i6 + 1 >> 1, t5[e3 + 2 + 32] = t5[e3 + 0 + 64] = i6 + a4 + 1 >> 1, t5[e3 + 1 + 0] = Ne(r3, n4, i6), t5[e3 + 3 + 0] = t5[e3 + 1 + 32] = Ne(n4, i6, a4), t5[e3 + 3 + 32] = t5[e3 + 1 + 64] = Ne(i6, a4, a4), t5[e3 + 3 + 64] = t5[e3 + 2 + 64] = t5[e3 + 0 + 96] = t5[e3 + 1 + 96] = t5[e3 + 2 + 96] = t5[e3 + 3 + 96] = a4;
    }
    function Fe(t5, e3) {
      var r3 = t5[e3 - 1 + 0], n4 = t5[e3 - 1 + 32], i6 = t5[e3 - 1 + 64], a4 = t5[e3 - 1 + 96], o4 = t5[e3 - 1 - 32], s4 = t5[e3 + 0 - 32], c6 = t5[e3 + 1 - 32], u5 = t5[e3 + 2 - 32];
      t5[e3 + 0 + 0] = t5[e3 + 2 + 32] = r3 + o4 + 1 >> 1, t5[e3 + 0 + 32] = t5[e3 + 2 + 64] = n4 + r3 + 1 >> 1, t5[e3 + 0 + 64] = t5[e3 + 2 + 96] = i6 + n4 + 1 >> 1, t5[e3 + 0 + 96] = a4 + i6 + 1 >> 1, t5[e3 + 3 + 0] = Ne(s4, c6, u5), t5[e3 + 2 + 0] = Ne(o4, s4, c6), t5[e3 + 1 + 0] = t5[e3 + 3 + 32] = Ne(r3, o4, s4), t5[e3 + 1 + 32] = t5[e3 + 3 + 64] = Ne(n4, r3, o4), t5[e3 + 1 + 64] = t5[e3 + 3 + 96] = Ne(i6, n4, r3), t5[e3 + 1 + 96] = Ne(a4, i6, n4);
    }
    function Ce(t5, e3) {
      var r3;
      for (r3 = 0;8 > r3; ++r3)
        n3(t5, e3 + 32 * r3, t5, e3 - 32, 8);
    }
    function je(t5, e3) {
      var r3;
      for (r3 = 0;8 > r3; ++r3)
        i5(t5, e3, t5[e3 - 1], 8), e3 += 32;
    }
    function Oe(t5, e3, r3) {
      var n4;
      for (n4 = 0;8 > n4; ++n4)
        i5(e3, r3 + 32 * n4, t5, 8);
    }
    function Be(t5, e3) {
      var r3, n4 = 8;
      for (r3 = 0;8 > r3; ++r3)
        n4 += t5[e3 + r3 - 32] + t5[e3 - 1 + 32 * r3];
      Oe(n4 >> 4, t5, e3);
    }
    function Me(t5, e3) {
      var r3, n4 = 4;
      for (r3 = 0;8 > r3; ++r3)
        n4 += t5[e3 + r3 - 32];
      Oe(n4 >> 3, t5, e3);
    }
    function Ee(t5, e3) {
      var r3, n4 = 4;
      for (r3 = 0;8 > r3; ++r3)
        n4 += t5[e3 - 1 + 32 * r3];
      Oe(n4 >> 3, t5, e3);
    }
    function qe(t5, e3) {
      Oe(128, t5, e3);
    }
    function De(t5, e3, r3) {
      var n4 = t5[e3 - r3], i6 = t5[e3 + 0], a4 = 3 * (i6 - n4) + jn[1020 + t5[e3 - 2 * r3] - t5[e3 + r3]], o4 = On[112 + (a4 + 4 >> 3)];
      t5[e3 - r3] = Bn[255 + n4 + On[112 + (a4 + 3 >> 3)]], t5[e3 + 0] = Bn[255 + i6 - o4];
    }
    function Re(t5, e3, r3, n4) {
      var i6 = t5[e3 + 0], a4 = t5[e3 + r3];
      return Mn[255 + t5[e3 - 2 * r3] - t5[e3 - r3]] > n4 || Mn[255 + a4 - i6] > n4;
    }
    function Te(t5, e3, r3, n4) {
      return 4 * Mn[255 + t5[e3 - r3] - t5[e3 + 0]] + Mn[255 + t5[e3 - 2 * r3] - t5[e3 + r3]] <= n4;
    }
    function Ue(t5, e3, r3, n4, i6) {
      var a4 = t5[e3 - 3 * r3], o4 = t5[e3 - 2 * r3], s4 = t5[e3 - r3], c6 = t5[e3 + 0], u5 = t5[e3 + r3], h5 = t5[e3 + 2 * r3], l5 = t5[e3 + 3 * r3];
      return 4 * Mn[255 + s4 - c6] + Mn[255 + o4 - u5] > n4 ? 0 : Mn[255 + t5[e3 - 4 * r3] - a4] <= i6 && Mn[255 + a4 - o4] <= i6 && Mn[255 + o4 - s4] <= i6 && Mn[255 + l5 - h5] <= i6 && Mn[255 + h5 - u5] <= i6 && Mn[255 + u5 - c6] <= i6;
    }
    function ze(t5, e3, r3, n4) {
      var i6 = 2 * n4 + 1;
      for (n4 = 0;16 > n4; ++n4)
        Te(t5, e3 + n4, r3, i6) && De(t5, e3 + n4, r3);
    }
    function He(t5, e3, r3, n4) {
      var i6 = 2 * n4 + 1;
      for (n4 = 0;16 > n4; ++n4)
        Te(t5, e3 + n4 * r3, 1, i6) && De(t5, e3 + n4 * r3, 1);
    }
    function We(t5, e3, r3, n4) {
      var i6;
      for (i6 = 3;0 < i6; --i6)
        ze(t5, e3 += 4 * r3, r3, n4);
    }
    function Ve(t5, e3, r3, n4) {
      var i6;
      for (i6 = 3;0 < i6; --i6)
        He(t5, e3 += 4, r3, n4);
    }
    function Ge(t5, e3, r3, n4, i6, a4, o4, s4) {
      for (a4 = 2 * a4 + 1;0 < i6--; ) {
        if (Ue(t5, e3, r3, a4, o4))
          if (Re(t5, e3, r3, s4))
            De(t5, e3, r3);
          else {
            var c6 = t5, u5 = e3, h5 = r3, l5 = c6[u5 - 2 * h5], f5 = c6[u5 - h5], d4 = c6[u5 + 0], p5 = c6[u5 + h5], g4 = c6[u5 + 2 * h5], m6 = 27 * (b4 = jn[1020 + 3 * (d4 - f5) + jn[1020 + l5 - p5]]) + 63 >> 7, v5 = 18 * b4 + 63 >> 7, b4 = 9 * b4 + 63 >> 7;
            c6[u5 - 3 * h5] = Bn[255 + c6[u5 - 3 * h5] + b4], c6[u5 - 2 * h5] = Bn[255 + l5 + v5], c6[u5 - h5] = Bn[255 + f5 + m6], c6[u5 + 0] = Bn[255 + d4 - m6], c6[u5 + h5] = Bn[255 + p5 - v5], c6[u5 + 2 * h5] = Bn[255 + g4 - b4];
          }
        e3 += n4;
      }
    }
    function Ye(t5, e3, r3, n4, i6, a4, o4, s4) {
      for (a4 = 2 * a4 + 1;0 < i6--; ) {
        if (Ue(t5, e3, r3, a4, o4))
          if (Re(t5, e3, r3, s4))
            De(t5, e3, r3);
          else {
            var c6 = t5, u5 = e3, h5 = r3, l5 = c6[u5 - h5], f5 = c6[u5 + 0], d4 = c6[u5 + h5], p5 = On[112 + ((g4 = 3 * (f5 - l5)) + 4 >> 3)], g4 = On[112 + (g4 + 3 >> 3)], m6 = p5 + 1 >> 1;
            c6[u5 - 2 * h5] = Bn[255 + c6[u5 - 2 * h5] + m6], c6[u5 - h5] = Bn[255 + l5 + g4], c6[u5 + 0] = Bn[255 + f5 - p5], c6[u5 + h5] = Bn[255 + d4 - m6];
          }
        e3 += n4;
      }
    }
    function Je(t5, e3, r3, n4, i6, a4) {
      Ge(t5, e3, r3, 1, 16, n4, i6, a4);
    }
    function Xe(t5, e3, r3, n4, i6, a4) {
      Ge(t5, e3, 1, r3, 16, n4, i6, a4);
    }
    function Ke(t5, e3, r3, n4, i6, a4) {
      var o4;
      for (o4 = 3;0 < o4; --o4)
        Ye(t5, e3 += 4 * r3, r3, 1, 16, n4, i6, a4);
    }
    function Ze(t5, e3, r3, n4, i6, a4) {
      var o4;
      for (o4 = 3;0 < o4; --o4)
        Ye(t5, e3 += 4, 1, r3, 16, n4, i6, a4);
    }
    function $e(t5, e3, r3, n4, i6, a4, o4, s4) {
      Ge(t5, e3, i6, 1, 8, a4, o4, s4), Ge(r3, n4, i6, 1, 8, a4, o4, s4);
    }
    function Qe(t5, e3, r3, n4, i6, a4, o4, s4) {
      Ge(t5, e3, 1, i6, 8, a4, o4, s4), Ge(r3, n4, 1, i6, 8, a4, o4, s4);
    }
    function tr(t5, e3, r3, n4, i6, a4, o4, s4) {
      Ye(t5, e3 + 4 * i6, i6, 1, 8, a4, o4, s4), Ye(r3, n4 + 4 * i6, i6, 1, 8, a4, o4, s4);
    }
    function er(t5, e3, r3, n4, i6, a4, o4, s4) {
      Ye(t5, e3 + 4, 1, i6, 8, a4, o4, s4), Ye(r3, n4 + 4, 1, i6, 8, a4, o4, s4);
    }
    function rr() {
      this.ba = new ot2, this.ec = [], this.cc = [], this.Mc = [], this.Dc = this.Nc = this.dc = this.fc = 0, this.Oa = new ct2, this.memory = 0, this.Ib = "OutputFunc", this.Jb = "OutputAlphaFunc", this.Nd = "OutputRowFunc";
    }
    function nr() {
      this.data = [], this.offset = this.kd = this.ha = this.w = 0, this.na = [], this.xa = this.gb = this.Ja = this.Sa = this.P = 0;
    }
    function ir() {
      this.nc = this.Ea = this.b = this.hc = 0, this.K = [], this.w = 0;
    }
    function ar() {
      this.ua = 0, this.Wa = new M2, this.vb = new M2, this.md = this.xc = this.wc = 0, this.vc = [], this.Wb = 0, this.Ya = new d3, this.yc = new l4;
    }
    function or() {
      this.xb = this.a = 0, this.l = new Gt2, this.ca = new ot2, this.V = [], this.Ba = 0, this.Ta = [], this.Ua = 0, this.m = new N4, this.Pb = 0, this.wd = new N4, this.Ma = this.$ = this.C = this.i = this.c = this.xd = 0, this.s = new ar, this.ab = 0, this.gc = o3(4, ir), this.Oc = 0;
    }
    function sr() {
      this.Lc = this.Z = this.$a = this.i = this.c = 0, this.l = new Gt2, this.ic = 0, this.ca = [], this.tb = 0, this.qd = null, this.rd = 0;
    }
    function cr(t5, e3, r3, n4, i6, a4, o4) {
      for (t5 = t5 == null ? 0 : t5[e3 + 0], e3 = 0;e3 < o4; ++e3)
        i6[a4 + e3] = t5 + r3[n4 + e3] & 255, t5 = i6[a4 + e3];
    }
    function ur(t5, e3, r3, n4, i6, a4, o4) {
      var s4;
      if (t5 == null)
        cr(null, null, r3, n4, i6, a4, o4);
      else
        for (s4 = 0;s4 < o4; ++s4)
          i6[a4 + s4] = t5[e3 + s4] + r3[n4 + s4] & 255;
    }
    function hr(t5, e3, r3, n4, i6, a4, o4) {
      if (t5 == null)
        cr(null, null, r3, n4, i6, a4, o4);
      else {
        var s4, c6 = t5[e3 + 0], u5 = c6, h5 = c6;
        for (s4 = 0;s4 < o4; ++s4)
          u5 = h5 + (c6 = t5[e3 + s4]) - u5, h5 = r3[n4 + s4] + (-256 & u5 ? 0 > u5 ? 0 : 255 : u5) & 255, u5 = c6, i6[a4 + s4] = h5;
      }
    }
    function lr(t5, r3, i6, o4) {
      var { width: s4, o: c6 } = r3;
      if (e2(t5 != null && r3 != null), 0 > i6 || 0 >= o4 || i6 + o4 > c6)
        return null;
      if (!t5.Cc) {
        if (t5.ga == null) {
          var u5;
          if (t5.ga = new sr, (u5 = t5.ga == null) || (u5 = r3.width * r3.o, e2(t5.Gb.length == 0), t5.Gb = a3(u5), t5.Uc = 0, t5.Gb == null ? u5 = 0 : (t5.mb = t5.Gb, t5.nb = t5.Uc, t5.rc = null, u5 = 1), u5 = !u5), !u5) {
            u5 = t5.ga;
            var { Fa: h5, P: l5, qc: f5, mb: d4, nb: p5 } = t5, g4 = l5 + 1, m6 = f5 - 1, b4 = u5.l;
            if (e2(h5 != null && d4 != null && r3 != null), mi[0] = null, mi[1] = cr, mi[2] = ur, mi[3] = hr, u5.ca = d4, u5.tb = p5, u5.c = r3.width, u5.i = r3.height, e2(0 < u5.c && 0 < u5.i), 1 >= f5)
              r3 = 0;
            else if (u5.$a = h5[l5 + 0] >> 0 & 3, u5.Z = h5[l5 + 0] >> 2 & 3, u5.Lc = h5[l5 + 0] >> 4 & 3, l5 = h5[l5 + 0] >> 6 & 3, 0 > u5.$a || 1 < u5.$a || 4 <= u5.Z || 1 < u5.Lc || l5)
              r3 = 0;
            else if (b4.put = dt2, b4.ac = ft2, b4.bc = pt2, b4.ma = u5, b4.width = r3.width, b4.height = r3.height, b4.Da = r3.Da, b4.v = r3.v, b4.va = r3.va, b4.j = r3.j, b4.o = r3.o, u5.$a)
              t: {
                e2(u5.$a == 1), r3 = kt2();
                e:
                  for (;; ) {
                    if (r3 == null) {
                      r3 = 0;
                      break t;
                    }
                    if (e2(u5 != null), u5.mc = r3, r3.c = u5.c, r3.i = u5.i, r3.l = u5.l, r3.l.ma = u5, r3.l.width = u5.c, r3.l.height = u5.i, r3.a = 0, v4(r3.m, h5, g4, m6), !It2(u5.c, u5.i, 1, r3, null))
                      break e;
                    if (r3.ab == 1 && r3.gc[0].hc == 3 && At2(r3.s) ? (u5.ic = 1, h5 = r3.c * r3.i, r3.Ta = null, r3.Ua = 0, r3.V = a3(h5), r3.Ba = 0, r3.V == null ? (r3.a = 1, r3 = 0) : r3 = 1) : (u5.ic = 0, r3 = Ft2(r3, u5.c)), !r3)
                      break e;
                    r3 = 1;
                    break t;
                  }
                u5.mc = null, r3 = 0;
              }
            else
              r3 = m6 >= u5.c * u5.i;
            u5 = !r3;
          }
          if (u5)
            return null;
          t5.ga.Lc != 1 ? t5.Ga = 0 : o4 = c6 - i6;
        }
        e2(t5.ga != null), e2(i6 + o4 <= c6);
        t: {
          if (r3 = (h5 = t5.ga).c, c6 = h5.l.o, h5.$a == 0) {
            if (g4 = t5.rc, m6 = t5.Vc, b4 = t5.Fa, l5 = t5.P + 1 + i6 * r3, f5 = t5.mb, d4 = t5.nb + i6 * r3, e2(l5 <= t5.P + t5.qc), h5.Z != 0)
              for (e2(mi[h5.Z] != null), u5 = 0;u5 < o4; ++u5)
                mi[h5.Z](g4, m6, b4, l5, f5, d4, r3), g4 = f5, m6 = d4, d4 += r3, l5 += r3;
            else
              for (u5 = 0;u5 < o4; ++u5)
                n3(f5, d4, b4, l5, r3), g4 = f5, m6 = d4, d4 += r3, l5 += r3;
            t5.rc = g4, t5.Vc = m6;
          } else {
            if (e2(h5.mc != null), r3 = i6 + o4, e2((u5 = h5.mc) != null), e2(r3 <= u5.i), u5.C >= r3)
              r3 = 1;
            else if (h5.ic || mr(), h5.ic) {
              h5 = u5.V, g4 = u5.Ba, m6 = u5.c;
              var y5 = u5.i, w4 = (b4 = 1, l5 = u5.$ / m6, f5 = u5.$ % m6, d4 = u5.m, p5 = u5.s, u5.$), N5 = m6 * y5, L4 = m6 * r3, x4 = p5.wc, _4 = w4 < L4 ? wt2(p5, f5, l5) : null;
              e2(w4 <= N5), e2(r3 <= y5), e2(At2(p5));
              e:
                for (;; ) {
                  for (;!d4.h && w4 < L4; ) {
                    if (f5 & x4 || (_4 = wt2(p5, f5, l5)), e2(_4 != null), S2(d4), 256 > (y5 = bt2(_4.G[0], _4.H[0], d4)))
                      h5[g4 + w4] = y5, ++w4, ++f5 >= m6 && (f5 = 0, ++l5 <= r3 && !(l5 % 16) && St2(u5, l5));
                    else {
                      if (!(280 > y5)) {
                        b4 = 0;
                        break e;
                      }
                      y5 = mt2(y5 - 256, d4);
                      var P3, k3 = bt2(_4.G[4], _4.H[4], d4);
                      if (S2(d4), !(w4 >= (k3 = vt2(m6, k3 = mt2(k3, d4))) && N5 - w4 >= y5)) {
                        b4 = 0;
                        break e;
                      }
                      for (P3 = 0;P3 < y5; ++P3)
                        h5[g4 + w4 + P3] = h5[g4 + w4 + P3 - k3];
                      for (w4 += y5, f5 += y5;f5 >= m6; )
                        f5 -= m6, ++l5 <= r3 && !(l5 % 16) && St2(u5, l5);
                      w4 < L4 && f5 & x4 && (_4 = wt2(p5, f5, l5));
                    }
                    e2(d4.h == A3(d4));
                  }
                  St2(u5, l5 > r3 ? r3 : l5);
                  break e;
                }
              !b4 || d4.h && w4 < N5 ? (b4 = 0, u5.a = d4.h ? 5 : 3) : u5.$ = w4, r3 = b4;
            } else
              r3 = _t2(u5, u5.V, u5.Ba, u5.c, u5.i, r3, Ct2);
            if (!r3) {
              o4 = 0;
              break t;
            }
          }
          i6 + o4 >= c6 && (t5.Cc = 1), o4 = 1;
        }
        if (!o4)
          return null;
        if (t5.Cc && ((o4 = t5.ga) != null && (o4.mc = null), t5.ga = null, 0 < t5.Ga))
          return alert("todo:WebPDequantizeLevels"), null;
      }
      return t5.nb + i6 * s4;
    }
    function fr(t5, e3, r3, n4, i6, a4) {
      for (;0 < i6--; ) {
        var o4, s4 = t5, c6 = e3 + (r3 ? 1 : 0), u5 = t5, h5 = e3 + (r3 ? 0 : 3);
        for (o4 = 0;o4 < n4; ++o4) {
          var l5 = u5[h5 + 4 * o4];
          l5 != 255 && (l5 *= 32897, s4[c6 + 4 * o4 + 0] = s4[c6 + 4 * o4 + 0] * l5 >> 23, s4[c6 + 4 * o4 + 1] = s4[c6 + 4 * o4 + 1] * l5 >> 23, s4[c6 + 4 * o4 + 2] = s4[c6 + 4 * o4 + 2] * l5 >> 23);
        }
        e3 += a4;
      }
    }
    function dr(t5, e3, r3, n4, i6) {
      for (;0 < n4--; ) {
        var a4;
        for (a4 = 0;a4 < r3; ++a4) {
          var o4 = t5[e3 + 2 * a4 + 0], s4 = 15 & (u5 = t5[e3 + 2 * a4 + 1]), c6 = 4369 * s4, u5 = (240 & u5 | u5 >> 4) * c6 >> 16;
          t5[e3 + 2 * a4 + 0] = (240 & o4 | o4 >> 4) * c6 >> 16 & 240 | (15 & o4 | o4 << 4) * c6 >> 16 >> 4 & 15, t5[e3 + 2 * a4 + 1] = 240 & u5 | s4;
        }
        e3 += i6;
      }
    }
    function pr(t5, e3, r3, n4, i6, a4, o4, s4) {
      var c6, u5, h5 = 255;
      for (u5 = 0;u5 < i6; ++u5) {
        for (c6 = 0;c6 < n4; ++c6) {
          var l5 = t5[e3 + c6];
          a4[o4 + 4 * c6] = l5, h5 &= l5;
        }
        e3 += r3, o4 += s4;
      }
      return h5 != 255;
    }
    function gr(t5, e3, r3, n4, i6) {
      var a4;
      for (a4 = 0;a4 < i6; ++a4)
        r3[n4 + a4] = t5[e3 + a4] >> 8;
    }
    function mr() {
      An = fr, xn = dr, Sn = pr, _n = gr;
    }
    function vr(r3, n4, i6) {
      t4[r3] = function(t5, r4, a4, o4, s4, c6, u5, h5, l5, f5, d4, p5, g4, m6, v5, b4, y5) {
        var w4, N5 = y5 - 1 >> 1, L4 = s4[c6 + 0] | u5[h5 + 0] << 16, A4 = l5[f5 + 0] | d4[p5 + 0] << 16;
        e2(t5 != null);
        var x4 = 3 * L4 + A4 + 131074 >> 2;
        for (n4(t5[r4 + 0], 255 & x4, x4 >> 16, g4, m6), a4 != null && (x4 = 3 * A4 + L4 + 131074 >> 2, n4(a4[o4 + 0], 255 & x4, x4 >> 16, v5, b4)), w4 = 1;w4 <= N5; ++w4) {
          var S3 = s4[c6 + w4] | u5[h5 + w4] << 16, _4 = l5[f5 + w4] | d4[p5 + w4] << 16, P3 = L4 + S3 + A4 + _4 + 524296, k3 = P3 + 2 * (S3 + A4) >> 3;
          x4 = k3 + L4 >> 1, L4 = (P3 = P3 + 2 * (L4 + _4) >> 3) + S3 >> 1, n4(t5[r4 + 2 * w4 - 1], 255 & x4, x4 >> 16, g4, m6 + (2 * w4 - 1) * i6), n4(t5[r4 + 2 * w4 - 0], 255 & L4, L4 >> 16, g4, m6 + (2 * w4 - 0) * i6), a4 != null && (x4 = P3 + A4 >> 1, L4 = k3 + _4 >> 1, n4(a4[o4 + 2 * w4 - 1], 255 & x4, x4 >> 16, v5, b4 + (2 * w4 - 1) * i6), n4(a4[o4 + 2 * w4 + 0], 255 & L4, L4 >> 16, v5, b4 + (2 * w4 + 0) * i6)), L4 = S3, A4 = _4;
        }
        1 & y5 || (x4 = 3 * L4 + A4 + 131074 >> 2, n4(t5[r4 + y5 - 1], 255 & x4, x4 >> 16, g4, m6 + (y5 - 1) * i6), a4 != null && (x4 = 3 * A4 + L4 + 131074 >> 2, n4(a4[o4 + y5 - 1], 255 & x4, x4 >> 16, v5, b4 + (y5 - 1) * i6)));
      };
    }
    function br() {
      vi[En] = bi, vi[qn] = wi, vi[Dn] = yi, vi[Rn] = Ni, vi[Tn] = Li, vi[Un] = Ai, vi[zn] = xi, vi[Hn] = wi, vi[Wn] = Ni, vi[Vn] = Li, vi[Gn] = Ai;
    }
    function yr(t5) {
      return t5 & ~Fi ? 0 > t5 ? 0 : 255 : t5 >> Ii;
    }
    function wr(t5, e3) {
      return yr((19077 * t5 >> 8) + (26149 * e3 >> 8) - 14234);
    }
    function Nr(t5, e3, r3) {
      return yr((19077 * t5 >> 8) - (6419 * e3 >> 8) - (13320 * r3 >> 8) + 8708);
    }
    function Lr(t5, e3) {
      return yr((19077 * t5 >> 8) + (33050 * e3 >> 8) - 17685);
    }
    function Ar(t5, e3, r3, n4, i6) {
      n4[i6 + 0] = wr(t5, r3), n4[i6 + 1] = Nr(t5, e3, r3), n4[i6 + 2] = Lr(t5, e3);
    }
    function xr(t5, e3, r3, n4, i6) {
      n4[i6 + 0] = Lr(t5, e3), n4[i6 + 1] = Nr(t5, e3, r3), n4[i6 + 2] = wr(t5, r3);
    }
    function Sr(t5, e3, r3, n4, i6) {
      var a4 = Nr(t5, e3, r3);
      e3 = a4 << 3 & 224 | Lr(t5, e3) >> 3, n4[i6 + 0] = 248 & wr(t5, r3) | a4 >> 5, n4[i6 + 1] = e3;
    }
    function _r(t5, e3, r3, n4, i6) {
      var a4 = 240 & Lr(t5, e3) | 15;
      n4[i6 + 0] = 240 & wr(t5, r3) | Nr(t5, e3, r3) >> 4, n4[i6 + 1] = a4;
    }
    function Pr(t5, e3, r3, n4, i6) {
      n4[i6 + 0] = 255, Ar(t5, e3, r3, n4, i6 + 1);
    }
    function kr(t5, e3, r3, n4, i6) {
      xr(t5, e3, r3, n4, i6), n4[i6 + 3] = 255;
    }
    function Ir(t5, e3, r3, n4, i6) {
      Ar(t5, e3, r3, n4, i6), n4[i6 + 3] = 255;
    }
    function Vt2(t5, e3) {
      return 0 > t5 ? 0 : t5 > e3 ? e3 : t5;
    }
    function Fr(e3, r3, n4) {
      t4[e3] = function(t5, e4, i6, a4, o4, s4, c6, u5, h5) {
        for (var l5 = u5 + (-2 & h5) * n4;u5 != l5; )
          r3(t5[e4 + 0], i6[a4 + 0], o4[s4 + 0], c6, u5), r3(t5[e4 + 1], i6[a4 + 0], o4[s4 + 0], c6, u5 + n4), e4 += 2, ++a4, ++s4, u5 += 2 * n4;
        1 & h5 && r3(t5[e4 + 0], i6[a4 + 0], o4[s4 + 0], c6, u5);
      };
    }
    function Cr(t5, e3, r3) {
      return r3 == 0 ? t5 == 0 ? e3 == 0 ? 6 : 5 : e3 == 0 ? 4 : 0 : r3;
    }
    function jr(t5, e3, r3, n4, i6) {
      switch (t5 >>> 30) {
        case 3:
          on(e3, r3, n4, i6, 0);
          break;
        case 2:
          sn(e3, r3, n4, i6);
          break;
        case 1:
          un(e3, r3, n4, i6);
      }
    }
    function Or(t5, e3) {
      var r3, a4, o4 = e3.M, s4 = e3.Nb, c6 = t5.oc, u5 = t5.pc + 40, h5 = t5.oc, l5 = t5.pc + 584, f5 = t5.oc, d4 = t5.pc + 600;
      for (r3 = 0;16 > r3; ++r3)
        c6[u5 + 32 * r3 - 1] = 129;
      for (r3 = 0;8 > r3; ++r3)
        h5[l5 + 32 * r3 - 1] = 129, f5[d4 + 32 * r3 - 1] = 129;
      for (0 < o4 ? c6[u5 - 1 - 32] = h5[l5 - 1 - 32] = f5[d4 - 1 - 32] = 129 : (i5(c6, u5 - 32 - 1, 127, 21), i5(h5, l5 - 32 - 1, 127, 9), i5(f5, d4 - 32 - 1, 127, 9)), a4 = 0;a4 < t5.za; ++a4) {
        var p5 = e3.ya[e3.aa + a4];
        if (0 < a4) {
          for (r3 = -1;16 > r3; ++r3)
            n3(c6, u5 + 32 * r3 - 4, c6, u5 + 32 * r3 + 12, 4);
          for (r3 = -1;8 > r3; ++r3)
            n3(h5, l5 + 32 * r3 - 4, h5, l5 + 32 * r3 + 4, 4), n3(f5, d4 + 32 * r3 - 4, f5, d4 + 32 * r3 + 4, 4);
        }
        var g4 = t5.Gd, m6 = t5.Hd + a4, v5 = p5.ad, b4 = p5.Hc;
        if (0 < o4 && (n3(c6, u5 - 32, g4[m6].y, 0, 16), n3(h5, l5 - 32, g4[m6].f, 0, 8), n3(f5, d4 - 32, g4[m6].ea, 0, 8)), p5.Za) {
          var y5 = c6, w4 = u5 - 32 + 16;
          for (0 < o4 && (a4 >= t5.za - 1 ? i5(y5, w4, g4[m6].y[15], 4) : n3(y5, w4, g4[m6 + 1].y, 0, 4)), r3 = 0;4 > r3; r3++)
            y5[w4 + 128 + r3] = y5[w4 + 256 + r3] = y5[w4 + 384 + r3] = y5[w4 + 0 + r3];
          for (r3 = 0;16 > r3; ++r3, b4 <<= 2)
            y5 = c6, w4 = u5 + Di[r3], fi[p5.Ob[r3]](y5, w4), jr(b4, v5, 16 * +r3, y5, w4);
        } else if (y5 = Cr(a4, o4, p5.Ob[0]), li[y5](c6, u5), b4 != 0)
          for (r3 = 0;16 > r3; ++r3, b4 <<= 2)
            jr(b4, v5, 16 * +r3, c6, u5 + Di[r3]);
        for (r3 = p5.Gc, y5 = Cr(a4, o4, p5.Dd), di[y5](h5, l5), di[y5](f5, d4), b4 = v5, y5 = h5, w4 = l5, 255 & (p5 = r3 >> 0) && (170 & p5 ? cn(b4, 256, y5, w4) : hn(b4, 256, y5, w4)), p5 = f5, b4 = d4, 255 & (r3 >>= 8) && (170 & r3 ? cn(v5, 320, p5, b4) : hn(v5, 320, p5, b4)), o4 < t5.Ub - 1 && (n3(g4[m6].y, 0, c6, u5 + 480, 16), n3(g4[m6].f, 0, h5, l5 + 224, 8), n3(g4[m6].ea, 0, f5, d4 + 224, 8)), r3 = 8 * s4 * t5.B, g4 = t5.sa, m6 = t5.ta + 16 * a4 + 16 * s4 * t5.R, v5 = t5.qa, p5 = t5.ra + 8 * a4 + r3, b4 = t5.Ha, y5 = t5.Ia + 8 * a4 + r3, r3 = 0;16 > r3; ++r3)
          n3(g4, m6 + r3 * t5.R, c6, u5 + 32 * r3, 16);
        for (r3 = 0;8 > r3; ++r3)
          n3(v5, p5 + r3 * t5.B, h5, l5 + 32 * r3, 8), n3(b4, y5 + r3 * t5.B, f5, d4 + 32 * r3, 8);
      }
    }
    function Br(t5, n4, i6, a4, o4, s4, c6, u5, h5) {
      var l5 = [0], f5 = [0], d4 = 0, p5 = h5 != null ? h5.kd : 0, g4 = h5 != null ? h5 : new nr;
      if (t5 == null || 12 > i6)
        return 7;
      g4.data = t5, g4.w = n4, g4.ha = i6, n4 = [n4], i6 = [i6], g4.gb = [g4.gb];
      t: {
        var m6 = n4, b4 = i6, y5 = g4.gb;
        if (e2(t5 != null), e2(b4 != null), e2(y5 != null), y5[0] = 0, 12 <= b4[0] && !r2(t5, m6[0], "RIFF")) {
          if (r2(t5, m6[0] + 8, "WEBP")) {
            y5 = 3;
            break t;
          }
          var w4 = j2(t5, m6[0] + 4);
          if (12 > w4 || 4294967286 < w4) {
            y5 = 3;
            break t;
          }
          if (p5 && w4 > b4[0] - 8) {
            y5 = 7;
            break t;
          }
          y5[0] = w4, m6[0] += 12, b4[0] -= 12;
        }
        y5 = 0;
      }
      if (y5 != 0)
        return y5;
      for (w4 = 0 < g4.gb[0], i6 = i6[0];; ) {
        t: {
          var L4 = t5;
          b4 = n4, y5 = i6;
          var A4 = l5, x4 = f5, S3 = m6 = [0];
          if ((k3 = d4 = [d4])[0] = 0, 8 > y5[0])
            y5 = 7;
          else {
            if (!r2(L4, b4[0], "VP8X")) {
              if (j2(L4, b4[0] + 4) != 10) {
                y5 = 3;
                break t;
              }
              if (18 > y5[0]) {
                y5 = 7;
                break t;
              }
              var _4 = j2(L4, b4[0] + 8), P3 = 1 + C2(L4, b4[0] + 12);
              if (2147483648 <= P3 * (L4 = 1 + C2(L4, b4[0] + 15))) {
                y5 = 3;
                break t;
              }
              S3 != null && (S3[0] = _4), A4 != null && (A4[0] = P3), x4 != null && (x4[0] = L4), b4[0] += 18, y5[0] -= 18, k3[0] = 1;
            }
            y5 = 0;
          }
        }
        if (d4 = d4[0], m6 = m6[0], y5 != 0)
          return y5;
        if (b4 = !!(2 & m6), !w4 && d4)
          return 3;
        if (s4 != null && (s4[0] = !!(16 & m6)), c6 != null && (c6[0] = b4), u5 != null && (u5[0] = 0), c6 = l5[0], m6 = f5[0], d4 && b4 && h5 == null) {
          y5 = 0;
          break;
        }
        if (4 > i6) {
          y5 = 7;
          break;
        }
        if (w4 && d4 || !w4 && !d4 && !r2(t5, n4[0], "ALPH")) {
          i6 = [i6], g4.na = [g4.na], g4.P = [g4.P], g4.Sa = [g4.Sa];
          t: {
            _4 = t5, y5 = n4, w4 = i6;
            var k3 = g4.gb;
            A4 = g4.na, x4 = g4.P, S3 = g4.Sa;
            P3 = 22, e2(_4 != null), e2(w4 != null), L4 = y5[0];
            var I3 = w4[0];
            for (e2(A4 != null), e2(S3 != null), A4[0] = null, x4[0] = null, S3[0] = 0;; ) {
              if (y5[0] = L4, w4[0] = I3, 8 > I3) {
                y5 = 7;
                break t;
              }
              var F3 = j2(_4, L4 + 4);
              if (4294967286 < F3) {
                y5 = 3;
                break t;
              }
              var O4 = 8 + F3 + 1 & -2;
              if (P3 += O4, 0 < k3 && P3 > k3) {
                y5 = 3;
                break t;
              }
              if (!r2(_4, L4, "VP8 ") || !r2(_4, L4, "VP8L")) {
                y5 = 0;
                break t;
              }
              if (I3[0] < O4) {
                y5 = 7;
                break t;
              }
              r2(_4, L4, "ALPH") || (A4[0] = _4, x4[0] = L4 + 8, S3[0] = F3), L4 += O4, I3 -= O4;
            }
          }
          if (i6 = i6[0], g4.na = g4.na[0], g4.P = g4.P[0], g4.Sa = g4.Sa[0], y5 != 0)
            break;
        }
        i6 = [i6], g4.Ja = [g4.Ja], g4.xa = [g4.xa];
        t:
          if (k3 = t5, y5 = n4, w4 = i6, A4 = g4.gb[0], x4 = g4.Ja, S3 = g4.xa, _4 = y5[0], L4 = !r2(k3, _4, "VP8 "), P3 = !r2(k3, _4, "VP8L"), e2(k3 != null), e2(w4 != null), e2(x4 != null), e2(S3 != null), 8 > w4[0])
            y5 = 7;
          else {
            if (L4 || P3) {
              if (k3 = j2(k3, _4 + 4), 12 <= A4 && k3 > A4 - 12) {
                y5 = 3;
                break t;
              }
              if (p5 && k3 > w4[0] - 8) {
                y5 = 7;
                break t;
              }
              x4[0] = k3, y5[0] += 8, w4[0] -= 8, S3[0] = P3;
            } else
              S3[0] = 5 <= w4[0] && k3[_4 + 0] == 47 && !(k3[_4 + 4] >> 5), x4[0] = w4[0];
            y5 = 0;
          }
        if (i6 = i6[0], g4.Ja = g4.Ja[0], g4.xa = g4.xa[0], n4 = n4[0], y5 != 0)
          break;
        if (4294967286 < g4.Ja)
          return 3;
        if (u5 == null || b4 || (u5[0] = g4.xa ? 2 : 1), c6 = [c6], m6 = [m6], g4.xa) {
          if (5 > i6) {
            y5 = 7;
            break;
          }
          u5 = c6, p5 = m6, b4 = s4, t5 == null || 5 > i6 ? t5 = 0 : 5 <= i6 && t5[n4 + 0] == 47 && !(t5[n4 + 4] >> 5) ? (w4 = [0], k3 = [0], A4 = [0], v4(x4 = new N4, t5, n4, i6), gt2(x4, w4, k3, A4) ? (u5 != null && (u5[0] = w4[0]), p5 != null && (p5[0] = k3[0]), b4 != null && (b4[0] = A4[0]), t5 = 1) : t5 = 0) : t5 = 0;
        } else {
          if (10 > i6) {
            y5 = 7;
            break;
          }
          u5 = m6, t5 == null || 10 > i6 || !Xt2(t5, n4 + 3, i6 - 3) ? t5 = 0 : (p5 = t5[n4 + 0] | t5[n4 + 1] << 8 | t5[n4 + 2] << 16, b4 = 16383 & (t5[n4 + 7] << 8 | t5[n4 + 6]), t5 = 16383 & (t5[n4 + 9] << 8 | t5[n4 + 8]), 1 & p5 || 3 < (p5 >> 1 & 7) || !(p5 >> 4 & 1) || p5 >> 5 >= g4.Ja || !b4 || !t5 ? t5 = 0 : (c6 && (c6[0] = b4), u5 && (u5[0] = t5), t5 = 1));
        }
        if (!t5)
          return 3;
        if (c6 = c6[0], m6 = m6[0], d4 && (l5[0] != c6 || f5[0] != m6))
          return 3;
        h5 != null && (h5[0] = g4, h5.offset = n4 - h5.w, e2(4294967286 > n4 - h5.w), e2(h5.offset == h5.ha - i6));
        break;
      }
      return y5 == 0 || y5 == 7 && d4 && h5 == null ? (s4 != null && (s4[0] |= g4.na != null && 0 < g4.na.length), a4 != null && (a4[0] = c6), o4 != null && (o4[0] = m6), 0) : y5;
    }
    function Mr(t5, e3, r3) {
      var { width: n4, height: i6 } = e3, a4 = 0, o4 = 0, s4 = n4, c6 = i6;
      if (e3.Da = t5 != null && 0 < t5.Da, e3.Da && (s4 = t5.cd, c6 = t5.bd, a4 = t5.v, o4 = t5.j, 11 > r3 || (a4 &= -2, o4 &= -2), 0 > a4 || 0 > o4 || 0 >= s4 || 0 >= c6 || a4 + s4 > n4 || o4 + c6 > i6))
        return 0;
      if (e3.v = a4, e3.j = o4, e3.va = a4 + s4, e3.o = o4 + c6, e3.U = s4, e3.T = c6, e3.da = t5 != null && 0 < t5.da, e3.da) {
        if (!E2(s4, c6, r3 = [t5.ib], a4 = [t5.hb]))
          return 0;
        e3.ib = r3[0], e3.hb = a4[0];
      }
      return e3.ob = t5 != null && t5.ob, e3.Kb = t5 == null || !t5.Sd, e3.da && (e3.ob = e3.ib < 3 * n4 / 4 && e3.hb < 3 * i6 / 4, e3.Kb = 0), 1;
    }
    function Er(t5) {
      if (t5 == null)
        return 2;
      if (11 > t5.S) {
        var e3 = t5.f.RGBA;
        e3.fb += (t5.height - 1) * e3.A, e3.A = -e3.A;
      } else
        e3 = t5.f.kb, t5 = t5.height, e3.O += (t5 - 1) * e3.fa, e3.fa = -e3.fa, e3.N += (t5 - 1 >> 1) * e3.Ab, e3.Ab = -e3.Ab, e3.W += (t5 - 1 >> 1) * e3.Db, e3.Db = -e3.Db, e3.F != null && (e3.J += (t5 - 1) * e3.lb, e3.lb = -e3.lb);
      return 0;
    }
    function qr(t5, e3, r3, n4) {
      if (n4 == null || 0 >= t5 || 0 >= e3)
        return 2;
      if (r3 != null) {
        if (r3.Da) {
          var { cd: i6, bd: o4 } = r3, s4 = -2 & r3.v, c6 = -2 & r3.j;
          if (0 > s4 || 0 > c6 || 0 >= i6 || 0 >= o4 || s4 + i6 > t5 || c6 + o4 > e3)
            return 2;
          t5 = i6, e3 = o4;
        }
        if (r3.da) {
          if (!E2(t5, e3, i6 = [r3.ib], o4 = [r3.hb]))
            return 2;
          t5 = i6[0], e3 = o4[0];
        }
      }
      n4.width = t5, n4.height = e3;
      t: {
        var { width: u5, height: h5 } = n4;
        if (t5 = n4.S, 0 >= u5 || 0 >= h5 || !(t5 >= En && 13 > t5))
          t5 = 2;
        else {
          if (0 >= n4.Rd && n4.sd == null) {
            s4 = o4 = i6 = e3 = 0;
            var l5 = (c6 = u5 * zi[t5]) * h5;
            if (11 > t5 || (o4 = (h5 + 1) / 2 * (e3 = (u5 + 1) / 2), t5 == 12 && (s4 = (i6 = u5) * h5)), (h5 = a3(l5 + 2 * o4 + s4)) == null) {
              t5 = 1;
              break t;
            }
            n4.sd = h5, 11 > t5 ? ((u5 = n4.f.RGBA).eb = h5, u5.fb = 0, u5.A = c6, u5.size = l5) : ((u5 = n4.f.kb).y = h5, u5.O = 0, u5.fa = c6, u5.Fd = l5, u5.f = h5, u5.N = 0 + l5, u5.Ab = e3, u5.Cd = o4, u5.ea = h5, u5.W = 0 + l5 + o4, u5.Db = e3, u5.Ed = o4, t5 == 12 && (u5.F = h5, u5.J = 0 + l5 + 2 * o4), u5.Tc = s4, u5.lb = i6);
          }
          if (e3 = 1, i6 = n4.S, o4 = n4.width, s4 = n4.height, i6 >= En && 13 > i6)
            if (11 > i6)
              t5 = n4.f.RGBA, e3 &= (c6 = Math.abs(t5.A)) * (s4 - 1) + o4 <= t5.size, e3 &= c6 >= o4 * zi[i6], e3 &= t5.eb != null;
            else {
              t5 = n4.f.kb, c6 = (o4 + 1) / 2, l5 = (s4 + 1) / 2, u5 = Math.abs(t5.fa);
              h5 = Math.abs(t5.Ab);
              var f5 = Math.abs(t5.Db), d4 = Math.abs(t5.lb), p5 = d4 * (s4 - 1) + o4;
              e3 &= u5 * (s4 - 1) + o4 <= t5.Fd, e3 &= h5 * (l5 - 1) + c6 <= t5.Cd, e3 = (e3 &= f5 * (l5 - 1) + c6 <= t5.Ed) & u5 >= o4 & h5 >= c6 & f5 >= c6, e3 &= t5.y != null, e3 &= t5.f != null, e3 &= t5.ea != null, i6 == 12 && (e3 &= d4 >= o4, e3 &= p5 <= t5.Tc, e3 &= t5.F != null);
            }
          else
            e3 = 0;
          t5 = e3 ? 0 : 2;
        }
      }
      return t5 != 0 || r3 != null && r3.fd && (t5 = Er(n4)), t5;
    }
    var Dr = 64, Rr = [0, 1, 3, 7, 15, 31, 63, 127, 255, 511, 1023, 2047, 4095, 8191, 16383, 32767, 65535, 131071, 262143, 524287, 1048575, 2097151, 4194303, 8388607, 16777215], Tr = 24, Ur = 32, zr = 8, Hr = [0, 0, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7];
    R2("Predictor0", "PredictorAdd0"), t4.Predictor0 = function() {
      return 4278190080;
    }, t4.Predictor1 = function(t5) {
      return t5;
    }, t4.Predictor2 = function(t5, e3, r3) {
      return e3[r3 + 0];
    }, t4.Predictor3 = function(t5, e3, r3) {
      return e3[r3 + 1];
    }, t4.Predictor4 = function(t5, e3, r3) {
      return e3[r3 - 1];
    }, t4.Predictor5 = function(t5, e3, r3) {
      return U2(U2(t5, e3[r3 + 1]), e3[r3 + 0]);
    }, t4.Predictor6 = function(t5, e3, r3) {
      return U2(t5, e3[r3 - 1]);
    }, t4.Predictor7 = function(t5, e3, r3) {
      return U2(t5, e3[r3 + 0]);
    }, t4.Predictor8 = function(t5, e3, r3) {
      return U2(e3[r3 - 1], e3[r3 + 0]);
    }, t4.Predictor9 = function(t5, e3, r3) {
      return U2(e3[r3 + 0], e3[r3 + 1]);
    }, t4.Predictor10 = function(t5, e3, r3) {
      return U2(U2(t5, e3[r3 - 1]), U2(e3[r3 + 0], e3[r3 + 1]));
    }, t4.Predictor11 = function(t5, e3, r3) {
      var n4 = e3[r3 + 0];
      return 0 >= W2(n4 >> 24 & 255, t5 >> 24 & 255, (e3 = e3[r3 - 1]) >> 24 & 255) + W2(n4 >> 16 & 255, t5 >> 16 & 255, e3 >> 16 & 255) + W2(n4 >> 8 & 255, t5 >> 8 & 255, e3 >> 8 & 255) + W2(255 & n4, 255 & t5, 255 & e3) ? n4 : t5;
    }, t4.Predictor12 = function(t5, e3, r3) {
      var n4 = e3[r3 + 0];
      return (z2((t5 >> 24 & 255) + (n4 >> 24 & 255) - ((e3 = e3[r3 - 1]) >> 24 & 255)) << 24 | z2((t5 >> 16 & 255) + (n4 >> 16 & 255) - (e3 >> 16 & 255)) << 16 | z2((t5 >> 8 & 255) + (n4 >> 8 & 255) - (e3 >> 8 & 255)) << 8 | z2((255 & t5) + (255 & n4) - (255 & e3))) >>> 0;
    }, t4.Predictor13 = function(t5, e3, r3) {
      var n4 = e3[r3 - 1];
      return (H2((t5 = U2(t5, e3[r3 + 0])) >> 24 & 255, n4 >> 24 & 255) << 24 | H2(t5 >> 16 & 255, n4 >> 16 & 255) << 16 | H2(t5 >> 8 & 255, n4 >> 8 & 255) << 8 | H2(t5 >> 0 & 255, n4 >> 0 & 255)) >>> 0;
    };
    var Wr = t4.PredictorAdd0;
    t4.PredictorAdd1 = V2, R2("Predictor2", "PredictorAdd2"), R2("Predictor3", "PredictorAdd3"), R2("Predictor4", "PredictorAdd4"), R2("Predictor5", "PredictorAdd5"), R2("Predictor6", "PredictorAdd6"), R2("Predictor7", "PredictorAdd7"), R2("Predictor8", "PredictorAdd8"), R2("Predictor9", "PredictorAdd9"), R2("Predictor10", "PredictorAdd10"), R2("Predictor11", "PredictorAdd11"), R2("Predictor12", "PredictorAdd12"), R2("Predictor13", "PredictorAdd13");
    var Vr = t4.PredictorAdd2;
    X2("ColorIndexInverseTransform", "MapARGB", "32b", function(t5) {
      return t5 >> 8 & 255;
    }, function(t5) {
      return t5;
    }), X2("VP8LColorIndexInverseTransformAlpha", "MapAlpha", "8b", function(t5) {
      return t5;
    }, function(t5) {
      return t5 >> 8 & 255;
    });
    var Gr, Yr = t4.ColorIndexInverseTransform, Jr = t4.MapARGB, Xr = t4.VP8LColorIndexInverseTransformAlpha, Kr = t4.MapAlpha, Zr = t4.VP8LPredictorsAdd = [];
    Zr.length = 16, (t4.VP8LPredictors = []).length = 16, (t4.VP8LPredictorsAdd_C = []).length = 16, (t4.VP8LPredictors_C = []).length = 16;
    var $r, Qr, tn, en, rn, nn, an, on, sn, cn, un, hn, ln2, fn, dn, pn, gn, mn, vn, bn, yn, wn, Nn, Ln, An, xn, Sn, _n, Pn = a3(511), kn = a3(2041), In = a3(225), Fn = a3(767), Cn = 0, jn = kn, On = In, Bn = Fn, Mn = Pn, En = 0, qn = 1, Dn = 2, Rn = 3, Tn = 4, Un = 5, zn = 6, Hn = 7, Wn = 8, Vn = 9, Gn = 10, Yn = [2, 3, 7], Jn = [3, 3, 11], Xn = [280, 256, 256, 256, 40], Kn = [0, 1, 1, 1, 0], Zn = [17, 18, 0, 1, 2, 3, 4, 5, 16, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15], $n = [24, 7, 23, 25, 40, 6, 39, 41, 22, 26, 38, 42, 56, 5, 55, 57, 21, 27, 54, 58, 37, 43, 72, 4, 71, 73, 20, 28, 53, 59, 70, 74, 36, 44, 88, 69, 75, 52, 60, 3, 87, 89, 19, 29, 86, 90, 35, 45, 68, 76, 85, 91, 51, 61, 104, 2, 103, 105, 18, 30, 102, 106, 34, 46, 84, 92, 67, 77, 101, 107, 50, 62, 120, 1, 119, 121, 83, 93, 17, 31, 100, 108, 66, 78, 118, 122, 33, 47, 117, 123, 49, 63, 99, 109, 82, 94, 0, 116, 124, 65, 79, 16, 32, 98, 110, 48, 115, 125, 81, 95, 64, 114, 126, 97, 111, 80, 113, 127, 96, 112], Qn = [2954, 2956, 2958, 2962, 2970, 2986, 3018, 3082, 3212, 3468, 3980, 5004], ti = 8, ei = [4, 5, 6, 7, 8, 9, 10, 10, 11, 12, 13, 14, 15, 16, 17, 17, 18, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 25, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 91, 93, 95, 96, 98, 100, 101, 102, 104, 106, 108, 110, 112, 114, 116, 118, 122, 124, 126, 128, 130, 132, 134, 136, 138, 140, 143, 145, 148, 151, 154, 157], ri = [4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 112, 114, 116, 119, 122, 125, 128, 131, 134, 137, 140, 143, 146, 149, 152, 155, 158, 161, 164, 167, 170, 173, 177, 181, 185, 189, 193, 197, 201, 205, 209, 213, 217, 221, 225, 229, 234, 239, 245, 249, 254, 259, 264, 269, 274, 279, 284], ni = null, ii = [[173, 148, 140, 0], [176, 155, 140, 135, 0], [180, 157, 141, 134, 130, 0], [254, 254, 243, 230, 196, 177, 153, 140, 133, 130, 129, 0]], ai = [0, 1, 4, 8, 5, 2, 3, 6, 9, 12, 13, 10, 7, 11, 14, 15], oi = [-0, 1, -1, 2, -2, 3, 4, 6, -3, 5, -4, -5, -6, 7, -7, 8, -8, -9], si = [[[[128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128], [128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128], [128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128]], [[253, 136, 254, 255, 228, 219, 128, 128, 128, 128, 128], [189, 129, 242, 255, 227, 213, 255, 219, 128, 128, 128], [106, 126, 227, 252, 214, 209, 255, 255, 128, 128, 128]], [[1, 98, 248, 255, 236, 226, 255, 255, 128, 128, 128], [181, 133, 238, 254, 221, 234, 255, 154, 128, 128, 128], [78, 134, 202, 247, 198, 180, 255, 219, 128, 128, 128]], [[1, 185, 249, 255, 243, 255, 128, 128, 128, 128, 128], [184, 150, 247, 255, 236, 224, 128, 128, 128, 128, 128], [77, 110, 216, 255, 236, 230, 128, 128, 128, 128, 128]], [[1, 101, 251, 255, 241, 255, 128, 128, 128, 128, 128], [170, 139, 241, 252, 236, 209, 255, 255, 128, 128, 128], [37, 116, 196, 243, 228, 255, 255, 255, 128, 128, 128]], [[1, 204, 254, 255, 245, 255, 128, 128, 128, 128, 128], [207, 160, 250, 255, 238, 128, 128, 128, 128, 128, 128], [102, 103, 231, 255, 211, 171, 128, 128, 128, 128, 128]], [[1, 152, 252, 255, 240, 255, 128, 128, 128, 128, 128], [177, 135, 243, 255, 234, 225, 128, 128, 128, 128, 128], [80, 129, 211, 255, 194, 224, 128, 128, 128, 128, 128]], [[1, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128], [246, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128], [255, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128]]], [[[198, 35, 237, 223, 193, 187, 162, 160, 145, 155, 62], [131, 45, 198, 221, 172, 176, 220, 157, 252, 221, 1], [68, 47, 146, 208, 149, 167, 221, 162, 255, 223, 128]], [[1, 149, 241, 255, 221, 224, 255, 255, 128, 128, 128], [184, 141, 234, 253, 222, 220, 255, 199, 128, 128, 128], [81, 99, 181, 242, 176, 190, 249, 202, 255, 255, 128]], [[1, 129, 232, 253, 214, 197, 242, 196, 255, 255, 128], [99, 121, 210, 250, 201, 198, 255, 202, 128, 128, 128], [23, 91, 163, 242, 170, 187, 247, 210, 255, 255, 128]], [[1, 200, 246, 255, 234, 255, 128, 128, 128, 128, 128], [109, 178, 241, 255, 231, 245, 255, 255, 128, 128, 128], [44, 130, 201, 253, 205, 192, 255, 255, 128, 128, 128]], [[1, 132, 239, 251, 219, 209, 255, 165, 128, 128, 128], [94, 136, 225, 251, 218, 190, 255, 255, 128, 128, 128], [22, 100, 174, 245, 186, 161, 255, 199, 128, 128, 128]], [[1, 182, 249, 255, 232, 235, 128, 128, 128, 128, 128], [124, 143, 241, 255, 227, 234, 128, 128, 128, 128, 128], [35, 77, 181, 251, 193, 211, 255, 205, 128, 128, 128]], [[1, 157, 247, 255, 236, 231, 255, 255, 128, 128, 128], [121, 141, 235, 255, 225, 227, 255, 255, 128, 128, 128], [45, 99, 188, 251, 195, 217, 255, 224, 128, 128, 128]], [[1, 1, 251, 255, 213, 255, 128, 128, 128, 128, 128], [203, 1, 248, 255, 255, 128, 128, 128, 128, 128, 128], [137, 1, 177, 255, 224, 255, 128, 128, 128, 128, 128]]], [[[253, 9, 248, 251, 207, 208, 255, 192, 128, 128, 128], [175, 13, 224, 243, 193, 185, 249, 198, 255, 255, 128], [73, 17, 171, 221, 161, 179, 236, 167, 255, 234, 128]], [[1, 95, 247, 253, 212, 183, 255, 255, 128, 128, 128], [239, 90, 244, 250, 211, 209, 255, 255, 128, 128, 128], [155, 77, 195, 248, 188, 195, 255, 255, 128, 128, 128]], [[1, 24, 239, 251, 218, 219, 255, 205, 128, 128, 128], [201, 51, 219, 255, 196, 186, 128, 128, 128, 128, 128], [69, 46, 190, 239, 201, 218, 255, 228, 128, 128, 128]], [[1, 191, 251, 255, 255, 128, 128, 128, 128, 128, 128], [223, 165, 249, 255, 213, 255, 128, 128, 128, 128, 128], [141, 124, 248, 255, 255, 128, 128, 128, 128, 128, 128]], [[1, 16, 248, 255, 255, 128, 128, 128, 128, 128, 128], [190, 36, 230, 255, 236, 255, 128, 128, 128, 128, 128], [149, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128]], [[1, 226, 255, 128, 128, 128, 128, 128, 128, 128, 128], [247, 192, 255, 128, 128, 128, 128, 128, 128, 128, 128], [240, 128, 255, 128, 128, 128, 128, 128, 128, 128, 128]], [[1, 134, 252, 255, 255, 128, 128, 128, 128, 128, 128], [213, 62, 250, 255, 255, 128, 128, 128, 128, 128, 128], [55, 93, 255, 128, 128, 128, 128, 128, 128, 128, 128]], [[128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128], [128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128], [128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128]]], [[[202, 24, 213, 235, 186, 191, 220, 160, 240, 175, 255], [126, 38, 182, 232, 169, 184, 228, 174, 255, 187, 128], [61, 46, 138, 219, 151, 178, 240, 170, 255, 216, 128]], [[1, 112, 230, 250, 199, 191, 247, 159, 255, 255, 128], [166, 109, 228, 252, 211, 215, 255, 174, 128, 128, 128], [39, 77, 162, 232, 172, 180, 245, 178, 255, 255, 128]], [[1, 52, 220, 246, 198, 199, 249, 220, 255, 255, 128], [124, 74, 191, 243, 183, 193, 250, 221, 255, 255, 128], [24, 71, 130, 219, 154, 170, 243, 182, 255, 255, 128]], [[1, 182, 225, 249, 219, 240, 255, 224, 128, 128, 128], [149, 150, 226, 252, 216, 205, 255, 171, 128, 128, 128], [28, 108, 170, 242, 183, 194, 254, 223, 255, 255, 128]], [[1, 81, 230, 252, 204, 203, 255, 192, 128, 128, 128], [123, 102, 209, 247, 188, 196, 255, 233, 128, 128, 128], [20, 95, 153, 243, 164, 173, 255, 203, 128, 128, 128]], [[1, 222, 248, 255, 216, 213, 128, 128, 128, 128, 128], [168, 175, 246, 252, 235, 205, 255, 255, 128, 128, 128], [47, 116, 215, 255, 211, 212, 255, 255, 128, 128, 128]], [[1, 121, 236, 253, 212, 214, 255, 255, 128, 128, 128], [141, 84, 213, 252, 201, 202, 255, 219, 128, 128, 128], [42, 80, 160, 240, 162, 185, 255, 205, 128, 128, 128]], [[1, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128], [244, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128], [238, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128]]]], ci = [[[231, 120, 48, 89, 115, 113, 120, 152, 112], [152, 179, 64, 126, 170, 118, 46, 70, 95], [175, 69, 143, 80, 85, 82, 72, 155, 103], [56, 58, 10, 171, 218, 189, 17, 13, 152], [114, 26, 17, 163, 44, 195, 21, 10, 173], [121, 24, 80, 195, 26, 62, 44, 64, 85], [144, 71, 10, 38, 171, 213, 144, 34, 26], [170, 46, 55, 19, 136, 160, 33, 206, 71], [63, 20, 8, 114, 114, 208, 12, 9, 226], [81, 40, 11, 96, 182, 84, 29, 16, 36]], [[134, 183, 89, 137, 98, 101, 106, 165, 148], [72, 187, 100, 130, 157, 111, 32, 75, 80], [66, 102, 167, 99, 74, 62, 40, 234, 128], [41, 53, 9, 178, 241, 141, 26, 8, 107], [74, 43, 26, 146, 73, 166, 49, 23, 157], [65, 38, 105, 160, 51, 52, 31, 115, 128], [104, 79, 12, 27, 217, 255, 87, 17, 7], [87, 68, 71, 44, 114, 51, 15, 186, 23], [47, 41, 14, 110, 182, 183, 21, 17, 194], [66, 45, 25, 102, 197, 189, 23, 18, 22]], [[88, 88, 147, 150, 42, 46, 45, 196, 205], [43, 97, 183, 117, 85, 38, 35, 179, 61], [39, 53, 200, 87, 26, 21, 43, 232, 171], [56, 34, 51, 104, 114, 102, 29, 93, 77], [39, 28, 85, 171, 58, 165, 90, 98, 64], [34, 22, 116, 206, 23, 34, 43, 166, 73], [107, 54, 32, 26, 51, 1, 81, 43, 31], [68, 25, 106, 22, 64, 171, 36, 225, 114], [34, 19, 21, 102, 132, 188, 16, 76, 124], [62, 18, 78, 95, 85, 57, 50, 48, 51]], [[193, 101, 35, 159, 215, 111, 89, 46, 111], [60, 148, 31, 172, 219, 228, 21, 18, 111], [112, 113, 77, 85, 179, 255, 38, 120, 114], [40, 42, 1, 196, 245, 209, 10, 25, 109], [88, 43, 29, 140, 166, 213, 37, 43, 154], [61, 63, 30, 155, 67, 45, 68, 1, 209], [100, 80, 8, 43, 154, 1, 51, 26, 71], [142, 78, 78, 16, 255, 128, 34, 197, 171], [41, 40, 5, 102, 211, 183, 4, 1, 221], [51, 50, 17, 168, 209, 192, 23, 25, 82]], [[138, 31, 36, 171, 27, 166, 38, 44, 229], [67, 87, 58, 169, 82, 115, 26, 59, 179], [63, 59, 90, 180, 59, 166, 93, 73, 154], [40, 40, 21, 116, 143, 209, 34, 39, 175], [47, 15, 16, 183, 34, 223, 49, 45, 183], [46, 17, 33, 183, 6, 98, 15, 32, 183], [57, 46, 22, 24, 128, 1, 54, 17, 37], [65, 32, 73, 115, 28, 128, 23, 128, 205], [40, 3, 9, 115, 51, 192, 18, 6, 223], [87, 37, 9, 115, 59, 77, 64, 21, 47]], [[104, 55, 44, 218, 9, 54, 53, 130, 226], [64, 90, 70, 205, 40, 41, 23, 26, 57], [54, 57, 112, 184, 5, 41, 38, 166, 213], [30, 34, 26, 133, 152, 116, 10, 32, 134], [39, 19, 53, 221, 26, 114, 32, 73, 255], [31, 9, 65, 234, 2, 15, 1, 118, 73], [75, 32, 12, 51, 192, 255, 160, 43, 51], [88, 31, 35, 67, 102, 85, 55, 186, 85], [56, 21, 23, 111, 59, 205, 45, 37, 192], [55, 38, 70, 124, 73, 102, 1, 34, 98]], [[125, 98, 42, 88, 104, 85, 117, 175, 82], [95, 84, 53, 89, 128, 100, 113, 101, 45], [75, 79, 123, 47, 51, 128, 81, 171, 1], [57, 17, 5, 71, 102, 57, 53, 41, 49], [38, 33, 13, 121, 57, 73, 26, 1, 85], [41, 10, 67, 138, 77, 110, 90, 47, 114], [115, 21, 2, 10, 102, 255, 166, 23, 6], [101, 29, 16, 10, 85, 128, 101, 196, 26], [57, 18, 10, 102, 102, 213, 34, 20, 43], [117, 20, 15, 36, 163, 128, 68, 1, 26]], [[102, 61, 71, 37, 34, 53, 31, 243, 192], [69, 60, 71, 38, 73, 119, 28, 222, 37], [68, 45, 128, 34, 1, 47, 11, 245, 171], [62, 17, 19, 70, 146, 85, 55, 62, 70], [37, 43, 37, 154, 100, 163, 85, 160, 1], [63, 9, 92, 136, 28, 64, 32, 201, 85], [75, 15, 9, 9, 64, 255, 184, 119, 16], [86, 6, 28, 5, 64, 255, 25, 248, 1], [56, 8, 17, 132, 137, 255, 55, 116, 128], [58, 15, 20, 82, 135, 57, 26, 121, 40]], [[164, 50, 31, 137, 154, 133, 25, 35, 218], [51, 103, 44, 131, 131, 123, 31, 6, 158], [86, 40, 64, 135, 148, 224, 45, 183, 128], [22, 26, 17, 131, 240, 154, 14, 1, 209], [45, 16, 21, 91, 64, 222, 7, 1, 197], [56, 21, 39, 155, 60, 138, 23, 102, 213], [83, 12, 13, 54, 192, 255, 68, 47, 28], [85, 26, 85, 85, 128, 128, 32, 146, 171], [18, 11, 7, 63, 144, 171, 4, 4, 246], [35, 27, 10, 146, 174, 171, 12, 26, 128]], [[190, 80, 35, 99, 180, 80, 126, 54, 45], [85, 126, 47, 87, 176, 51, 41, 20, 32], [101, 75, 128, 139, 118, 146, 116, 128, 85], [56, 41, 15, 176, 236, 85, 37, 9, 62], [71, 30, 17, 119, 118, 255, 17, 18, 138], [101, 38, 60, 138, 55, 70, 43, 26, 142], [146, 36, 19, 30, 171, 255, 97, 27, 20], [138, 45, 61, 62, 219, 1, 81, 188, 64], [32, 41, 20, 117, 151, 142, 20, 21, 163], [112, 19, 12, 61, 195, 128, 48, 4, 24]]], ui = [[[[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[176, 246, 255, 255, 255, 255, 255, 255, 255, 255, 255], [223, 241, 252, 255, 255, 255, 255, 255, 255, 255, 255], [249, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 244, 252, 255, 255, 255, 255, 255, 255, 255, 255], [234, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [253, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 246, 254, 255, 255, 255, 255, 255, 255, 255, 255], [239, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 248, 254, 255, 255, 255, 255, 255, 255, 255, 255], [251, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [251, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 254, 253, 255, 254, 255, 255, 255, 255, 255, 255], [250, 255, 254, 255, 254, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]]], [[[217, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [225, 252, 241, 253, 255, 255, 254, 255, 255, 255, 255], [234, 250, 241, 250, 253, 255, 253, 254, 255, 255, 255]], [[255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [223, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [238, 253, 254, 254, 255, 255, 255, 255, 255, 255, 255]], [[255, 248, 254, 255, 255, 255, 255, 255, 255, 255, 255], [249, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 253, 255, 255, 255, 255, 255, 255, 255, 255, 255], [247, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [252, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [253, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 254, 253, 255, 255, 255, 255, 255, 255, 255, 255], [250, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]]], [[[186, 251, 250, 255, 255, 255, 255, 255, 255, 255, 255], [234, 251, 244, 254, 255, 255, 255, 255, 255, 255, 255], [251, 251, 243, 253, 254, 255, 254, 255, 255, 255, 255]], [[255, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [236, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [251, 253, 253, 254, 254, 255, 255, 255, 255, 255, 255]], [[255, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [254, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]]], [[[248, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [250, 254, 252, 254, 255, 255, 255, 255, 255, 255, 255], [248, 254, 249, 253, 255, 255, 255, 255, 255, 255, 255]], [[255, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255], [246, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255], [252, 254, 251, 254, 254, 255, 255, 255, 255, 255, 255]], [[255, 254, 252, 255, 255, 255, 255, 255, 255, 255, 255], [248, 254, 253, 255, 255, 255, 255, 255, 255, 255, 255], [253, 255, 254, 254, 255, 255, 255, 255, 255, 255, 255]], [[255, 251, 254, 255, 255, 255, 255, 255, 255, 255, 255], [245, 251, 254, 255, 255, 255, 255, 255, 255, 255, 255], [253, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 251, 253, 255, 255, 255, 255, 255, 255, 255, 255], [252, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 252, 255, 255, 255, 255, 255, 255, 255, 255, 255], [249, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 253, 255, 255, 255, 255, 255, 255, 255, 255], [250, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]]]], hi = [0, 1, 2, 3, 6, 4, 5, 6, 6, 6, 6, 6, 6, 6, 6, 7, 0], li = [], fi = [], di = [], pi = 1, gi = 2, mi = [], vi = [];
    vr("UpsampleRgbLinePair", Ar, 3), vr("UpsampleBgrLinePair", xr, 3), vr("UpsampleRgbaLinePair", Ir, 4), vr("UpsampleBgraLinePair", kr, 4), vr("UpsampleArgbLinePair", Pr, 4), vr("UpsampleRgba4444LinePair", _r, 2), vr("UpsampleRgb565LinePair", Sr, 2);
    var { UpsampleRgbLinePair: bi, UpsampleBgrLinePair: yi, UpsampleRgbaLinePair: wi, UpsampleBgraLinePair: Ni, UpsampleArgbLinePair: Li, UpsampleRgba4444LinePair: Ai, UpsampleRgb565LinePair: xi } = t4, Si = 16, _i = 1 << Si - 1, Pi = -227, ki = 482, Ii = 6, Fi = (256 << Ii) - 1, Ci = 0, ji = a3(256), Oi = a3(256), Bi = a3(256), Mi = a3(256), Ei = a3(ki - Pi), qi = a3(ki - Pi);
    Fr("YuvToRgbRow", Ar, 3), Fr("YuvToBgrRow", xr, 3), Fr("YuvToRgbaRow", Ir, 4), Fr("YuvToBgraRow", kr, 4), Fr("YuvToArgbRow", Pr, 4), Fr("YuvToRgba4444Row", _r, 2), Fr("YuvToRgb565Row", Sr, 2);
    var Di = [0, 4, 8, 12, 128, 132, 136, 140, 256, 260, 264, 268, 384, 388, 392, 396], Ri = [0, 2, 8], Ti = [8, 7, 6, 4, 4, 2, 2, 2, 1, 1, 1, 1], Ui = 1;
    this.WebPDecodeRGBA = function(t5, r3, n4, i6, a4) {
      var o4 = qn, s4 = new rr, c6 = new ot2;
      s4.ba = c6, c6.S = o4, c6.width = [c6.width], c6.height = [c6.height];
      var { width: u5, height: h5 } = c6, l5 = new st2;
      if (l5 == null || t5 == null)
        var f5 = 2;
      else
        e2(l5 != null), f5 = Br(t5, r3, n4, l5.width, l5.height, l5.Pd, l5.Qd, l5.format, null);
      if (f5 != 0 ? u5 = 0 : (u5 != null && (u5[0] = l5.width[0]), h5 != null && (h5[0] = l5.height[0]), u5 = 1), u5) {
        c6.width = c6.width[0], c6.height = c6.height[0], i6 != null && (i6[0] = c6.width), a4 != null && (a4[0] = c6.height);
        t: {
          if (i6 = new Gt2, (a4 = new nr).data = t5, a4.w = r3, a4.ha = n4, a4.kd = 1, r3 = [0], e2(a4 != null), ((t5 = Br(a4.data, a4.w, a4.ha, null, null, null, r3, null, a4)) == 0 || t5 == 7) && r3[0] && (t5 = 4), (r3 = t5) == 0) {
            if (e2(s4 != null), i6.data = a4.data, i6.w = a4.w + a4.offset, i6.ha = a4.ha - a4.offset, i6.put = dt2, i6.ac = ft2, i6.bc = pt2, i6.ma = s4, a4.xa) {
              if ((t5 = kt2()) == null) {
                s4 = 1;
                break t;
              }
              if (function(t6, r4) {
                var n5 = [0], i7 = [0], a5 = [0];
                e:
                  for (;; ) {
                    if (t6 == null)
                      return 0;
                    if (r4 == null)
                      return t6.a = 2, 0;
                    if (t6.l = r4, t6.a = 0, v4(t6.m, r4.data, r4.w, r4.ha), !gt2(t6.m, n5, i7, a5)) {
                      t6.a = 3;
                      break e;
                    }
                    if (t6.xb = gi, r4.width = n5[0], r4.height = i7[0], !It2(n5[0], i7[0], 1, t6, null))
                      break e;
                    return 1;
                  }
                return e2(t6.a != 0), 0;
              }(t5, i6)) {
                if (i6 = (r3 = qr(i6.width, i6.height, s4.Oa, s4.ba)) == 0) {
                  e: {
                    i6 = t5;
                    r:
                      for (;; ) {
                        if (i6 == null) {
                          i6 = 0;
                          break e;
                        }
                        if (e2(i6.s.yc != null), e2(i6.s.Ya != null), e2(0 < i6.s.Wb), e2((n4 = i6.l) != null), e2((a4 = n4.ma) != null), i6.xb != 0) {
                          if (i6.ca = a4.ba, i6.tb = a4.tb, e2(i6.ca != null), !Mr(a4.Oa, n4, Rn)) {
                            i6.a = 2;
                            break r;
                          }
                          if (!Ft2(i6, n4.width))
                            break r;
                          if (n4.da)
                            break r;
                          if ((n4.da || nt2(i6.ca.S)) && mr(), 11 > i6.ca.S || (alert("todo:WebPInitConvertARGBToYUV"), i6.ca.f.kb.F != null && mr()), i6.Pb && 0 < i6.s.ua && i6.s.vb.X == null && !O3(i6.s.vb, i6.s.Wa.Xa)) {
                            i6.a = 1;
                            break r;
                          }
                          i6.xb = 0;
                        }
                        if (!_t2(i6, i6.V, i6.Ba, i6.c, i6.i, n4.o, Lt2))
                          break r;
                        a4.Dc = i6.Ma, i6 = 1;
                        break e;
                      }
                    e2(i6.a != 0), i6 = 0;
                  }
                  i6 = !i6;
                }
                i6 && (r3 = t5.a);
              } else
                r3 = t5.a;
            } else {
              if ((t5 = new Yt2) == null) {
                s4 = 1;
                break t;
              }
              if (t5.Fa = a4.na, t5.P = a4.P, t5.qc = a4.Sa, Kt2(t5, i6)) {
                if ((r3 = qr(i6.width, i6.height, s4.Oa, s4.ba)) == 0) {
                  if (t5.Aa = 0, n4 = s4.Oa, e2((a4 = t5) != null), n4 != null) {
                    if (0 < (u5 = 0 > (u5 = n4.Md) ? 0 : 100 < u5 ? 255 : 255 * u5 / 100)) {
                      for (h5 = l5 = 0;4 > h5; ++h5)
                        12 > (f5 = a4.pb[h5]).lc && (f5.ia = u5 * Ti[0 > f5.lc ? 0 : f5.lc] >> 3), l5 |= f5.ia;
                      l5 && (alert("todo:VP8InitRandom"), a4.ia = 1);
                    }
                    a4.Ga = n4.Id, 100 < a4.Ga ? a4.Ga = 100 : 0 > a4.Ga && (a4.Ga = 0);
                  }
                  Qt2(t5, i6) || (r3 = t5.a);
                }
              } else
                r3 = t5.a;
            }
            r3 == 0 && s4.Oa != null && s4.Oa.fd && (r3 = Er(s4.ba));
          }
          s4 = r3;
        }
        o4 = s4 != 0 ? null : 11 > o4 ? c6.f.RGBA.eb : c6.f.kb.y;
      } else
        o4 = null;
      return o4;
    };
    var zi = [3, 4, 3, 4, 4, 2, 2, 4, 4, 4, 2, 1, 1];
  };
  function u3(t4, e3) {
    for (var r3 = "", n4 = 0;n4 < 4; n4++)
      r3 += String.fromCharCode(t4[e3++]);
    return r3;
  }
  function h3(t4, e3) {
    return (t4[e3 + 0] << 0 | t4[e3 + 1] << 8 | t4[e3 + 2] << 16) >>> 0;
  }
  function l3(t4, e3) {
    return (t4[e3 + 0] << 0 | t4[e3 + 1] << 8 | t4[e3 + 2] << 16 | t4[e3 + 3] << 24) >>> 0;
  }
  new c4;
  var f3 = [0], d2 = [0], p3 = [], g2 = new c4, m4 = t3, v3 = function(t4, e3) {
    var r3 = {}, n4 = 0, i6 = false, a4 = 0, o4 = 0;
    if (r3.frames = [], !function(t5, e4, r4, n5) {
      for (var i7 = 0;i7 < n5; i7++)
        if (t5[e4 + i7] != r4.charCodeAt(i7))
          return true;
      return false;
    }(t4, e3, "RIFF", 4)) {
      var s4, c5;
      l3(t4, e3 += 4);
      for (e3 += 8;e3 < t4.length; ) {
        var f4 = u3(t4, e3), d3 = l3(t4, e3 += 4);
        e3 += 4;
        var p4 = d3 + (1 & d3);
        switch (f4) {
          case "VP8 ":
          case "VP8L":
            r3.frames[n4] === undefined && (r3.frames[n4] = {});
            (v4 = r3.frames[n4]).src_off = i6 ? o4 : e3 - 8, v4.src_size = a4 + d3 + 8, n4++, i6 && (i6 = false, a4 = 0, o4 = 0);
            break;
          case "VP8X":
            (v4 = r3.header = {}).feature_flags = t4[e3];
            var g3 = e3 + 4;
            v4.canvas_width = 1 + h3(t4, g3);
            g3 += 3;
            v4.canvas_height = 1 + h3(t4, g3);
            g3 += 3;
            break;
          case "ALPH":
            i6 = true, a4 = p4 + 8, o4 = e3 - 8;
            break;
          case "ANIM":
            (v4 = r3.header).bgcolor = l3(t4, e3);
            g3 = e3 + 4;
            v4.loop_count = (s4 = t4)[(c5 = g3) + 0] << 0 | s4[c5 + 1] << 8;
            g3 += 2;
            break;
          case "ANMF":
            var m5, v4;
            (v4 = r3.frames[n4] = {}).offset_x = 2 * h3(t4, e3), e3 += 3, v4.offset_y = 2 * h3(t4, e3), e3 += 3, v4.width = 1 + h3(t4, e3), e3 += 3, v4.height = 1 + h3(t4, e3), e3 += 3, v4.duration = h3(t4, e3), e3 += 3, m5 = t4[e3++], v4.dispose = 1 & m5, v4.blend = m5 >> 1 & 1;
        }
        f4 != "ANMF" && (e3 += p4);
      }
      return r3;
    }
  }(m4, 0);
  v3.response = m4, v3.rgbaoutput = true, v3.dataurl = false;
  var b2 = v3.header ? v3.header : null, y3 = v3.frames ? v3.frames : null;
  if (b2) {
    b2.loop_counter = b2.loop_count, f3 = [b2.canvas_height], d2 = [b2.canvas_width];
    for (var w2 = 0;w2 < y3.length && y3[w2].blend != 0; w2++)
      ;
  }
  var N3 = y3[0], L2 = g2.WebPDecodeRGBA(m4, N3.src_off, N3.src_size, d2, f3);
  N3.rgba = L2, N3.imgwidth = d2[0], N3.imgheight = f3[0];
  for (var A2 = 0;A2 < d2[0] * f3[0] * 4; A2++)
    p3[A2] = L2[A2];
  return this.width = d2, this.height = f3, this.data = p3, this;
}
var n2, a2, u2, h2, l2, N2, S, k, q, D = 1, R = function(t2) {
  return t2.replace(/\\/g, "\\\\").replace(/\(/g, "\\(").replace(/\)/g, "\\)");
}, T2 = function(t2) {
  return t2.replace(/\\\\/g, "\\").replace(/\\\(/g, "(").replace(/\\\)/g, ")");
}, U = function(t2) {
  return t2.toFixed(2);
}, z = function(t2) {
  return t2.toFixed(5);
}, H = function(t2, e2) {
  t2.prototype = Object.create(e2.prototype), t2.prototype.constructor = t2;
}, W = function(t2) {
  return t2 * D;
}, V = function(t2) {
  var e2 = new ut, r2 = At.internal.getHeight(t2) || 0, n3 = At.internal.getWidth(t2) || 0;
  return e2.BBox = [0, 0, Number(U(n3)), Number(U(r2))], e2;
}, G, Y, J, X, K, Z, $, Q = function(t2) {
  if (t2.appearanceStreamContent)
    return t2.appearanceStreamContent;
  if (t2.V || t2.DV) {
    var e2 = [], r2 = t2._V || t2.DV, n3 = tt(t2, r2), i5 = t2.scope.internal.getFont(t2.fontName, t2.fontStyle).id;
    e2.push("/Tx BMC"), e2.push("q"), e2.push("BT"), e2.push(t2.scope.__private__.encodeColorString(t2.color)), e2.push("/" + i5 + " " + U(n3.fontSize) + " Tf"), e2.push("1 0 0 1 0 0 Tm"), e2.push(n3.text), e2.push("ET"), e2.push("Q"), e2.push("EMC");
    var a3 = V(t2);
    return a3.scope = t2.scope, a3.stream = e2.join(`
`), a3;
  }
}, tt = function(t2, e2) {
  var r2 = t2.fontSize === 0 ? t2.maxFontSize : t2.fontSize, n3 = { text: "", fontSize: "" }, i5 = (e2 = (e2 = e2.substr(0, 1) == "(" ? e2.substr(1) : e2).substr(e2.length - 1) == ")" ? e2.substr(0, e2.length - 1) : e2).split(" ");
  i5 = t2.multiline ? i5.map(function(t3) {
    return t3.split(`
`);
  }) : i5.map(function(t3) {
    return [t3];
  });
  var a3 = r2, o3 = At.internal.getHeight(t2) || 0;
  o3 = o3 < 0 ? -o3 : o3;
  var s3 = At.internal.getWidth(t2) || 0;
  s3 = s3 < 0 ? -s3 : s3;
  var c4 = function(e3, r3, n4) {
    if (e3 + 1 < i5.length) {
      var a4 = r3 + " " + i5[e3 + 1][0];
      return et2(a4, t2, n4).width <= s3 - 4;
    }
    return false;
  };
  a3++;
  t:
    for (;a3 > 0; ) {
      e2 = "", a3--;
      var u3, h3, l3 = et2("3", t2, a3).height, f3 = t2.multiline ? o3 - a3 : (o3 - l3) / 2, d2 = f3 += 2, p3 = 0, g2 = 0, m4 = 0;
      if (a3 <= 0) {
        e2 = `(...) Tj
`, e2 += "% Width of Text: " + et2(e2, t2, a3 = 12).width + ", FieldWidth:" + s3 + `
`;
        break;
      }
      for (var v3 = "", b2 = 0, y3 = 0;y3 < i5.length; y3++)
        if (i5.hasOwnProperty(y3)) {
          var w2 = false;
          if (i5[y3].length !== 1 && m4 !== i5[y3].length - 1) {
            if ((l3 + 2) * (b2 + 2) + 2 > o3)
              continue t;
            v3 += i5[y3][m4], w2 = true, g2 = y3, y3--;
          } else {
            v3 = (v3 += i5[y3][m4] + " ").substr(v3.length - 1) == " " ? v3.substr(0, v3.length - 1) : v3;
            var N3 = parseInt(y3), L2 = c4(N3, v3, a3), A2 = y3 >= i5.length - 1;
            if (L2 && !A2) {
              v3 += " ", m4 = 0;
              continue;
            }
            if (L2 || A2) {
              if (A2)
                g2 = N3;
              else if (t2.multiline && (l3 + 2) * (b2 + 2) + 2 > o3)
                continue t;
            } else {
              if (!t2.multiline)
                continue t;
              if ((l3 + 2) * (b2 + 2) + 2 > o3)
                continue t;
              g2 = N3;
            }
          }
          for (var x3 = "", S2 = p3;S2 <= g2; S2++) {
            var _3 = i5[S2];
            if (t2.multiline) {
              if (S2 === g2) {
                x3 += _3[m4] + " ", m4 = (m4 + 1) % _3.length;
                continue;
              }
              if (S2 === p3) {
                x3 += _3[_3.length - 1] + " ";
                continue;
              }
            }
            x3 += _3[0] + " ";
          }
          switch (x3 = x3.substr(x3.length - 1) == " " ? x3.substr(0, x3.length - 1) : x3, h3 = et2(x3, t2, a3).width, t2.textAlign) {
            case "right":
              u3 = s3 - h3 - 2;
              break;
            case "center":
              u3 = (s3 - h3) / 2;
              break;
            case "left":
            default:
              u3 = 2;
          }
          e2 += U(u3) + " " + U(d2) + ` Td
`, e2 += "(" + R(x3) + `) Tj
`, e2 += -U(u3) + ` 0 Td
`, d2 = -(a3 + 2), h3 = 0, p3 = w2 ? g2 : g2 + 1, b2++, v3 = "";
        } else
          ;
      break;
    }
  return n3.text = e2, n3.fontSize = a3, n3;
}, et2 = function(t2, e2, r2) {
  var n3 = e2.scope.internal.getFont(e2.fontName, e2.fontStyle), i5 = e2.scope.getStringUnitWidth(t2, { font: n3, fontSize: parseFloat(r2), charSpace: 0 }) * parseFloat(r2);
  return { height: e2.scope.getStringUnitWidth("3", { font: n3, fontSize: parseFloat(r2), charSpace: 0 }) * parseFloat(r2) * 1.5, width: i5 };
}, rt, nt = function(t2, e2) {
  var r2 = { type: "reference", object: t2 };
  e2.internal.getPageInfo(t2.page).pageContext.annotations.find(function(t3) {
    return t3.type === r2.type && t3.object === r2.object;
  }) === undefined && e2.internal.getPageInfo(t2.page).pageContext.annotations.push(r2);
}, it = function(e2, r2) {
  for (var n3 in e2)
    if (e2.hasOwnProperty(n3)) {
      var i5 = n3, a3 = e2[n3];
      r2.internal.newObjectDeferredBegin(a3.objId, true), _typeof(a3) === "object" && typeof a3.putStream == "function" && a3.putStream(), delete e2[i5];
    }
}, at = function(e2, r2) {
  if (r2.scope = e2, e2.internal !== undefined && (e2.internal.acroformPlugin === undefined || e2.internal.acroformPlugin.isInitialized === false)) {
    if (lt.FieldNum = 0, e2.internal.acroformPlugin = JSON.parse(JSON.stringify(rt)), e2.internal.acroformPlugin.acroFormDictionaryRoot)
      throw new Error("Exception while creating AcroformDictionary");
    D = e2.internal.scaleFactor, e2.internal.acroformPlugin.acroFormDictionaryRoot = new ht, e2.internal.acroformPlugin.acroFormDictionaryRoot.scope = e2, e2.internal.acroformPlugin.acroFormDictionaryRoot._eventID = e2.internal.events.subscribe("postPutResources", function() {
      (function(t2) {
        t2.internal.events.unsubscribe(t2.internal.acroformPlugin.acroFormDictionaryRoot._eventID), delete t2.internal.acroformPlugin.acroFormDictionaryRoot._eventID, t2.internal.acroformPlugin.printedOut = true;
      })(e2);
    }), e2.internal.events.subscribe("buildDocument", function() {
      (function(t2) {
        t2.internal.acroformPlugin.acroFormDictionaryRoot.objId = undefined;
        var e3 = t2.internal.acroformPlugin.acroFormDictionaryRoot.Fields;
        for (var r3 in e3)
          if (e3.hasOwnProperty(r3)) {
            var n3 = e3[r3];
            n3.objId = undefined, n3.hasAnnotation && nt(n3, t2);
          }
      })(e2);
    }), e2.internal.events.subscribe("putCatalog", function() {
      (function(t2) {
        if (t2.internal.acroformPlugin.acroFormDictionaryRoot === undefined)
          throw new Error("putCatalogCallback: Root missing.");
        t2.internal.write("/AcroForm " + t2.internal.acroformPlugin.acroFormDictionaryRoot.objId + " 0 R");
      })(e2);
    }), e2.internal.events.subscribe("postPutPages", function(r3) {
      (function(e3, r4) {
        var n3 = !e3;
        for (var i5 in e3 || (r4.internal.newObjectDeferredBegin(r4.internal.acroformPlugin.acroFormDictionaryRoot.objId, true), r4.internal.acroformPlugin.acroFormDictionaryRoot.putStream()), e3 = e3 || r4.internal.acroformPlugin.acroFormDictionaryRoot.Kids)
          if (e3.hasOwnProperty(i5)) {
            var a3 = e3[i5], o3 = [], s3 = a3.Rect;
            if (a3.Rect && (a3.Rect = $(a3.Rect, r4)), r4.internal.newObjectDeferredBegin(a3.objId, true), a3.DA = At.createDefaultAppearanceStream(a3), _typeof(a3) === "object" && typeof a3.getKeyValueListForStream == "function" && (o3 = a3.getKeyValueListForStream()), a3.Rect = s3, a3.hasAppearanceStream && !a3.appearanceStreamContent) {
              var c4 = Q(a3);
              o3.push({ key: "AP", value: "<</N " + c4 + ">>" }), r4.internal.acroformPlugin.xForms.push(c4);
            }
            if (a3.appearanceStreamContent) {
              var u3 = "";
              for (var h3 in a3.appearanceStreamContent)
                if (a3.appearanceStreamContent.hasOwnProperty(h3)) {
                  var l3 = a3.appearanceStreamContent[h3];
                  if (u3 += "/" + h3 + " ", u3 += "<<", Object.keys(l3).length >= 1 || Array.isArray(l3)) {
                    for (var i5 in l3)
                      if (l3.hasOwnProperty(i5)) {
                        var f3 = l3[i5];
                        typeof f3 == "function" && (f3 = f3.call(r4, a3)), u3 += "/" + i5 + " " + f3 + " ", r4.internal.acroformPlugin.xForms.indexOf(f3) >= 0 || r4.internal.acroformPlugin.xForms.push(f3);
                      }
                  } else
                    typeof (f3 = l3) == "function" && (f3 = f3.call(r4, a3)), u3 += "/" + i5 + " " + f3, r4.internal.acroformPlugin.xForms.indexOf(f3) >= 0 || r4.internal.acroformPlugin.xForms.push(f3);
                  u3 += ">>";
                }
              o3.push({ key: "AP", value: `<<
` + u3 + ">>" });
            }
            r4.internal.putStream({ additionalKeyValues: o3, objectId: a3.objId }), r4.internal.out("endobj");
          }
        n3 && it(r4.internal.acroformPlugin.xForms, r4);
      })(r3, e2);
    }), e2.internal.acroformPlugin.isInitialized = true;
  }
}, ot, st = function(t2, e2, r2) {
  var n3 = function(t3) {
    return t3;
  };
  return e2 !== undefined && r2 && (n3 = r2.internal.getEncryptor(e2)), (t2 = t2 || "").toString(), t2 = "(" + R(n3(t2)) + ")";
}, ct = function() {
  this._objId = undefined, this._scope = undefined, Object.defineProperty(this, "objId", { get: function() {
    if (this._objId === undefined) {
      if (this.scope === undefined)
        return;
      this._objId = this.scope.internal.newObjectDeferred();
    }
    return this._objId;
  }, set: function(t2) {
    this._objId = t2;
  } }), Object.defineProperty(this, "scope", { value: this._scope, writable: true });
}, ut = function() {
  ct.call(this), Object.defineProperty(this, "Type", { value: "/XObject", configurable: false, writable: true }), Object.defineProperty(this, "Subtype", { value: "/Form", configurable: false, writable: true }), Object.defineProperty(this, "FormType", { value: 1, configurable: false, writable: true });
  var t2, e2 = [];
  Object.defineProperty(this, "BBox", { configurable: false, get: function() {
    return e2;
  }, set: function(t3) {
    e2 = t3;
  } }), Object.defineProperty(this, "Resources", { value: "2 0 R", configurable: false, writable: true }), Object.defineProperty(this, "stream", { enumerable: false, configurable: true, set: function(e3) {
    t2 = e3.trim();
  }, get: function() {
    return t2 || null;
  } });
}, ht = function() {
  ct.call(this);
  var t2, e2 = [];
  Object.defineProperty(this, "Kids", { enumerable: false, configurable: true, get: function() {
    return e2.length > 0 ? e2 : undefined;
  } }), Object.defineProperty(this, "Fields", { enumerable: false, configurable: false, get: function() {
    return e2;
  } }), Object.defineProperty(this, "DA", { enumerable: false, configurable: false, get: function() {
    if (t2) {
      var e3 = function(t3) {
        return t3;
      };
      return this.scope && (e3 = this.scope.internal.getEncryptor(this.objId)), "(" + R(e3(t2)) + ")";
    }
  }, set: function(e3) {
    t2 = e3;
  } });
}, lt = function t2() {
  ct.call(this);
  var e2 = 4;
  Object.defineProperty(this, "F", { enumerable: false, configurable: false, get: function() {
    return e2;
  }, set: function(t3) {
    if (isNaN(t3))
      throw new Error('Invalid value "' + t3 + '" for attribute F supplied.');
    e2 = t3;
  } }), Object.defineProperty(this, "showWhenPrinted", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(e2, 3));
  }, set: function(t3) {
    Boolean(t3) === true ? this.F = K(e2, 3) : this.F = Z(e2, 3);
  } });
  var r2 = 0;
  Object.defineProperty(this, "Ff", { enumerable: false, configurable: false, get: function() {
    return r2;
  }, set: function(t3) {
    if (isNaN(t3))
      throw new Error('Invalid value "' + t3 + '" for attribute Ff supplied.');
    r2 = t3;
  } });
  var n3 = [];
  Object.defineProperty(this, "Rect", { enumerable: false, configurable: false, get: function() {
    if (n3.length !== 0)
      return n3;
  }, set: function(t3) {
    n3 = t3 !== undefined ? t3 : [];
  } }), Object.defineProperty(this, "x", { enumerable: true, configurable: true, get: function() {
    return !n3 || isNaN(n3[0]) ? 0 : n3[0];
  }, set: function(t3) {
    n3[0] = t3;
  } }), Object.defineProperty(this, "y", { enumerable: true, configurable: true, get: function() {
    return !n3 || isNaN(n3[1]) ? 0 : n3[1];
  }, set: function(t3) {
    n3[1] = t3;
  } }), Object.defineProperty(this, "width", { enumerable: true, configurable: true, get: function() {
    return !n3 || isNaN(n3[2]) ? 0 : n3[2];
  }, set: function(t3) {
    n3[2] = t3;
  } }), Object.defineProperty(this, "height", { enumerable: true, configurable: true, get: function() {
    return !n3 || isNaN(n3[3]) ? 0 : n3[3];
  }, set: function(t3) {
    n3[3] = t3;
  } });
  var i5 = "";
  Object.defineProperty(this, "FT", { enumerable: true, configurable: false, get: function() {
    return i5;
  }, set: function(t3) {
    switch (t3) {
      case "/Btn":
      case "/Tx":
      case "/Ch":
      case "/Sig":
        i5 = t3;
        break;
      default:
        throw new Error('Invalid value "' + t3 + '" for attribute FT supplied.');
    }
  } });
  var a3 = null;
  Object.defineProperty(this, "T", { enumerable: true, configurable: false, get: function() {
    if (!a3 || a3.length < 1) {
      if (this instanceof yt)
        return;
      a3 = "FieldObject" + t2.FieldNum++;
    }
    var e3 = function(t3) {
      return t3;
    };
    return this.scope && (e3 = this.scope.internal.getEncryptor(this.objId)), "(" + R(e3(a3)) + ")";
  }, set: function(t3) {
    a3 = t3.toString();
  } }), Object.defineProperty(this, "fieldName", { configurable: true, enumerable: true, get: function() {
    return a3;
  }, set: function(t3) {
    a3 = t3;
  } });
  var o3 = "helvetica";
  Object.defineProperty(this, "fontName", { enumerable: true, configurable: true, get: function() {
    return o3;
  }, set: function(t3) {
    o3 = t3;
  } });
  var s3 = "normal";
  Object.defineProperty(this, "fontStyle", { enumerable: true, configurable: true, get: function() {
    return s3;
  }, set: function(t3) {
    s3 = t3;
  } });
  var c4 = 0;
  Object.defineProperty(this, "fontSize", { enumerable: true, configurable: true, get: function() {
    return c4;
  }, set: function(t3) {
    c4 = t3;
  } });
  var u3 = undefined;
  Object.defineProperty(this, "maxFontSize", { enumerable: true, configurable: true, get: function() {
    return u3 === undefined ? 50 / D : u3;
  }, set: function(t3) {
    u3 = t3;
  } });
  var h3 = "black";
  Object.defineProperty(this, "color", { enumerable: true, configurable: true, get: function() {
    return h3;
  }, set: function(t3) {
    h3 = t3;
  } });
  var l3 = "/F1 0 Tf 0 g";
  Object.defineProperty(this, "DA", { enumerable: true, configurable: false, get: function() {
    if (!(!l3 || this instanceof yt || this instanceof Nt))
      return st(l3, this.objId, this.scope);
  }, set: function(t3) {
    t3 = t3.toString(), l3 = t3;
  } });
  var f3 = null;
  Object.defineProperty(this, "DV", { enumerable: false, configurable: false, get: function() {
    if (f3)
      return this instanceof mt == false ? st(f3, this.objId, this.scope) : f3;
  }, set: function(t3) {
    t3 = t3.toString(), f3 = this instanceof mt == false ? t3.substr(0, 1) === "(" ? T2(t3.substr(1, t3.length - 2)) : T2(t3) : t3;
  } }), Object.defineProperty(this, "defaultValue", { enumerable: true, configurable: true, get: function() {
    return this instanceof mt == true ? T2(f3.substr(1, f3.length - 1)) : f3;
  }, set: function(t3) {
    t3 = t3.toString(), f3 = this instanceof mt == true ? "/" + t3 : t3;
  } });
  var d2 = null;
  Object.defineProperty(this, "_V", { enumerable: false, configurable: false, get: function() {
    if (d2)
      return d2;
  }, set: function(t3) {
    this.V = t3;
  } }), Object.defineProperty(this, "V", { enumerable: false, configurable: false, get: function() {
    if (d2)
      return this instanceof mt == false ? st(d2, this.objId, this.scope) : d2;
  }, set: function(t3) {
    t3 = t3.toString(), d2 = this instanceof mt == false ? t3.substr(0, 1) === "(" ? T2(t3.substr(1, t3.length - 2)) : T2(t3) : t3;
  } }), Object.defineProperty(this, "value", { enumerable: true, configurable: true, get: function() {
    return this instanceof mt == true ? T2(d2.substr(1, d2.length - 1)) : d2;
  }, set: function(t3) {
    t3 = t3.toString(), d2 = this instanceof mt == true ? "/" + t3 : t3;
  } }), Object.defineProperty(this, "hasAnnotation", { enumerable: true, configurable: true, get: function() {
    return this.Rect;
  } }), Object.defineProperty(this, "Type", { enumerable: true, configurable: false, get: function() {
    return this.hasAnnotation ? "/Annot" : null;
  } }), Object.defineProperty(this, "Subtype", { enumerable: true, configurable: false, get: function() {
    return this.hasAnnotation ? "/Widget" : null;
  } });
  var p3, g2 = false;
  Object.defineProperty(this, "hasAppearanceStream", { enumerable: true, configurable: true, get: function() {
    return g2;
  }, set: function(t3) {
    t3 = Boolean(t3), g2 = t3;
  } }), Object.defineProperty(this, "page", { enumerable: true, configurable: true, get: function() {
    if (p3)
      return p3;
  }, set: function(t3) {
    p3 = t3;
  } }), Object.defineProperty(this, "readOnly", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 1));
  }, set: function(t3) {
    Boolean(t3) === true ? this.Ff = K(this.Ff, 1) : this.Ff = Z(this.Ff, 1);
  } }), Object.defineProperty(this, "required", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 2));
  }, set: function(t3) {
    Boolean(t3) === true ? this.Ff = K(this.Ff, 2) : this.Ff = Z(this.Ff, 2);
  } }), Object.defineProperty(this, "noExport", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 3));
  }, set: function(t3) {
    Boolean(t3) === true ? this.Ff = K(this.Ff, 3) : this.Ff = Z(this.Ff, 3);
  } });
  var m4 = null;
  Object.defineProperty(this, "Q", { enumerable: true, configurable: false, get: function() {
    if (m4 !== null)
      return m4;
  }, set: function(t3) {
    if ([0, 1, 2].indexOf(t3) === -1)
      throw new Error('Invalid value "' + t3 + '" for attribute Q supplied.');
    m4 = t3;
  } }), Object.defineProperty(this, "textAlign", { get: function() {
    var t3;
    switch (m4) {
      case 0:
      default:
        t3 = "left";
        break;
      case 1:
        t3 = "center";
        break;
      case 2:
        t3 = "right";
    }
    return t3;
  }, configurable: true, enumerable: true, set: function(t3) {
    switch (t3) {
      case "right":
      case 2:
        m4 = 2;
        break;
      case "center":
      case 1:
        m4 = 1;
        break;
      case "left":
      case 0:
      default:
        m4 = 0;
    }
  } });
}, ft = function() {
  lt.call(this), this.FT = "/Ch", this.V = "()", this.fontName = "zapfdingbats";
  var t3 = 0;
  Object.defineProperty(this, "TI", { enumerable: true, configurable: false, get: function() {
    return t3;
  }, set: function(e3) {
    t3 = e3;
  } }), Object.defineProperty(this, "topIndex", { enumerable: true, configurable: true, get: function() {
    return t3;
  }, set: function(e3) {
    t3 = e3;
  } });
  var e2 = [];
  Object.defineProperty(this, "Opt", { enumerable: true, configurable: false, get: function() {
    return ot(e2, this.objId, this.scope);
  }, set: function(t4) {
    var r2, n3;
    n3 = [], typeof (r2 = t4) == "string" && (n3 = function(t5, e3, r3) {
      r3 || (r3 = 1);
      for (var n4, i5 = [];n4 = e3.exec(t5); )
        i5.push(n4[r3]);
      return i5;
    }(r2, /\((.*?)\)/g)), e2 = n3;
  } }), this.getOptions = function() {
    return e2;
  }, this.setOptions = function(t4) {
    e2 = t4, this.sort && e2.sort();
  }, this.addOption = function(t4) {
    t4 = (t4 = t4 || "").toString(), e2.push(t4), this.sort && e2.sort();
  }, this.removeOption = function(t4, r2) {
    for (r2 = r2 || false, t4 = (t4 = t4 || "").toString();e2.indexOf(t4) !== -1 && (e2.splice(e2.indexOf(t4), 1), r2 !== false); )
      ;
  }, Object.defineProperty(this, "combo", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 18));
  }, set: function(t4) {
    Boolean(t4) === true ? this.Ff = K(this.Ff, 18) : this.Ff = Z(this.Ff, 18);
  } }), Object.defineProperty(this, "edit", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 19));
  }, set: function(t4) {
    this.combo === true && (Boolean(t4) === true ? this.Ff = K(this.Ff, 19) : this.Ff = Z(this.Ff, 19));
  } }), Object.defineProperty(this, "sort", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 20));
  }, set: function(t4) {
    Boolean(t4) === true ? (this.Ff = K(this.Ff, 20), e2.sort()) : this.Ff = Z(this.Ff, 20);
  } }), Object.defineProperty(this, "multiSelect", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 22));
  }, set: function(t4) {
    Boolean(t4) === true ? this.Ff = K(this.Ff, 22) : this.Ff = Z(this.Ff, 22);
  } }), Object.defineProperty(this, "doNotSpellCheck", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 23));
  }, set: function(t4) {
    Boolean(t4) === true ? this.Ff = K(this.Ff, 23) : this.Ff = Z(this.Ff, 23);
  } }), Object.defineProperty(this, "commitOnSelChange", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 27));
  }, set: function(t4) {
    Boolean(t4) === true ? this.Ff = K(this.Ff, 27) : this.Ff = Z(this.Ff, 27);
  } }), this.hasAppearanceStream = false;
}, dt = function() {
  ft.call(this), this.fontName = "helvetica", this.combo = false;
}, pt = function() {
  dt.call(this), this.combo = true;
}, gt = function() {
  pt.call(this), this.edit = true;
}, mt = function() {
  lt.call(this), this.FT = "/Btn", Object.defineProperty(this, "noToggleToOff", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 15));
  }, set: function(t3) {
    Boolean(t3) === true ? this.Ff = K(this.Ff, 15) : this.Ff = Z(this.Ff, 15);
  } }), Object.defineProperty(this, "radio", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 16));
  }, set: function(t3) {
    Boolean(t3) === true ? this.Ff = K(this.Ff, 16) : this.Ff = Z(this.Ff, 16);
  } }), Object.defineProperty(this, "pushButton", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 17));
  }, set: function(t3) {
    Boolean(t3) === true ? this.Ff = K(this.Ff, 17) : this.Ff = Z(this.Ff, 17);
  } }), Object.defineProperty(this, "radioIsUnison", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 26));
  }, set: function(t3) {
    Boolean(t3) === true ? this.Ff = K(this.Ff, 26) : this.Ff = Z(this.Ff, 26);
  } });
  var e2, r2 = {};
  Object.defineProperty(this, "MK", { enumerable: false, configurable: false, get: function() {
    var t3 = function(t4) {
      return t4;
    };
    if (this.scope && (t3 = this.scope.internal.getEncryptor(this.objId)), Object.keys(r2).length !== 0) {
      var e3, n3 = [];
      for (e3 in n3.push("<<"), r2)
        n3.push("/" + e3 + " (" + R(t3(r2[e3])) + ")");
      return n3.push(">>"), n3.join(`
`);
    }
  }, set: function(e3) {
    _typeof(e3) === "object" && (r2 = e3);
  } }), Object.defineProperty(this, "caption", { enumerable: true, configurable: true, get: function() {
    return r2.CA || "";
  }, set: function(t3) {
    typeof t3 == "string" && (r2.CA = t3);
  } }), Object.defineProperty(this, "AS", { enumerable: false, configurable: false, get: function() {
    return e2;
  }, set: function(t3) {
    e2 = t3;
  } }), Object.defineProperty(this, "appearanceState", { enumerable: true, configurable: true, get: function() {
    return e2.substr(1, e2.length - 1);
  }, set: function(t3) {
    e2 = "/" + t3;
  } });
}, vt = function() {
  mt.call(this), this.pushButton = true;
}, bt = function() {
  mt.call(this), this.radio = true, this.pushButton = false;
  var t3 = [];
  Object.defineProperty(this, "Kids", { enumerable: true, configurable: false, get: function() {
    return t3;
  }, set: function(e2) {
    t3 = e2 !== undefined ? e2 : [];
  } });
}, yt = function() {
  var e2, r2;
  lt.call(this), Object.defineProperty(this, "Parent", { enumerable: false, configurable: false, get: function() {
    return e2;
  }, set: function(t3) {
    e2 = t3;
  } }), Object.defineProperty(this, "optionName", { enumerable: false, configurable: true, get: function() {
    return r2;
  }, set: function(t3) {
    r2 = t3;
  } });
  var n3, i5 = {};
  Object.defineProperty(this, "MK", { enumerable: false, configurable: false, get: function() {
    var t3 = function(t4) {
      return t4;
    };
    this.scope && (t3 = this.scope.internal.getEncryptor(this.objId));
    var e3, r3 = [];
    for (e3 in r3.push("<<"), i5)
      r3.push("/" + e3 + " (" + R(t3(i5[e3])) + ")");
    return r3.push(">>"), r3.join(`
`);
  }, set: function(e3) {
    _typeof(e3) === "object" && (i5 = e3);
  } }), Object.defineProperty(this, "caption", { enumerable: true, configurable: true, get: function() {
    return i5.CA || "";
  }, set: function(t3) {
    typeof t3 == "string" && (i5.CA = t3);
  } }), Object.defineProperty(this, "AS", { enumerable: false, configurable: false, get: function() {
    return n3;
  }, set: function(t3) {
    n3 = t3;
  } }), Object.defineProperty(this, "appearanceState", { enumerable: true, configurable: true, get: function() {
    return n3.substr(1, n3.length - 1);
  }, set: function(t3) {
    n3 = "/" + t3;
  } }), this.caption = "l", this.appearanceState = "Off", this._AppearanceType = At.RadioButton.Circle, this.appearanceStreamContent = this._AppearanceType.createAppearanceStream(this.optionName);
}, wt = function() {
  mt.call(this), this.fontName = "zapfdingbats", this.caption = "3", this.appearanceState = "On", this.value = "On", this.textAlign = "center", this.appearanceStreamContent = At.CheckBox.createAppearanceStream();
}, Nt = function() {
  lt.call(this), this.FT = "/Tx", Object.defineProperty(this, "multiline", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 13));
  }, set: function(t4) {
    Boolean(t4) === true ? this.Ff = K(this.Ff, 13) : this.Ff = Z(this.Ff, 13);
  } }), Object.defineProperty(this, "fileSelect", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 21));
  }, set: function(t4) {
    Boolean(t4) === true ? this.Ff = K(this.Ff, 21) : this.Ff = Z(this.Ff, 21);
  } }), Object.defineProperty(this, "doNotSpellCheck", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 23));
  }, set: function(t4) {
    Boolean(t4) === true ? this.Ff = K(this.Ff, 23) : this.Ff = Z(this.Ff, 23);
  } }), Object.defineProperty(this, "doNotScroll", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 24));
  }, set: function(t4) {
    Boolean(t4) === true ? this.Ff = K(this.Ff, 24) : this.Ff = Z(this.Ff, 24);
  } }), Object.defineProperty(this, "comb", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 25));
  }, set: function(t4) {
    Boolean(t4) === true ? this.Ff = K(this.Ff, 25) : this.Ff = Z(this.Ff, 25);
  } }), Object.defineProperty(this, "richText", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 26));
  }, set: function(t4) {
    Boolean(t4) === true ? this.Ff = K(this.Ff, 26) : this.Ff = Z(this.Ff, 26);
  } });
  var t3 = null;
  Object.defineProperty(this, "MaxLen", { enumerable: true, configurable: false, get: function() {
    return t3;
  }, set: function(e2) {
    t3 = e2;
  } }), Object.defineProperty(this, "maxLength", { enumerable: true, configurable: true, get: function() {
    return t3;
  }, set: function(e2) {
    Number.isInteger(e2) && (t3 = e2);
  } }), Object.defineProperty(this, "hasAppearanceStream", { enumerable: true, configurable: true, get: function() {
    return this.V || this.DV;
  } });
}, Lt = function() {
  Nt.call(this), Object.defineProperty(this, "password", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 14));
  }, set: function(t3) {
    Boolean(t3) === true ? this.Ff = K(this.Ff, 14) : this.Ff = Z(this.Ff, 14);
  } }), this.password = true;
}, At, xt, St, Pt, kt, It, Ft, Ct, Bt, Mt, Ut, zt, Ht, Wt, Vt, Gt, Yt, Jt, Xt, Kt, re, ne, ie3, ae, oe = function(t3, e2) {
  for (var r2 in e2)
    ae.call(e2, r2) && (t3[r2] = e2[r2]);
  function n3() {
    this.constructor = t3;
  }
  return n3.prototype = e2.prototype, t3.prototype = new n3, t3.__super__ = e2.prototype, t3;
}, se, ce, ue, he, le, fe, de = function(t3, e2) {
  this.raw = t3, this.length = t3.length, this.platformID = e2.platformID, this.encodingID = e2.encodingID, this.languageID = e2.languageID;
}, pe, ge, me, ve, be, ye, we, Ne, Le, jspdf_es_min_default;
var init_jspdf_es_min = __esm(() => {
  init_typeof();
  init_browser();
  n2 = function() {
    return typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this;
  }();
  a2 = { log: i4, warn: function(t2) {
    n2.console && (typeof n2.console.warn == "function" ? n2.console.warn.apply(n2.console, arguments) : i4.call(null, arguments));
  }, error: function(t2) {
    n2.console && (typeof n2.console.error == "function" ? n2.console.error.apply(n2.console, arguments) : i4(t2));
  } };
  l2 = n2.saveAs || ((typeof window == "undefined" ? "undefined" : _typeof(window)) !== "object" || window !== n2 ? function() {} : typeof HTMLAnchorElement != "undefined" && ("download" in HTMLAnchorElement.prototype) ? function(t2, e2, r2) {
    var i5 = n2.URL || n2.webkitURL, a3 = document.createElement("a");
    e2 = e2 || t2.name || "download", a3.download = e2, a3.rel = "noopener", typeof t2 == "string" ? (a3.href = t2, a3.origin !== location.origin ? s2(a3.href) ? o2(t2, e2, r2) : c3(a3, a3.target = "_blank") : c3(a3)) : (a3.href = i5.createObjectURL(t2), setTimeout(function() {
      i5.revokeObjectURL(a3.href);
    }, 40000), setTimeout(function() {
      c3(a3);
    }, 0));
  } : ("msSaveOrOpenBlob" in navigator) ? function(e2, r2, n3) {
    if (r2 = r2 || e2.name || "download", typeof e2 == "string")
      if (s2(e2))
        o2(e2, r2, n3);
      else {
        var i5 = document.createElement("a");
        i5.href = e2, i5.target = "_blank", setTimeout(function() {
          c3(i5);
        });
      }
    else
      navigator.msSaveOrOpenBlob(function(e3, r3) {
        return r3 === undefined ? r3 = { autoBom: false } : _typeof(r3) !== "object" && (a2.warn("Deprecated: Expected third argument to be a object"), r3 = { autoBom: !r3 }), r3.autoBom && /^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(e3.type) ? new Blob([String.fromCharCode(65279), e3], { type: e3.type }) : e3;
      }(e2, n3), r2);
  } : function(e2, r2, i5, a3) {
    if ((a3 = a3 || open("", "_blank")) && (a3.document.title = a3.document.body.innerText = "downloading..."), typeof e2 == "string")
      return o2(e2, r2, i5);
    var s3 = e2.type === "application/octet-stream", c4 = /constructor/i.test(n2.HTMLElement) || n2.safari, u3 = /CriOS\/[\d]+/.test(navigator.userAgent);
    if ((u3 || s3 && c4) && (typeof FileReader == "undefined" ? "undefined" : _typeof(FileReader)) === "object") {
      var h3 = new FileReader;
      h3.onloadend = function() {
        var t2 = h3.result;
        t2 = u3 ? t2 : t2.replace(/^data:[^;]*;/, "data:attachment/file;"), a3 ? a3.location.href = t2 : location = t2, a3 = null;
      }, h3.readAsDataURL(e2);
    } else {
      var l3 = n2.URL || n2.webkitURL, f2 = l3.createObjectURL(e2);
      a3 ? a3.location = f2 : location.href = f2, a3 = null, setTimeout(function() {
        l3.revokeObjectURL(f2);
      }, 40000);
    }
  });
  u2 = n2.atob.bind(n2), h2 = n2.btoa.bind(n2);
  N2 = "0123456789abcdef".split("");
  S = function(t2) {
    for (var e2 = 0;e2 < t2.length; e2++)
      t2[e2] = L(t2[e2]);
    return t2.join("");
  }(y2("hello")) != "5d41402abc4b2a76b9719d911017c592";
  k = { print: 4, modify: 8, copy: 16, "annot-forms": 32 };
  I.prototype.lsbFirstWord = function(t2) {
    return String.fromCharCode(t2 >> 0 & 255, t2 >> 8 & 255, t2 >> 16 & 255, t2 >> 24 & 255);
  }, I.prototype.toHexString = function(t2) {
    return t2.split("").map(function(t3) {
      return ("0" + (255 & t3.charCodeAt(0)).toString(16)).slice(-2);
    }).join("");
  }, I.prototype.hexToBytes = function(t2) {
    for (var e2 = [], r2 = 0;r2 < t2.length; r2 += 2)
      e2.push(String.fromCharCode(parseInt(t2.substr(r2, 2), 16)));
    return e2.join("");
  }, I.prototype.processOwnerPassword = function(t2, e2) {
    return P(x2(e2).substr(0, 5), t2);
  }, I.prototype.encryptor = function(t2, e2) {
    var r2 = x2(this.encryptionKey + String.fromCharCode(255 & t2, t2 >> 8 & 255, t2 >> 16 & 255, 255 & e2, e2 >> 8 & 255)).substr(0, 10);
    return function(t3) {
      return P(r2, t3);
    };
  }, j.prototype.equals = function(e2) {
    var r2, n3 = "id,objectNumber,equals";
    if (!e2 || _typeof(e2) !== _typeof(this))
      return false;
    var i5 = 0;
    for (r2 in this)
      if (!(n3.indexOf(r2) >= 0)) {
        if (this.hasOwnProperty(r2) && !e2.hasOwnProperty(r2))
          return false;
        if (this[r2] !== e2[r2])
          return false;
        i5++;
      }
    for (r2 in e2)
      e2.hasOwnProperty(r2) && n3.indexOf(r2) < 0 && i5--;
    return i5 === 0;
  }, E.API = { events: [] }, E.version = "2.5.2";
  q = E.API;
  q.__acroform__ = {};
  G = q.__acroform__.setBit = function(t2, e2) {
    if (t2 = t2 || 0, e2 = e2 || 0, isNaN(t2) || isNaN(e2))
      throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.setBit");
    return t2 |= 1 << e2;
  };
  Y = q.__acroform__.clearBit = function(t2, e2) {
    if (t2 = t2 || 0, e2 = e2 || 0, isNaN(t2) || isNaN(e2))
      throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.clearBit");
    return t2 &= ~(1 << e2);
  };
  J = q.__acroform__.getBit = function(t2, e2) {
    if (isNaN(t2) || isNaN(e2))
      throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.getBit");
    return (t2 & 1 << e2) == 0 ? 0 : 1;
  };
  X = q.__acroform__.getBitForPdf = function(t2, e2) {
    if (isNaN(t2) || isNaN(e2))
      throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.getBitForPdf");
    return J(t2, e2 - 1);
  };
  K = q.__acroform__.setBitForPdf = function(t2, e2) {
    if (isNaN(t2) || isNaN(e2))
      throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.setBitForPdf");
    return G(t2, e2 - 1);
  };
  Z = q.__acroform__.clearBitForPdf = function(t2, e2) {
    if (isNaN(t2) || isNaN(e2))
      throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.clearBitForPdf");
    return Y(t2, e2 - 1);
  };
  $ = q.__acroform__.calculateCoordinates = function(t2, e2) {
    var r2 = e2.internal.getHorizontalCoordinate, n3 = e2.internal.getVerticalCoordinate, i5 = t2[0], a3 = t2[1], o3 = t2[2], s3 = t2[3], c4 = {};
    return c4.lowerLeft_X = r2(i5) || 0, c4.lowerLeft_Y = n3(a3 + s3) || 0, c4.upperRight_X = r2(i5 + o3) || 0, c4.upperRight_Y = n3(a3) || 0, [Number(U(c4.lowerLeft_X)), Number(U(c4.lowerLeft_Y)), Number(U(c4.upperRight_X)), Number(U(c4.upperRight_Y))];
  };
  rt = { fields: [], xForms: [], acroFormDictionaryRoot: null, printedOut: false, internal: null, isInitialized: false };
  ot = q.__acroform__.arrayToPdfArray = function(e2, r2, n3) {
    var i5 = function(t2) {
      return t2;
    };
    if (Array.isArray(e2)) {
      for (var a3 = "[", o3 = 0;o3 < e2.length; o3++)
        switch (o3 !== 0 && (a3 += " "), _typeof(e2[o3])) {
          case "boolean":
          case "number":
          case "object":
            a3 += e2[o3].toString();
            break;
          case "string":
            e2[o3].substr(0, 1) !== "/" ? (r2 !== undefined && n3 && (i5 = n3.internal.getEncryptor(r2)), a3 += "(" + R(i5(e2[o3].toString())) + ")") : a3 += e2[o3].toString();
        }
      return a3 += "]";
    }
    throw new Error("Invalid argument passed to jsPDF.__acroform__.arrayToPdfArray");
  };
  ct.prototype.toString = function() {
    return this.objId + " 0 R";
  }, ct.prototype.putStream = function() {
    var t2 = this.getKeyValueListForStream();
    this.scope.internal.putStream({ data: this.stream, additionalKeyValues: t2, objectId: this.objId }), this.scope.internal.out("endobj");
  }, ct.prototype.getKeyValueListForStream = function() {
    var t2 = [], e2 = Object.getOwnPropertyNames(this).filter(function(t3) {
      return t3 != "content" && t3 != "appearanceStreamContent" && t3 != "scope" && t3 != "objId" && t3.substring(0, 1) != "_";
    });
    for (var r2 in e2)
      if (Object.getOwnPropertyDescriptor(this, e2[r2]).configurable === false) {
        var n3 = e2[r2], i5 = this[n3];
        i5 && (Array.isArray(i5) ? t2.push({ key: n3, value: ot(i5, this.objId, this.scope) }) : i5 instanceof ct ? (i5.scope = this.scope, t2.push({ key: n3, value: i5.objId + " 0 R" })) : typeof i5 != "function" && t2.push({ key: n3, value: i5 }));
      }
    return t2;
  };
  H(ut, ct);
  H(ht, ct);
  H(lt, ct);
  H(ft, lt);
  H(dt, ft);
  H(pt, dt);
  H(gt, pt);
  H(mt, lt);
  H(vt, mt);
  H(bt, mt);
  H(yt, lt), bt.prototype.setAppearance = function(t3) {
    if (!("createAppearanceStream" in t3) || !("getCA" in t3))
      throw new Error("Couldn't assign Appearance to RadioButton. Appearance was Invalid!");
    for (var e2 in this.Kids)
      if (this.Kids.hasOwnProperty(e2)) {
        var r2 = this.Kids[e2];
        r2.appearanceStreamContent = t3.createAppearanceStream(r2.optionName), r2.caption = t3.getCA();
      }
  }, bt.prototype.createOption = function(t3) {
    var e2 = new yt;
    return e2.Parent = this, e2.optionName = t3, this.Kids.push(e2), xt.call(this.scope, e2), e2;
  };
  H(wt, mt);
  H(Nt, lt);
  H(Lt, Nt);
  At = { CheckBox: { createAppearanceStream: function() {
    return { N: { On: At.CheckBox.YesNormal }, D: { On: At.CheckBox.YesPushDown, Off: At.CheckBox.OffPushDown } };
  }, YesPushDown: function(t3) {
    var e2 = V(t3);
    e2.scope = t3.scope;
    var r2 = [], n3 = t3.scope.internal.getFont(t3.fontName, t3.fontStyle).id, i5 = t3.scope.__private__.encodeColorString(t3.color), a3 = tt(t3, t3.caption);
    return r2.push("0.749023 g"), r2.push("0 0 " + U(At.internal.getWidth(t3)) + " " + U(At.internal.getHeight(t3)) + " re"), r2.push("f"), r2.push("BMC"), r2.push("q"), r2.push("0 0 1 rg"), r2.push("/" + n3 + " " + U(a3.fontSize) + " Tf " + i5), r2.push("BT"), r2.push(a3.text), r2.push("ET"), r2.push("Q"), r2.push("EMC"), e2.stream = r2.join(`
`), e2;
  }, YesNormal: function(t3) {
    var e2 = V(t3);
    e2.scope = t3.scope;
    var r2 = t3.scope.internal.getFont(t3.fontName, t3.fontStyle).id, n3 = t3.scope.__private__.encodeColorString(t3.color), i5 = [], a3 = At.internal.getHeight(t3), o3 = At.internal.getWidth(t3), s3 = tt(t3, t3.caption);
    return i5.push("1 g"), i5.push("0 0 " + U(o3) + " " + U(a3) + " re"), i5.push("f"), i5.push("q"), i5.push("0 0 1 rg"), i5.push("0 0 " + U(o3 - 1) + " " + U(a3 - 1) + " re"), i5.push("W"), i5.push("n"), i5.push("0 g"), i5.push("BT"), i5.push("/" + r2 + " " + U(s3.fontSize) + " Tf " + n3), i5.push(s3.text), i5.push("ET"), i5.push("Q"), e2.stream = i5.join(`
`), e2;
  }, OffPushDown: function(t3) {
    var e2 = V(t3);
    e2.scope = t3.scope;
    var r2 = [];
    return r2.push("0.749023 g"), r2.push("0 0 " + U(At.internal.getWidth(t3)) + " " + U(At.internal.getHeight(t3)) + " re"), r2.push("f"), e2.stream = r2.join(`
`), e2;
  } }, RadioButton: { Circle: { createAppearanceStream: function(t3) {
    var e2 = { D: { Off: At.RadioButton.Circle.OffPushDown }, N: {} };
    return e2.N[t3] = At.RadioButton.Circle.YesNormal, e2.D[t3] = At.RadioButton.Circle.YesPushDown, e2;
  }, getCA: function() {
    return "l";
  }, YesNormal: function(t3) {
    var e2 = V(t3);
    e2.scope = t3.scope;
    var r2 = [], n3 = At.internal.getWidth(t3) <= At.internal.getHeight(t3) ? At.internal.getWidth(t3) / 4 : At.internal.getHeight(t3) / 4;
    n3 = Number((0.9 * n3).toFixed(5));
    var i5 = At.internal.Bezier_C, a3 = Number((n3 * i5).toFixed(5));
    return r2.push("q"), r2.push("1 0 0 1 " + z(At.internal.getWidth(t3) / 2) + " " + z(At.internal.getHeight(t3) / 2) + " cm"), r2.push(n3 + " 0 m"), r2.push(n3 + " " + a3 + " " + a3 + " " + n3 + " 0 " + n3 + " c"), r2.push("-" + a3 + " " + n3 + " -" + n3 + " " + a3 + " -" + n3 + " 0 c"), r2.push("-" + n3 + " -" + a3 + " -" + a3 + " -" + n3 + " 0 -" + n3 + " c"), r2.push(a3 + " -" + n3 + " " + n3 + " -" + a3 + " " + n3 + " 0 c"), r2.push("f"), r2.push("Q"), e2.stream = r2.join(`
`), e2;
  }, YesPushDown: function(t3) {
    var e2 = V(t3);
    e2.scope = t3.scope;
    var r2 = [], n3 = At.internal.getWidth(t3) <= At.internal.getHeight(t3) ? At.internal.getWidth(t3) / 4 : At.internal.getHeight(t3) / 4;
    n3 = Number((0.9 * n3).toFixed(5));
    var i5 = Number((2 * n3).toFixed(5)), a3 = Number((i5 * At.internal.Bezier_C).toFixed(5)), o3 = Number((n3 * At.internal.Bezier_C).toFixed(5));
    return r2.push("0.749023 g"), r2.push("q"), r2.push("1 0 0 1 " + z(At.internal.getWidth(t3) / 2) + " " + z(At.internal.getHeight(t3) / 2) + " cm"), r2.push(i5 + " 0 m"), r2.push(i5 + " " + a3 + " " + a3 + " " + i5 + " 0 " + i5 + " c"), r2.push("-" + a3 + " " + i5 + " -" + i5 + " " + a3 + " -" + i5 + " 0 c"), r2.push("-" + i5 + " -" + a3 + " -" + a3 + " -" + i5 + " 0 -" + i5 + " c"), r2.push(a3 + " -" + i5 + " " + i5 + " -" + a3 + " " + i5 + " 0 c"), r2.push("f"), r2.push("Q"), r2.push("0 g"), r2.push("q"), r2.push("1 0 0 1 " + z(At.internal.getWidth(t3) / 2) + " " + z(At.internal.getHeight(t3) / 2) + " cm"), r2.push(n3 + " 0 m"), r2.push(n3 + " " + o3 + " " + o3 + " " + n3 + " 0 " + n3 + " c"), r2.push("-" + o3 + " " + n3 + " -" + n3 + " " + o3 + " -" + n3 + " 0 c"), r2.push("-" + n3 + " -" + o3 + " -" + o3 + " -" + n3 + " 0 -" + n3 + " c"), r2.push(o3 + " -" + n3 + " " + n3 + " -" + o3 + " " + n3 + " 0 c"), r2.push("f"), r2.push("Q"), e2.stream = r2.join(`
`), e2;
  }, OffPushDown: function(t3) {
    var e2 = V(t3);
    e2.scope = t3.scope;
    var r2 = [], n3 = At.internal.getWidth(t3) <= At.internal.getHeight(t3) ? At.internal.getWidth(t3) / 4 : At.internal.getHeight(t3) / 4;
    n3 = Number((0.9 * n3).toFixed(5));
    var i5 = Number((2 * n3).toFixed(5)), a3 = Number((i5 * At.internal.Bezier_C).toFixed(5));
    return r2.push("0.749023 g"), r2.push("q"), r2.push("1 0 0 1 " + z(At.internal.getWidth(t3) / 2) + " " + z(At.internal.getHeight(t3) / 2) + " cm"), r2.push(i5 + " 0 m"), r2.push(i5 + " " + a3 + " " + a3 + " " + i5 + " 0 " + i5 + " c"), r2.push("-" + a3 + " " + i5 + " -" + i5 + " " + a3 + " -" + i5 + " 0 c"), r2.push("-" + i5 + " -" + a3 + " -" + a3 + " -" + i5 + " 0 -" + i5 + " c"), r2.push(a3 + " -" + i5 + " " + i5 + " -" + a3 + " " + i5 + " 0 c"), r2.push("f"), r2.push("Q"), e2.stream = r2.join(`
`), e2;
  } }, Cross: { createAppearanceStream: function(t3) {
    var e2 = { D: { Off: At.RadioButton.Cross.OffPushDown }, N: {} };
    return e2.N[t3] = At.RadioButton.Cross.YesNormal, e2.D[t3] = At.RadioButton.Cross.YesPushDown, e2;
  }, getCA: function() {
    return "8";
  }, YesNormal: function(t3) {
    var e2 = V(t3);
    e2.scope = t3.scope;
    var r2 = [], n3 = At.internal.calculateCross(t3);
    return r2.push("q"), r2.push("1 1 " + U(At.internal.getWidth(t3) - 2) + " " + U(At.internal.getHeight(t3) - 2) + " re"), r2.push("W"), r2.push("n"), r2.push(U(n3.x1.x) + " " + U(n3.x1.y) + " m"), r2.push(U(n3.x2.x) + " " + U(n3.x2.y) + " l"), r2.push(U(n3.x4.x) + " " + U(n3.x4.y) + " m"), r2.push(U(n3.x3.x) + " " + U(n3.x3.y) + " l"), r2.push("s"), r2.push("Q"), e2.stream = r2.join(`
`), e2;
  }, YesPushDown: function(t3) {
    var e2 = V(t3);
    e2.scope = t3.scope;
    var r2 = At.internal.calculateCross(t3), n3 = [];
    return n3.push("0.749023 g"), n3.push("0 0 " + U(At.internal.getWidth(t3)) + " " + U(At.internal.getHeight(t3)) + " re"), n3.push("f"), n3.push("q"), n3.push("1 1 " + U(At.internal.getWidth(t3) - 2) + " " + U(At.internal.getHeight(t3) - 2) + " re"), n3.push("W"), n3.push("n"), n3.push(U(r2.x1.x) + " " + U(r2.x1.y) + " m"), n3.push(U(r2.x2.x) + " " + U(r2.x2.y) + " l"), n3.push(U(r2.x4.x) + " " + U(r2.x4.y) + " m"), n3.push(U(r2.x3.x) + " " + U(r2.x3.y) + " l"), n3.push("s"), n3.push("Q"), e2.stream = n3.join(`
`), e2;
  }, OffPushDown: function(t3) {
    var e2 = V(t3);
    e2.scope = t3.scope;
    var r2 = [];
    return r2.push("0.749023 g"), r2.push("0 0 " + U(At.internal.getWidth(t3)) + " " + U(At.internal.getHeight(t3)) + " re"), r2.push("f"), e2.stream = r2.join(`
`), e2;
  } } }, createDefaultAppearanceStream: function(t3) {
    var e2 = t3.scope.internal.getFont(t3.fontName, t3.fontStyle).id, r2 = t3.scope.__private__.encodeColorString(t3.color);
    return "/" + e2 + " " + t3.fontSize + " Tf " + r2;
  } };
  At.internal = { Bezier_C: 0.551915024494, calculateCross: function(t3) {
    var e2 = At.internal.getWidth(t3), r2 = At.internal.getHeight(t3), n3 = Math.min(e2, r2);
    return { x1: { x: (e2 - n3) / 2, y: (r2 - n3) / 2 + n3 }, x2: { x: (e2 - n3) / 2 + n3, y: (r2 - n3) / 2 }, x3: { x: (e2 - n3) / 2, y: (r2 - n3) / 2 }, x4: { x: (e2 - n3) / 2 + n3, y: (r2 - n3) / 2 + n3 } };
  } }, At.internal.getWidth = function(e2) {
    var r2 = 0;
    return _typeof(e2) === "object" && (r2 = W(e2.Rect[2])), r2;
  }, At.internal.getHeight = function(e2) {
    var r2 = 0;
    return _typeof(e2) === "object" && (r2 = W(e2.Rect[3])), r2;
  };
  xt = q.addField = function(t3) {
    if (at(this, t3), !(t3 instanceof lt))
      throw new Error("Invalid argument passed to jsPDF.addField.");
    var e2;
    return (e2 = t3).scope.internal.acroformPlugin.printedOut && (e2.scope.internal.acroformPlugin.printedOut = false, e2.scope.internal.acroformPlugin.acroFormDictionaryRoot = null), e2.scope.internal.acroformPlugin.acroFormDictionaryRoot.Fields.push(e2), t3.page = t3.scope.internal.getCurrentPageInfo().pageNumber, this;
  };
  q.AcroFormChoiceField = ft, q.AcroFormListBox = dt, q.AcroFormComboBox = pt, q.AcroFormEditBox = gt, q.AcroFormButton = mt, q.AcroFormPushButton = vt, q.AcroFormRadioButton = bt, q.AcroFormCheckBox = wt, q.AcroFormTextField = Nt, q.AcroFormPasswordField = Lt, q.AcroFormAppearance = At, q.AcroForm = { ChoiceField: ft, ListBox: dt, ComboBox: pt, EditBox: gt, Button: mt, PushButton: vt, RadioButton: bt, CheckBox: wt, TextField: Nt, PasswordField: Lt, Appearance: At }, E.AcroForm = { ChoiceField: ft, ListBox: dt, ComboBox: pt, EditBox: gt, Button: mt, PushButton: vt, RadioButton: bt, CheckBox: wt, TextField: Nt, PasswordField: Lt, Appearance: At };
  St = E.AcroForm;
  (function(e2) {
    e2.__addimage__ = {};
    var r2 = "UNKNOWN", n3 = { PNG: [[137, 80, 78, 71]], TIFF: [[77, 77, 0, 42], [73, 73, 42, 0]], JPEG: [[255, 216, 255, 224, undefined, undefined, 74, 70, 73, 70, 0], [255, 216, 255, 225, undefined, undefined, 69, 120, 105, 102, 0, 0], [255, 216, 255, 219], [255, 216, 255, 238]], JPEG2000: [[0, 0, 0, 12, 106, 80, 32, 32]], GIF87a: [[71, 73, 70, 56, 55, 97]], GIF89a: [[71, 73, 70, 56, 57, 97]], WEBP: [[82, 73, 70, 70, undefined, undefined, undefined, undefined, 87, 69, 66, 80]], BMP: [[66, 77], [66, 65], [67, 73], [67, 80], [73, 67], [80, 84]] }, i5 = e2.__addimage__.getImageFileTypeByImageData = function(t3, e3) {
      var i6, a4, o4, s4, c5, u3 = r2;
      if ((e3 = e3 || r2) === "RGBA" || t3.data !== undefined && t3.data instanceof Uint8ClampedArray && "height" in t3 && "width" in t3)
        return "RGBA";
      if (x3(t3))
        for (c5 in n3)
          for (o4 = n3[c5], i6 = 0;i6 < o4.length; i6 += 1) {
            for (s4 = true, a4 = 0;a4 < o4[i6].length; a4 += 1)
              if (o4[i6][a4] !== undefined && o4[i6][a4] !== t3[a4]) {
                s4 = false;
                break;
              }
            if (s4 === true) {
              u3 = c5;
              break;
            }
          }
      else
        for (c5 in n3)
          for (o4 = n3[c5], i6 = 0;i6 < o4.length; i6 += 1) {
            for (s4 = true, a4 = 0;a4 < o4[i6].length; a4 += 1)
              if (o4[i6][a4] !== undefined && o4[i6][a4] !== t3.charCodeAt(a4)) {
                s4 = false;
                break;
              }
            if (s4 === true) {
              u3 = c5;
              break;
            }
          }
      return u3 === r2 && e3 !== r2 && (u3 = e3), u3;
    }, a3 = function t(e3) {
      for (var r3 = this.internal.write, n4 = this.internal.putStream, i6 = (0, this.internal.getFilters)();i6.indexOf("FlateEncode") !== -1; )
        i6.splice(i6.indexOf("FlateEncode"), 1);
      e3.objectId = this.internal.newObject();
      var a4 = [];
      if (a4.push({ key: "Type", value: "/XObject" }), a4.push({ key: "Subtype", value: "/Image" }), a4.push({ key: "Width", value: e3.width }), a4.push({ key: "Height", value: e3.height }), e3.colorSpace === b2.INDEXED ? a4.push({ key: "ColorSpace", value: "[/Indexed /DeviceRGB " + (e3.palette.length / 3 - 1) + " " + ("sMask" in e3 && e3.sMask !== undefined ? e3.objectId + 2 : e3.objectId + 1) + " 0 R]" }) : (a4.push({ key: "ColorSpace", value: "/" + e3.colorSpace }), e3.colorSpace === b2.DEVICE_CMYK && a4.push({ key: "Decode", value: "[1 0 1 0 1 0 1 0]" })), a4.push({ key: "BitsPerComponent", value: e3.bitsPerComponent }), "decodeParameters" in e3 && e3.decodeParameters !== undefined && a4.push({ key: "DecodeParms", value: "<<" + e3.decodeParameters + ">>" }), "transparency" in e3 && Array.isArray(e3.transparency)) {
        for (var o4 = "", s4 = 0, c5 = e3.transparency.length;s4 < c5; s4++)
          o4 += e3.transparency[s4] + " " + e3.transparency[s4] + " ";
        a4.push({ key: "Mask", value: "[" + o4 + "]" });
      }
      e3.sMask !== undefined && a4.push({ key: "SMask", value: e3.objectId + 1 + " 0 R" });
      var u3 = e3.filter !== undefined ? ["/" + e3.filter] : undefined;
      if (n4({ data: e3.data, additionalKeyValues: a4, alreadyAppliedFilters: u3, objectId: e3.objectId }), r3("endobj"), "sMask" in e3 && e3.sMask !== undefined) {
        var h4 = "/Predictor " + e3.predictor + " /Colors 1 /BitsPerComponent " + e3.bitsPerComponent + " /Columns " + e3.width, l4 = { width: e3.width, height: e3.height, colorSpace: "DeviceGray", bitsPerComponent: e3.bitsPerComponent, decodeParameters: h4, data: e3.sMask };
        "filter" in e3 && (l4.filter = e3.filter), t.call(this, l4);
      }
      if (e3.colorSpace === b2.INDEXED) {
        var f4 = this.internal.newObject();
        n4({ data: _3(new Uint8Array(e3.palette)), objectId: f4 }), r3("endobj");
      }
    }, o3 = function() {
      var t3 = this.internal.collections.addImage_images;
      for (var e3 in t3)
        a3.call(this, t3[e3]);
    }, s3 = function() {
      var t3, e3 = this.internal.collections.addImage_images, r3 = this.internal.write;
      for (var n4 in e3)
        r3("/I" + (t3 = e3[n4]).index, t3.objectId, "0", "R");
    }, c4 = function() {
      this.internal.collections.addImage_images || (this.internal.collections.addImage_images = {}, this.internal.events.subscribe("putResources", o3), this.internal.events.subscribe("putXobjectDict", s3));
    }, h3 = function() {
      var t3 = this.internal.collections.addImage_images;
      return c4.call(this), t3;
    }, l3 = function() {
      return Object.keys(this.internal.collections.addImage_images).length;
    }, f3 = function(t3) {
      return typeof e2["process" + t3.toUpperCase()] == "function";
    }, d2 = function(e3) {
      return _typeof(e3) === "object" && e3.nodeType === 1;
    }, p3 = function(t3, r3) {
      if (t3.nodeName === "IMG" && t3.hasAttribute("src")) {
        var n4 = "" + t3.getAttribute("src");
        if (n4.indexOf("data:image/") === 0)
          return u2(unescape(n4).split("base64,").pop());
        var i6 = e2.loadFile(n4, true);
        if (i6 !== undefined)
          return i6;
      }
      if (t3.nodeName === "CANVAS") {
        if (t3.width === 0 || t3.height === 0)
          throw new Error("Given canvas must have data. Canvas width: " + t3.width + ", height: " + t3.height);
        var a4;
        switch (r3) {
          case "PNG":
            a4 = "image/png";
            break;
          case "WEBP":
            a4 = "image/webp";
            break;
          case "JPEG":
          case "JPG":
          default:
            a4 = "image/jpeg";
        }
        return u2(t3.toDataURL(a4, 1).split("base64,").pop());
      }
    }, g2 = function(t3) {
      var e3 = this.internal.collections.addImage_images;
      if (e3) {
        for (var r3 in e3)
          if (t3 === e3[r3].alias)
            return e3[r3];
      }
    }, m4 = function(t3, e3, r3) {
      return t3 || e3 || (t3 = -96, e3 = -96), t3 < 0 && (t3 = -1 * r3.width * 72 / t3 / this.internal.scaleFactor), e3 < 0 && (e3 = -1 * r3.height * 72 / e3 / this.internal.scaleFactor), t3 === 0 && (t3 = e3 * r3.width / r3.height), e3 === 0 && (e3 = t3 * r3.height / r3.width), [t3, e3];
    }, v3 = function(t3, e3, r3, n4, i6, a4) {
      var o4 = m4.call(this, r3, n4, i6), s4 = this.internal.getCoordinateString, c5 = this.internal.getVerticalCoordinateString, u3 = h3.call(this);
      if (r3 = o4[0], n4 = o4[1], u3[i6.index] = i6, a4) {
        a4 *= Math.PI / 180;
        var l4 = Math.cos(a4), f4 = Math.sin(a4), d3 = function(t4) {
          return t4.toFixed(4);
        }, p4 = [d3(l4), d3(f4), d3(-1 * f4), d3(l4), 0, 0, "cm"];
      }
      this.internal.write("q"), a4 ? (this.internal.write([1, "0", "0", 1, s4(t3), c5(e3 + n4), "cm"].join(" ")), this.internal.write(p4.join(" ")), this.internal.write([s4(r3), "0", "0", s4(n4), "0", "0", "cm"].join(" "))) : this.internal.write([s4(r3), "0", "0", s4(n4), s4(t3), c5(e3 + n4), "cm"].join(" ")), this.isAdvancedAPI() && this.internal.write([1, 0, 0, -1, 0, 0, "cm"].join(" ")), this.internal.write("/I" + i6.index + " Do"), this.internal.write("Q");
    }, b2 = e2.color_spaces = { DEVICE_RGB: "DeviceRGB", DEVICE_GRAY: "DeviceGray", DEVICE_CMYK: "DeviceCMYK", CAL_GREY: "CalGray", CAL_RGB: "CalRGB", LAB: "Lab", ICC_BASED: "ICCBased", INDEXED: "Indexed", PATTERN: "Pattern", SEPARATION: "Separation", DEVICE_N: "DeviceN" };
    e2.decode = { DCT_DECODE: "DCTDecode", FLATE_DECODE: "FlateDecode", LZW_DECODE: "LZWDecode", JPX_DECODE: "JPXDecode", JBIG2_DECODE: "JBIG2Decode", ASCII85_DECODE: "ASCII85Decode", ASCII_HEX_DECODE: "ASCIIHexDecode", RUN_LENGTH_DECODE: "RunLengthDecode", CCITT_FAX_DECODE: "CCITTFaxDecode" };
    var y3 = e2.image_compression = { NONE: "NONE", FAST: "FAST", MEDIUM: "MEDIUM", SLOW: "SLOW" }, w2 = e2.__addimage__.sHashCode = function(t3) {
      var e3, r3, n4 = 0;
      if (typeof t3 == "string")
        for (r3 = t3.length, e3 = 0;e3 < r3; e3++)
          n4 = (n4 << 5) - n4 + t3.charCodeAt(e3), n4 |= 0;
      else if (x3(t3))
        for (r3 = t3.byteLength / 2, e3 = 0;e3 < r3; e3++)
          n4 = (n4 << 5) - n4 + t3[e3], n4 |= 0;
      return n4;
    }, N3 = e2.__addimage__.validateStringAsBase64 = function(t3) {
      (t3 = t3 || "").toString().trim();
      var e3 = true;
      return t3.length === 0 && (e3 = false), t3.length % 4 != 0 && (e3 = false), /^[A-Za-z0-9+/]+$/.test(t3.substr(0, t3.length - 2)) === false && (e3 = false), /^[A-Za-z0-9/][A-Za-z0-9+/]|[A-Za-z0-9+/]=|==$/.test(t3.substr(-2)) === false && (e3 = false), e3;
    }, L2 = e2.__addimage__.extractImageFromDataUrl = function(t3) {
      var e3 = (t3 = t3 || "").split("base64,"), r3 = null;
      if (e3.length === 2) {
        var n4 = /^data:(\w*\/\w*);*(charset=(?!charset=)[\w=-]*)*;*$/.exec(e3[0]);
        Array.isArray(n4) && (r3 = { mimeType: n4[1], charset: n4[2], data: e3[1] });
      }
      return r3;
    }, A2 = e2.__addimage__.supportsArrayBuffer = function() {
      return typeof ArrayBuffer != "undefined" && typeof Uint8Array != "undefined";
    };
    e2.__addimage__.isArrayBuffer = function(t3) {
      return A2() && t3 instanceof ArrayBuffer;
    };
    var x3 = e2.__addimage__.isArrayBufferView = function(t3) {
      return A2() && typeof Uint32Array != "undefined" && (t3 instanceof Int8Array || t3 instanceof Uint8Array || typeof Uint8ClampedArray != "undefined" && t3 instanceof Uint8ClampedArray || t3 instanceof Int16Array || t3 instanceof Uint16Array || t3 instanceof Int32Array || t3 instanceof Uint32Array || t3 instanceof Float32Array || t3 instanceof Float64Array);
    }, S2 = e2.__addimage__.binaryStringToUint8Array = function(t3) {
      for (var e3 = t3.length, r3 = new Uint8Array(e3), n4 = 0;n4 < e3; n4++)
        r3[n4] = t3.charCodeAt(n4);
      return r3;
    }, _3 = e2.__addimage__.arrayBufferToBinaryString = function(t3) {
      for (var e3 = "", r3 = x3(t3) ? t3 : new Uint8Array(t3), n4 = 0;n4 < r3.length; n4 += 8192)
        e3 += String.fromCharCode.apply(null, r3.subarray(n4, n4 + 8192));
      return e3;
    };
    e2.addImage = function() {
      var e3, n4, i6, a4, o4, s4, u3, h4, l4;
      if (typeof arguments[1] == "number" ? (n4 = r2, i6 = arguments[1], a4 = arguments[2], o4 = arguments[3], s4 = arguments[4], u3 = arguments[5], h4 = arguments[6], l4 = arguments[7]) : (n4 = arguments[1], i6 = arguments[2], a4 = arguments[3], o4 = arguments[4], s4 = arguments[5], u3 = arguments[6], h4 = arguments[7], l4 = arguments[8]), _typeof(e3 = arguments[0]) === "object" && !d2(e3) && "imageData" in e3) {
        var f4 = e3;
        e3 = f4.imageData, n4 = f4.format || n4 || r2, i6 = f4.x || i6 || 0, a4 = f4.y || a4 || 0, o4 = f4.w || f4.width || o4, s4 = f4.h || f4.height || s4, u3 = f4.alias || u3, h4 = f4.compression || h4, l4 = f4.rotation || f4.angle || l4;
      }
      var p4 = this.internal.getFilters();
      if (h4 === undefined && p4.indexOf("FlateEncode") !== -1 && (h4 = "SLOW"), isNaN(i6) || isNaN(a4))
        throw new Error("Invalid coordinates passed to jsPDF.addImage");
      c4.call(this);
      var g3 = P2.call(this, e3, n4, u3, h4);
      return v3.call(this, i6, a4, o4, s4, g3, l4), this;
    };
    var P2 = function(t3, n4, a4, o4) {
      var s4, c5, u3;
      if (typeof t3 == "string" && i5(t3) === r2) {
        t3 = unescape(t3);
        var h4 = k2(t3, false);
        (h4 !== "" || (h4 = e2.loadFile(t3, true)) !== undefined) && (t3 = h4);
      }
      if (d2(t3) && (t3 = p3(t3, n4)), n4 = i5(t3, n4), !f3(n4))
        throw new Error("addImage does not support files of type '" + n4 + "', please ensure that a plugin for '" + n4 + "' support is added.");
      if (((u3 = a4) == null || u3.length === 0) && (a4 = function(t4) {
        return typeof t4 == "string" || x3(t4) ? w2(t4) : x3(t4.data) ? w2(t4.data) : null;
      }(t3)), (s4 = g2.call(this, a4)) || (A2() && (t3 instanceof Uint8Array || n4 === "RGBA" || (c5 = t3, t3 = S2(t3))), s4 = this["process" + n4.toUpperCase()](t3, l3.call(this), a4, function(t4) {
        return t4 && typeof t4 == "string" && (t4 = t4.toUpperCase()), t4 in e2.image_compression ? t4 : y3.NONE;
      }(o4), c5)), !s4)
        throw new Error("An unknown error occurred whilst processing the image.");
      return s4;
    }, k2 = e2.__addimage__.convertBase64ToBinaryString = function(t3, e3) {
      var r3;
      e3 = typeof e3 != "boolean" || e3;
      var n4, i6 = "";
      if (typeof t3 == "string") {
        n4 = (r3 = L2(t3)) !== null ? r3.data : t3;
        try {
          i6 = u2(n4);
        } catch (t4) {
          if (e3)
            throw N3(n4) ? new Error("atob-Error in jsPDF.convertBase64ToBinaryString " + t4.message) : new Error("Supplied Data is not a valid base64-String jsPDF.convertBase64ToBinaryString ");
        }
      }
      return i6;
    };
    e2.getImageProperties = function(t3) {
      var n4, a4, o4 = "";
      if (d2(t3) && (t3 = p3(t3)), typeof t3 == "string" && i5(t3) === r2 && ((o4 = k2(t3, false)) === "" && (o4 = e2.loadFile(t3) || ""), t3 = o4), a4 = i5(t3), !f3(a4))
        throw new Error("addImage does not support files of type '" + a4 + "', please ensure that a plugin for '" + a4 + "' support is added.");
      if (!A2() || t3 instanceof Uint8Array || (t3 = S2(t3)), !(n4 = this["process" + a4.toUpperCase()](t3)))
        throw new Error("An unknown error occurred whilst processing the image");
      return n4.fileType = a4, n4;
    };
  })(E.API), function(t3) {
    var e2 = function(t4) {
      if (t4 !== undefined && t4 != "")
        return true;
    };
    E.API.events.push(["addPage", function(t4) {
      this.internal.getPageInfo(t4.pageNumber).pageContext.annotations = [];
    }]), t3.events.push(["putPage", function(t4) {
      for (var r2, n3, i5, a3 = this.internal.getCoordinateString, o3 = this.internal.getVerticalCoordinateString, s3 = this.internal.getPageInfoByObjId(t4.objId), c4 = t4.pageContext.annotations, u3 = false, h3 = 0;h3 < c4.length && !u3; h3++)
        switch ((r2 = c4[h3]).type) {
          case "link":
            (e2(r2.options.url) || e2(r2.options.pageNumber)) && (u3 = true);
            break;
          case "reference":
          case "text":
          case "freetext":
            u3 = true;
        }
      if (u3 != 0) {
        this.internal.write("/Annots [");
        for (var l3 = 0;l3 < c4.length; l3++) {
          r2 = c4[l3];
          var f3 = this.internal.pdfEscape, d2 = this.internal.getEncryptor(t4.objId);
          switch (r2.type) {
            case "reference":
              this.internal.write(" " + r2.object.objId + " 0 R ");
              break;
            case "text":
              var p3 = this.internal.newAdditionalObject(), g2 = this.internal.newAdditionalObject(), m4 = this.internal.getEncryptor(p3.objId), v3 = r2.title || "Note";
              i5 = "<</Type /Annot /Subtype /Text " + (n3 = "/Rect [" + a3(r2.bounds.x) + " " + o3(r2.bounds.y + r2.bounds.h) + " " + a3(r2.bounds.x + r2.bounds.w) + " " + o3(r2.bounds.y) + "] ") + "/Contents (" + f3(m4(r2.contents)) + ")", i5 += " /Popup " + g2.objId + " 0 R", i5 += " /P " + s3.objId + " 0 R", i5 += " /T (" + f3(m4(v3)) + ") >>", p3.content = i5;
              var b2 = p3.objId + " 0 R";
              i5 = "<</Type /Annot /Subtype /Popup " + (n3 = "/Rect [" + a3(r2.bounds.x + 30) + " " + o3(r2.bounds.y + r2.bounds.h) + " " + a3(r2.bounds.x + r2.bounds.w + 30) + " " + o3(r2.bounds.y) + "] ") + " /Parent " + b2, r2.open && (i5 += " /Open true"), i5 += " >>", g2.content = i5, this.internal.write(p3.objId, "0 R", g2.objId, "0 R");
              break;
            case "freetext":
              n3 = "/Rect [" + a3(r2.bounds.x) + " " + o3(r2.bounds.y) + " " + a3(r2.bounds.x + r2.bounds.w) + " " + o3(r2.bounds.y + r2.bounds.h) + "] ";
              var y3 = r2.color || "#000000";
              i5 = "<</Type /Annot /Subtype /FreeText " + n3 + "/Contents (" + f3(d2(r2.contents)) + ")", i5 += " /DS(font: Helvetica,sans-serif 12.0pt; text-align:left; color:#" + y3 + ")", i5 += " /Border [0 0 0]", i5 += " >>", this.internal.write(i5);
              break;
            case "link":
              if (r2.options.name) {
                var w2 = this.annotations._nameMap[r2.options.name];
                r2.options.pageNumber = w2.page, r2.options.top = w2.y;
              } else
                r2.options.top || (r2.options.top = 0);
              if (n3 = "/Rect [" + r2.finalBounds.x + " " + r2.finalBounds.y + " " + r2.finalBounds.w + " " + r2.finalBounds.h + "] ", i5 = "", r2.options.url)
                i5 = "<</Type /Annot /Subtype /Link " + n3 + "/Border [0 0 0] /A <</S /URI /URI (" + f3(d2(r2.options.url)) + ") >>";
              else if (r2.options.pageNumber) {
                switch (i5 = "<</Type /Annot /Subtype /Link " + n3 + "/Border [0 0 0] /Dest [" + this.internal.getPageInfo(r2.options.pageNumber).objId + " 0 R", r2.options.magFactor = r2.options.magFactor || "XYZ", r2.options.magFactor) {
                  case "Fit":
                    i5 += " /Fit]";
                    break;
                  case "FitH":
                    i5 += " /FitH " + r2.options.top + "]";
                    break;
                  case "FitV":
                    r2.options.left = r2.options.left || 0, i5 += " /FitV " + r2.options.left + "]";
                    break;
                  case "XYZ":
                  default:
                    var N3 = o3(r2.options.top);
                    r2.options.left = r2.options.left || 0, r2.options.zoom === undefined && (r2.options.zoom = 0), i5 += " /XYZ " + r2.options.left + " " + N3 + " " + r2.options.zoom + "]";
                }
              }
              i5 != "" && (i5 += " >>", this.internal.write(i5));
          }
        }
        this.internal.write("]");
      }
    }]), t3.createAnnotation = function(t4) {
      var e3 = this.internal.getCurrentPageInfo();
      switch (t4.type) {
        case "link":
          this.link(t4.bounds.x, t4.bounds.y, t4.bounds.w, t4.bounds.h, t4);
          break;
        case "text":
        case "freetext":
          e3.pageContext.annotations.push(t4);
      }
    }, t3.link = function(t4, e3, r2, n3, i5) {
      var a3 = this.internal.getCurrentPageInfo(), o3 = this.internal.getCoordinateString, s3 = this.internal.getVerticalCoordinateString;
      a3.pageContext.annotations.push({ finalBounds: { x: o3(t4), y: s3(e3), w: o3(t4 + r2), h: s3(e3 + n3) }, options: i5, type: "link" });
    }, t3.textWithLink = function(t4, e3, r2, n3) {
      var i5, a3, o3 = this.getTextWidth(t4), s3 = this.internal.getLineHeight() / this.internal.scaleFactor;
      if (n3.maxWidth !== undefined) {
        a3 = n3.maxWidth;
        var c4 = this.splitTextToSize(t4, a3).length;
        i5 = Math.ceil(s3 * c4);
      } else
        a3 = o3, i5 = s3;
      return this.text(t4, e3, r2, n3), r2 += 0.2 * s3, n3.align === "center" && (e3 -= o3 / 2), n3.align === "right" && (e3 -= o3), this.link(e3, r2 - s3, a3, i5, n3), o3;
    }, t3.getTextWidth = function(t4) {
      var e3 = this.internal.getFontSize();
      return this.getStringUnitWidth(t4) * e3 / this.internal.scaleFactor;
    };
  }(E.API), function(t3) {
    var e2 = { 1569: [65152], 1570: [65153, 65154], 1571: [65155, 65156], 1572: [65157, 65158], 1573: [65159, 65160], 1574: [65161, 65162, 65163, 65164], 1575: [65165, 65166], 1576: [65167, 65168, 65169, 65170], 1577: [65171, 65172], 1578: [65173, 65174, 65175, 65176], 1579: [65177, 65178, 65179, 65180], 1580: [65181, 65182, 65183, 65184], 1581: [65185, 65186, 65187, 65188], 1582: [65189, 65190, 65191, 65192], 1583: [65193, 65194], 1584: [65195, 65196], 1585: [65197, 65198], 1586: [65199, 65200], 1587: [65201, 65202, 65203, 65204], 1588: [65205, 65206, 65207, 65208], 1589: [65209, 65210, 65211, 65212], 1590: [65213, 65214, 65215, 65216], 1591: [65217, 65218, 65219, 65220], 1592: [65221, 65222, 65223, 65224], 1593: [65225, 65226, 65227, 65228], 1594: [65229, 65230, 65231, 65232], 1601: [65233, 65234, 65235, 65236], 1602: [65237, 65238, 65239, 65240], 1603: [65241, 65242, 65243, 65244], 1604: [65245, 65246, 65247, 65248], 1605: [65249, 65250, 65251, 65252], 1606: [65253, 65254, 65255, 65256], 1607: [65257, 65258, 65259, 65260], 1608: [65261, 65262], 1609: [65263, 65264, 64488, 64489], 1610: [65265, 65266, 65267, 65268], 1649: [64336, 64337], 1655: [64477], 1657: [64358, 64359, 64360, 64361], 1658: [64350, 64351, 64352, 64353], 1659: [64338, 64339, 64340, 64341], 1662: [64342, 64343, 64344, 64345], 1663: [64354, 64355, 64356, 64357], 1664: [64346, 64347, 64348, 64349], 1667: [64374, 64375, 64376, 64377], 1668: [64370, 64371, 64372, 64373], 1670: [64378, 64379, 64380, 64381], 1671: [64382, 64383, 64384, 64385], 1672: [64392, 64393], 1676: [64388, 64389], 1677: [64386, 64387], 1678: [64390, 64391], 1681: [64396, 64397], 1688: [64394, 64395], 1700: [64362, 64363, 64364, 64365], 1702: [64366, 64367, 64368, 64369], 1705: [64398, 64399, 64400, 64401], 1709: [64467, 64468, 64469, 64470], 1711: [64402, 64403, 64404, 64405], 1713: [64410, 64411, 64412, 64413], 1715: [64406, 64407, 64408, 64409], 1722: [64414, 64415], 1723: [64416, 64417, 64418, 64419], 1726: [64426, 64427, 64428, 64429], 1728: [64420, 64421], 1729: [64422, 64423, 64424, 64425], 1733: [64480, 64481], 1734: [64473, 64474], 1735: [64471, 64472], 1736: [64475, 64476], 1737: [64482, 64483], 1739: [64478, 64479], 1740: [64508, 64509, 64510, 64511], 1744: [64484, 64485, 64486, 64487], 1746: [64430, 64431], 1747: [64432, 64433] }, r2 = { 65247: { 65154: 65269, 65156: 65271, 65160: 65273, 65166: 65275 }, 65248: { 65154: 65270, 65156: 65272, 65160: 65274, 65166: 65276 }, 65165: { 65247: { 65248: { 65258: 65010 } } }, 1617: { 1612: 64606, 1613: 64607, 1614: 64608, 1615: 64609, 1616: 64610 } }, n3 = { 1612: 64606, 1613: 64607, 1614: 64608, 1615: 64609, 1616: 64610 }, i5 = [1570, 1571, 1573, 1575];
    t3.__arabicParser__ = {};
    var a3 = t3.__arabicParser__.isInArabicSubstitutionA = function(t4) {
      return e2[t4.charCodeAt(0)] !== undefined;
    }, o3 = t3.__arabicParser__.isArabicLetter = function(t4) {
      return typeof t4 == "string" && /^[\u0600-\u06FF\u0750-\u077F\u08A0-\u08FF\uFB50-\uFDFF\uFE70-\uFEFF]+$/.test(t4);
    }, s3 = t3.__arabicParser__.isArabicEndLetter = function(t4) {
      return o3(t4) && a3(t4) && e2[t4.charCodeAt(0)].length <= 2;
    }, c4 = t3.__arabicParser__.isArabicAlfLetter = function(t4) {
      return o3(t4) && i5.indexOf(t4.charCodeAt(0)) >= 0;
    };
    t3.__arabicParser__.arabicLetterHasIsolatedForm = function(t4) {
      return o3(t4) && a3(t4) && e2[t4.charCodeAt(0)].length >= 1;
    };
    var u3 = t3.__arabicParser__.arabicLetterHasFinalForm = function(t4) {
      return o3(t4) && a3(t4) && e2[t4.charCodeAt(0)].length >= 2;
    };
    t3.__arabicParser__.arabicLetterHasInitialForm = function(t4) {
      return o3(t4) && a3(t4) && e2[t4.charCodeAt(0)].length >= 3;
    };
    var h3 = t3.__arabicParser__.arabicLetterHasMedialForm = function(t4) {
      return o3(t4) && a3(t4) && e2[t4.charCodeAt(0)].length == 4;
    }, l3 = t3.__arabicParser__.resolveLigatures = function(t4) {
      var e3 = 0, n4 = r2, i6 = "", a4 = 0;
      for (e3 = 0;e3 < t4.length; e3 += 1)
        n4[t4.charCodeAt(e3)] !== undefined ? (a4++, typeof (n4 = n4[t4.charCodeAt(e3)]) == "number" && (i6 += String.fromCharCode(n4), n4 = r2, a4 = 0), e3 === t4.length - 1 && (n4 = r2, i6 += t4.charAt(e3 - (a4 - 1)), e3 -= a4 - 1, a4 = 0)) : (n4 = r2, i6 += t4.charAt(e3 - a4), e3 -= a4, a4 = 0);
      return i6;
    };
    t3.__arabicParser__.isArabicDiacritic = function(t4) {
      return t4 !== undefined && n3[t4.charCodeAt(0)] !== undefined;
    };
    var f3 = t3.__arabicParser__.getCorrectForm = function(t4, e3, r3) {
      return o3(t4) ? a3(t4) === false ? -1 : !u3(t4) || !o3(e3) && !o3(r3) || !o3(r3) && s3(e3) || s3(t4) && !o3(e3) || s3(t4) && c4(e3) || s3(t4) && s3(e3) ? 0 : h3(t4) && o3(e3) && !s3(e3) && o3(r3) && u3(r3) ? 3 : s3(t4) || !o3(r3) ? 1 : 2 : -1;
    }, d2 = function(t4) {
      var r3 = 0, n4 = 0, i6 = 0, a4 = "", s4 = "", c5 = "", u4 = (t4 = t4 || "").split("\\s+"), h4 = [];
      for (r3 = 0;r3 < u4.length; r3 += 1) {
        for (h4.push(""), n4 = 0;n4 < u4[r3].length; n4 += 1)
          a4 = u4[r3][n4], s4 = u4[r3][n4 - 1], c5 = u4[r3][n4 + 1], o3(a4) ? (i6 = f3(a4, s4, c5), h4[r3] += i6 !== -1 ? String.fromCharCode(e2[a4.charCodeAt(0)][i6]) : a4) : h4[r3] += a4;
        h4[r3] = l3(h4[r3]);
      }
      return h4.join(" ");
    }, p3 = t3.__arabicParser__.processArabic = t3.processArabic = function() {
      var t4, e3 = typeof arguments[0] == "string" ? arguments[0] : arguments[0].text, r3 = [];
      if (Array.isArray(e3)) {
        var n4 = 0;
        for (r3 = [], n4 = 0;n4 < e3.length; n4 += 1)
          Array.isArray(e3[n4]) ? r3.push([d2(e3[n4][0]), e3[n4][1], e3[n4][2]]) : r3.push([d2(e3[n4])]);
        t4 = r3;
      } else
        t4 = d2(e3);
      return typeof arguments[0] == "string" ? t4 : (arguments[0].text = t4, arguments[0]);
    };
    t3.events.push(["preProcessText", p3]);
  }(E.API), E.API.autoPrint = function(t3) {
    var e2;
    switch ((t3 = t3 || {}).variant = t3.variant || "non-conform", t3.variant) {
      case "javascript":
        this.addJS("print({});");
        break;
      case "non-conform":
      default:
        this.internal.events.subscribe("postPutResources", function() {
          e2 = this.internal.newObject(), this.internal.out("<<"), this.internal.out("/S /Named"), this.internal.out("/Type /Action"), this.internal.out("/N /Print"), this.internal.out(">>"), this.internal.out("endobj");
        }), this.internal.events.subscribe("putCatalog", function() {
          this.internal.out("/OpenAction " + e2 + " 0 R");
        });
    }
    return this;
  }, function(t3) {
    var e2 = function() {
      var t4 = undefined;
      Object.defineProperty(this, "pdf", { get: function() {
        return t4;
      }, set: function(e4) {
        t4 = e4;
      } });
      var e3 = 150;
      Object.defineProperty(this, "width", { get: function() {
        return e3;
      }, set: function(t5) {
        e3 = isNaN(t5) || Number.isInteger(t5) === false || t5 < 0 ? 150 : t5, this.getContext("2d").pageWrapXEnabled && (this.getContext("2d").pageWrapX = e3 + 1);
      } });
      var r2 = 300;
      Object.defineProperty(this, "height", { get: function() {
        return r2;
      }, set: function(t5) {
        r2 = isNaN(t5) || Number.isInteger(t5) === false || t5 < 0 ? 300 : t5, this.getContext("2d").pageWrapYEnabled && (this.getContext("2d").pageWrapY = r2 + 1);
      } });
      var n3 = [];
      Object.defineProperty(this, "childNodes", { get: function() {
        return n3;
      }, set: function(t5) {
        n3 = t5;
      } });
      var i5 = {};
      Object.defineProperty(this, "style", { get: function() {
        return i5;
      }, set: function(t5) {
        i5 = t5;
      } }), Object.defineProperty(this, "parentNode", {});
    };
    e2.prototype.getContext = function(t4, e3) {
      var r2;
      if ((t4 = t4 || "2d") !== "2d")
        return null;
      for (r2 in e3)
        this.pdf.context2d.hasOwnProperty(r2) && (this.pdf.context2d[r2] = e3[r2]);
      return this.pdf.context2d._canvas = this, this.pdf.context2d;
    }, e2.prototype.toDataURL = function() {
      throw new Error("toDataURL is not implemented.");
    }, t3.events.push(["initialized", function() {
      this.canvas = new e2, this.canvas.pdf = this;
    }]);
  }(E.API), function(e2) {
    var r2 = { left: 0, top: 0, bottom: 0, right: 0 }, n3 = false, i5 = function() {
      this.internal.__cell__ === undefined && (this.internal.__cell__ = {}, this.internal.__cell__.padding = 3, this.internal.__cell__.headerFunction = undefined, this.internal.__cell__.margins = Object.assign({}, r2), this.internal.__cell__.margins.width = this.getPageWidth(), a3.call(this));
    }, a3 = function() {
      this.internal.__cell__.lastCell = new o3, this.internal.__cell__.pages = 1;
    }, o3 = function() {
      var t3 = arguments[0];
      Object.defineProperty(this, "x", { enumerable: true, get: function() {
        return t3;
      }, set: function(e4) {
        t3 = e4;
      } });
      var e3 = arguments[1];
      Object.defineProperty(this, "y", { enumerable: true, get: function() {
        return e3;
      }, set: function(t4) {
        e3 = t4;
      } });
      var r3 = arguments[2];
      Object.defineProperty(this, "width", { enumerable: true, get: function() {
        return r3;
      }, set: function(t4) {
        r3 = t4;
      } });
      var n4 = arguments[3];
      Object.defineProperty(this, "height", { enumerable: true, get: function() {
        return n4;
      }, set: function(t4) {
        n4 = t4;
      } });
      var i6 = arguments[4];
      Object.defineProperty(this, "text", { enumerable: true, get: function() {
        return i6;
      }, set: function(t4) {
        i6 = t4;
      } });
      var a4 = arguments[5];
      Object.defineProperty(this, "lineNumber", { enumerable: true, get: function() {
        return a4;
      }, set: function(t4) {
        a4 = t4;
      } });
      var o4 = arguments[6];
      return Object.defineProperty(this, "align", { enumerable: true, get: function() {
        return o4;
      }, set: function(t4) {
        o4 = t4;
      } }), this;
    };
    o3.prototype.clone = function() {
      return new o3(this.x, this.y, this.width, this.height, this.text, this.lineNumber, this.align);
    }, o3.prototype.toArray = function() {
      return [this.x, this.y, this.width, this.height, this.text, this.lineNumber, this.align];
    }, e2.setHeaderFunction = function(t3) {
      return i5.call(this), this.internal.__cell__.headerFunction = typeof t3 == "function" ? t3 : undefined, this;
    }, e2.getTextDimensions = function(t3, e3) {
      i5.call(this);
      var r3 = (e3 = e3 || {}).fontSize || this.getFontSize(), n4 = e3.font || this.getFont(), a4 = e3.scaleFactor || this.internal.scaleFactor, o4 = 0, s4 = 0, c5 = 0, u3 = this;
      if (!Array.isArray(t3) && typeof t3 != "string") {
        if (typeof t3 != "number")
          throw new Error("getTextDimensions expects text-parameter to be of type String or type Number or an Array of Strings.");
        t3 = String(t3);
      }
      var h3 = e3.maxWidth;
      h3 > 0 ? typeof t3 == "string" ? t3 = this.splitTextToSize(t3, h3) : Object.prototype.toString.call(t3) === "[object Array]" && (t3 = t3.reduce(function(t4, e4) {
        return t4.concat(u3.splitTextToSize(e4, h3));
      }, [])) : t3 = Array.isArray(t3) ? t3 : [t3];
      for (var l3 = 0;l3 < t3.length; l3++)
        o4 < (c5 = this.getStringUnitWidth(t3[l3], { font: n4 }) * r3) && (o4 = c5);
      return o4 !== 0 && (s4 = t3.length), { w: o4 /= a4, h: Math.max((s4 * r3 * this.getLineHeightFactor() - r3 * (this.getLineHeightFactor() - 1)) / a4, 0) };
    }, e2.cellAddPage = function() {
      i5.call(this), this.addPage();
      var t3 = this.internal.__cell__.margins || r2;
      return this.internal.__cell__.lastCell = new o3(t3.left, t3.top, undefined, undefined), this.internal.__cell__.pages += 1, this;
    };
    var s3 = e2.cell = function() {
      var t3;
      t3 = arguments[0] instanceof o3 ? arguments[0] : new o3(arguments[0], arguments[1], arguments[2], arguments[3], arguments[4], arguments[5]), i5.call(this);
      var e3 = this.internal.__cell__.lastCell, a4 = this.internal.__cell__.padding, s4 = this.internal.__cell__.margins || r2, c5 = this.internal.__cell__.tableHeaderRow, u3 = this.internal.__cell__.printHeaders;
      return e3.lineNumber !== undefined && (e3.lineNumber === t3.lineNumber ? (t3.x = (e3.x || 0) + (e3.width || 0), t3.y = e3.y || 0) : e3.y + e3.height + t3.height + s4.bottom > this.getPageHeight() ? (this.cellAddPage(), t3.y = s4.top, u3 && c5 && (this.printHeaderRow(t3.lineNumber, true), t3.y += c5[0].height)) : t3.y = e3.y + e3.height || t3.y), t3.text[0] !== undefined && (this.rect(t3.x, t3.y, t3.width, t3.height, n3 === true ? "FD" : undefined), t3.align === "right" ? this.text(t3.text, t3.x + t3.width - a4, t3.y + a4, { align: "right", baseline: "top" }) : t3.align === "center" ? this.text(t3.text, t3.x + t3.width / 2, t3.y + a4, { align: "center", baseline: "top", maxWidth: t3.width - a4 - a4 }) : this.text(t3.text, t3.x + a4, t3.y + a4, { align: "left", baseline: "top", maxWidth: t3.width - a4 - a4 })), this.internal.__cell__.lastCell = t3, this;
    };
    e2.table = function(e3, n4, u3, h3, l3) {
      if (i5.call(this), !u3)
        throw new Error("No data for PDF table.");
      var f3, d2, p3, g2, m4 = [], v3 = [], b2 = [], y3 = {}, w2 = {}, N3 = [], L2 = [], A2 = (l3 = l3 || {}).autoSize || false, x3 = l3.printHeaders !== false, S2 = l3.css && l3.css["font-size"] !== undefined ? 16 * l3.css["font-size"] : l3.fontSize || 12, _3 = l3.margins || Object.assign({ width: this.getPageWidth() }, r2), P2 = typeof l3.padding == "number" ? l3.padding : 3, k2 = l3.headerBackgroundColor || "#c8c8c8", I2 = l3.headerTextColor || "#000";
      if (a3.call(this), this.internal.__cell__.printHeaders = x3, this.internal.__cell__.margins = _3, this.internal.__cell__.table_font_size = S2, this.internal.__cell__.padding = P2, this.internal.__cell__.headerBackgroundColor = k2, this.internal.__cell__.headerTextColor = I2, this.setFontSize(S2), h3 == null)
        v3 = m4 = Object.keys(u3[0]), b2 = m4.map(function() {
          return "left";
        });
      else if (Array.isArray(h3) && _typeof(h3[0]) === "object")
        for (m4 = h3.map(function(t3) {
          return t3.name;
        }), v3 = h3.map(function(t3) {
          return t3.prompt || t3.name || "";
        }), b2 = h3.map(function(t3) {
          return t3.align || "left";
        }), f3 = 0;f3 < h3.length; f3 += 1)
          w2[h3[f3].name] = h3[f3].width * (19.049976 / 25.4);
      else
        Array.isArray(h3) && typeof h3[0] == "string" && (v3 = m4 = h3, b2 = m4.map(function() {
          return "left";
        }));
      if (A2 || Array.isArray(h3) && typeof h3[0] == "string")
        for (f3 = 0;f3 < m4.length; f3 += 1) {
          for (y3[g2 = m4[f3]] = u3.map(function(t3) {
            return t3[g2];
          }), this.setFont(undefined, "bold"), N3.push(this.getTextDimensions(v3[f3], { fontSize: this.internal.__cell__.table_font_size, scaleFactor: this.internal.scaleFactor }).w), d2 = y3[g2], this.setFont(undefined, "normal"), p3 = 0;p3 < d2.length; p3 += 1)
            N3.push(this.getTextDimensions(d2[p3], { fontSize: this.internal.__cell__.table_font_size, scaleFactor: this.internal.scaleFactor }).w);
          w2[g2] = Math.max.apply(null, N3) + P2 + P2, N3 = [];
        }
      if (x3) {
        var F2 = {};
        for (f3 = 0;f3 < m4.length; f3 += 1)
          F2[m4[f3]] = {}, F2[m4[f3]].text = v3[f3], F2[m4[f3]].align = b2[f3];
        var C2 = c4.call(this, F2, w2);
        L2 = m4.map(function(t3) {
          return new o3(e3, n4, w2[t3], C2, F2[t3].text, undefined, F2[t3].align);
        }), this.setTableHeaderRow(L2), this.printHeaderRow(1, false);
      }
      var j2 = h3.reduce(function(t3, e4) {
        return t3[e4.name] = e4.align, t3;
      }, {});
      for (f3 = 0;f3 < u3.length; f3 += 1) {
        "rowStart" in l3 && l3.rowStart instanceof Function && l3.rowStart({ row: f3, data: u3[f3] }, this);
        var O3 = c4.call(this, u3[f3], w2);
        for (p3 = 0;p3 < m4.length; p3 += 1) {
          var B2 = u3[f3][m4[p3]];
          "cellStart" in l3 && l3.cellStart instanceof Function && l3.cellStart({ row: f3, col: p3, data: B2 }, this), s3.call(this, new o3(e3, n4, w2[m4[p3]], O3, B2, f3 + 2, j2[m4[p3]]));
        }
      }
      return this.internal.__cell__.table_x = e3, this.internal.__cell__.table_y = n4, this;
    };
    var c4 = function(t3, e3) {
      var r3 = this.internal.__cell__.padding, n4 = this.internal.__cell__.table_font_size, i6 = this.internal.scaleFactor;
      return Object.keys(t3).map(function(n5) {
        var i7 = t3[n5];
        return this.splitTextToSize(i7.hasOwnProperty("text") ? i7.text : i7, e3[n5] - r3 - r3);
      }, this).map(function(t4) {
        return this.getLineHeightFactor() * t4.length * n4 / i6 + r3 + r3;
      }, this).reduce(function(t4, e4) {
        return Math.max(t4, e4);
      }, 0);
    };
    e2.setTableHeaderRow = function(t3) {
      i5.call(this), this.internal.__cell__.tableHeaderRow = t3;
    }, e2.printHeaderRow = function(t3, e3) {
      if (i5.call(this), !this.internal.__cell__.tableHeaderRow)
        throw new Error("Property tableHeaderRow does not exist.");
      var r3;
      if (n3 = true, typeof this.internal.__cell__.headerFunction == "function") {
        var a4 = this.internal.__cell__.headerFunction(this, this.internal.__cell__.pages);
        this.internal.__cell__.lastCell = new o3(a4[0], a4[1], a4[2], a4[3], undefined, -1);
      }
      this.setFont(undefined, "bold");
      for (var c5 = [], u3 = 0;u3 < this.internal.__cell__.tableHeaderRow.length; u3 += 1) {
        r3 = this.internal.__cell__.tableHeaderRow[u3].clone(), e3 && (r3.y = this.internal.__cell__.margins.top || 0, c5.push(r3)), r3.lineNumber = t3;
        var h3 = this.getTextColor();
        this.setTextColor(this.internal.__cell__.headerTextColor), this.setFillColor(this.internal.__cell__.headerBackgroundColor), s3.call(this, r3), this.setTextColor(h3);
      }
      c5.length > 0 && this.setTableHeaderRow(c5), this.setFont(undefined, "normal"), n3 = false;
    };
  }(E.API);
  Pt = { italic: ["italic", "oblique", "normal"], oblique: ["oblique", "italic", "normal"], normal: ["normal", "oblique", "italic"] };
  kt = ["ultra-condensed", "extra-condensed", "condensed", "semi-condensed", "normal", "semi-expanded", "expanded", "extra-expanded", "ultra-expanded"];
  It = _t(kt);
  Ft = [100, 200, 300, 400, 500, 600, 700, 800, 900];
  Ct = _t(Ft);
  Bt = { "sans-serif": "helvetica", fixed: "courier", monospace: "courier", terminal: "courier", cursive: "times", fantasy: "times", serif: "times" };
  Mt = { caption: "times", icon: "times", menu: "times", "message-box": "times", "small-caption": "times", "status-bar": "times" };
  Wt = ["times"];
  (function(e2) {
    var r2, n3, i5, o3, s3, c4, u3, h3, l3, d2 = function(t3) {
      return t3 = t3 || {}, this.isStrokeTransparent = t3.isStrokeTransparent || false, this.strokeOpacity = t3.strokeOpacity || 1, this.strokeStyle = t3.strokeStyle || "#000000", this.fillStyle = t3.fillStyle || "#000000", this.isFillTransparent = t3.isFillTransparent || false, this.fillOpacity = t3.fillOpacity || 1, this.font = t3.font || "10px sans-serif", this.textBaseline = t3.textBaseline || "alphabetic", this.textAlign = t3.textAlign || "left", this.lineWidth = t3.lineWidth || 1, this.lineJoin = t3.lineJoin || "miter", this.lineCap = t3.lineCap || "butt", this.path = t3.path || [], this.transform = t3.transform !== undefined ? t3.transform.clone() : new h3, this.globalCompositeOperation = t3.globalCompositeOperation || "normal", this.globalAlpha = t3.globalAlpha || 1, this.clip_path = t3.clip_path || [], this.currentPoint = t3.currentPoint || new c4, this.miterLimit = t3.miterLimit || 10, this.lastPoint = t3.lastPoint || new c4, this.lineDashOffset = t3.lineDashOffset || 0, this.lineDash = t3.lineDash || [], this.margin = t3.margin || [0, 0, 0, 0], this.prevPageLastElemOffset = t3.prevPageLastElemOffset || 0, this.ignoreClearRect = typeof t3.ignoreClearRect != "boolean" || t3.ignoreClearRect, this;
    };
    e2.events.push(["initialized", function() {
      this.context2d = new p3(this), r2 = this.internal.f2, n3 = this.internal.getCoordinateString, i5 = this.internal.getVerticalCoordinateString, o3 = this.internal.getHorizontalCoordinate, s3 = this.internal.getVerticalCoordinate, c4 = this.internal.Point, u3 = this.internal.Rectangle, h3 = this.internal.Matrix, l3 = new d2;
    }]);
    var p3 = function(t3) {
      Object.defineProperty(this, "canvas", { get: function() {
        return { parentNode: false, style: false };
      } });
      var e3 = t3;
      Object.defineProperty(this, "pdf", { get: function() {
        return e3;
      } });
      var r3 = false;
      Object.defineProperty(this, "pageWrapXEnabled", { get: function() {
        return r3;
      }, set: function(t4) {
        r3 = Boolean(t4);
      } });
      var n4 = false;
      Object.defineProperty(this, "pageWrapYEnabled", { get: function() {
        return n4;
      }, set: function(t4) {
        n4 = Boolean(t4);
      } });
      var i6 = 0;
      Object.defineProperty(this, "posX", { get: function() {
        return i6;
      }, set: function(t4) {
        isNaN(t4) || (i6 = t4);
      } });
      var a3 = 0;
      Object.defineProperty(this, "posY", { get: function() {
        return a3;
      }, set: function(t4) {
        isNaN(t4) || (a3 = t4);
      } }), Object.defineProperty(this, "margin", { get: function() {
        return l3.margin;
      }, set: function(t4) {
        var e4;
        typeof t4 == "number" ? e4 = [t4, t4, t4, t4] : ((e4 = new Array(4))[0] = t4[0], e4[1] = t4.length >= 2 ? t4[1] : e4[0], e4[2] = t4.length >= 3 ? t4[2] : e4[0], e4[3] = t4.length >= 4 ? t4[3] : e4[1]), l3.margin = e4;
      } });
      var o4 = false;
      Object.defineProperty(this, "autoPaging", { get: function() {
        return o4;
      }, set: function(t4) {
        o4 = t4;
      } });
      var s4 = 0;
      Object.defineProperty(this, "lastBreak", { get: function() {
        return s4;
      }, set: function(t4) {
        s4 = t4;
      } });
      var c5 = [];
      Object.defineProperty(this, "pageBreaks", { get: function() {
        return c5;
      }, set: function(t4) {
        c5 = t4;
      } }), Object.defineProperty(this, "ctx", { get: function() {
        return l3;
      }, set: function(t4) {
        t4 instanceof d2 && (l3 = t4);
      } }), Object.defineProperty(this, "path", { get: function() {
        return l3.path;
      }, set: function(t4) {
        l3.path = t4;
      } });
      var u4 = [];
      Object.defineProperty(this, "ctxStack", { get: function() {
        return u4;
      }, set: function(t4) {
        u4 = t4;
      } }), Object.defineProperty(this, "fillStyle", { get: function() {
        return this.ctx.fillStyle;
      }, set: function(t4) {
        var e4;
        e4 = g2(t4), this.ctx.fillStyle = e4.style, this.ctx.isFillTransparent = e4.a === 0, this.ctx.fillOpacity = e4.a, this.pdf.setFillColor(e4.r, e4.g, e4.b, { a: e4.a }), this.pdf.setTextColor(e4.r, e4.g, e4.b, { a: e4.a });
      } }), Object.defineProperty(this, "strokeStyle", { get: function() {
        return this.ctx.strokeStyle;
      }, set: function(t4) {
        var e4 = g2(t4);
        this.ctx.strokeStyle = e4.style, this.ctx.isStrokeTransparent = e4.a === 0, this.ctx.strokeOpacity = e4.a, e4.a === 0 ? this.pdf.setDrawColor(255, 255, 255) : (e4.a, this.pdf.setDrawColor(e4.r, e4.g, e4.b));
      } }), Object.defineProperty(this, "lineCap", { get: function() {
        return this.ctx.lineCap;
      }, set: function(t4) {
        ["butt", "round", "square"].indexOf(t4) !== -1 && (this.ctx.lineCap = t4, this.pdf.setLineCap(t4));
      } }), Object.defineProperty(this, "lineWidth", { get: function() {
        return this.ctx.lineWidth;
      }, set: function(t4) {
        isNaN(t4) || (this.ctx.lineWidth = t4, this.pdf.setLineWidth(t4));
      } }), Object.defineProperty(this, "lineJoin", { get: function() {
        return this.ctx.lineJoin;
      }, set: function(t4) {
        ["bevel", "round", "miter"].indexOf(t4) !== -1 && (this.ctx.lineJoin = t4, this.pdf.setLineJoin(t4));
      } }), Object.defineProperty(this, "miterLimit", { get: function() {
        return this.ctx.miterLimit;
      }, set: function(t4) {
        isNaN(t4) || (this.ctx.miterLimit = t4, this.pdf.setMiterLimit(t4));
      } }), Object.defineProperty(this, "textBaseline", { get: function() {
        return this.ctx.textBaseline;
      }, set: function(t4) {
        this.ctx.textBaseline = t4;
      } }), Object.defineProperty(this, "textAlign", { get: function() {
        return this.ctx.textAlign;
      }, set: function(t4) {
        ["right", "end", "center", "left", "start"].indexOf(t4) !== -1 && (this.ctx.textAlign = t4);
      } });
      var h4 = null;
      function f3(t4, e4) {
        if (h4 === null) {
          var r4 = function(t5) {
            var e5 = [];
            return Object.keys(t5).forEach(function(r5) {
              t5[r5].forEach(function(t6) {
                var n5 = null;
                switch (t6) {
                  case "bold":
                    n5 = { family: r5, weight: "bold" };
                    break;
                  case "italic":
                    n5 = { family: r5, style: "italic" };
                    break;
                  case "bolditalic":
                    n5 = { family: r5, weight: "bold", style: "italic" };
                    break;
                  case "":
                  case "normal":
                    n5 = { family: r5 };
                }
                n5 !== null && (n5.ref = { name: r5, style: t6 }, e5.push(n5));
              });
            }), e5;
          }(t4.getFontList());
          h4 = function(t5) {
            for (var e5 = {}, r5 = 0;r5 < t5.length; ++r5) {
              var n5 = jt(t5[r5]), i7 = n5.family, a4 = n5.stretch, o5 = n5.style, s5 = n5.weight;
              e5[i7] = e5[i7] || {}, e5[i7][a4] = e5[i7][a4] || {}, e5[i7][a4][o5] = e5[i7][a4][o5] || {}, e5[i7][a4][o5][s5] = n5;
            }
            return e5;
          }(r4.concat(e4));
        }
        return h4;
      }
      var p4 = null;
      Object.defineProperty(this, "fontFaces", { get: function() {
        return p4;
      }, set: function(t4) {
        h4 = null, p4 = t4;
      } }), Object.defineProperty(this, "font", { get: function() {
        return this.ctx.font;
      }, set: function(t4) {
        var e4;
        if (this.ctx.font = t4, (e4 = /^\s*(?=(?:(?:[-a-z]+\s*){0,2}(italic|oblique))?)(?=(?:(?:[-a-z]+\s*){0,2}(small-caps))?)(?=(?:(?:[-a-z]+\s*){0,2}(bold(?:er)?|lighter|[1-9]00))?)(?:(?:normal|\1|\2|\3)\s*){0,3}((?:xx?-)?(?:small|large)|medium|smaller|larger|[.\d]+(?:\%|in|[cem]m|ex|p[ctx]))(?:\s*\/\s*(normal|[.\d]+(?:\%|in|[cem]m|ex|p[ctx])))?\s*([-_,\"\'\sa-z]+?)\s*$/i.exec(t4)) !== null) {
          var r4 = e4[1], n5 = (e4[2], e4[3]), i7 = e4[4], a4 = (e4[5], e4[6]), o5 = /^([.\d]+)((?:%|in|[cem]m|ex|p[ctx]))$/i.exec(i7)[2];
          i7 = o5 === "px" ? Math.floor(parseFloat(i7) * this.pdf.internal.scaleFactor) : o5 === "em" ? Math.floor(parseFloat(i7) * this.pdf.getFontSize()) : Math.floor(parseFloat(i7) * this.pdf.internal.scaleFactor), this.pdf.setFontSize(i7);
          var s5 = function(t5) {
            var e5, r5, n6 = [], i8 = t5.trim();
            if (i8 === "")
              return Wt;
            if (i8 in Mt)
              return [Mt[i8]];
            for (;i8 !== ""; ) {
              switch (r5 = null, e5 = (i8 = Dt(i8)).charAt(0)) {
                case '"':
                case "'":
                  r5 = Rt(i8.substring(1), e5);
                  break;
                default:
                  r5 = Tt(i8);
              }
              if (r5 === null)
                return Wt;
              if (n6.push(r5[0]), (i8 = Dt(r5[1])) !== "" && i8.charAt(0) !== ",")
                return Wt;
              i8 = i8.replace(/^,/, "");
            }
            return n6;
          }(a4);
          if (this.fontFaces) {
            var c6 = qt(f3(this.pdf, this.fontFaces), s5.map(function(t5) {
              return { family: t5, stretch: "normal", weight: n5, style: r4 };
            }));
            this.pdf.setFont(c6.ref.name, c6.ref.style);
          } else {
            var u5 = "";
            (n5 === "bold" || parseInt(n5, 10) >= 700 || r4 === "bold") && (u5 = "bold"), r4 === "italic" && (u5 += "italic"), u5.length === 0 && (u5 = "normal");
            for (var h5 = "", l4 = { arial: "Helvetica", Arial: "Helvetica", verdana: "Helvetica", Verdana: "Helvetica", helvetica: "Helvetica", Helvetica: "Helvetica", "sans-serif": "Helvetica", fixed: "Courier", monospace: "Courier", terminal: "Courier", cursive: "Times", fantasy: "Times", serif: "Times" }, d3 = 0;d3 < s5.length; d3++) {
              if (this.pdf.internal.getFont(s5[d3], u5, { noFallback: true, disableWarning: true }) !== undefined) {
                h5 = s5[d3];
                break;
              }
              if (u5 === "bolditalic" && this.pdf.internal.getFont(s5[d3], "bold", { noFallback: true, disableWarning: true }) !== undefined)
                h5 = s5[d3], u5 = "bold";
              else if (this.pdf.internal.getFont(s5[d3], "normal", { noFallback: true, disableWarning: true }) !== undefined) {
                h5 = s5[d3], u5 = "normal";
                break;
              }
            }
            if (h5 === "") {
              for (var p5 = 0;p5 < s5.length; p5++)
                if (l4[s5[p5]]) {
                  h5 = l4[s5[p5]];
                  break;
                }
            }
            h5 = h5 === "" ? "Times" : h5, this.pdf.setFont(h5, u5);
          }
        }
      } }), Object.defineProperty(this, "globalCompositeOperation", { get: function() {
        return this.ctx.globalCompositeOperation;
      }, set: function(t4) {
        this.ctx.globalCompositeOperation = t4;
      } }), Object.defineProperty(this, "globalAlpha", { get: function() {
        return this.ctx.globalAlpha;
      }, set: function(t4) {
        this.ctx.globalAlpha = t4;
      } }), Object.defineProperty(this, "lineDashOffset", { get: function() {
        return this.ctx.lineDashOffset;
      }, set: function(t4) {
        this.ctx.lineDashOffset = t4, T3.call(this);
      } }), Object.defineProperty(this, "lineDash", { get: function() {
        return this.ctx.lineDash;
      }, set: function(t4) {
        this.ctx.lineDash = t4, T3.call(this);
      } }), Object.defineProperty(this, "ignoreClearRect", { get: function() {
        return this.ctx.ignoreClearRect;
      }, set: function(t4) {
        this.ctx.ignoreClearRect = Boolean(t4);
      } });
    };
    p3.prototype.setLineDash = function(t3) {
      this.lineDash = t3;
    }, p3.prototype.getLineDash = function() {
      return this.lineDash.length % 2 ? this.lineDash.concat(this.lineDash) : this.lineDash.slice();
    }, p3.prototype.fill = function() {
      A2.call(this, "fill", false);
    }, p3.prototype.stroke = function() {
      A2.call(this, "stroke", false);
    }, p3.prototype.beginPath = function() {
      this.path = [{ type: "begin" }];
    }, p3.prototype.moveTo = function(t3, e3) {
      if (isNaN(t3) || isNaN(e3))
        throw a2.error("jsPDF.context2d.moveTo: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.moveTo");
      var r3 = this.ctx.transform.applyToPoint(new c4(t3, e3));
      this.path.push({ type: "mt", x: r3.x, y: r3.y }), this.ctx.lastPoint = new c4(t3, e3);
    }, p3.prototype.closePath = function() {
      var e3 = new c4(0, 0), r3 = 0;
      for (r3 = this.path.length - 1;r3 !== -1; r3--)
        if (this.path[r3].type === "begin" && _typeof(this.path[r3 + 1]) === "object" && typeof this.path[r3 + 1].x == "number") {
          e3 = new c4(this.path[r3 + 1].x, this.path[r3 + 1].y);
          break;
        }
      this.path.push({ type: "close" }), this.ctx.lastPoint = new c4(e3.x, e3.y);
    }, p3.prototype.lineTo = function(t3, e3) {
      if (isNaN(t3) || isNaN(e3))
        throw a2.error("jsPDF.context2d.lineTo: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.lineTo");
      var r3 = this.ctx.transform.applyToPoint(new c4(t3, e3));
      this.path.push({ type: "lt", x: r3.x, y: r3.y }), this.ctx.lastPoint = new c4(r3.x, r3.y);
    }, p3.prototype.clip = function() {
      this.ctx.clip_path = JSON.parse(JSON.stringify(this.path)), A2.call(this, null, true);
    }, p3.prototype.quadraticCurveTo = function(t3, e3, r3, n4) {
      if (isNaN(r3) || isNaN(n4) || isNaN(t3) || isNaN(e3))
        throw a2.error("jsPDF.context2d.quadraticCurveTo: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.quadraticCurveTo");
      var i6 = this.ctx.transform.applyToPoint(new c4(r3, n4)), o4 = this.ctx.transform.applyToPoint(new c4(t3, e3));
      this.path.push({ type: "qct", x1: o4.x, y1: o4.y, x: i6.x, y: i6.y }), this.ctx.lastPoint = new c4(i6.x, i6.y);
    }, p3.prototype.bezierCurveTo = function(t3, e3, r3, n4, i6, o4) {
      if (isNaN(i6) || isNaN(o4) || isNaN(t3) || isNaN(e3) || isNaN(r3) || isNaN(n4))
        throw a2.error("jsPDF.context2d.bezierCurveTo: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.bezierCurveTo");
      var s4 = this.ctx.transform.applyToPoint(new c4(i6, o4)), u4 = this.ctx.transform.applyToPoint(new c4(t3, e3)), h4 = this.ctx.transform.applyToPoint(new c4(r3, n4));
      this.path.push({ type: "bct", x1: u4.x, y1: u4.y, x2: h4.x, y2: h4.y, x: s4.x, y: s4.y }), this.ctx.lastPoint = new c4(s4.x, s4.y);
    }, p3.prototype.arc = function(t3, e3, r3, n4, i6, o4) {
      if (isNaN(t3) || isNaN(e3) || isNaN(r3) || isNaN(n4) || isNaN(i6))
        throw a2.error("jsPDF.context2d.arc: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.arc");
      if (o4 = Boolean(o4), !this.ctx.transform.isIdentity) {
        var s4 = this.ctx.transform.applyToPoint(new c4(t3, e3));
        t3 = s4.x, e3 = s4.y;
        var u4 = this.ctx.transform.applyToPoint(new c4(0, r3)), h4 = this.ctx.transform.applyToPoint(new c4(0, 0));
        r3 = Math.sqrt(Math.pow(u4.x - h4.x, 2) + Math.pow(u4.y - h4.y, 2));
      }
      Math.abs(i6 - n4) >= 2 * Math.PI && (n4 = 0, i6 = 2 * Math.PI), this.path.push({ type: "arc", x: t3, y: e3, radius: r3, startAngle: n4, endAngle: i6, counterclockwise: o4 });
    }, p3.prototype.arcTo = function(t3, e3, r3, n4, i6) {
      throw new Error("arcTo not implemented.");
    }, p3.prototype.rect = function(t3, e3, r3, n4) {
      if (isNaN(t3) || isNaN(e3) || isNaN(r3) || isNaN(n4))
        throw a2.error("jsPDF.context2d.rect: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.rect");
      this.moveTo(t3, e3), this.lineTo(t3 + r3, e3), this.lineTo(t3 + r3, e3 + n4), this.lineTo(t3, e3 + n4), this.lineTo(t3, e3), this.lineTo(t3 + r3, e3), this.lineTo(t3, e3);
    }, p3.prototype.fillRect = function(t3, e3, r3, n4) {
      if (isNaN(t3) || isNaN(e3) || isNaN(r3) || isNaN(n4))
        throw a2.error("jsPDF.context2d.fillRect: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.fillRect");
      if (!m4.call(this)) {
        var i6 = {};
        this.lineCap !== "butt" && (i6.lineCap = this.lineCap, this.lineCap = "butt"), this.lineJoin !== "miter" && (i6.lineJoin = this.lineJoin, this.lineJoin = "miter"), this.beginPath(), this.rect(t3, e3, r3, n4), this.fill(), i6.hasOwnProperty("lineCap") && (this.lineCap = i6.lineCap), i6.hasOwnProperty("lineJoin") && (this.lineJoin = i6.lineJoin);
      }
    }, p3.prototype.strokeRect = function(t3, e3, r3, n4) {
      if (isNaN(t3) || isNaN(e3) || isNaN(r3) || isNaN(n4))
        throw a2.error("jsPDF.context2d.strokeRect: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.strokeRect");
      v3.call(this) || (this.beginPath(), this.rect(t3, e3, r3, n4), this.stroke());
    }, p3.prototype.clearRect = function(t3, e3, r3, n4) {
      if (isNaN(t3) || isNaN(e3) || isNaN(r3) || isNaN(n4))
        throw a2.error("jsPDF.context2d.clearRect: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.clearRect");
      this.ignoreClearRect || (this.fillStyle = "#ffffff", this.fillRect(t3, e3, r3, n4));
    }, p3.prototype.save = function(t3) {
      t3 = typeof t3 != "boolean" || t3;
      for (var e3 = this.pdf.internal.getCurrentPageInfo().pageNumber, r3 = 0;r3 < this.pdf.internal.getNumberOfPages(); r3++)
        this.pdf.setPage(r3 + 1), this.pdf.internal.out("q");
      if (this.pdf.setPage(e3), t3) {
        this.ctx.fontSize = this.pdf.internal.getFontSize();
        var n4 = new d2(this.ctx);
        this.ctxStack.push(this.ctx), this.ctx = n4;
      }
    }, p3.prototype.restore = function(t3) {
      t3 = typeof t3 != "boolean" || t3;
      for (var e3 = this.pdf.internal.getCurrentPageInfo().pageNumber, r3 = 0;r3 < this.pdf.internal.getNumberOfPages(); r3++)
        this.pdf.setPage(r3 + 1), this.pdf.internal.out("Q");
      this.pdf.setPage(e3), t3 && this.ctxStack.length !== 0 && (this.ctx = this.ctxStack.pop(), this.fillStyle = this.ctx.fillStyle, this.strokeStyle = this.ctx.strokeStyle, this.font = this.ctx.font, this.lineCap = this.ctx.lineCap, this.lineWidth = this.ctx.lineWidth, this.lineJoin = this.ctx.lineJoin, this.lineDash = this.ctx.lineDash, this.lineDashOffset = this.ctx.lineDashOffset);
    }, p3.prototype.toDataURL = function() {
      throw new Error("toDataUrl not implemented.");
    };
    var g2 = function(t3) {
      var e3, r3, n4, i6;
      if (t3.isCanvasGradient === true && (t3 = t3.getColor()), !t3)
        return { r: 0, g: 0, b: 0, a: 0, style: t3 };
      if (/transparent|rgba\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*0+\s*\)/.test(t3))
        e3 = 0, r3 = 0, n4 = 0, i6 = 0;
      else {
        var a3 = /rgb\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)/.exec(t3);
        if (a3 !== null)
          e3 = parseInt(a3[1]), r3 = parseInt(a3[2]), n4 = parseInt(a3[3]), i6 = 1;
        else if ((a3 = /rgba\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*([\d.]+)\s*\)/.exec(t3)) !== null)
          e3 = parseInt(a3[1]), r3 = parseInt(a3[2]), n4 = parseInt(a3[3]), i6 = parseFloat(a3[4]);
        else {
          if (i6 = 1, typeof t3 == "string" && t3.charAt(0) !== "#") {
            var o4 = new f2(t3);
            t3 = o4.ok ? o4.toHex() : "#000000";
          }
          t3.length === 4 ? (e3 = t3.substring(1, 2), e3 += e3, r3 = t3.substring(2, 3), r3 += r3, n4 = t3.substring(3, 4), n4 += n4) : (e3 = t3.substring(1, 3), r3 = t3.substring(3, 5), n4 = t3.substring(5, 7)), e3 = parseInt(e3, 16), r3 = parseInt(r3, 16), n4 = parseInt(n4, 16);
        }
      }
      return { r: e3, g: r3, b: n4, a: i6, style: t3 };
    }, m4 = function() {
      return this.ctx.isFillTransparent || this.globalAlpha == 0;
    }, v3 = function() {
      return Boolean(this.ctx.isStrokeTransparent || this.globalAlpha == 0);
    };
    p3.prototype.fillText = function(t3, e3, r3, n4) {
      if (isNaN(e3) || isNaN(r3) || typeof t3 != "string")
        throw a2.error("jsPDF.context2d.fillText: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.fillText");
      if (n4 = isNaN(n4) ? undefined : n4, !m4.call(this)) {
        var i6 = q2(this.ctx.transform.rotation), o4 = this.ctx.transform.scaleX;
        C2.call(this, { text: t3, x: e3, y: r3, scale: o4, angle: i6, align: this.textAlign, maxWidth: n4 });
      }
    }, p3.prototype.strokeText = function(t3, e3, r3, n4) {
      if (isNaN(e3) || isNaN(r3) || typeof t3 != "string")
        throw a2.error("jsPDF.context2d.strokeText: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.strokeText");
      if (!v3.call(this)) {
        n4 = isNaN(n4) ? undefined : n4;
        var i6 = q2(this.ctx.transform.rotation), o4 = this.ctx.transform.scaleX;
        C2.call(this, { text: t3, x: e3, y: r3, scale: o4, renderingMode: "stroke", angle: i6, align: this.textAlign, maxWidth: n4 });
      }
    }, p3.prototype.measureText = function(t3) {
      if (typeof t3 != "string")
        throw a2.error("jsPDF.context2d.measureText: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.measureText");
      var e3 = this.pdf, r3 = this.pdf.internal.scaleFactor, n4 = e3.internal.getFontSize(), i6 = e3.getStringUnitWidth(t3) * n4 / e3.internal.scaleFactor, o4 = function(t4) {
        var e4 = (t4 = t4 || {}).width || 0;
        return Object.defineProperty(this, "width", { get: function() {
          return e4;
        } }), this;
      };
      return new o4({ width: i6 *= Math.round(96 * r3 / 72 * 1e4) / 1e4 });
    }, p3.prototype.scale = function(t3, e3) {
      if (isNaN(t3) || isNaN(e3))
        throw a2.error("jsPDF.context2d.scale: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.scale");
      var r3 = new h3(t3, 0, 0, e3, 0, 0);
      this.ctx.transform = this.ctx.transform.multiply(r3);
    }, p3.prototype.rotate = function(t3) {
      if (isNaN(t3))
        throw a2.error("jsPDF.context2d.rotate: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.rotate");
      var e3 = new h3(Math.cos(t3), Math.sin(t3), -Math.sin(t3), Math.cos(t3), 0, 0);
      this.ctx.transform = this.ctx.transform.multiply(e3);
    }, p3.prototype.translate = function(t3, e3) {
      if (isNaN(t3) || isNaN(e3))
        throw a2.error("jsPDF.context2d.translate: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.translate");
      var r3 = new h3(1, 0, 0, 1, t3, e3);
      this.ctx.transform = this.ctx.transform.multiply(r3);
    }, p3.prototype.transform = function(t3, e3, r3, n4, i6, o4) {
      if (isNaN(t3) || isNaN(e3) || isNaN(r3) || isNaN(n4) || isNaN(i6) || isNaN(o4))
        throw a2.error("jsPDF.context2d.transform: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.transform");
      var s4 = new h3(t3, e3, r3, n4, i6, o4);
      this.ctx.transform = this.ctx.transform.multiply(s4);
    }, p3.prototype.setTransform = function(t3, e3, r3, n4, i6, a3) {
      t3 = isNaN(t3) ? 1 : t3, e3 = isNaN(e3) ? 0 : e3, r3 = isNaN(r3) ? 0 : r3, n4 = isNaN(n4) ? 1 : n4, i6 = isNaN(i6) ? 0 : i6, a3 = isNaN(a3) ? 0 : a3, this.ctx.transform = new h3(t3, e3, r3, n4, i6, a3);
    };
    var b2 = function() {
      return this.margin[0] > 0 || this.margin[1] > 0 || this.margin[2] > 0 || this.margin[3] > 0;
    };
    p3.prototype.drawImage = function(t3, e3, r3, n4, i6, a3, o4, s4, c5) {
      var l4 = this.pdf.getImageProperties(t3), f3 = 1, d3 = 1, p4 = 1, g3 = 1;
      n4 !== undefined && s4 !== undefined && (p4 = s4 / n4, g3 = c5 / i6, f3 = l4.width / n4 * s4 / n4, d3 = l4.height / i6 * c5 / i6), a3 === undefined && (a3 = e3, o4 = r3, e3 = 0, r3 = 0), n4 !== undefined && s4 === undefined && (s4 = n4, c5 = i6), n4 === undefined && s4 === undefined && (s4 = l4.width, c5 = l4.height);
      for (var m5, v4 = this.ctx.transform.decompose(), w3 = q2(v4.rotate.shx), A3 = new h3, S3 = (A3 = (A3 = (A3 = A3.multiply(v4.translate)).multiply(v4.skew)).multiply(v4.scale)).applyToRectangle(new u3(a3 - e3 * p4, o4 - r3 * g3, n4 * f3, i6 * d3)), _4 = y3.call(this, S3), P3 = [], k3 = 0;k3 < _4.length; k3 += 1)
        P3.indexOf(_4[k3]) === -1 && P3.push(_4[k3]);
      if (L2(P3), this.autoPaging)
        for (var I3 = P3[0], F3 = P3[P3.length - 1], C3 = I3;C3 < F3 + 1; C3++) {
          this.pdf.setPage(C3);
          var j3 = this.pdf.internal.pageSize.width - this.margin[3] - this.margin[1], O4 = C3 === 1 ? this.posY + this.margin[0] : this.margin[0], B3 = this.pdf.internal.pageSize.height - this.posY - this.margin[0] - this.margin[2], M3 = this.pdf.internal.pageSize.height - this.margin[0] - this.margin[2], E3 = C3 === 1 ? 0 : B3 + (C3 - 2) * M3;
          if (this.ctx.clip_path.length !== 0) {
            var D3 = this.path;
            m5 = JSON.parse(JSON.stringify(this.ctx.clip_path)), this.path = N3(m5, this.posX + this.margin[3], -E3 + O4 + this.ctx.prevPageLastElemOffset), x3.call(this, "fill", true), this.path = D3;
          }
          var R3 = JSON.parse(JSON.stringify(S3));
          R3 = N3([R3], this.posX + this.margin[3], -E3 + O4 + this.ctx.prevPageLastElemOffset)[0];
          var T4 = (C3 > I3 || C3 < F3) && b2.call(this);
          T4 && (this.pdf.saveGraphicsState(), this.pdf.rect(this.margin[3], this.margin[0], j3, M3, null).clip().discardPath()), this.pdf.addImage(t3, "JPEG", R3.x, R3.y, R3.w, R3.h, null, null, w3), T4 && this.pdf.restoreGraphicsState();
        }
      else
        this.pdf.addImage(t3, "JPEG", S3.x, S3.y, S3.w, S3.h, null, null, w3);
    };
    var y3 = function(t3, e3, r3) {
      var n4 = [];
      e3 = e3 || this.pdf.internal.pageSize.width, r3 = r3 || this.pdf.internal.pageSize.height - this.margin[0] - this.margin[2];
      var i6 = this.posY + this.ctx.prevPageLastElemOffset;
      switch (t3.type) {
        default:
        case "mt":
        case "lt":
          n4.push(Math.floor((t3.y + i6) / r3) + 1);
          break;
        case "arc":
          n4.push(Math.floor((t3.y + i6 - t3.radius) / r3) + 1), n4.push(Math.floor((t3.y + i6 + t3.radius) / r3) + 1);
          break;
        case "qct":
          var a3 = D2(this.ctx.lastPoint.x, this.ctx.lastPoint.y, t3.x1, t3.y1, t3.x, t3.y);
          n4.push(Math.floor((a3.y + i6) / r3) + 1), n4.push(Math.floor((a3.y + a3.h + i6) / r3) + 1);
          break;
        case "bct":
          var o4 = R2(this.ctx.lastPoint.x, this.ctx.lastPoint.y, t3.x1, t3.y1, t3.x2, t3.y2, t3.x, t3.y);
          n4.push(Math.floor((o4.y + i6) / r3) + 1), n4.push(Math.floor((o4.y + o4.h + i6) / r3) + 1);
          break;
        case "rect":
          n4.push(Math.floor((t3.y + i6) / r3) + 1), n4.push(Math.floor((t3.y + t3.h + i6) / r3) + 1);
      }
      for (var s4 = 0;s4 < n4.length; s4 += 1)
        for (;this.pdf.internal.getNumberOfPages() < n4[s4]; )
          w2.call(this);
      return n4;
    }, w2 = function() {
      var t3 = this.fillStyle, e3 = this.strokeStyle, r3 = this.font, n4 = this.lineCap, i6 = this.lineWidth, a3 = this.lineJoin;
      this.pdf.addPage(), this.fillStyle = t3, this.strokeStyle = e3, this.font = r3, this.lineCap = n4, this.lineWidth = i6, this.lineJoin = a3;
    }, N3 = function(t3, e3, r3) {
      for (var n4 = 0;n4 < t3.length; n4++)
        switch (t3[n4].type) {
          case "bct":
            t3[n4].x2 += e3, t3[n4].y2 += r3;
          case "qct":
            t3[n4].x1 += e3, t3[n4].y1 += r3;
          case "mt":
          case "lt":
          case "arc":
          default:
            t3[n4].x += e3, t3[n4].y += r3;
        }
      return t3;
    }, L2 = function(t3) {
      return t3.sort(function(t4, e3) {
        return t4 - e3;
      });
    }, A2 = function(t3, e3) {
      for (var r3, n4, i6 = this.fillStyle, a3 = this.strokeStyle, o4 = this.lineCap, s4 = this.lineWidth, c5 = Math.abs(s4 * this.ctx.transform.scaleX), u4 = this.lineJoin, h4 = JSON.parse(JSON.stringify(this.path)), l4 = JSON.parse(JSON.stringify(this.path)), f3 = [], d3 = 0;d3 < l4.length; d3++)
        if (l4[d3].x !== undefined)
          for (var p4 = y3.call(this, l4[d3]), g3 = 0;g3 < p4.length; g3 += 1)
            f3.indexOf(p4[g3]) === -1 && f3.push(p4[g3]);
      for (var m5 = 0;m5 < f3.length; m5++)
        for (;this.pdf.internal.getNumberOfPages() < f3[m5]; )
          w2.call(this);
      if (L2(f3), this.autoPaging)
        for (var v4 = f3[0], A3 = f3[f3.length - 1], S3 = v4;S3 < A3 + 1; S3++) {
          this.pdf.setPage(S3), this.fillStyle = i6, this.strokeStyle = a3, this.lineCap = o4, this.lineWidth = c5, this.lineJoin = u4;
          var _4 = this.pdf.internal.pageSize.width - this.margin[3] - this.margin[1], P3 = S3 === 1 ? this.posY + this.margin[0] : this.margin[0], k3 = this.pdf.internal.pageSize.height - this.posY - this.margin[0] - this.margin[2], I3 = this.pdf.internal.pageSize.height - this.margin[0] - this.margin[2], F3 = S3 === 1 ? 0 : k3 + (S3 - 2) * I3;
          if (this.ctx.clip_path.length !== 0) {
            var C3 = this.path;
            r3 = JSON.parse(JSON.stringify(this.ctx.clip_path)), this.path = N3(r3, this.posX + this.margin[3], -F3 + P3 + this.ctx.prevPageLastElemOffset), x3.call(this, t3, true), this.path = C3;
          }
          if (n4 = JSON.parse(JSON.stringify(h4)), this.path = N3(n4, this.posX + this.margin[3], -F3 + P3 + this.ctx.prevPageLastElemOffset), e3 === false || S3 === 0) {
            var j3 = (S3 > v4 || S3 < A3) && b2.call(this);
            j3 && (this.pdf.saveGraphicsState(), this.pdf.rect(this.margin[3], this.margin[0], _4, I3, null).clip().discardPath()), x3.call(this, t3, e3), j3 && this.pdf.restoreGraphicsState();
          }
          this.lineWidth = s4;
        }
      else
        this.lineWidth = c5, x3.call(this, t3, e3), this.lineWidth = s4;
      this.path = h4;
    }, x3 = function(t3, e3) {
      if ((t3 !== "stroke" || e3 || !v3.call(this)) && (t3 === "stroke" || e3 || !m4.call(this))) {
        for (var r3, n4, i6 = [], a3 = this.path, o4 = 0;o4 < a3.length; o4++) {
          var s4 = a3[o4];
          switch (s4.type) {
            case "begin":
              i6.push({ begin: true });
              break;
            case "close":
              i6.push({ close: true });
              break;
            case "mt":
              i6.push({ start: s4, deltas: [], abs: [] });
              break;
            case "lt":
              var c5 = i6.length;
              if (a3[o4 - 1] && !isNaN(a3[o4 - 1].x) && (r3 = [s4.x - a3[o4 - 1].x, s4.y - a3[o4 - 1].y], c5 > 0)) {
                for (;c5 >= 0; c5--)
                  if (i6[c5 - 1].close !== true && i6[c5 - 1].begin !== true) {
                    i6[c5 - 1].deltas.push(r3), i6[c5 - 1].abs.push(s4);
                    break;
                  }
              }
              break;
            case "bct":
              r3 = [s4.x1 - a3[o4 - 1].x, s4.y1 - a3[o4 - 1].y, s4.x2 - a3[o4 - 1].x, s4.y2 - a3[o4 - 1].y, s4.x - a3[o4 - 1].x, s4.y - a3[o4 - 1].y], i6[i6.length - 1].deltas.push(r3);
              break;
            case "qct":
              var u4 = a3[o4 - 1].x + 2 / 3 * (s4.x1 - a3[o4 - 1].x), h4 = a3[o4 - 1].y + 2 / 3 * (s4.y1 - a3[o4 - 1].y), l4 = s4.x + 2 / 3 * (s4.x1 - s4.x), f3 = s4.y + 2 / 3 * (s4.y1 - s4.y), d3 = s4.x, p4 = s4.y;
              r3 = [u4 - a3[o4 - 1].x, h4 - a3[o4 - 1].y, l4 - a3[o4 - 1].x, f3 - a3[o4 - 1].y, d3 - a3[o4 - 1].x, p4 - a3[o4 - 1].y], i6[i6.length - 1].deltas.push(r3);
              break;
            case "arc":
              i6.push({ deltas: [], abs: [], arc: true }), Array.isArray(i6[i6.length - 1].abs) && i6[i6.length - 1].abs.push(s4);
          }
        }
        n4 = e3 ? null : t3 === "stroke" ? "stroke" : "fill";
        for (var g3 = false, b3 = 0;b3 < i6.length; b3++)
          if (i6[b3].arc)
            for (var y4 = i6[b3].abs, w3 = 0;w3 < y4.length; w3++) {
              var N4 = y4[w3];
              N4.type === "arc" ? P2.call(this, N4.x, N4.y, N4.radius, N4.startAngle, N4.endAngle, N4.counterclockwise, undefined, e3, !g3) : j2.call(this, N4.x, N4.y), g3 = true;
            }
          else if (i6[b3].close === true)
            this.pdf.internal.out("h"), g3 = false;
          else if (i6[b3].begin !== true) {
            var L3 = i6[b3].start.x, A3 = i6[b3].start.y;
            O3.call(this, i6[b3].deltas, L3, A3), g3 = true;
          }
        n4 && k2.call(this, n4), e3 && I2.call(this);
      }
    }, S2 = function(t3) {
      var e3 = this.pdf.internal.getFontSize() / this.pdf.internal.scaleFactor, r3 = e3 * (this.pdf.internal.getLineHeightFactor() - 1);
      switch (this.ctx.textBaseline) {
        case "bottom":
          return t3 - r3;
        case "top":
          return t3 + e3 - r3;
        case "hanging":
          return t3 + e3 - 2 * r3;
        case "middle":
          return t3 + e3 / 2 - r3;
        case "ideographic":
          return t3;
        case "alphabetic":
        default:
          return t3;
      }
    }, _3 = function(t3) {
      return t3 + this.pdf.internal.getFontSize() / this.pdf.internal.scaleFactor * (this.pdf.internal.getLineHeightFactor() - 1);
    };
    p3.prototype.createLinearGradient = function() {
      var t3 = function() {};
      return t3.colorStops = [], t3.addColorStop = function(t4, e3) {
        this.colorStops.push([t4, e3]);
      }, t3.getColor = function() {
        return this.colorStops.length === 0 ? "#000000" : this.colorStops[0][1];
      }, t3.isCanvasGradient = true, t3;
    }, p3.prototype.createPattern = function() {
      return this.createLinearGradient();
    }, p3.prototype.createRadialGradient = function() {
      return this.createLinearGradient();
    };
    var P2 = function(t3, e3, r3, n4, i6, a3, o4, s4, c5) {
      for (var u4 = M2.call(this, r3, n4, i6, a3), h4 = 0;h4 < u4.length; h4++) {
        var l4 = u4[h4];
        h4 === 0 && (c5 ? F2.call(this, l4.x1 + t3, l4.y1 + e3) : j2.call(this, l4.x1 + t3, l4.y1 + e3)), B2.call(this, t3, e3, l4.x2, l4.y2, l4.x3, l4.y3, l4.x4, l4.y4);
      }
      s4 ? I2.call(this) : k2.call(this, o4);
    }, k2 = function(t3) {
      switch (t3) {
        case "stroke":
          this.pdf.internal.out("S");
          break;
        case "fill":
          this.pdf.internal.out("f");
      }
    }, I2 = function() {
      this.pdf.clip(), this.pdf.discardPath();
    }, F2 = function(t3, e3) {
      this.pdf.internal.out(n3(t3) + " " + i5(e3) + " m");
    }, C2 = function(t3) {
      var e3;
      switch (t3.align) {
        case "right":
        case "end":
          e3 = "right";
          break;
        case "center":
          e3 = "center";
          break;
        case "left":
        case "start":
        default:
          e3 = "left";
      }
      var r3 = this.pdf.getTextDimensions(t3.text), n4 = S2.call(this, t3.y), i6 = _3.call(this, n4) - r3.h, a3 = this.ctx.transform.applyToPoint(new c4(t3.x, n4)), o4 = this.ctx.transform.decompose(), s4 = new h3;
      s4 = (s4 = (s4 = s4.multiply(o4.translate)).multiply(o4.skew)).multiply(o4.scale);
      for (var l4, f3, d3, p4 = this.ctx.transform.applyToRectangle(new u3(t3.x, n4, r3.w, r3.h)), g3 = s4.applyToRectangle(new u3(t3.x, i6, r3.w, r3.h)), m5 = y3.call(this, g3), v4 = [], w3 = 0;w3 < m5.length; w3 += 1)
        v4.indexOf(m5[w3]) === -1 && v4.push(m5[w3]);
      if (L2(v4), this.autoPaging)
        for (var A3 = v4[0], P3 = v4[v4.length - 1], k3 = A3;k3 < P3 + 1; k3++) {
          this.pdf.setPage(k3);
          var I3 = k3 === 1 ? this.posY + this.margin[0] : this.margin[0], F3 = this.pdf.internal.pageSize.height - this.posY - this.margin[0] - this.margin[2], C3 = this.pdf.internal.pageSize.height - this.margin[2], j3 = C3 - this.margin[0], O4 = this.pdf.internal.pageSize.width - this.margin[1], B3 = O4 - this.margin[3], M3 = k3 === 1 ? 0 : F3 + (k3 - 2) * j3;
          if (this.ctx.clip_path.length !== 0) {
            var E3 = this.path;
            l4 = JSON.parse(JSON.stringify(this.ctx.clip_path)), this.path = N3(l4, this.posX + this.margin[3], -1 * M3 + I3), x3.call(this, "fill", true), this.path = E3;
          }
          var q3 = N3([JSON.parse(JSON.stringify(g3))], this.posX + this.margin[3], -M3 + I3 + this.ctx.prevPageLastElemOffset)[0];
          t3.scale >= 0.01 && (f3 = this.pdf.internal.getFontSize(), this.pdf.setFontSize(f3 * t3.scale), d3 = this.lineWidth, this.lineWidth = d3 * t3.scale);
          var D3 = this.autoPaging !== "text";
          if (D3 || q3.y + q3.h <= C3) {
            if (D3 || q3.y >= I3 && q3.x <= O4) {
              var R3 = D3 ? t3.text : this.pdf.splitTextToSize(t3.text, t3.maxWidth || O4 - q3.x)[0], T4 = N3([JSON.parse(JSON.stringify(p4))], this.posX + this.margin[3], -M3 + I3 + this.ctx.prevPageLastElemOffset)[0], U2 = D3 && (k3 > A3 || k3 < P3) && b2.call(this);
              U2 && (this.pdf.saveGraphicsState(), this.pdf.rect(this.margin[3], this.margin[0], B3, j3, null).clip().discardPath()), this.pdf.text(R3, T4.x, T4.y, { angle: t3.angle, align: e3, renderingMode: t3.renderingMode }), U2 && this.pdf.restoreGraphicsState();
            }
          } else
            q3.y < C3 && (this.ctx.prevPageLastElemOffset += C3 - q3.y);
          t3.scale >= 0.01 && (this.pdf.setFontSize(f3), this.lineWidth = d3);
        }
      else
        t3.scale >= 0.01 && (f3 = this.pdf.internal.getFontSize(), this.pdf.setFontSize(f3 * t3.scale), d3 = this.lineWidth, this.lineWidth = d3 * t3.scale), this.pdf.text(t3.text, a3.x + this.posX, a3.y + this.posY, { angle: t3.angle, align: e3, renderingMode: t3.renderingMode, maxWidth: t3.maxWidth }), t3.scale >= 0.01 && (this.pdf.setFontSize(f3), this.lineWidth = d3);
    }, j2 = function(t3, e3, r3, a3) {
      r3 = r3 || 0, a3 = a3 || 0, this.pdf.internal.out(n3(t3 + r3) + " " + i5(e3 + a3) + " l");
    }, O3 = function(t3, e3, r3) {
      return this.pdf.lines(t3, e3, r3, null, null);
    }, B2 = function(t3, e3, n4, i6, a3, c5, u4, h4) {
      this.pdf.internal.out([r2(o3(n4 + t3)), r2(s3(i6 + e3)), r2(o3(a3 + t3)), r2(s3(c5 + e3)), r2(o3(u4 + t3)), r2(s3(h4 + e3)), "c"].join(" "));
    }, M2 = function(t3, e3, r3, n4) {
      for (var i6 = 2 * Math.PI, a3 = Math.PI / 2;e3 > r3; )
        e3 -= i6;
      var o4 = Math.abs(r3 - e3);
      o4 < i6 && n4 && (o4 = i6 - o4);
      for (var s4 = [], c5 = n4 ? -1 : 1, u4 = e3;o4 > 0.00001; ) {
        var h4 = u4 + c5 * Math.min(o4, a3);
        s4.push(E2.call(this, t3, u4, h4)), o4 -= Math.abs(h4 - u4), u4 = h4;
      }
      return s4;
    }, E2 = function(t3, e3, r3) {
      var n4 = (r3 - e3) / 2, i6 = t3 * Math.cos(n4), a3 = t3 * Math.sin(n4), o4 = i6, s4 = -a3, c5 = o4 * o4 + s4 * s4, u4 = c5 + o4 * i6 + s4 * a3, h4 = 4 / 3 * (Math.sqrt(2 * c5 * u4) - u4) / (o4 * a3 - s4 * i6), l4 = o4 - h4 * s4, f3 = s4 + h4 * o4, d3 = l4, p4 = -f3, g3 = n4 + e3, m5 = Math.cos(g3), v4 = Math.sin(g3);
      return { x1: t3 * Math.cos(e3), y1: t3 * Math.sin(e3), x2: l4 * m5 - f3 * v4, y2: l4 * v4 + f3 * m5, x3: d3 * m5 - p4 * v4, y3: d3 * v4 + p4 * m5, x4: t3 * Math.cos(r3), y4: t3 * Math.sin(r3) };
    }, q2 = function(t3) {
      return 180 * t3 / Math.PI;
    }, D2 = function(t3, e3, r3, n4, i6, a3) {
      var o4 = t3 + 0.5 * (r3 - t3), s4 = e3 + 0.5 * (n4 - e3), c5 = i6 + 0.5 * (r3 - i6), h4 = a3 + 0.5 * (n4 - a3), l4 = Math.min(t3, i6, o4, c5), f3 = Math.max(t3, i6, o4, c5), d3 = Math.min(e3, a3, s4, h4), p4 = Math.max(e3, a3, s4, h4);
      return new u3(l4, d3, f3 - l4, p4 - d3);
    }, R2 = function(t3, e3, r3, n4, i6, a3, o4, s4) {
      var c5, h4, l4, f3, d3, p4, g3, m5, v4, b3, y4, w3, N4, L3, A3 = r3 - t3, x4 = n4 - e3, S3 = i6 - r3, _4 = a3 - n4, P3 = o4 - i6, k3 = s4 - a3;
      for (h4 = 0;h4 < 41; h4++)
        v4 = (g3 = (l4 = t3 + (c5 = h4 / 40) * A3) + c5 * ((d3 = r3 + c5 * S3) - l4)) + c5 * (d3 + c5 * (i6 + c5 * P3 - d3) - g3), b3 = (m5 = (f3 = e3 + c5 * x4) + c5 * ((p4 = n4 + c5 * _4) - f3)) + c5 * (p4 + c5 * (a3 + c5 * k3 - p4) - m5), h4 == 0 ? (y4 = v4, w3 = b3, N4 = v4, L3 = b3) : (y4 = Math.min(y4, v4), w3 = Math.min(w3, b3), N4 = Math.max(N4, v4), L3 = Math.max(L3, b3));
      return new u3(Math.round(y4), Math.round(w3), Math.round(N4 - y4), Math.round(L3 - w3));
    }, T3 = function() {
      if (this.prevLineDash || this.ctx.lineDash.length || this.ctx.lineDashOffset) {
        var t3, e3, r3 = (t3 = this.ctx.lineDash, e3 = this.ctx.lineDashOffset, JSON.stringify({ lineDash: t3, lineDashOffset: e3 }));
        this.prevLineDash !== r3 && (this.pdf.setLineDash(this.ctx.lineDash, this.ctx.lineDashOffset), this.prevLineDash = r3);
      }
    };
  })(E.API), function(t3) {
    var r2 = function(t4) {
      var e2, r3, n4, i6, a4, o3, s3, c4, u3, h3;
      for (/[^\x00-\xFF]/.test(t4), r3 = [], n4 = 0, i6 = (t4 += e2 = "\x00\x00\x00\x00".slice(t4.length % 4 || 4)).length;i6 > n4; n4 += 4)
        (a4 = (t4.charCodeAt(n4) << 24) + (t4.charCodeAt(n4 + 1) << 16) + (t4.charCodeAt(n4 + 2) << 8) + t4.charCodeAt(n4 + 3)) !== 0 ? (o3 = (a4 = ((a4 = ((a4 = ((a4 = (a4 - (h3 = a4 % 85)) / 85) - (u3 = a4 % 85)) / 85) - (c4 = a4 % 85)) / 85) - (s3 = a4 % 85)) / 85) % 85, r3.push(o3 + 33, s3 + 33, c4 + 33, u3 + 33, h3 + 33)) : r3.push(122);
      return function(t5, e3) {
        for (var r4 = e3;r4 > 0; r4--)
          t5.pop();
      }(r3, e2.length), String.fromCharCode.apply(String, r3) + "~>";
    }, n3 = function(t4) {
      var e2, r3, n4, i6, a4, o3 = String, s3 = "length", c4 = 255, u3 = "charCodeAt", h3 = "slice", l3 = "replace";
      for (t4[h3](-2), t4 = t4[h3](0, -2)[l3](/\s/g, "")[l3]("z", "!!!!!"), n4 = [], i6 = 0, a4 = (t4 += e2 = "uuuuu"[h3](t4[s3] % 5 || 5))[s3];a4 > i6; i6 += 5)
        r3 = 52200625 * (t4[u3](i6) - 33) + 614125 * (t4[u3](i6 + 1) - 33) + 7225 * (t4[u3](i6 + 2) - 33) + 85 * (t4[u3](i6 + 3) - 33) + (t4[u3](i6 + 4) - 33), n4.push(c4 & r3 >> 24, c4 & r3 >> 16, c4 & r3 >> 8, c4 & r3);
      return function(t5, e3) {
        for (var r4 = e3;r4 > 0; r4--)
          t5.pop();
      }(n4, e2[s3]), o3.fromCharCode.apply(o3, n4);
    }, i5 = function(t4) {
      var e2 = new RegExp(/^([0-9A-Fa-f]{2})+$/);
      if ((t4 = t4.replace(/\s/g, "")).indexOf(">") !== -1 && (t4 = t4.substr(0, t4.indexOf(">"))), t4.length % 2 && (t4 += "0"), e2.test(t4) === false)
        return "";
      for (var r3 = "", n4 = 0;n4 < t4.length; n4 += 2)
        r3 += String.fromCharCode("0x" + (t4[n4] + t4[n4 + 1]));
      return r3;
    }, a3 = function(t4) {
      for (var r3 = new Uint8Array(t4.length), n4 = t4.length;n4--; )
        r3[n4] = t4.charCodeAt(n4);
      return t4 = (r3 = zlibSync(r3)).reduce(function(t5, e2) {
        return t5 + String.fromCharCode(e2);
      }, "");
    };
    t3.processDataByFilters = function(t4, e2) {
      var o3 = 0, s3 = t4 || "", c4 = [];
      for (typeof (e2 = e2 || []) == "string" && (e2 = [e2]), o3 = 0;o3 < e2.length; o3 += 1)
        switch (e2[o3]) {
          case "ASCII85Decode":
          case "/ASCII85Decode":
            s3 = n3(s3), c4.push("/ASCII85Encode");
            break;
          case "ASCII85Encode":
          case "/ASCII85Encode":
            s3 = r2(s3), c4.push("/ASCII85Decode");
            break;
          case "ASCIIHexDecode":
          case "/ASCIIHexDecode":
            s3 = i5(s3), c4.push("/ASCIIHexEncode");
            break;
          case "ASCIIHexEncode":
          case "/ASCIIHexEncode":
            s3 = s3.split("").map(function(t5) {
              return ("0" + t5.charCodeAt().toString(16)).slice(-2);
            }).join("") + ">", c4.push("/ASCIIHexDecode");
            break;
          case "FlateEncode":
          case "/FlateEncode":
            s3 = a3(s3), c4.push("/FlateDecode");
            break;
          default:
            throw new Error('The filter: "' + e2[o3] + '" is not implemented');
        }
      return { data: s3, reverseChain: c4.reverse().join(" ") };
    };
  }(E.API), function(t3) {
    t3.loadFile = function(t4, e2, r2) {
      return function(t5, e3, r3) {
        e3 = e3 !== false, r3 = typeof r3 == "function" ? r3 : function() {};
        var n3 = undefined;
        try {
          n3 = function(t6, e4, r4) {
            var n4 = new XMLHttpRequest, i5 = 0, a3 = function(t7) {
              var e5 = t7.length, r5 = [], n5 = String.fromCharCode;
              for (i5 = 0;i5 < e5; i5 += 1)
                r5.push(n5(255 & t7.charCodeAt(i5)));
              return r5.join("");
            };
            if (n4.open("GET", t6, !e4), n4.overrideMimeType("text/plain; charset=x-user-defined"), e4 === false && (n4.onload = function() {
              n4.status === 200 ? r4(a3(this.responseText)) : r4(undefined);
            }), n4.send(null), e4 && n4.status === 200)
              return a3(n4.responseText);
          }(t5, e3, r3);
        } catch (t6) {}
        return n3;
      }(t4, e2, r2);
    }, t3.loadImageFile = t3.loadFile;
  }(E.API), function(e2) {
    function r2() {
      return (n2.html2canvas ? Promise.resolve(n2.html2canvas) : Promise.resolve().then(() => __toESM(require_html2canvas(), 1))).catch(function(t3) {
        return Promise.reject(new Error("Could not load html2canvas: " + t3));
      }).then(function(t3) {
        return t3.default ? t3.default : t3;
      });
    }
    function i5() {
      return (n2.DOMPurify ? Promise.resolve(n2.DOMPurify) : Promise.resolve().then(() => __toESM(require_purify(), 1))).catch(function(t3) {
        return Promise.reject(new Error("Could not load dompurify: " + t3));
      }).then(function(t3) {
        return t3.default ? t3.default : t3;
      });
    }
    var a3 = function(e3) {
      var r3 = _typeof(e3);
      return r3 === "undefined" ? "undefined" : r3 === "string" || e3 instanceof String ? "string" : r3 === "number" || e3 instanceof Number ? "number" : r3 === "function" || e3 instanceof Function ? "function" : e3 && e3.constructor === Array ? "array" : e3 && e3.nodeType === 1 ? "element" : r3 === "object" ? "object" : "unknown";
    }, o3 = function(t3, e3) {
      var r3 = document.createElement(t3);
      for (var n3 in e3.className && (r3.className = e3.className), e3.innerHTML && e3.dompurify && (r3.innerHTML = e3.dompurify.sanitize(e3.innerHTML)), e3.style)
        r3.style[n3] = e3.style[n3];
      return r3;
    }, s3 = function t(e3) {
      var r3 = Object.assign(t.convert(Promise.resolve()), JSON.parse(JSON.stringify(t.template))), n3 = t.convert(Promise.resolve(), r3);
      return n3 = (n3 = n3.setProgress(1, t, 1, [t])).set(e3);
    };
    (s3.prototype = Object.create(Promise.prototype)).constructor = s3, s3.convert = function(t3, e3) {
      return t3.__proto__ = e3 || s3.prototype, t3;
    }, s3.template = { prop: { src: null, container: null, overlay: null, canvas: null, img: null, pdf: null, pageSize: null, callback: function() {} }, progress: { val: 0, state: null, n: 0, stack: [] }, opt: { filename: "file.pdf", margin: [0, 0, 0, 0], enableLinks: true, x: 0, y: 0, html2canvas: {}, jsPDF: {}, backgroundColor: "transparent" } }, s3.prototype.from = function(t3, e3) {
      return this.then(function() {
        switch (e3 = e3 || function(t4) {
          switch (a3(t4)) {
            case "string":
              return "string";
            case "element":
              return t4.nodeName.toLowerCase() === "canvas" ? "canvas" : "element";
            default:
              return "unknown";
          }
        }(t3)) {
          case "string":
            return this.then(i5).then(function(e4) {
              return this.set({ src: o3("div", { innerHTML: t3, dompurify: e4 }) });
            });
          case "element":
            return this.set({ src: t3 });
          case "canvas":
            return this.set({ canvas: t3 });
          case "img":
            return this.set({ img: t3 });
          default:
            return this.error("Unknown source type.");
        }
      });
    }, s3.prototype.to = function(t3) {
      switch (t3) {
        case "container":
          return this.toContainer();
        case "canvas":
          return this.toCanvas();
        case "img":
          return this.toImg();
        case "pdf":
          return this.toPdf();
        default:
          return this.error("Invalid target.");
      }
    }, s3.prototype.toContainer = function() {
      return this.thenList([function() {
        return this.prop.src || this.error("Cannot duplicate - no source HTML.");
      }, function() {
        return this.prop.pageSize || this.setPageSize();
      }]).then(function() {
        var t3 = { position: "relative", display: "inline-block", width: (typeof this.opt.width != "number" || isNaN(this.opt.width) || typeof this.opt.windowWidth != "number" || isNaN(this.opt.windowWidth) ? Math.max(this.prop.src.clientWidth, this.prop.src.scrollWidth, this.prop.src.offsetWidth) : this.opt.windowWidth) + "px", left: 0, right: 0, top: 0, margin: "auto", backgroundColor: this.opt.backgroundColor }, e3 = function t(e4, r3) {
          for (var n3 = e4.nodeType === 3 ? document.createTextNode(e4.nodeValue) : e4.cloneNode(false), i6 = e4.firstChild;i6; i6 = i6.nextSibling)
            r3 !== true && i6.nodeType === 1 && i6.nodeName === "SCRIPT" || n3.appendChild(t(i6, r3));
          return e4.nodeType === 1 && (e4.nodeName === "CANVAS" ? (n3.width = e4.width, n3.height = e4.height, n3.getContext("2d").drawImage(e4, 0, 0)) : e4.nodeName !== "TEXTAREA" && e4.nodeName !== "SELECT" || (n3.value = e4.value), n3.addEventListener("load", function() {
            n3.scrollTop = e4.scrollTop, n3.scrollLeft = e4.scrollLeft;
          }, true)), n3;
        }(this.prop.src, this.opt.html2canvas.javascriptEnabled);
        e3.tagName === "BODY" && (t3.height = Math.max(document.body.scrollHeight, document.body.offsetHeight, document.documentElement.clientHeight, document.documentElement.scrollHeight, document.documentElement.offsetHeight) + "px"), this.prop.overlay = o3("div", { className: "html2pdf__overlay", style: { position: "fixed", overflow: "hidden", zIndex: 1000, left: "-100000px", right: 0, bottom: 0, top: 0 } }), this.prop.container = o3("div", { className: "html2pdf__container", style: t3 }), this.prop.container.appendChild(e3), this.prop.container.firstChild.appendChild(o3("div", { style: { clear: "both", border: "0 none transparent", margin: 0, padding: 0, height: 0 } })), this.prop.container.style.float = "none", this.prop.overlay.appendChild(this.prop.container), document.body.appendChild(this.prop.overlay), this.prop.container.firstChild.style.position = "relative", this.prop.container.height = Math.max(this.prop.container.firstChild.clientHeight, this.prop.container.firstChild.scrollHeight, this.prop.container.firstChild.offsetHeight) + "px";
      });
    }, s3.prototype.toCanvas = function() {
      var t3 = [function() {
        return document.body.contains(this.prop.container) || this.toContainer();
      }];
      return this.thenList(t3).then(r2).then(function(t4) {
        var e3 = Object.assign({}, this.opt.html2canvas);
        return delete e3.onrendered, t4(this.prop.container, e3);
      }).then(function(t4) {
        (this.opt.html2canvas.onrendered || function() {})(t4), this.prop.canvas = t4, document.body.removeChild(this.prop.overlay);
      });
    }, s3.prototype.toContext2d = function() {
      var t3 = [function() {
        return document.body.contains(this.prop.container) || this.toContainer();
      }];
      return this.thenList(t3).then(r2).then(function(t4) {
        var e3 = this.opt.jsPDF, r3 = this.opt.fontFaces, n3 = typeof this.opt.width != "number" || isNaN(this.opt.width) || typeof this.opt.windowWidth != "number" || isNaN(this.opt.windowWidth) ? 1 : this.opt.width / this.opt.windowWidth, i6 = Object.assign({ async: true, allowTaint: true, scale: n3, scrollX: this.opt.scrollX || 0, scrollY: this.opt.scrollY || 0, backgroundColor: "#ffffff", imageTimeout: 15000, logging: true, proxy: null, removeContainer: true, foreignObjectRendering: false, useCORS: false }, this.opt.html2canvas);
        if (delete i6.onrendered, e3.context2d.autoPaging = this.opt.autoPaging === undefined || this.opt.autoPaging, e3.context2d.posX = this.opt.x, e3.context2d.posY = this.opt.y, e3.context2d.margin = this.opt.margin, e3.context2d.fontFaces = r3, r3)
          for (var a4 = 0;a4 < r3.length; ++a4) {
            var o4 = r3[a4], s4 = o4.src.find(function(t5) {
              return t5.format === "truetype";
            });
            s4 && e3.addFont(s4.url, o4.ref.name, o4.ref.style);
          }
        return i6.windowHeight = i6.windowHeight || 0, i6.windowHeight = i6.windowHeight == 0 ? Math.max(this.prop.container.clientHeight, this.prop.container.scrollHeight, this.prop.container.offsetHeight) : i6.windowHeight, e3.context2d.save(true), t4(this.prop.container, i6);
      }).then(function(t4) {
        this.opt.jsPDF.context2d.restore(true), (this.opt.html2canvas.onrendered || function() {})(t4), this.prop.canvas = t4, document.body.removeChild(this.prop.overlay);
      });
    }, s3.prototype.toImg = function() {
      return this.thenList([function() {
        return this.prop.canvas || this.toCanvas();
      }]).then(function() {
        var t3 = this.prop.canvas.toDataURL("image/" + this.opt.image.type, this.opt.image.quality);
        this.prop.img = document.createElement("img"), this.prop.img.src = t3;
      });
    }, s3.prototype.toPdf = function() {
      return this.thenList([function() {
        return this.toContext2d();
      }]).then(function() {
        this.prop.pdf = this.prop.pdf || this.opt.jsPDF;
      });
    }, s3.prototype.output = function(t3, e3, r3) {
      return (r3 = r3 || "pdf").toLowerCase() === "img" || r3.toLowerCase() === "image" ? this.outputImg(t3, e3) : this.outputPdf(t3, e3);
    }, s3.prototype.outputPdf = function(t3, e3) {
      return this.thenList([function() {
        return this.prop.pdf || this.toPdf();
      }]).then(function() {
        return this.prop.pdf.output(t3, e3);
      });
    }, s3.prototype.outputImg = function(t3) {
      return this.thenList([function() {
        return this.prop.img || this.toImg();
      }]).then(function() {
        switch (t3) {
          case undefined:
          case "img":
            return this.prop.img;
          case "datauristring":
          case "dataurlstring":
            return this.prop.img.src;
          case "datauri":
          case "dataurl":
            return document.location.href = this.prop.img.src;
          default:
            throw 'Image output type "' + t3 + '" is not supported.';
        }
      });
    }, s3.prototype.save = function(t3) {
      return this.thenList([function() {
        return this.prop.pdf || this.toPdf();
      }]).set(t3 ? { filename: t3 } : null).then(function() {
        this.prop.pdf.save(this.opt.filename);
      });
    }, s3.prototype.doCallback = function() {
      return this.thenList([function() {
        return this.prop.pdf || this.toPdf();
      }]).then(function() {
        this.prop.callback(this.prop.pdf);
      });
    }, s3.prototype.set = function(t3) {
      if (a3(t3) !== "object")
        return this;
      var e3 = Object.keys(t3 || {}).map(function(e4) {
        if (e4 in s3.template.prop)
          return function() {
            this.prop[e4] = t3[e4];
          };
        switch (e4) {
          case "margin":
            return this.setMargin.bind(this, t3.margin);
          case "jsPDF":
            return function() {
              return this.opt.jsPDF = t3.jsPDF, this.setPageSize();
            };
          case "pageSize":
            return this.setPageSize.bind(this, t3.pageSize);
          default:
            return function() {
              this.opt[e4] = t3[e4];
            };
        }
      }, this);
      return this.then(function() {
        return this.thenList(e3);
      });
    }, s3.prototype.get = function(t3, e3) {
      return this.then(function() {
        var r3 = t3 in s3.template.prop ? this.prop[t3] : this.opt[t3];
        return e3 ? e3(r3) : r3;
      });
    }, s3.prototype.setMargin = function(t3) {
      return this.then(function() {
        switch (a3(t3)) {
          case "number":
            t3 = [t3, t3, t3, t3];
          case "array":
            if (t3.length === 2 && (t3 = [t3[0], t3[1], t3[0], t3[1]]), t3.length === 4)
              break;
          default:
            return this.error("Invalid margin array.");
        }
        this.opt.margin = t3;
      }).then(this.setPageSize);
    }, s3.prototype.setPageSize = function(t3) {
      function e3(t4, e4) {
        return Math.floor(t4 * e4 / 72 * 96);
      }
      return this.then(function() {
        (t3 = t3 || E.getPageSize(this.opt.jsPDF)).hasOwnProperty("inner") || (t3.inner = { width: t3.width - this.opt.margin[1] - this.opt.margin[3], height: t3.height - this.opt.margin[0] - this.opt.margin[2] }, t3.inner.px = { width: e3(t3.inner.width, t3.k), height: e3(t3.inner.height, t3.k) }, t3.inner.ratio = t3.inner.height / t3.inner.width), this.prop.pageSize = t3;
      });
    }, s3.prototype.setProgress = function(t3, e3, r3, n3) {
      return t3 != null && (this.progress.val = t3), e3 != null && (this.progress.state = e3), r3 != null && (this.progress.n = r3), n3 != null && (this.progress.stack = n3), this.progress.ratio = this.progress.val / this.progress.state, this;
    }, s3.prototype.updateProgress = function(t3, e3, r3, n3) {
      return this.setProgress(t3 ? this.progress.val + t3 : null, e3 || null, r3 ? this.progress.n + r3 : null, n3 ? this.progress.stack.concat(n3) : null);
    }, s3.prototype.then = function(t3, e3) {
      var r3 = this;
      return this.thenCore(t3, e3, function(t4, e4) {
        return r3.updateProgress(null, null, 1, [t4]), Promise.prototype.then.call(this, function(e5) {
          return r3.updateProgress(null, t4), e5;
        }).then(t4, e4).then(function(t5) {
          return r3.updateProgress(1), t5;
        });
      });
    }, s3.prototype.thenCore = function(t3, e3, r3) {
      r3 = r3 || Promise.prototype.then;
      t3 && (t3 = t3.bind(this)), e3 && (e3 = e3.bind(this));
      var n3 = Promise.toString().indexOf("[native code]") !== -1 && Promise.name === "Promise" ? this : s3.convert(Object.assign({}, this), Promise.prototype), i6 = r3.call(n3, t3, e3);
      return s3.convert(i6, this.__proto__);
    }, s3.prototype.thenExternal = function(t3, e3) {
      return Promise.prototype.then.call(this, t3, e3);
    }, s3.prototype.thenList = function(t3) {
      var e3 = this;
      return t3.forEach(function(t4) {
        e3 = e3.thenCore(t4);
      }), e3;
    }, s3.prototype.catch = function(t3) {
      t3 && (t3 = t3.bind(this));
      var e3 = Promise.prototype.catch.call(this, t3);
      return s3.convert(e3, this);
    }, s3.prototype.catchExternal = function(t3) {
      return Promise.prototype.catch.call(this, t3);
    }, s3.prototype.error = function(t3) {
      return this.then(function() {
        throw new Error(t3);
      });
    }, s3.prototype.using = s3.prototype.set, s3.prototype.saveAs = s3.prototype.save, s3.prototype.export = s3.prototype.output, s3.prototype.run = s3.prototype.then, E.getPageSize = function(e3, r3, n3) {
      if (_typeof(e3) === "object") {
        var i6 = e3;
        e3 = i6.orientation, r3 = i6.unit || r3, n3 = i6.format || n3;
      }
      r3 = r3 || "mm", n3 = n3 || "a4", e3 = ("" + (e3 || "P")).toLowerCase();
      var a4, o4 = ("" + n3).toLowerCase(), s4 = { a0: [2383.94, 3370.39], a1: [1683.78, 2383.94], a2: [1190.55, 1683.78], a3: [841.89, 1190.55], a4: [595.28, 841.89], a5: [419.53, 595.28], a6: [297.64, 419.53], a7: [209.76, 297.64], a8: [147.4, 209.76], a9: [104.88, 147.4], a10: [73.7, 104.88], b0: [2834.65, 4008.19], b1: [2004.09, 2834.65], b2: [1417.32, 2004.09], b3: [1000.63, 1417.32], b4: [708.66, 1000.63], b5: [498.9, 708.66], b6: [354.33, 498.9], b7: [249.45, 354.33], b8: [175.75, 249.45], b9: [124.72, 175.75], b10: [87.87, 124.72], c0: [2599.37, 3676.54], c1: [1836.85, 2599.37], c2: [1298.27, 1836.85], c3: [918.43, 1298.27], c4: [649.13, 918.43], c5: [459.21, 649.13], c6: [323.15, 459.21], c7: [229.61, 323.15], c8: [161.57, 229.61], c9: [113.39, 161.57], c10: [79.37, 113.39], dl: [311.81, 623.62], letter: [612, 792], "government-letter": [576, 756], legal: [612, 1008], "junior-legal": [576, 360], ledger: [1224, 792], tabloid: [792, 1224], "credit-card": [153, 243] };
      switch (r3) {
        case "pt":
          a4 = 1;
          break;
        case "mm":
          a4 = 2.834645669291339;
          break;
        case "cm":
          a4 = 28.346456692913385;
          break;
        case "in":
          a4 = 72;
          break;
        case "px":
          a4 = 0.75;
          break;
        case "pc":
        case "em":
          a4 = 12;
          break;
        case "ex":
          a4 = 6;
          break;
        default:
          throw "Invalid unit: " + r3;
      }
      var c4, u3 = 0, h3 = 0;
      if (s4.hasOwnProperty(o4))
        u3 = s4[o4][1] / a4, h3 = s4[o4][0] / a4;
      else
        try {
          u3 = n3[1], h3 = n3[0];
        } catch (t3) {
          throw new Error("Invalid format: " + n3);
        }
      if (e3 === "p" || e3 === "portrait")
        e3 = "p", h3 > u3 && (c4 = h3, h3 = u3, u3 = c4);
      else {
        if (e3 !== "l" && e3 !== "landscape")
          throw "Invalid orientation: " + e3;
        e3 = "l", u3 > h3 && (c4 = h3, h3 = u3, u3 = c4);
      }
      return { width: h3, height: u3, unit: r3, k: a4, orientation: e3 };
    }, e2.html = function(t3, e3) {
      (e3 = e3 || {}).callback = e3.callback || function() {}, e3.html2canvas = e3.html2canvas || {}, e3.html2canvas.canvas = e3.html2canvas.canvas || this.canvas, e3.jsPDF = e3.jsPDF || this, e3.fontFaces = e3.fontFaces ? e3.fontFaces.map(jt) : null;
      var r3 = new s3(e3);
      return e3.worker ? r3 : r3.from(t3).doCallback();
    };
  }(E.API), E.API.addJS = function(t3) {
    return Ht = t3, this.internal.events.subscribe("postPutResources", function() {
      Ut = this.internal.newObject(), this.internal.out("<<"), this.internal.out("/Names [(EmbeddedJS) " + (Ut + 1) + " 0 R]"), this.internal.out(">>"), this.internal.out("endobj"), zt = this.internal.newObject(), this.internal.out("<<"), this.internal.out("/S /JavaScript"), this.internal.out("/JS (" + Ht + ")"), this.internal.out(">>"), this.internal.out("endobj");
    }), this.internal.events.subscribe("putCatalog", function() {
      Ut !== undefined && zt !== undefined && this.internal.out("/Names <</JavaScript " + Ut + " 0 R>>");
    }), this;
  }, function(t3) {
    var e2;
    t3.events.push(["postPutResources", function() {
      var t4 = this, r2 = /^(\d+) 0 obj$/;
      if (this.outline.root.children.length > 0)
        for (var n3 = t4.outline.render().split(/\r\n/), i5 = 0;i5 < n3.length; i5++) {
          var a3 = n3[i5], o3 = r2.exec(a3);
          if (o3 != null) {
            var s3 = o3[1];
            t4.internal.newObjectDeferredBegin(s3, false);
          }
          t4.internal.write(a3);
        }
      if (this.outline.createNamedDestinations) {
        var c4 = this.internal.pages.length, u3 = [];
        for (i5 = 0;i5 < c4; i5++) {
          var h3 = t4.internal.newObject();
          u3.push(h3);
          var l3 = t4.internal.getPageInfo(i5 + 1);
          t4.internal.write("<< /D[" + l3.objId + " 0 R /XYZ null null null]>> endobj");
        }
        var f3 = t4.internal.newObject();
        t4.internal.write("<< /Names [ ");
        for (i5 = 0;i5 < u3.length; i5++)
          t4.internal.write("(page_" + (i5 + 1) + ")" + u3[i5] + " 0 R");
        t4.internal.write(" ] >>", "endobj"), e2 = t4.internal.newObject(), t4.internal.write("<< /Dests " + f3 + " 0 R"), t4.internal.write(">>", "endobj");
      }
    }]), t3.events.push(["putCatalog", function() {
      this.outline.root.children.length > 0 && (this.internal.write("/Outlines", this.outline.makeRef(this.outline.root)), this.outline.createNamedDestinations && this.internal.write("/Names " + e2 + " 0 R"));
    }]), t3.events.push(["initialized", function() {
      var t4 = this;
      t4.outline = { createNamedDestinations: false, root: { children: [] } }, t4.outline.add = function(t5, e3, r2) {
        var n3 = { title: e3, options: r2, children: [] };
        return t5 == null && (t5 = this.root), t5.children.push(n3), n3;
      }, t4.outline.render = function() {
        return this.ctx = {}, this.ctx.val = "", this.ctx.pdf = t4, this.genIds_r(this.root), this.renderRoot(this.root), this.renderItems(this.root), this.ctx.val;
      }, t4.outline.genIds_r = function(e3) {
        e3.id = t4.internal.newObjectDeferred();
        for (var r2 = 0;r2 < e3.children.length; r2++)
          this.genIds_r(e3.children[r2]);
      }, t4.outline.renderRoot = function(t5) {
        this.objStart(t5), this.line("/Type /Outlines"), t5.children.length > 0 && (this.line("/First " + this.makeRef(t5.children[0])), this.line("/Last " + this.makeRef(t5.children[t5.children.length - 1]))), this.line("/Count " + this.count_r({ count: 0 }, t5)), this.objEnd();
      }, t4.outline.renderItems = function(e3) {
        for (var r2 = this.ctx.pdf.internal.getVerticalCoordinateString, n3 = 0;n3 < e3.children.length; n3++) {
          var i5 = e3.children[n3];
          this.objStart(i5), this.line("/Title " + this.makeString(i5.title)), this.line("/Parent " + this.makeRef(e3)), n3 > 0 && this.line("/Prev " + this.makeRef(e3.children[n3 - 1])), n3 < e3.children.length - 1 && this.line("/Next " + this.makeRef(e3.children[n3 + 1])), i5.children.length > 0 && (this.line("/First " + this.makeRef(i5.children[0])), this.line("/Last " + this.makeRef(i5.children[i5.children.length - 1])));
          var a3 = this.count = this.count_r({ count: 0 }, i5);
          if (a3 > 0 && this.line("/Count " + a3), i5.options && i5.options.pageNumber) {
            var o3 = t4.internal.getPageInfo(i5.options.pageNumber);
            this.line("/Dest [" + o3.objId + " 0 R /XYZ 0 " + r2(0) + " 0]");
          }
          this.objEnd();
        }
        for (var s3 = 0;s3 < e3.children.length; s3++)
          this.renderItems(e3.children[s3]);
      }, t4.outline.line = function(t5) {
        this.ctx.val += t5 + `\r
`;
      }, t4.outline.makeRef = function(t5) {
        return t5.id + " 0 R";
      }, t4.outline.makeString = function(e3) {
        return "(" + t4.internal.pdfEscape(e3) + ")";
      }, t4.outline.objStart = function(t5) {
        this.ctx.val += `\r
` + t5.id + ` 0 obj\r
<<\r
`;
      }, t4.outline.objEnd = function() {
        this.ctx.val += `>> \r
endobj\r
`;
      }, t4.outline.count_r = function(t5, e3) {
        for (var r2 = 0;r2 < e3.children.length; r2++)
          t5.count++, this.count_r(t5, e3.children[r2]);
        return t5.count;
      };
    }]);
  }(E.API), function(t3) {
    var e2 = [192, 193, 194, 195, 196, 197, 198, 199];
    t3.processJPEG = function(t4, r2, n3, i5, a3, o3) {
      var s3, c4 = this.decode.DCT_DECODE, u3 = null;
      if (typeof t4 == "string" || this.__addimage__.isArrayBuffer(t4) || this.__addimage__.isArrayBufferView(t4)) {
        switch (t4 = a3 || t4, t4 = this.__addimage__.isArrayBuffer(t4) ? new Uint8Array(t4) : t4, (s3 = function(t5) {
          for (var r3, n4 = 256 * t5.charCodeAt(4) + t5.charCodeAt(5), i6 = t5.length, a4 = { width: 0, height: 0, numcomponents: 1 }, o4 = 4;o4 < i6; o4 += 2) {
            if (o4 += n4, e2.indexOf(t5.charCodeAt(o4 + 1)) !== -1) {
              r3 = 256 * t5.charCodeAt(o4 + 5) + t5.charCodeAt(o4 + 6), a4 = { width: 256 * t5.charCodeAt(o4 + 7) + t5.charCodeAt(o4 + 8), height: r3, numcomponents: t5.charCodeAt(o4 + 9) };
              break;
            }
            n4 = 256 * t5.charCodeAt(o4 + 2) + t5.charCodeAt(o4 + 3);
          }
          return a4;
        }(t4 = this.__addimage__.isArrayBufferView(t4) ? this.__addimage__.arrayBufferToBinaryString(t4) : t4)).numcomponents) {
          case 1:
            o3 = this.color_spaces.DEVICE_GRAY;
            break;
          case 4:
            o3 = this.color_spaces.DEVICE_CMYK;
            break;
          case 3:
            o3 = this.color_spaces.DEVICE_RGB;
        }
        u3 = { data: t4, width: s3.width, height: s3.height, colorSpace: o3, bitsPerComponent: 8, filter: c4, index: r2, alias: n3 };
      }
      return u3;
    };
  }(E.API);
  Kt = function() {
    var t3, e2, i5;
    function a3(t4) {
      var e3, r2, n3, i6, a4, o4, s3, c4, u3, h3, l3, f3, d2, p3;
      for (this.data = t4, this.pos = 8, this.palette = [], this.imgData = [], this.transparency = {}, this.animation = null, this.text = {}, o4 = null;; ) {
        switch (e3 = this.readUInt32(), u3 = function() {
          var t5, e4;
          for (e4 = [], t5 = 0;t5 < 4; ++t5)
            e4.push(String.fromCharCode(this.data[this.pos++]));
          return e4;
        }.call(this).join("")) {
          case "IHDR":
            this.width = this.readUInt32(), this.height = this.readUInt32(), this.bits = this.data[this.pos++], this.colorType = this.data[this.pos++], this.compressionMethod = this.data[this.pos++], this.filterMethod = this.data[this.pos++], this.interlaceMethod = this.data[this.pos++];
            break;
          case "acTL":
            this.animation = { numFrames: this.readUInt32(), numPlays: this.readUInt32() || Infinity, frames: [] };
            break;
          case "PLTE":
            this.palette = this.read(e3);
            break;
          case "fcTL":
            o4 && this.animation.frames.push(o4), this.pos += 4, o4 = { width: this.readUInt32(), height: this.readUInt32(), xOffset: this.readUInt32(), yOffset: this.readUInt32() }, a4 = this.readUInt16(), i6 = this.readUInt16() || 100, o4.delay = 1000 * a4 / i6, o4.disposeOp = this.data[this.pos++], o4.blendOp = this.data[this.pos++], o4.data = [];
            break;
          case "IDAT":
          case "fdAT":
            for (u3 === "fdAT" && (this.pos += 4, e3 -= 4), t4 = (o4 != null ? o4.data : undefined) || this.imgData, f3 = 0;0 <= e3 ? f3 < e3 : f3 > e3; 0 <= e3 ? ++f3 : --f3)
              t4.push(this.data[this.pos++]);
            break;
          case "tRNS":
            switch (this.transparency = {}, this.colorType) {
              case 3:
                if (n3 = this.palette.length / 3, this.transparency.indexed = this.read(e3), this.transparency.indexed.length > n3)
                  throw new Error("More transparent colors than palette size");
                if ((h3 = n3 - this.transparency.indexed.length) > 0)
                  for (d2 = 0;0 <= h3 ? d2 < h3 : d2 > h3; 0 <= h3 ? ++d2 : --d2)
                    this.transparency.indexed.push(255);
                break;
              case 0:
                this.transparency.grayscale = this.read(e3)[0];
                break;
              case 2:
                this.transparency.rgb = this.read(e3);
            }
            break;
          case "tEXt":
            s3 = (l3 = this.read(e3)).indexOf(0), c4 = String.fromCharCode.apply(String, l3.slice(0, s3)), this.text[c4] = String.fromCharCode.apply(String, l3.slice(s3 + 1));
            break;
          case "IEND":
            return o4 && this.animation.frames.push(o4), this.colors = function() {
              switch (this.colorType) {
                case 0:
                case 3:
                case 4:
                  return 1;
                case 2:
                case 6:
                  return 3;
              }
            }.call(this), this.hasAlphaChannel = (p3 = this.colorType) === 4 || p3 === 6, r2 = this.colors + (this.hasAlphaChannel ? 1 : 0), this.pixelBitlength = this.bits * r2, this.colorSpace = function() {
              switch (this.colors) {
                case 1:
                  return "DeviceGray";
                case 3:
                  return "DeviceRGB";
              }
            }.call(this), void (this.imgData = new Uint8Array(this.imgData));
          default:
            this.pos += e3;
        }
        if (this.pos += 4, this.pos > this.data.length)
          throw new Error("Incomplete or corrupt PNG file");
      }
    }
    a3.prototype.read = function(t4) {
      var e3, r2;
      for (r2 = [], e3 = 0;0 <= t4 ? e3 < t4 : e3 > t4; 0 <= t4 ? ++e3 : --e3)
        r2.push(this.data[this.pos++]);
      return r2;
    }, a3.prototype.readUInt32 = function() {
      return this.data[this.pos++] << 24 | this.data[this.pos++] << 16 | this.data[this.pos++] << 8 | this.data[this.pos++];
    }, a3.prototype.readUInt16 = function() {
      return this.data[this.pos++] << 8 | this.data[this.pos++];
    }, a3.prototype.decodePixels = function(t4) {
      var e3 = this.pixelBitlength / 8, n3 = new Uint8Array(this.width * this.height * e3), i6 = 0, a4 = this;
      if (t4 == null && (t4 = this.imgData), t4.length === 0)
        return new Uint8Array(0);
      function o4(r2, o5, s3, c4) {
        var u3, h3, l3, f3, d2, p3, g2, m4, v3, b2, y3, w2, N3, L2, A2, x3, S2, _3, P2, k2, I2, F2 = Math.ceil((a4.width - r2) / s3), C2 = Math.ceil((a4.height - o5) / c4), j2 = a4.width == F2 && a4.height == C2;
        for (L2 = e3 * F2, w2 = j2 ? n3 : new Uint8Array(L2 * C2), p3 = t4.length, N3 = 0, h3 = 0;N3 < C2 && i6 < p3; ) {
          switch (t4[i6++]) {
            case 0:
              for (f3 = S2 = 0;S2 < L2; f3 = S2 += 1)
                w2[h3++] = t4[i6++];
              break;
            case 1:
              for (f3 = _3 = 0;_3 < L2; f3 = _3 += 1)
                u3 = t4[i6++], d2 = f3 < e3 ? 0 : w2[h3 - e3], w2[h3++] = (u3 + d2) % 256;
              break;
            case 2:
              for (f3 = P2 = 0;P2 < L2; f3 = P2 += 1)
                u3 = t4[i6++], l3 = (f3 - f3 % e3) / e3, A2 = N3 && w2[(N3 - 1) * L2 + l3 * e3 + f3 % e3], w2[h3++] = (A2 + u3) % 256;
              break;
            case 3:
              for (f3 = k2 = 0;k2 < L2; f3 = k2 += 1)
                u3 = t4[i6++], l3 = (f3 - f3 % e3) / e3, d2 = f3 < e3 ? 0 : w2[h3 - e3], A2 = N3 && w2[(N3 - 1) * L2 + l3 * e3 + f3 % e3], w2[h3++] = (u3 + Math.floor((d2 + A2) / 2)) % 256;
              break;
            case 4:
              for (f3 = I2 = 0;I2 < L2; f3 = I2 += 1)
                u3 = t4[i6++], l3 = (f3 - f3 % e3) / e3, d2 = f3 < e3 ? 0 : w2[h3 - e3], N3 === 0 ? A2 = x3 = 0 : (A2 = w2[(N3 - 1) * L2 + l3 * e3 + f3 % e3], x3 = l3 && w2[(N3 - 1) * L2 + (l3 - 1) * e3 + f3 % e3]), g2 = d2 + A2 - x3, m4 = Math.abs(g2 - d2), b2 = Math.abs(g2 - A2), y3 = Math.abs(g2 - x3), v3 = m4 <= b2 && m4 <= y3 ? d2 : b2 <= y3 ? A2 : x3, w2[h3++] = (u3 + v3) % 256;
              break;
            default:
              throw new Error("Invalid filter algorithm: " + t4[i6 - 1]);
          }
          if (!j2) {
            var O3 = ((o5 + N3 * c4) * a4.width + r2) * e3, B2 = N3 * L2;
            for (f3 = 0;f3 < F2; f3 += 1) {
              for (var M2 = 0;M2 < e3; M2 += 1)
                n3[O3++] = w2[B2++];
              O3 += (s3 - 1) * e3;
            }
          }
          N3++;
        }
      }
      return t4 = unzlibSync(t4), a4.interlaceMethod == 1 ? (o4(0, 0, 8, 8), o4(4, 0, 8, 8), o4(0, 4, 4, 8), o4(2, 0, 4, 4), o4(0, 2, 2, 4), o4(1, 0, 2, 2), o4(0, 1, 1, 2)) : o4(0, 0, 1, 1), n3;
    }, a3.prototype.decodePalette = function() {
      var t4, e3, r2, n3, i6, a4, o4, s3, c4;
      for (r2 = this.palette, a4 = this.transparency.indexed || [], i6 = new Uint8Array((a4.length || 0) + r2.length), n3 = 0, t4 = 0, e3 = o4 = 0, s3 = r2.length;o4 < s3; e3 = o4 += 3)
        i6[n3++] = r2[e3], i6[n3++] = r2[e3 + 1], i6[n3++] = r2[e3 + 2], i6[n3++] = (c4 = a4[t4++]) != null ? c4 : 255;
      return i6;
    }, a3.prototype.copyToImageData = function(t4, e3) {
      var r2, n3, i6, a4, o4, s3, c4, u3, h3, l3, f3;
      if (n3 = this.colors, h3 = null, r2 = this.hasAlphaChannel, this.palette.length && (h3 = (f3 = this._decodedPalette) != null ? f3 : this._decodedPalette = this.decodePalette(), n3 = 4, r2 = true), u3 = (i6 = t4.data || t4).length, o4 = h3 || e3, a4 = s3 = 0, n3 === 1)
        for (;a4 < u3; )
          c4 = h3 ? 4 * e3[a4 / 4] : s3, l3 = o4[c4++], i6[a4++] = l3, i6[a4++] = l3, i6[a4++] = l3, i6[a4++] = r2 ? o4[c4++] : 255, s3 = c4;
      else
        for (;a4 < u3; )
          c4 = h3 ? 4 * e3[a4 / 4] : s3, i6[a4++] = o4[c4++], i6[a4++] = o4[c4++], i6[a4++] = o4[c4++], i6[a4++] = r2 ? o4[c4++] : 255, s3 = c4;
    }, a3.prototype.decode = function() {
      var t4;
      return t4 = new Uint8Array(this.width * this.height * 4), this.copyToImageData(t4, this.decodePixels()), t4;
    };
    var o3 = function() {
      if (Object.prototype.toString.call(n2) === "[object Window]") {
        try {
          e2 = n2.document.createElement("canvas"), i5 = e2.getContext("2d");
        } catch (t4) {
          return false;
        }
        return true;
      }
      return false;
    };
    return o3(), t3 = function(t4) {
      var r2;
      if (o3() === true)
        return i5.width = t4.width, i5.height = t4.height, i5.clearRect(0, 0, t4.width, t4.height), i5.putImageData(t4, 0, 0), (r2 = new Image).src = e2.toDataURL(), r2;
      throw new Error("This method requires a Browser with Canvas-capability.");
    }, a3.prototype.decodeFrames = function(e3) {
      var r2, n3, i6, a4, o4, s3, c4, u3;
      if (this.animation) {
        for (u3 = [], n3 = o4 = 0, s3 = (c4 = this.animation.frames).length;o4 < s3; n3 = ++o4)
          r2 = c4[n3], i6 = e3.createImageData(r2.width, r2.height), a4 = this.decodePixels(new Uint8Array(r2.data)), this.copyToImageData(i6, a4), r2.imageData = i6, u3.push(r2.image = t3(i6));
        return u3;
      }
    }, a3.prototype.renderFrame = function(t4, e3) {
      var r2, n3, i6;
      return r2 = (n3 = this.animation.frames)[e3], i6 = n3[e3 - 1], e3 === 0 && t4.clearRect(0, 0, this.width, this.height), (i6 != null ? i6.disposeOp : undefined) === 1 ? t4.clearRect(i6.xOffset, i6.yOffset, i6.width, i6.height) : (i6 != null ? i6.disposeOp : undefined) === 2 && t4.putImageData(i6.imageData, i6.xOffset, i6.yOffset), r2.blendOp === 0 && t4.clearRect(r2.xOffset, r2.yOffset, r2.width, r2.height), t4.drawImage(r2.image, r2.xOffset, r2.yOffset);
    }, a3.prototype.animate = function(t4) {
      var e3, r2, n3, i6, a4, o4, s3 = this;
      return r2 = 0, o4 = this.animation, i6 = o4.numFrames, n3 = o4.frames, a4 = o4.numPlays, (e3 = function() {
        var o5, c4;
        if (o5 = r2++ % i6, c4 = n3[o5], s3.renderFrame(t4, o5), i6 > 1 && r2 / i6 < a4)
          return s3.animation._timeout = setTimeout(e3, c4.delay);
      })();
    }, a3.prototype.stopAnimation = function() {
      var t4;
      return clearTimeout((t4 = this.animation) != null ? t4._timeout : undefined);
    }, a3.prototype.render = function(t4) {
      var e3, r2;
      return t4._png && t4._png.stopAnimation(), t4._png = this, t4.width = this.width, t4.height = this.height, e3 = t4.getContext("2d"), this.animation ? (this.decodeFrames(e3), this.animate(e3)) : (r2 = e3.createImageData(this.width, this.height), this.copyToImageData(r2, this.decodePixels()), e3.putImageData(r2, 0, 0));
    }, a3;
  }();
  (function(t3) {
    var r2 = function() {
      return typeof zlibSync == "function";
    }, n3 = function(r3, n4, a4, h4) {
      var l4 = 4, f4 = s3;
      switch (h4) {
        case t3.image_compression.FAST:
          l4 = 1, f4 = o3;
          break;
        case t3.image_compression.MEDIUM:
          l4 = 6, f4 = c4;
          break;
        case t3.image_compression.SLOW:
          l4 = 9, f4 = u3;
      }
      r3 = i5(r3, n4, a4, f4);
      var d2 = zlibSync(r3, { level: l4 });
      return t3.__addimage__.arrayBufferToBinaryString(d2);
    }, i5 = function(t4, e2, r3, n4) {
      for (var i6, a4, o4, s4 = t4.length / e2, c5 = new Uint8Array(t4.length + s4), u4 = l3(), h4 = 0;h4 < s4; h4 += 1) {
        if (o4 = h4 * e2, i6 = t4.subarray(o4, o4 + e2), n4)
          c5.set(n4(i6, r3, a4), o4 + h4);
        else {
          for (var d2, p3 = u4.length, g2 = [];d2 < p3; d2 += 1)
            g2[d2] = u4[d2](i6, r3, a4);
          var m4 = f3(g2.concat());
          c5.set(g2[m4], o4 + h4);
        }
        a4 = i6;
      }
      return c5;
    }, a3 = function(t4) {
      var e2 = Array.apply([], t4);
      return e2.unshift(0), e2;
    }, o3 = function(t4, e2) {
      var r3, n4 = [], i6 = t4.length;
      n4[0] = 1;
      for (var a4 = 0;a4 < i6; a4 += 1)
        r3 = t4[a4 - e2] || 0, n4[a4 + 1] = t4[a4] - r3 + 256 & 255;
      return n4;
    }, s3 = function(t4, e2, r3) {
      var n4, i6 = [], a4 = t4.length;
      i6[0] = 2;
      for (var o4 = 0;o4 < a4; o4 += 1)
        n4 = r3 && r3[o4] || 0, i6[o4 + 1] = t4[o4] - n4 + 256 & 255;
      return i6;
    }, c4 = function(t4, e2, r3) {
      var n4, i6, a4 = [], o4 = t4.length;
      a4[0] = 3;
      for (var s4 = 0;s4 < o4; s4 += 1)
        n4 = t4[s4 - e2] || 0, i6 = r3 && r3[s4] || 0, a4[s4 + 1] = t4[s4] + 256 - (n4 + i6 >>> 1) & 255;
      return a4;
    }, u3 = function(t4, e2, r3) {
      var n4, i6, a4, o4, s4 = [], c5 = t4.length;
      s4[0] = 4;
      for (var u4 = 0;u4 < c5; u4 += 1)
        n4 = t4[u4 - e2] || 0, i6 = r3 && r3[u4] || 0, a4 = r3 && r3[u4 - e2] || 0, o4 = h3(n4, i6, a4), s4[u4 + 1] = t4[u4] - o4 + 256 & 255;
      return s4;
    }, h3 = function(t4, e2, r3) {
      if (t4 === e2 && e2 === r3)
        return t4;
      var n4 = Math.abs(e2 - r3), i6 = Math.abs(t4 - r3), a4 = Math.abs(t4 + e2 - r3 - r3);
      return n4 <= i6 && n4 <= a4 ? t4 : i6 <= a4 ? e2 : r3;
    }, l3 = function() {
      return [a3, o3, s3, c4, u3];
    }, f3 = function(t4) {
      var e2 = t4.map(function(t5) {
        return t5.reduce(function(t6, e3) {
          return t6 + Math.abs(e3);
        }, 0);
      });
      return e2.indexOf(Math.min.apply(null, e2));
    };
    t3.processPNG = function(e2, i6, a4, o4) {
      var s4, c5, u4, h4, l4, f4, d2, p3, g2, m4, v3, b2, y3, w2, N3, L2 = this.decode.FLATE_DECODE, A2 = "";
      if (this.__addimage__.isArrayBuffer(e2) && (e2 = new Uint8Array(e2)), this.__addimage__.isArrayBufferView(e2)) {
        if (e2 = (u4 = new Kt(e2)).imgData, c5 = u4.bits, s4 = u4.colorSpace, l4 = u4.colors, [4, 6].indexOf(u4.colorType) !== -1) {
          if (u4.bits === 8) {
            g2 = (p3 = u4.pixelBitlength == 32 ? new Uint32Array(u4.decodePixels().buffer) : u4.pixelBitlength == 16 ? new Uint16Array(u4.decodePixels().buffer) : new Uint8Array(u4.decodePixels().buffer)).length, v3 = new Uint8Array(g2 * u4.colors), m4 = new Uint8Array(g2);
            var x3, S2 = u4.pixelBitlength - u4.bits;
            for (w2 = 0, N3 = 0;w2 < g2; w2++) {
              for (y3 = p3[w2], x3 = 0;x3 < S2; )
                v3[N3++] = y3 >>> x3 & 255, x3 += u4.bits;
              m4[w2] = y3 >>> x3 & 255;
            }
          }
          if (u4.bits === 16) {
            g2 = (p3 = new Uint32Array(u4.decodePixels().buffer)).length, v3 = new Uint8Array(g2 * (32 / u4.pixelBitlength) * u4.colors), m4 = new Uint8Array(g2 * (32 / u4.pixelBitlength)), b2 = u4.colors > 1, w2 = 0, N3 = 0;
            for (var _3 = 0;w2 < g2; )
              y3 = p3[w2++], v3[N3++] = y3 >>> 0 & 255, b2 && (v3[N3++] = y3 >>> 16 & 255, y3 = p3[w2++], v3[N3++] = y3 >>> 0 & 255), m4[_3++] = y3 >>> 16 & 255;
            c5 = 8;
          }
          o4 !== t3.image_compression.NONE && r2() ? (e2 = n3(v3, u4.width * u4.colors, u4.colors, o4), d2 = n3(m4, u4.width, 1, o4)) : (e2 = v3, d2 = m4, L2 = undefined);
        }
        if (u4.colorType === 3 && (s4 = this.color_spaces.INDEXED, f4 = u4.palette, u4.transparency.indexed)) {
          var P2 = u4.transparency.indexed, k2 = 0;
          for (w2 = 0, g2 = P2.length;w2 < g2; ++w2)
            k2 += P2[w2];
          if ((k2 /= 255) === g2 - 1 && P2.indexOf(0) !== -1)
            h4 = [P2.indexOf(0)];
          else if (k2 !== g2) {
            for (p3 = u4.decodePixels(), m4 = new Uint8Array(p3.length), w2 = 0, g2 = p3.length;w2 < g2; w2++)
              m4[w2] = P2[p3[w2]];
            d2 = n3(m4, u4.width, 1);
          }
        }
        var I2 = function(e3) {
          var r3;
          switch (e3) {
            case t3.image_compression.FAST:
              r3 = 11;
              break;
            case t3.image_compression.MEDIUM:
              r3 = 13;
              break;
            case t3.image_compression.SLOW:
              r3 = 14;
              break;
            default:
              r3 = 12;
          }
          return r3;
        }(o4);
        return L2 === this.decode.FLATE_DECODE && (A2 = "/Predictor " + I2 + " "), A2 += "/Colors " + l4 + " /BitsPerComponent " + c5 + " /Columns " + u4.width, (this.__addimage__.isArrayBuffer(e2) || this.__addimage__.isArrayBufferView(e2)) && (e2 = this.__addimage__.arrayBufferToBinaryString(e2)), (d2 && this.__addimage__.isArrayBuffer(d2) || this.__addimage__.isArrayBufferView(d2)) && (d2 = this.__addimage__.arrayBufferToBinaryString(d2)), { alias: a4, data: e2, index: i6, filter: L2, decodeParameters: A2, transparency: h4, palette: f4, sMask: d2, predictor: I2, width: u4.width, height: u4.height, bitsPerComponent: c5, colorSpace: s4 };
      }
    };
  })(E.API), function(t3) {
    t3.processGIF89A = function(e2, r2, n3, i5) {
      var a3 = new Zt(e2), o3 = a3.width, s3 = a3.height, c4 = [];
      a3.decodeAndBlitFrameRGBA(0, c4);
      var u3 = { data: c4, width: o3, height: s3 }, h3 = new Qt(100).encode(u3, 100);
      return t3.processJPEG.call(this, h3, r2, n3, i5);
    }, t3.processGIF87A = t3.processGIF89A;
  }(E.API), te.prototype.parseHeader = function() {
    if (this.fileSize = this.datav.getUint32(this.pos, true), this.pos += 4, this.reserved = this.datav.getUint32(this.pos, true), this.pos += 4, this.offset = this.datav.getUint32(this.pos, true), this.pos += 4, this.headerSize = this.datav.getUint32(this.pos, true), this.pos += 4, this.width = this.datav.getUint32(this.pos, true), this.pos += 4, this.height = this.datav.getInt32(this.pos, true), this.pos += 4, this.planes = this.datav.getUint16(this.pos, true), this.pos += 2, this.bitPP = this.datav.getUint16(this.pos, true), this.pos += 2, this.compress = this.datav.getUint32(this.pos, true), this.pos += 4, this.rawSize = this.datav.getUint32(this.pos, true), this.pos += 4, this.hr = this.datav.getUint32(this.pos, true), this.pos += 4, this.vr = this.datav.getUint32(this.pos, true), this.pos += 4, this.colors = this.datav.getUint32(this.pos, true), this.pos += 4, this.importantColors = this.datav.getUint32(this.pos, true), this.pos += 4, this.bitPP === 16 && this.is_with_alpha && (this.bitPP = 15), this.bitPP < 15) {
      var t3 = this.colors === 0 ? 1 << this.bitPP : this.colors;
      this.palette = new Array(t3);
      for (var e2 = 0;e2 < t3; e2++) {
        var r2 = this.datav.getUint8(this.pos++, true), n3 = this.datav.getUint8(this.pos++, true), i5 = this.datav.getUint8(this.pos++, true), a3 = this.datav.getUint8(this.pos++, true);
        this.palette[e2] = { red: i5, green: n3, blue: r2, quad: a3 };
      }
    }
    this.height < 0 && (this.height *= -1, this.bottom_up = false);
  }, te.prototype.parseBGR = function() {
    this.pos = this.offset;
    try {
      var t3 = "bit" + this.bitPP, e2 = this.width * this.height * 4;
      this.data = new Uint8Array(e2), this[t3]();
    } catch (t4) {
      a2.log("bit decode error:" + t4);
    }
  }, te.prototype.bit1 = function() {
    var t3, e2 = Math.ceil(this.width / 8), r2 = e2 % 4;
    for (t3 = this.height - 1;t3 >= 0; t3--) {
      for (var n3 = this.bottom_up ? t3 : this.height - 1 - t3, i5 = 0;i5 < e2; i5++)
        for (var a3 = this.datav.getUint8(this.pos++, true), o3 = n3 * this.width * 4 + 8 * i5 * 4, s3 = 0;s3 < 8 && 8 * i5 + s3 < this.width; s3++) {
          var c4 = this.palette[a3 >> 7 - s3 & 1];
          this.data[o3 + 4 * s3] = c4.blue, this.data[o3 + 4 * s3 + 1] = c4.green, this.data[o3 + 4 * s3 + 2] = c4.red, this.data[o3 + 4 * s3 + 3] = 255;
        }
      r2 !== 0 && (this.pos += 4 - r2);
    }
  }, te.prototype.bit4 = function() {
    for (var t3 = Math.ceil(this.width / 2), e2 = t3 % 4, r2 = this.height - 1;r2 >= 0; r2--) {
      for (var n3 = this.bottom_up ? r2 : this.height - 1 - r2, i5 = 0;i5 < t3; i5++) {
        var a3 = this.datav.getUint8(this.pos++, true), o3 = n3 * this.width * 4 + 2 * i5 * 4, s3 = a3 >> 4, c4 = 15 & a3, u3 = this.palette[s3];
        if (this.data[o3] = u3.blue, this.data[o3 + 1] = u3.green, this.data[o3 + 2] = u3.red, this.data[o3 + 3] = 255, 2 * i5 + 1 >= this.width)
          break;
        u3 = this.palette[c4], this.data[o3 + 4] = u3.blue, this.data[o3 + 4 + 1] = u3.green, this.data[o3 + 4 + 2] = u3.red, this.data[o3 + 4 + 3] = 255;
      }
      e2 !== 0 && (this.pos += 4 - e2);
    }
  }, te.prototype.bit8 = function() {
    for (var t3 = this.width % 4, e2 = this.height - 1;e2 >= 0; e2--) {
      for (var r2 = this.bottom_up ? e2 : this.height - 1 - e2, n3 = 0;n3 < this.width; n3++) {
        var i5 = this.datav.getUint8(this.pos++, true), a3 = r2 * this.width * 4 + 4 * n3;
        if (i5 < this.palette.length) {
          var o3 = this.palette[i5];
          this.data[a3] = o3.red, this.data[a3 + 1] = o3.green, this.data[a3 + 2] = o3.blue, this.data[a3 + 3] = 255;
        } else
          this.data[a3] = 255, this.data[a3 + 1] = 255, this.data[a3 + 2] = 255, this.data[a3 + 3] = 255;
      }
      t3 !== 0 && (this.pos += 4 - t3);
    }
  }, te.prototype.bit15 = function() {
    for (var t3 = this.width % 3, e2 = parseInt("11111", 2), r2 = this.height - 1;r2 >= 0; r2--) {
      for (var n3 = this.bottom_up ? r2 : this.height - 1 - r2, i5 = 0;i5 < this.width; i5++) {
        var a3 = this.datav.getUint16(this.pos, true);
        this.pos += 2;
        var o3 = (a3 & e2) / e2 * 255 | 0, s3 = (a3 >> 5 & e2) / e2 * 255 | 0, c4 = (a3 >> 10 & e2) / e2 * 255 | 0, u3 = a3 >> 15 ? 255 : 0, h3 = n3 * this.width * 4 + 4 * i5;
        this.data[h3] = c4, this.data[h3 + 1] = s3, this.data[h3 + 2] = o3, this.data[h3 + 3] = u3;
      }
      this.pos += t3;
    }
  }, te.prototype.bit16 = function() {
    for (var t3 = this.width % 3, e2 = parseInt("11111", 2), r2 = parseInt("111111", 2), n3 = this.height - 1;n3 >= 0; n3--) {
      for (var i5 = this.bottom_up ? n3 : this.height - 1 - n3, a3 = 0;a3 < this.width; a3++) {
        var o3 = this.datav.getUint16(this.pos, true);
        this.pos += 2;
        var s3 = (o3 & e2) / e2 * 255 | 0, c4 = (o3 >> 5 & r2) / r2 * 255 | 0, u3 = (o3 >> 11) / e2 * 255 | 0, h3 = i5 * this.width * 4 + 4 * a3;
        this.data[h3] = u3, this.data[h3 + 1] = c4, this.data[h3 + 2] = s3, this.data[h3 + 3] = 255;
      }
      this.pos += t3;
    }
  }, te.prototype.bit24 = function() {
    for (var t3 = this.height - 1;t3 >= 0; t3--) {
      for (var e2 = this.bottom_up ? t3 : this.height - 1 - t3, r2 = 0;r2 < this.width; r2++) {
        var n3 = this.datav.getUint8(this.pos++, true), i5 = this.datav.getUint8(this.pos++, true), a3 = this.datav.getUint8(this.pos++, true), o3 = e2 * this.width * 4 + 4 * r2;
        this.data[o3] = a3, this.data[o3 + 1] = i5, this.data[o3 + 2] = n3, this.data[o3 + 3] = 255;
      }
      this.pos += this.width % 4;
    }
  }, te.prototype.bit32 = function() {
    for (var t3 = this.height - 1;t3 >= 0; t3--)
      for (var e2 = this.bottom_up ? t3 : this.height - 1 - t3, r2 = 0;r2 < this.width; r2++) {
        var n3 = this.datav.getUint8(this.pos++, true), i5 = this.datav.getUint8(this.pos++, true), a3 = this.datav.getUint8(this.pos++, true), o3 = this.datav.getUint8(this.pos++, true), s3 = e2 * this.width * 4 + 4 * r2;
        this.data[s3] = a3, this.data[s3 + 1] = i5, this.data[s3 + 2] = n3, this.data[s3 + 3] = o3;
      }
  }, te.prototype.getData = function() {
    return this.data;
  }, function(t3) {
    t3.processBMP = function(e2, r2, n3, i5) {
      var a3 = new te(e2, false), o3 = a3.width, s3 = a3.height, c4 = { data: a3.getData(), width: o3, height: s3 }, u3 = new Qt(100).encode(c4, 100);
      return t3.processJPEG.call(this, u3, r2, n3, i5);
    };
  }(E.API), ee.prototype.getData = function() {
    return this.data;
  }, function(t3) {
    t3.processWEBP = function(e2, r2, n3, i5) {
      var a3 = new ee(e2, false), o3 = a3.width, s3 = a3.height, c4 = { data: a3.getData(), width: o3, height: s3 }, u3 = new Qt(100).encode(c4, 100);
      return t3.processJPEG.call(this, u3, r2, n3, i5);
    };
  }(E.API), E.API.processRGBA = function(t3, e2, r2) {
    for (var n3 = t3.data, i5 = n3.length, a3 = new Uint8Array(i5 / 4 * 3), o3 = new Uint8Array(i5 / 4), s3 = 0, c4 = 0, u3 = 0;u3 < i5; u3 += 4) {
      var h3 = n3[u3], l3 = n3[u3 + 1], f3 = n3[u3 + 2], d2 = n3[u3 + 3];
      a3[s3++] = h3, a3[s3++] = l3, a3[s3++] = f3, o3[c4++] = d2;
    }
    var p3 = this.__addimage__.arrayBufferToBinaryString(a3);
    return { alpha: this.__addimage__.arrayBufferToBinaryString(o3), data: p3, index: e2, alias: r2, colorSpace: "DeviceRGB", bitsPerComponent: 8, width: t3.width, height: t3.height };
  }, E.API.setLanguage = function(t3) {
    return this.internal.languageSettings === undefined && (this.internal.languageSettings = {}, this.internal.languageSettings.isSubscribed = false), { af: "Afrikaans", sq: "Albanian", ar: "Arabic (Standard)", "ar-DZ": "Arabic (Algeria)", "ar-BH": "Arabic (Bahrain)", "ar-EG": "Arabic (Egypt)", "ar-IQ": "Arabic (Iraq)", "ar-JO": "Arabic (Jordan)", "ar-KW": "Arabic (Kuwait)", "ar-LB": "Arabic (Lebanon)", "ar-LY": "Arabic (Libya)", "ar-MA": "Arabic (Morocco)", "ar-OM": "Arabic (Oman)", "ar-QA": "Arabic (Qatar)", "ar-SA": "Arabic (Saudi Arabia)", "ar-SY": "Arabic (Syria)", "ar-TN": "Arabic (Tunisia)", "ar-AE": "Arabic (U.A.E.)", "ar-YE": "Arabic (Yemen)", an: "Aragonese", hy: "Armenian", as: "Assamese", ast: "Asturian", az: "Azerbaijani", eu: "Basque", be: "Belarusian", bn: "Bengali", bs: "Bosnian", br: "Breton", bg: "Bulgarian", my: "Burmese", ca: "Catalan", ch: "Chamorro", ce: "Chechen", zh: "Chinese", "zh-HK": "Chinese (Hong Kong)", "zh-CN": "Chinese (PRC)", "zh-SG": "Chinese (Singapore)", "zh-TW": "Chinese (Taiwan)", cv: "Chuvash", co: "Corsican", cr: "Cree", hr: "Croatian", cs: "Czech", da: "Danish", nl: "Dutch (Standard)", "nl-BE": "Dutch (Belgian)", en: "English", "en-AU": "English (Australia)", "en-BZ": "English (Belize)", "en-CA": "English (Canada)", "en-IE": "English (Ireland)", "en-JM": "English (Jamaica)", "en-NZ": "English (New Zealand)", "en-PH": "English (Philippines)", "en-ZA": "English (South Africa)", "en-TT": "English (Trinidad & Tobago)", "en-GB": "English (United Kingdom)", "en-US": "English (United States)", "en-ZW": "English (Zimbabwe)", eo: "Esperanto", et: "Estonian", fo: "Faeroese", fj: "Fijian", fi: "Finnish", fr: "French (Standard)", "fr-BE": "French (Belgium)", "fr-CA": "French (Canada)", "fr-FR": "French (France)", "fr-LU": "French (Luxembourg)", "fr-MC": "French (Monaco)", "fr-CH": "French (Switzerland)", fy: "Frisian", fur: "Friulian", gd: "Gaelic (Scots)", "gd-IE": "Gaelic (Irish)", gl: "Galacian", ka: "Georgian", de: "German (Standard)", "de-AT": "German (Austria)", "de-DE": "German (Germany)", "de-LI": "German (Liechtenstein)", "de-LU": "German (Luxembourg)", "de-CH": "German (Switzerland)", el: "Greek", gu: "Gujurati", ht: "Haitian", he: "Hebrew", hi: "Hindi", hu: "Hungarian", is: "Icelandic", id: "Indonesian", iu: "Inuktitut", ga: "Irish", it: "Italian (Standard)", "it-CH": "Italian (Switzerland)", ja: "Japanese", kn: "Kannada", ks: "Kashmiri", kk: "Kazakh", km: "Khmer", ky: "Kirghiz", tlh: "Klingon", ko: "Korean", "ko-KP": "Korean (North Korea)", "ko-KR": "Korean (South Korea)", la: "Latin", lv: "Latvian", lt: "Lithuanian", lb: "Luxembourgish", mk: "North Macedonia", ms: "Malay", ml: "Malayalam", mt: "Maltese", mi: "Maori", mr: "Marathi", mo: "Moldavian", nv: "Navajo", ng: "Ndonga", ne: "Nepali", no: "Norwegian", nb: "Norwegian (Bokmal)", nn: "Norwegian (Nynorsk)", oc: "Occitan", or: "Oriya", om: "Oromo", fa: "Persian", "fa-IR": "Persian/Iran", pl: "Polish", pt: "Portuguese", "pt-BR": "Portuguese (Brazil)", pa: "Punjabi", "pa-IN": "Punjabi (India)", "pa-PK": "Punjabi (Pakistan)", qu: "Quechua", rm: "Rhaeto-Romanic", ro: "Romanian", "ro-MO": "Romanian (Moldavia)", ru: "Russian", "ru-MO": "Russian (Moldavia)", sz: "Sami (Lappish)", sg: "Sango", sa: "Sanskrit", sc: "Sardinian", sd: "Sindhi", si: "Singhalese", sr: "Serbian", sk: "Slovak", sl: "Slovenian", so: "Somani", sb: "Sorbian", es: "Spanish", "es-AR": "Spanish (Argentina)", "es-BO": "Spanish (Bolivia)", "es-CL": "Spanish (Chile)", "es-CO": "Spanish (Colombia)", "es-CR": "Spanish (Costa Rica)", "es-DO": "Spanish (Dominican Republic)", "es-EC": "Spanish (Ecuador)", "es-SV": "Spanish (El Salvador)", "es-GT": "Spanish (Guatemala)", "es-HN": "Spanish (Honduras)", "es-MX": "Spanish (Mexico)", "es-NI": "Spanish (Nicaragua)", "es-PA": "Spanish (Panama)", "es-PY": "Spanish (Paraguay)", "es-PE": "Spanish (Peru)", "es-PR": "Spanish (Puerto Rico)", "es-ES": "Spanish (Spain)", "es-UY": "Spanish (Uruguay)", "es-VE": "Spanish (Venezuela)", sx: "Sutu", sw: "Swahili", sv: "Swedish", "sv-FI": "Swedish (Finland)", "sv-SV": "Swedish (Sweden)", ta: "Tamil", tt: "Tatar", te: "Teluga", th: "Thai", tig: "Tigre", ts: "Tsonga", tn: "Tswana", tr: "Turkish", tk: "Turkmen", uk: "Ukrainian", hsb: "Upper Sorbian", ur: "Urdu", ve: "Venda", vi: "Vietnamese", vo: "Volapuk", wa: "Walloon", cy: "Welsh", xh: "Xhosa", ji: "Yiddish", zu: "Zulu" }[t3] !== undefined && (this.internal.languageSettings.languageCode = t3, this.internal.languageSettings.isSubscribed === false && (this.internal.events.subscribe("putCatalog", function() {
      this.internal.write("/Lang (" + this.internal.languageSettings.languageCode + ")");
    }), this.internal.languageSettings.isSubscribed = true)), this;
  }, Vt = E.API, Gt = Vt.getCharWidthsArray = function(e2, r2) {
    var n3, i5, a3 = (r2 = r2 || {}).font || this.internal.getFont(), o3 = r2.fontSize || this.internal.getFontSize(), s3 = r2.charSpace || this.internal.getCharSpace(), c4 = r2.widths ? r2.widths : a3.metadata.Unicode.widths, u3 = c4.fof ? c4.fof : 1, h3 = r2.kerning ? r2.kerning : a3.metadata.Unicode.kerning, l3 = h3.fof ? h3.fof : 1, f3 = r2.doKerning !== false, d2 = 0, p3 = e2.length, g2 = 0, m4 = c4[0] || u3, v3 = [];
    for (n3 = 0;n3 < p3; n3++)
      i5 = e2.charCodeAt(n3), typeof a3.metadata.widthOfString == "function" ? v3.push((a3.metadata.widthOfGlyph(a3.metadata.characterToGlyph(i5)) + s3 * (1000 / o3) || 0) / 1000) : (d2 = f3 && _typeof(h3[i5]) === "object" && !isNaN(parseInt(h3[i5][g2], 10)) ? h3[i5][g2] / l3 : 0, v3.push((c4[i5] || m4) / u3 + d2)), g2 = i5;
    return v3;
  }, Yt = Vt.getStringUnitWidth = function(t3, e2) {
    var r2 = (e2 = e2 || {}).fontSize || this.internal.getFontSize(), n3 = e2.font || this.internal.getFont(), i5 = e2.charSpace || this.internal.getCharSpace();
    return Vt.processArabic && (t3 = Vt.processArabic(t3)), typeof n3.metadata.widthOfString == "function" ? n3.metadata.widthOfString(t3, r2, i5) / r2 : Gt.apply(this, arguments).reduce(function(t4, e3) {
      return t4 + e3;
    }, 0);
  }, Jt = function(t3, e2, r2, n3) {
    for (var i5 = [], a3 = 0, o3 = t3.length, s3 = 0;a3 !== o3 && s3 + e2[a3] < r2; )
      s3 += e2[a3], a3++;
    i5.push(t3.slice(0, a3));
    var c4 = a3;
    for (s3 = 0;a3 !== o3; )
      s3 + e2[a3] > n3 && (i5.push(t3.slice(c4, a3)), s3 = 0, c4 = a3), s3 += e2[a3], a3++;
    return c4 !== a3 && i5.push(t3.slice(c4, a3)), i5;
  }, Xt = function(t3, e2, r2) {
    r2 || (r2 = {});
    var n3, i5, a3, o3, s3, c4, u3, h3 = [], l3 = [h3], f3 = r2.textIndent || 0, d2 = 0, p3 = 0, g2 = t3.split(" "), m4 = Gt.apply(this, [" ", r2])[0];
    if (c4 = r2.lineIndent === -1 ? g2[0].length + 2 : r2.lineIndent || 0) {
      var v3 = Array(c4).join(" "), b2 = [];
      g2.map(function(t4) {
        (t4 = t4.split(/\s*\n/)).length > 1 ? b2 = b2.concat(t4.map(function(t5, e3) {
          return (e3 && t5.length ? `
` : "") + t5;
        })) : b2.push(t4[0]);
      }), g2 = b2, c4 = Yt.apply(this, [v3, r2]);
    }
    for (a3 = 0, o3 = g2.length;a3 < o3; a3++) {
      var y3 = 0;
      if (n3 = g2[a3], c4 && n3[0] == `
` && (n3 = n3.substr(1), y3 = 1), f3 + d2 + (p3 = (i5 = Gt.apply(this, [n3, r2])).reduce(function(t4, e3) {
        return t4 + e3;
      }, 0)) > e2 || y3) {
        if (p3 > e2) {
          for (s3 = Jt.apply(this, [n3, i5, e2 - (f3 + d2), e2]), h3.push(s3.shift()), h3 = [s3.pop()];s3.length; )
            l3.push([s3.shift()]);
          p3 = i5.slice(n3.length - (h3[0] ? h3[0].length : 0)).reduce(function(t4, e3) {
            return t4 + e3;
          }, 0);
        } else
          h3 = [n3];
        l3.push(h3), f3 = p3 + c4, d2 = m4;
      } else
        h3.push(n3), f3 += d2 + p3, d2 = m4;
    }
    return u3 = c4 ? function(t4, e3) {
      return (e3 ? v3 : "") + t4.join(" ");
    } : function(t4) {
      return t4.join(" ");
    }, l3.map(u3);
  }, Vt.splitTextToSize = function(t3, e2, r2) {
    var n3, i5 = (r2 = r2 || {}).fontSize || this.internal.getFontSize(), a3 = function(t4) {
      if (t4.widths && t4.kerning)
        return { widths: t4.widths, kerning: t4.kerning };
      var e3 = this.internal.getFont(t4.fontName, t4.fontStyle);
      return e3.metadata.Unicode ? { widths: e3.metadata.Unicode.widths || { 0: 1 }, kerning: e3.metadata.Unicode.kerning || {} } : { font: e3.metadata, fontSize: this.internal.getFontSize(), charSpace: this.internal.getCharSpace() };
    }.call(this, r2);
    n3 = Array.isArray(t3) ? t3 : String(t3).split(/\r?\n/);
    var o3 = 1 * this.internal.scaleFactor * e2 / i5;
    a3.textIndent = r2.textIndent ? 1 * r2.textIndent * this.internal.scaleFactor / i5 : 0, a3.lineIndent = r2.lineIndent;
    var s3, c4, u3 = [];
    for (s3 = 0, c4 = n3.length;s3 < c4; s3++)
      u3 = u3.concat(Xt.apply(this, [n3[s3], o3, a3]));
    return u3;
  }, function(e2) {
    e2.__fontmetrics__ = e2.__fontmetrics__ || {};
    for (var r2 = "klmnopqrstuvwxyz", n3 = {}, i5 = {}, a3 = 0;a3 < r2.length; a3++)
      n3[r2[a3]] = "0123456789abcdef"[a3], i5["0123456789abcdef"[a3]] = r2[a3];
    var o3 = function(t3) {
      return "0x" + parseInt(t3, 10).toString(16);
    }, s3 = e2.__fontmetrics__.compress = function(e3) {
      var r3, n4, a4, c5, u4 = ["{"];
      for (var h4 in e3) {
        if (r3 = e3[h4], isNaN(parseInt(h4, 10)) ? n4 = "'" + h4 + "'" : (h4 = parseInt(h4, 10), n4 = (n4 = o3(h4).slice(2)).slice(0, -1) + i5[n4.slice(-1)]), typeof r3 == "number")
          r3 < 0 ? (a4 = o3(r3).slice(3), c5 = "-") : (a4 = o3(r3).slice(2), c5 = ""), a4 = c5 + a4.slice(0, -1) + i5[a4.slice(-1)];
        else {
          if (_typeof(r3) !== "object")
            throw new Error("Don't know what to do with value type " + _typeof(r3) + ".");
          a4 = s3(r3);
        }
        u4.push(n4 + a4);
      }
      return u4.push("}"), u4.join("");
    }, c4 = e2.__fontmetrics__.uncompress = function(t3) {
      if (typeof t3 != "string")
        throw new Error("Invalid argument passed to uncompress.");
      for (var e3, r3, i6, a4, o4 = {}, s4 = 1, c5 = o4, u4 = [], h4 = "", l4 = "", f3 = t3.length - 1, d2 = 1;d2 < f3; d2 += 1)
        (a4 = t3[d2]) == "'" ? e3 ? (i6 = e3.join(""), e3 = undefined) : e3 = [] : e3 ? e3.push(a4) : a4 == "{" ? (u4.push([c5, i6]), c5 = {}, i6 = undefined) : a4 == "}" ? ((r3 = u4.pop())[0][r3[1]] = c5, i6 = undefined, c5 = r3[0]) : a4 == "-" ? s4 = -1 : i6 === undefined ? n3.hasOwnProperty(a4) ? (h4 += n3[a4], i6 = parseInt(h4, 16) * s4, s4 = 1, h4 = "") : h4 += a4 : n3.hasOwnProperty(a4) ? (l4 += n3[a4], c5[i6] = parseInt(l4, 16) * s4, s4 = 1, i6 = undefined, l4 = "") : l4 += a4;
      return o4;
    }, u3 = { codePages: ["WinAnsiEncoding"], WinAnsiEncoding: c4("{19m8n201n9q201o9r201s9l201t9m201u8m201w9n201x9o201y8o202k8q202l8r202m9p202q8p20aw8k203k8t203t8v203u9v2cq8s212m9t15m8w15n9w2dw9s16k8u16l9u17s9z17x8y17y9y}") }, h3 = { Unicode: { Courier: u3, "Courier-Bold": u3, "Courier-BoldOblique": u3, "Courier-Oblique": u3, Helvetica: u3, "Helvetica-Bold": u3, "Helvetica-BoldOblique": u3, "Helvetica-Oblique": u3, "Times-Roman": u3, "Times-Bold": u3, "Times-BoldItalic": u3, "Times-Italic": u3 } }, l3 = { Unicode: { "Courier-Oblique": c4("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"), "Times-BoldItalic": c4("{'widths'{k3o2q4ycx2r201n3m201o6o201s2l201t2l201u2l201w3m201x3m201y3m2k1t2l2r202m2n2n3m2o3m2p5n202q6o2r1w2s2l2t2l2u3m2v3t2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v2l3w3t3x3t3y3t3z3m4k5n4l4m4m4m4n4m4o4s4p4m4q4m4r4s4s4y4t2r4u3m4v4m4w3x4x5t4y4s4z4s5k3x5l4s5m4m5n3r5o3x5p4s5q4m5r5t5s4m5t3x5u3x5v2l5w1w5x2l5y3t5z3m6k2l6l3m6m3m6n2w6o3m6p2w6q2l6r3m6s3r6t1w6u1w6v3m6w1w6x4y6y3r6z3m7k3m7l3m7m2r7n2r7o1w7p3r7q2w7r4m7s3m7t2w7u2r7v2n7w1q7x2n7y3t202l3mcl4mal2ram3man3mao3map3mar3mas2lat4uau1uav3maw3way4uaz2lbk2sbl3t'fof'6obo2lbp3tbq3mbr1tbs2lbu1ybv3mbz3mck4m202k3mcm4mcn4mco4mcp4mcq5ycr4mcs4mct4mcu4mcv4mcw2r2m3rcy2rcz2rdl4sdm4sdn4sdo4sdp4sdq4sds4sdt4sdu4sdv4sdw4sdz3mek3mel3mem3men3meo3mep3meq4ser2wes2wet2weu2wev2wew1wex1wey1wez1wfl3rfm3mfn3mfo3mfp3mfq3mfr3tfs3mft3rfu3rfv3rfw3rfz2w203k6o212m6o2dw2l2cq2l3t3m3u2l17s3x19m3m}'kerning'{cl{4qu5kt5qt5rs17ss5ts}201s{201ss}201t{cks4lscmscnscoscpscls2wu2yu201ts}201x{2wu2yu}2k{201ts}2w{4qx5kx5ou5qx5rs17su5tu}2x{17su5tu5ou}2y{4qx5kx5ou5qx5rs17ss5ts}'fof'-6ofn{17sw5tw5ou5qw5rs}7t{cksclscmscnscoscps4ls}3u{17su5tu5os5qs}3v{17su5tu5os5qs}7p{17su5tu}ck{4qu5kt5qt5rs17ss5ts}4l{4qu5kt5qt5rs17ss5ts}cm{4qu5kt5qt5rs17ss5ts}cn{4qu5kt5qt5rs17ss5ts}co{4qu5kt5qt5rs17ss5ts}cp{4qu5kt5qt5rs17ss5ts}6l{4qu5ou5qw5rt17su5tu}5q{ckuclucmucnucoucpu4lu}5r{ckuclucmucnucoucpu4lu}7q{cksclscmscnscoscps4ls}6p{4qu5ou5qw5rt17sw5tw}ek{4qu5ou5qw5rt17su5tu}el{4qu5ou5qw5rt17su5tu}em{4qu5ou5qw5rt17su5tu}en{4qu5ou5qw5rt17su5tu}eo{4qu5ou5qw5rt17su5tu}ep{4qu5ou5qw5rt17su5tu}es{17ss5ts5qs4qu}et{4qu5ou5qw5rt17sw5tw}eu{4qu5ou5qw5rt17ss5ts}ev{17ss5ts5qs4qu}6z{17sw5tw5ou5qw5rs}fm{17sw5tw5ou5qw5rs}7n{201ts}fo{17sw5tw5ou5qw5rs}fp{17sw5tw5ou5qw5rs}fq{17sw5tw5ou5qw5rs}7r{cksclscmscnscoscps4ls}fs{17sw5tw5ou5qw5rs}ft{17su5tu}fu{17su5tu}fv{17su5tu}fw{17su5tu}fz{cksclscmscnscoscps4ls}}}"), "Helvetica-Bold": c4("{'widths'{k3s2q4scx1w201n3r201o6o201s1w201t1w201u1w201w3m201x3m201y3m2k1w2l2l202m2n2n3r2o3r2p5t202q6o2r1s2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v2l3w3u3x3u3y3u3z3x4k6l4l4s4m4s4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3r4v4s4w3x4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v2l5w1w5x2l5y3u5z3r6k2l6l3r6m3x6n3r6o3x6p3r6q2l6r3x6s3x6t1w6u1w6v3r6w1w6x5t6y3x6z3x7k3x7l3x7m2r7n3r7o2l7p3x7q3r7r4y7s3r7t3r7u3m7v2r7w1w7x2r7y3u202l3rcl4sal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3xbq3rbr1wbs2lbu2obv3rbz3xck4s202k3rcm4scn4sco4scp4scq6ocr4scs4mct4mcu4mcv4mcw1w2m2zcy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3res3ret3reu3rev3rew1wex1wey1wez1wfl3xfm3xfn3xfo3xfp3xfq3xfr3ufs3xft3xfu3xfv3xfw3xfz3r203k6o212m6o2dw2l2cq2l3t3r3u2l17s4m19m3r}'kerning'{cl{4qs5ku5ot5qs17sv5tv}201t{2ww4wy2yw}201w{2ks}201x{2ww4wy2yw}2k{201ts201xs}2w{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}2x{5ow5qs}2y{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}'fof'-6o7p{17su5tu5ot}ck{4qs5ku5ot5qs17sv5tv}4l{4qs5ku5ot5qs17sv5tv}cm{4qs5ku5ot5qs17sv5tv}cn{4qs5ku5ot5qs17sv5tv}co{4qs5ku5ot5qs17sv5tv}cp{4qs5ku5ot5qs17sv5tv}6l{17st5tt5os}17s{2kwclvcmvcnvcovcpv4lv4wwckv}5o{2kucltcmtcntcotcpt4lt4wtckt}5q{2ksclscmscnscoscps4ls4wvcks}5r{2ks4ws}5t{2kwclvcmvcnvcovcpv4lv4wwckv}eo{17st5tt5os}fu{17su5tu5ot}6p{17ss5ts}ek{17st5tt5os}el{17st5tt5os}em{17st5tt5os}en{17st5tt5os}6o{201ts}ep{17st5tt5os}es{17ss5ts}et{17ss5ts}eu{17ss5ts}ev{17ss5ts}6z{17su5tu5os5qt}fm{17su5tu5os5qt}fn{17su5tu5os5qt}fo{17su5tu5os5qt}fp{17su5tu5os5qt}fq{17su5tu5os5qt}fs{17su5tu5os5qt}ft{17su5tu5ot}7m{5os}fv{17su5tu5ot}fw{17su5tu5ot}}}"), Courier: c4("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"), "Courier-BoldOblique": c4("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"), "Times-Bold": c4("{'widths'{k3q2q5ncx2r201n3m201o6o201s2l201t2l201u2l201w3m201x3m201y3m2k1t2l2l202m2n2n3m2o3m2p6o202q6o2r1w2s2l2t2l2u3m2v3t2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v2l3w3t3x3t3y3t3z3m4k5x4l4s4m4m4n4s4o4s4p4m4q3x4r4y4s4y4t2r4u3m4v4y4w4m4x5y4y4s4z4y5k3x5l4y5m4s5n3r5o4m5p4s5q4s5r6o5s4s5t4s5u4m5v2l5w1w5x2l5y3u5z3m6k2l6l3m6m3r6n2w6o3r6p2w6q2l6r3m6s3r6t1w6u2l6v3r6w1w6x5n6y3r6z3m7k3r7l3r7m2w7n2r7o2l7p3r7q3m7r4s7s3m7t3m7u2w7v2r7w1q7x2r7y3o202l3mcl4sal2lam3man3mao3map3mar3mas2lat4uau1yav3maw3tay4uaz2lbk2sbl3t'fof'6obo2lbp3rbr1tbs2lbu2lbv3mbz3mck4s202k3mcm4scn4sco4scp4scq6ocr4scs4mct4mcu4mcv4mcw2r2m3rcy2rcz2rdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3rek3mel3mem3men3meo3mep3meq4ser2wes2wet2weu2wev2wew1wex1wey1wez1wfl3rfm3mfn3mfo3mfp3mfq3mfr3tfs3mft3rfu3rfv3rfw3rfz3m203k6o212m6o2dw2l2cq2l3t3m3u2l17s4s19m3m}'kerning'{cl{4qt5ks5ot5qy5rw17sv5tv}201t{cks4lscmscnscoscpscls4wv}2k{201ts}2w{4qu5ku7mu5os5qx5ru17su5tu}2x{17su5tu5ou5qs}2y{4qv5kv7mu5ot5qz5ru17su5tu}'fof'-6o7t{cksclscmscnscoscps4ls}3u{17su5tu5os5qu}3v{17su5tu5os5qu}fu{17su5tu5ou5qu}7p{17su5tu5ou5qu}ck{4qt5ks5ot5qy5rw17sv5tv}4l{4qt5ks5ot5qy5rw17sv5tv}cm{4qt5ks5ot5qy5rw17sv5tv}cn{4qt5ks5ot5qy5rw17sv5tv}co{4qt5ks5ot5qy5rw17sv5tv}cp{4qt5ks5ot5qy5rw17sv5tv}6l{17st5tt5ou5qu}17s{ckuclucmucnucoucpu4lu4wu}5o{ckuclucmucnucoucpu4lu4wu}5q{ckzclzcmzcnzcozcpz4lz4wu}5r{ckxclxcmxcnxcoxcpx4lx4wu}5t{ckuclucmucnucoucpu4lu4wu}7q{ckuclucmucnucoucpu4lu}6p{17sw5tw5ou5qu}ek{17st5tt5qu}el{17st5tt5ou5qu}em{17st5tt5qu}en{17st5tt5qu}eo{17st5tt5qu}ep{17st5tt5ou5qu}es{17ss5ts5qu}et{17sw5tw5ou5qu}eu{17sw5tw5ou5qu}ev{17ss5ts5qu}6z{17sw5tw5ou5qu5rs}fm{17sw5tw5ou5qu5rs}fn{17sw5tw5ou5qu5rs}fo{17sw5tw5ou5qu5rs}fp{17sw5tw5ou5qu5rs}fq{17sw5tw5ou5qu5rs}7r{cktcltcmtcntcotcpt4lt5os}fs{17sw5tw5ou5qu5rs}ft{17su5tu5ou5qu}7m{5os}fv{17su5tu5ou5qu}fw{17su5tu5ou5qu}fz{cksclscmscnscoscps4ls}}}"), Symbol: c4("{'widths'{k3uaw4r19m3m2k1t2l2l202m2y2n3m2p5n202q6o3k3m2s2l2t2l2v3r2w1t3m3m2y1t2z1wbk2sbl3r'fof'6o3n3m3o3m3p3m3q3m3r3m3s3m3t3m3u1w3v1w3w3r3x3r3y3r3z2wbp3t3l3m5v2l5x2l5z3m2q4yfr3r7v3k7w1o7x3k}'kerning'{'fof'-6o}}"), Helvetica: c4("{'widths'{k3p2q4mcx1w201n3r201o6o201s1q201t1q201u1q201w2l201x2l201y2l2k1w2l1w202m2n2n3r2o3r2p5t202q6o2r1n2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v1w3w3u3x3u3y3u3z3r4k6p4l4m4m4m4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3m4v4m4w3r4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v1w5w1w5x1w5y2z5z3r6k2l6l3r6m3r6n3m6o3r6p3r6q1w6r3r6s3r6t1q6u1q6v3m6w1q6x5n6y3r6z3r7k3r7l3r7m2l7n3m7o1w7p3r7q3m7r4s7s3m7t3m7u3m7v2l7w1u7x2l7y3u202l3rcl4mal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3rbr1wbs2lbu2obv3rbz3xck4m202k3rcm4mcn4mco4mcp4mcq6ocr4scs4mct4mcu4mcv4mcw1w2m2ncy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3mes3ret3reu3rev3rew1wex1wey1wez1wfl3rfm3rfn3rfo3rfp3rfq3rfr3ufs3xft3rfu3rfv3rfw3rfz3m203k6o212m6o2dw2l2cq2l3t3r3u1w17s4m19m3r}'kerning'{5q{4wv}cl{4qs5kw5ow5qs17sv5tv}201t{2wu4w1k2yu}201x{2wu4wy2yu}17s{2ktclucmucnu4otcpu4lu4wycoucku}2w{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}2x{17sy5ty5oy5qs}2y{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}'fof'-6o7p{17sv5tv5ow}ck{4qs5kw5ow5qs17sv5tv}4l{4qs5kw5ow5qs17sv5tv}cm{4qs5kw5ow5qs17sv5tv}cn{4qs5kw5ow5qs17sv5tv}co{4qs5kw5ow5qs17sv5tv}cp{4qs5kw5ow5qs17sv5tv}6l{17sy5ty5ow}do{17st5tt}4z{17st5tt}7s{fst}dm{17st5tt}dn{17st5tt}5o{ckwclwcmwcnwcowcpw4lw4wv}dp{17st5tt}dq{17st5tt}7t{5ow}ds{17st5tt}5t{2ktclucmucnu4otcpu4lu4wycoucku}fu{17sv5tv5ow}6p{17sy5ty5ow5qs}ek{17sy5ty5ow}el{17sy5ty5ow}em{17sy5ty5ow}en{5ty}eo{17sy5ty5ow}ep{17sy5ty5ow}es{17sy5ty5qs}et{17sy5ty5ow5qs}eu{17sy5ty5ow5qs}ev{17sy5ty5ow5qs}6z{17sy5ty5ow5qs}fm{17sy5ty5ow5qs}fn{17sy5ty5ow5qs}fo{17sy5ty5ow5qs}fp{17sy5ty5qs}fq{17sy5ty5ow5qs}7r{5ow}fs{17sy5ty5ow5qs}ft{17sv5tv5ow}7m{5ow}fv{17sv5tv5ow}fw{17sv5tv5ow}}}"), "Helvetica-BoldOblique": c4("{'widths'{k3s2q4scx1w201n3r201o6o201s1w201t1w201u1w201w3m201x3m201y3m2k1w2l2l202m2n2n3r2o3r2p5t202q6o2r1s2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v2l3w3u3x3u3y3u3z3x4k6l4l4s4m4s4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3r4v4s4w3x4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v2l5w1w5x2l5y3u5z3r6k2l6l3r6m3x6n3r6o3x6p3r6q2l6r3x6s3x6t1w6u1w6v3r6w1w6x5t6y3x6z3x7k3x7l3x7m2r7n3r7o2l7p3x7q3r7r4y7s3r7t3r7u3m7v2r7w1w7x2r7y3u202l3rcl4sal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3xbq3rbr1wbs2lbu2obv3rbz3xck4s202k3rcm4scn4sco4scp4scq6ocr4scs4mct4mcu4mcv4mcw1w2m2zcy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3res3ret3reu3rev3rew1wex1wey1wez1wfl3xfm3xfn3xfo3xfp3xfq3xfr3ufs3xft3xfu3xfv3xfw3xfz3r203k6o212m6o2dw2l2cq2l3t3r3u2l17s4m19m3r}'kerning'{cl{4qs5ku5ot5qs17sv5tv}201t{2ww4wy2yw}201w{2ks}201x{2ww4wy2yw}2k{201ts201xs}2w{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}2x{5ow5qs}2y{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}'fof'-6o7p{17su5tu5ot}ck{4qs5ku5ot5qs17sv5tv}4l{4qs5ku5ot5qs17sv5tv}cm{4qs5ku5ot5qs17sv5tv}cn{4qs5ku5ot5qs17sv5tv}co{4qs5ku5ot5qs17sv5tv}cp{4qs5ku5ot5qs17sv5tv}6l{17st5tt5os}17s{2kwclvcmvcnvcovcpv4lv4wwckv}5o{2kucltcmtcntcotcpt4lt4wtckt}5q{2ksclscmscnscoscps4ls4wvcks}5r{2ks4ws}5t{2kwclvcmvcnvcovcpv4lv4wwckv}eo{17st5tt5os}fu{17su5tu5ot}6p{17ss5ts}ek{17st5tt5os}el{17st5tt5os}em{17st5tt5os}en{17st5tt5os}6o{201ts}ep{17st5tt5os}es{17ss5ts}et{17ss5ts}eu{17ss5ts}ev{17ss5ts}6z{17su5tu5os5qt}fm{17su5tu5os5qt}fn{17su5tu5os5qt}fo{17su5tu5os5qt}fp{17su5tu5os5qt}fq{17su5tu5os5qt}fs{17su5tu5os5qt}ft{17su5tu5ot}7m{5os}fv{17su5tu5ot}fw{17su5tu5ot}}}"), ZapfDingbats: c4("{'widths'{k4u2k1w'fof'6o}'kerning'{'fof'-6o}}"), "Courier-Bold": c4("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"), "Times-Italic": c4("{'widths'{k3n2q4ycx2l201n3m201o5t201s2l201t2l201u2l201w3r201x3r201y3r2k1t2l2l202m2n2n3m2o3m2p5n202q5t2r1p2s2l2t2l2u3m2v4n2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v2l3w4n3x4n3y4n3z3m4k5w4l3x4m3x4n4m4o4s4p3x4q3x4r4s4s4s4t2l4u2w4v4m4w3r4x5n4y4m4z4s5k3x5l4s5m3x5n3m5o3r5p4s5q3x5r5n5s3x5t3r5u3r5v2r5w1w5x2r5y2u5z3m6k2l6l3m6m3m6n2w6o3m6p2w6q1w6r3m6s3m6t1w6u1w6v2w6w1w6x4s6y3m6z3m7k3m7l3m7m2r7n2r7o1w7p3m7q2w7r4m7s2w7t2w7u2r7v2s7w1v7x2s7y3q202l3mcl3xal2ram3man3mao3map3mar3mas2lat4wau1vav3maw4nay4waz2lbk2sbl4n'fof'6obo2lbp3mbq3obr1tbs2lbu1zbv3mbz3mck3x202k3mcm3xcn3xco3xcp3xcq5tcr4mcs3xct3xcu3xcv3xcw2l2m2ucy2lcz2ldl4mdm4sdn4sdo4sdp4sdq4sds4sdt4sdu4sdv4sdw4sdz3mek3mel3mem3men3meo3mep3meq4mer2wes2wet2weu2wev2wew1wex1wey1wez1wfl3mfm3mfn3mfo3mfp3mfq3mfr4nfs3mft3mfu3mfv3mfw3mfz2w203k6o212m6m2dw2l2cq2l3t3m3u2l17s3r19m3m}'kerning'{cl{5kt4qw}201s{201sw}201t{201tw2wy2yy6q-t}201x{2wy2yy}2k{201tw}2w{7qs4qy7rs5ky7mw5os5qx5ru17su5tu}2x{17ss5ts5os}2y{7qs4qy7rs5ky7mw5os5qx5ru17su5tu}'fof'-6o6t{17ss5ts5qs}7t{5os}3v{5qs}7p{17su5tu5qs}ck{5kt4qw}4l{5kt4qw}cm{5kt4qw}cn{5kt4qw}co{5kt4qw}cp{5kt4qw}6l{4qs5ks5ou5qw5ru17su5tu}17s{2ks}5q{ckvclvcmvcnvcovcpv4lv}5r{ckuclucmucnucoucpu4lu}5t{2ks}6p{4qs5ks5ou5qw5ru17su5tu}ek{4qs5ks5ou5qw5ru17su5tu}el{4qs5ks5ou5qw5ru17su5tu}em{4qs5ks5ou5qw5ru17su5tu}en{4qs5ks5ou5qw5ru17su5tu}eo{4qs5ks5ou5qw5ru17su5tu}ep{4qs5ks5ou5qw5ru17su5tu}es{5ks5qs4qs}et{4qs5ks5ou5qw5ru17su5tu}eu{4qs5ks5qw5ru17su5tu}ev{5ks5qs4qs}ex{17ss5ts5qs}6z{4qv5ks5ou5qw5ru17su5tu}fm{4qv5ks5ou5qw5ru17su5tu}fn{4qv5ks5ou5qw5ru17su5tu}fo{4qv5ks5ou5qw5ru17su5tu}fp{4qv5ks5ou5qw5ru17su5tu}fq{4qv5ks5ou5qw5ru17su5tu}7r{5os}fs{4qv5ks5ou5qw5ru17su5tu}ft{17su5tu5qs}fu{17su5tu5qs}fv{17su5tu5qs}fw{17su5tu5qs}}}"), "Times-Roman": c4("{'widths'{k3n2q4ycx2l201n3m201o6o201s2l201t2l201u2l201w2w201x2w201y2w2k1t2l2l202m2n2n3m2o3m2p5n202q6o2r1m2s2l2t2l2u3m2v3s2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v1w3w3s3x3s3y3s3z2w4k5w4l4s4m4m4n4m4o4s4p3x4q3r4r4s4s4s4t2l4u2r4v4s4w3x4x5t4y4s4z4s5k3r5l4s5m4m5n3r5o3x5p4s5q4s5r5y5s4s5t4s5u3x5v2l5w1w5x2l5y2z5z3m6k2l6l2w6m3m6n2w6o3m6p2w6q2l6r3m6s3m6t1w6u1w6v3m6w1w6x4y6y3m6z3m7k3m7l3m7m2l7n2r7o1w7p3m7q3m7r4s7s3m7t3m7u2w7v3k7w1o7x3k7y3q202l3mcl4sal2lam3man3mao3map3mar3mas2lat4wau1vav3maw3say4waz2lbk2sbl3s'fof'6obo2lbp3mbq2xbr1tbs2lbu1zbv3mbz2wck4s202k3mcm4scn4sco4scp4scq5tcr4mcs3xct3xcu3xcv3xcw2l2m2tcy2lcz2ldl4sdm4sdn4sdo4sdp4sdq4sds4sdt4sdu4sdv4sdw4sdz3mek2wel2wem2wen2weo2wep2weq4mer2wes2wet2weu2wev2wew1wex1wey1wez1wfl3mfm3mfn3mfo3mfp3mfq3mfr3sfs3mft3mfu3mfv3mfw3mfz3m203k6o212m6m2dw2l2cq2l3t3m3u1w17s4s19m3m}'kerning'{cl{4qs5ku17sw5ou5qy5rw201ss5tw201ws}201s{201ss}201t{ckw4lwcmwcnwcowcpwclw4wu201ts}2k{201ts}2w{4qs5kw5os5qx5ru17sx5tx}2x{17sw5tw5ou5qu}2y{4qs5kw5os5qx5ru17sx5tx}'fof'-6o7t{ckuclucmucnucoucpu4lu5os5rs}3u{17su5tu5qs}3v{17su5tu5qs}7p{17sw5tw5qs}ck{4qs5ku17sw5ou5qy5rw201ss5tw201ws}4l{4qs5ku17sw5ou5qy5rw201ss5tw201ws}cm{4qs5ku17sw5ou5qy5rw201ss5tw201ws}cn{4qs5ku17sw5ou5qy5rw201ss5tw201ws}co{4qs5ku17sw5ou5qy5rw201ss5tw201ws}cp{4qs5ku17sw5ou5qy5rw201ss5tw201ws}6l{17su5tu5os5qw5rs}17s{2ktclvcmvcnvcovcpv4lv4wuckv}5o{ckwclwcmwcnwcowcpw4lw4wu}5q{ckyclycmycnycoycpy4ly4wu5ms}5r{cktcltcmtcntcotcpt4lt4ws}5t{2ktclvcmvcnvcovcpv4lv4wuckv}7q{cksclscmscnscoscps4ls}6p{17su5tu5qw5rs}ek{5qs5rs}el{17su5tu5os5qw5rs}em{17su5tu5os5qs5rs}en{17su5qs5rs}eo{5qs5rs}ep{17su5tu5os5qw5rs}es{5qs}et{17su5tu5qw5rs}eu{17su5tu5qs5rs}ev{5qs}6z{17sv5tv5os5qx5rs}fm{5os5qt5rs}fn{17sv5tv5os5qx5rs}fo{17sv5tv5os5qx5rs}fp{5os5qt5rs}fq{5os5qt5rs}7r{ckuclucmucnucoucpu4lu5os}fs{17sv5tv5os5qx5rs}ft{17ss5ts5qs}fu{17sw5tw5qs}fv{17sw5tw5qs}fw{17ss5ts5qs}fz{ckuclucmucnucoucpu4lu5os5rs}}}"), "Helvetica-Oblique": c4("{'widths'{k3p2q4mcx1w201n3r201o6o201s1q201t1q201u1q201w2l201x2l201y2l2k1w2l1w202m2n2n3r2o3r2p5t202q6o2r1n2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v1w3w3u3x3u3y3u3z3r4k6p4l4m4m4m4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3m4v4m4w3r4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v1w5w1w5x1w5y2z5z3r6k2l6l3r6m3r6n3m6o3r6p3r6q1w6r3r6s3r6t1q6u1q6v3m6w1q6x5n6y3r6z3r7k3r7l3r7m2l7n3m7o1w7p3r7q3m7r4s7s3m7t3m7u3m7v2l7w1u7x2l7y3u202l3rcl4mal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3rbr1wbs2lbu2obv3rbz3xck4m202k3rcm4mcn4mco4mcp4mcq6ocr4scs4mct4mcu4mcv4mcw1w2m2ncy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3mes3ret3reu3rev3rew1wex1wey1wez1wfl3rfm3rfn3rfo3rfp3rfq3rfr3ufs3xft3rfu3rfv3rfw3rfz3m203k6o212m6o2dw2l2cq2l3t3r3u1w17s4m19m3r}'kerning'{5q{4wv}cl{4qs5kw5ow5qs17sv5tv}201t{2wu4w1k2yu}201x{2wu4wy2yu}17s{2ktclucmucnu4otcpu4lu4wycoucku}2w{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}2x{17sy5ty5oy5qs}2y{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}'fof'-6o7p{17sv5tv5ow}ck{4qs5kw5ow5qs17sv5tv}4l{4qs5kw5ow5qs17sv5tv}cm{4qs5kw5ow5qs17sv5tv}cn{4qs5kw5ow5qs17sv5tv}co{4qs5kw5ow5qs17sv5tv}cp{4qs5kw5ow5qs17sv5tv}6l{17sy5ty5ow}do{17st5tt}4z{17st5tt}7s{fst}dm{17st5tt}dn{17st5tt}5o{ckwclwcmwcnwcowcpw4lw4wv}dp{17st5tt}dq{17st5tt}7t{5ow}ds{17st5tt}5t{2ktclucmucnu4otcpu4lu4wycoucku}fu{17sv5tv5ow}6p{17sy5ty5ow5qs}ek{17sy5ty5ow}el{17sy5ty5ow}em{17sy5ty5ow}en{5ty}eo{17sy5ty5ow}ep{17sy5ty5ow}es{17sy5ty5qs}et{17sy5ty5ow5qs}eu{17sy5ty5ow5qs}ev{17sy5ty5ow5qs}6z{17sy5ty5ow5qs}fm{17sy5ty5ow5qs}fn{17sy5ty5ow5qs}fo{17sy5ty5ow5qs}fp{17sy5ty5qs}fq{17sy5ty5ow5qs}7r{5ow}fs{17sy5ty5ow5qs}ft{17sv5tv5ow}7m{5ow}fv{17sv5tv5ow}fw{17sv5tv5ow}}}") } };
    e2.events.push(["addFont", function(t3) {
      var e3 = t3.font, r3 = l3.Unicode[e3.postScriptName];
      r3 && (e3.metadata.Unicode = {}, e3.metadata.Unicode.widths = r3.widths, e3.metadata.Unicode.kerning = r3.kerning);
      var n4 = h3.Unicode[e3.postScriptName];
      n4 && (e3.metadata.Unicode.encoding = n4, e3.encoding = n4.codePages[0]);
    }]);
  }(E.API), function(t3) {
    var e2 = function(t4) {
      for (var e3 = t4.length, r2 = new Uint8Array(e3), n3 = 0;n3 < e3; n3++)
        r2[n3] = t4.charCodeAt(n3);
      return r2;
    };
    t3.API.events.push(["addFont", function(r2) {
      var n3 = undefined, i5 = r2.font, a3 = r2.instance;
      if (!i5.isStandardFont) {
        if (a3 === undefined)
          throw new Error("Font does not exist in vFS, import fonts or remove declaration doc.addFont('" + i5.postScriptName + "').");
        if (typeof (n3 = a3.existsFileInVFS(i5.postScriptName) === false ? a3.loadFile(i5.postScriptName) : a3.getFileFromVFS(i5.postScriptName)) != "string")
          throw new Error("Font is not stored as string-data in vFS, import fonts or remove declaration doc.addFont('" + i5.postScriptName + "').");
        (function(r3, n4) {
          n4 = /^\x00\x01\x00\x00/.test(n4) ? e2(n4) : e2(u2(n4)), r3.metadata = t3.API.TTFFont.open(n4), r3.metadata.Unicode = r3.metadata.Unicode || { encoding: {}, kerning: {}, widths: [] }, r3.metadata.glyIdsUsed = [0];
        })(i5, n3);
      }
    }]);
  }(E), function(t3) {
    function e2() {
      return (n2.canvg ? Promise.resolve(n2.canvg) : Promise.resolve().then(() => (init_index_es(), exports_index_es))).catch(function(t4) {
        return Promise.reject(new Error("Could not load canvg: " + t4));
      }).then(function(t4) {
        return t4.default ? t4.default : t4;
      });
    }
    E.API.addSvgAsImage = function(t4, r2, n3, i5, o3, s3, c4, u3) {
      if (isNaN(r2) || isNaN(n3))
        throw a2.error("jsPDF.addSvgAsImage: Invalid coordinates", arguments), new Error("Invalid coordinates passed to jsPDF.addSvgAsImage");
      if (isNaN(i5) || isNaN(o3))
        throw a2.error("jsPDF.addSvgAsImage: Invalid measurements", arguments), new Error("Invalid measurements (width and/or height) passed to jsPDF.addSvgAsImage");
      var h3 = document.createElement("canvas");
      h3.width = i5, h3.height = o3;
      var l3 = h3.getContext("2d");
      l3.fillStyle = "#fff", l3.fillRect(0, 0, h3.width, h3.height);
      var f3 = { ignoreMouse: true, ignoreAnimation: true, ignoreDimensions: true }, d2 = this;
      return e2().then(function(e3) {
        return e3.fromString(l3, t4, f3);
      }, function() {
        return Promise.reject(new Error("Could not load canvg."));
      }).then(function(t5) {
        return t5.render(f3);
      }).then(function() {
        d2.addImage(h3.toDataURL("image/jpeg", 1), r2, n3, i5, o3, c4, u3);
      });
    };
  }(), E.API.putTotalPages = function(t3) {
    var e2, r2 = 0;
    parseInt(this.internal.getFont().id.substr(1), 10) < 15 ? (e2 = new RegExp(t3, "g"), r2 = this.internal.getNumberOfPages()) : (e2 = new RegExp(this.pdfEscape16(t3, this.internal.getFont()), "g"), r2 = this.pdfEscape16(this.internal.getNumberOfPages() + "", this.internal.getFont()));
    for (var n3 = 1;n3 <= this.internal.getNumberOfPages(); n3++)
      for (var i5 = 0;i5 < this.internal.pages[n3].length; i5++)
        this.internal.pages[n3][i5] = this.internal.pages[n3][i5].replace(e2, r2);
    return this;
  }, E.API.viewerPreferences = function(e2, r2) {
    var n3;
    e2 = e2 || {}, r2 = r2 || false;
    var i5, a3, o3, s3 = { HideToolbar: { defaultValue: false, value: false, type: "boolean", explicitSet: false, valueSet: [true, false], pdfVersion: 1.3 }, HideMenubar: { defaultValue: false, value: false, type: "boolean", explicitSet: false, valueSet: [true, false], pdfVersion: 1.3 }, HideWindowUI: { defaultValue: false, value: false, type: "boolean", explicitSet: false, valueSet: [true, false], pdfVersion: 1.3 }, FitWindow: { defaultValue: false, value: false, type: "boolean", explicitSet: false, valueSet: [true, false], pdfVersion: 1.3 }, CenterWindow: { defaultValue: false, value: false, type: "boolean", explicitSet: false, valueSet: [true, false], pdfVersion: 1.3 }, DisplayDocTitle: { defaultValue: false, value: false, type: "boolean", explicitSet: false, valueSet: [true, false], pdfVersion: 1.4 }, NonFullScreenPageMode: { defaultValue: "UseNone", value: "UseNone", type: "name", explicitSet: false, valueSet: ["UseNone", "UseOutlines", "UseThumbs", "UseOC"], pdfVersion: 1.3 }, Direction: { defaultValue: "L2R", value: "L2R", type: "name", explicitSet: false, valueSet: ["L2R", "R2L"], pdfVersion: 1.3 }, ViewArea: { defaultValue: "CropBox", value: "CropBox", type: "name", explicitSet: false, valueSet: ["MediaBox", "CropBox", "TrimBox", "BleedBox", "ArtBox"], pdfVersion: 1.4 }, ViewClip: { defaultValue: "CropBox", value: "CropBox", type: "name", explicitSet: false, valueSet: ["MediaBox", "CropBox", "TrimBox", "BleedBox", "ArtBox"], pdfVersion: 1.4 }, PrintArea: { defaultValue: "CropBox", value: "CropBox", type: "name", explicitSet: false, valueSet: ["MediaBox", "CropBox", "TrimBox", "BleedBox", "ArtBox"], pdfVersion: 1.4 }, PrintClip: { defaultValue: "CropBox", value: "CropBox", type: "name", explicitSet: false, valueSet: ["MediaBox", "CropBox", "TrimBox", "BleedBox", "ArtBox"], pdfVersion: 1.4 }, PrintScaling: { defaultValue: "AppDefault", value: "AppDefault", type: "name", explicitSet: false, valueSet: ["AppDefault", "None"], pdfVersion: 1.6 }, Duplex: { defaultValue: "", value: "none", type: "name", explicitSet: false, valueSet: ["Simplex", "DuplexFlipShortEdge", "DuplexFlipLongEdge", "none"], pdfVersion: 1.7 }, PickTrayByPDFSize: { defaultValue: false, value: false, type: "boolean", explicitSet: false, valueSet: [true, false], pdfVersion: 1.7 }, PrintPageRange: { defaultValue: "", value: "", type: "array", explicitSet: false, valueSet: null, pdfVersion: 1.7 }, NumCopies: { defaultValue: 1, value: 1, type: "integer", explicitSet: false, valueSet: null, pdfVersion: 1.7 } }, c4 = Object.keys(s3), u3 = [], h3 = 0, l3 = 0, f3 = 0;
    function d2(t3, e3) {
      var r3, n4 = false;
      for (r3 = 0;r3 < t3.length; r3 += 1)
        t3[r3] === e3 && (n4 = true);
      return n4;
    }
    if (this.internal.viewerpreferences === undefined && (this.internal.viewerpreferences = {}, this.internal.viewerpreferences.configuration = JSON.parse(JSON.stringify(s3)), this.internal.viewerpreferences.isSubscribed = false), n3 = this.internal.viewerpreferences.configuration, e2 === "reset" || r2 === true) {
      var p3 = c4.length;
      for (f3 = 0;f3 < p3; f3 += 1)
        n3[c4[f3]].value = n3[c4[f3]].defaultValue, n3[c4[f3]].explicitSet = false;
    }
    if (_typeof(e2) === "object") {
      for (a3 in e2)
        if (o3 = e2[a3], d2(c4, a3) && o3 !== undefined) {
          if (n3[a3].type === "boolean" && typeof o3 == "boolean")
            n3[a3].value = o3;
          else if (n3[a3].type === "name" && d2(n3[a3].valueSet, o3))
            n3[a3].value = o3;
          else if (n3[a3].type === "integer" && Number.isInteger(o3))
            n3[a3].value = o3;
          else if (n3[a3].type === "array") {
            for (h3 = 0;h3 < o3.length; h3 += 1)
              if (i5 = true, o3[h3].length === 1 && typeof o3[h3][0] == "number")
                u3.push(String(o3[h3] - 1));
              else if (o3[h3].length > 1) {
                for (l3 = 0;l3 < o3[h3].length; l3 += 1)
                  typeof o3[h3][l3] != "number" && (i5 = false);
                i5 === true && u3.push([o3[h3][0] - 1, o3[h3][1] - 1].join(" "));
              }
            n3[a3].value = "[" + u3.join(" ") + "]";
          } else
            n3[a3].value = n3[a3].defaultValue;
          n3[a3].explicitSet = true;
        }
    }
    return this.internal.viewerpreferences.isSubscribed === false && (this.internal.events.subscribe("putCatalog", function() {
      var t3, e3 = [];
      for (t3 in n3)
        n3[t3].explicitSet === true && (n3[t3].type === "name" ? e3.push("/" + t3 + " /" + n3[t3].value) : e3.push("/" + t3 + " " + n3[t3].value));
      e3.length !== 0 && this.internal.write(`/ViewerPreferences
<<
` + e3.join(`
`) + `
>>`);
    }), this.internal.viewerpreferences.isSubscribed = true), this.internal.viewerpreferences.configuration = n3, this;
  }, function(t3) {
    var e2 = function() {
      var t4 = '<rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"><rdf:Description rdf:about="" xmlns:jspdf="' + this.internal.__metadata__.namespaceuri + '"><jspdf:metadata>', e3 = unescape(encodeURIComponent('<x:xmpmeta xmlns:x="adobe:ns:meta/">')), r3 = unescape(encodeURIComponent(t4)), n3 = unescape(encodeURIComponent(this.internal.__metadata__.metadata)), i5 = unescape(encodeURIComponent("</jspdf:metadata></rdf:Description></rdf:RDF>")), a3 = unescape(encodeURIComponent("</x:xmpmeta>")), o3 = r3.length + n3.length + i5.length + e3.length + a3.length;
      this.internal.__metadata__.metadata_object_number = this.internal.newObject(), this.internal.write("<< /Type /Metadata /Subtype /XML /Length " + o3 + " >>"), this.internal.write("stream"), this.internal.write(e3 + r3 + n3 + i5 + a3), this.internal.write("endstream"), this.internal.write("endobj");
    }, r2 = function() {
      this.internal.__metadata__.metadata_object_number && this.internal.write("/Metadata " + this.internal.__metadata__.metadata_object_number + " 0 R");
    };
    t3.addMetadata = function(t4, n3) {
      return this.internal.__metadata__ === undefined && (this.internal.__metadata__ = { metadata: t4, namespaceuri: n3 || "http://jspdf.default.namespaceuri/" }, this.internal.events.subscribe("putCatalog", r2), this.internal.events.subscribe("postPutResources", e2)), this;
    };
  }(E.API), function(t3) {
    var e2 = t3.API, r2 = e2.pdfEscape16 = function(t4, e3) {
      for (var r3, n4 = e3.metadata.Unicode.widths, i6 = ["", "0", "00", "000", "0000"], a3 = [""], o3 = 0, s3 = t4.length;o3 < s3; ++o3) {
        if (r3 = e3.metadata.characterToGlyph(t4.charCodeAt(o3)), e3.metadata.glyIdsUsed.push(r3), e3.metadata.toUnicode[r3] = t4.charCodeAt(o3), n4.indexOf(r3) == -1 && (n4.push(r3), n4.push([parseInt(e3.metadata.widthOfGlyph(r3), 10)])), r3 == "0")
          return a3.join("");
        r3 = r3.toString(16), a3.push(i6[4 - r3.length], r3);
      }
      return a3.join("");
    }, n3 = function(t4) {
      var e3, r3, n4, i6, a3, o3, s3;
      for (a3 = `/CIDInit /ProcSet findresource begin
12 dict begin
begincmap
/CIDSystemInfo <<
  /Registry (Adobe)
  /Ordering (UCS)
  /Supplement 0
>> def
/CMapName /Adobe-Identity-UCS def
/CMapType 2 def
1 begincodespacerange
<0000><ffff>
endcodespacerange`, n4 = [], o3 = 0, s3 = (r3 = Object.keys(t4).sort(function(t5, e4) {
        return t5 - e4;
      })).length;o3 < s3; o3++)
        e3 = r3[o3], n4.length >= 100 && (a3 += `
` + n4.length + ` beginbfchar
` + n4.join(`
`) + `
endbfchar`, n4 = []), t4[e3] !== undefined && t4[e3] !== null && typeof t4[e3].toString == "function" && (i6 = ("0000" + t4[e3].toString(16)).slice(-4), e3 = ("0000" + (+e3).toString(16)).slice(-4), n4.push("<" + e3 + "><" + i6 + ">"));
      return n4.length && (a3 += `
` + n4.length + ` beginbfchar
` + n4.join(`
`) + `
endbfchar
`), a3 += `endcmap
CMapName currentdict /CMap defineresource pop
end
end`;
    };
    e2.events.push(["putFont", function(e3) {
      (function(e4) {
        var { font: r3, out: i6, newObject: a3, putStream: o3 } = e4;
        if (r3.metadata instanceof t3.API.TTFFont && r3.encoding === "Identity-H") {
          for (var s3 = r3.metadata.Unicode.widths, c4 = r3.metadata.subset.encode(r3.metadata.glyIdsUsed, 1), u3 = "", h3 = 0;h3 < c4.length; h3++)
            u3 += String.fromCharCode(c4[h3]);
          var l3 = a3();
          o3({ data: u3, addLength1: true, objectId: l3 }), i6("endobj");
          var f3 = a3();
          o3({ data: n3(r3.metadata.toUnicode), addLength1: true, objectId: f3 }), i6("endobj");
          var d2 = a3();
          i6("<<"), i6("/Type /FontDescriptor"), i6("/FontName /" + F(r3.fontName)), i6("/FontFile2 " + l3 + " 0 R"), i6("/FontBBox " + t3.API.PDFObject.convert(r3.metadata.bbox)), i6("/Flags " + r3.metadata.flags), i6("/StemV " + r3.metadata.stemV), i6("/ItalicAngle " + r3.metadata.italicAngle), i6("/Ascent " + r3.metadata.ascender), i6("/Descent " + r3.metadata.decender), i6("/CapHeight " + r3.metadata.capHeight), i6(">>"), i6("endobj");
          var p3 = a3();
          i6("<<"), i6("/Type /Font"), i6("/BaseFont /" + F(r3.fontName)), i6("/FontDescriptor " + d2 + " 0 R"), i6("/W " + t3.API.PDFObject.convert(s3)), i6("/CIDToGIDMap /Identity"), i6("/DW 1000"), i6("/Subtype /CIDFontType2"), i6("/CIDSystemInfo"), i6("<<"), i6("/Supplement 0"), i6("/Registry (Adobe)"), i6("/Ordering (" + r3.encoding + ")"), i6(">>"), i6(">>"), i6("endobj"), r3.objectNumber = a3(), i6("<<"), i6("/Type /Font"), i6("/Subtype /Type0"), i6("/ToUnicode " + f3 + " 0 R"), i6("/BaseFont /" + F(r3.fontName)), i6("/Encoding /" + r3.encoding), i6("/DescendantFonts [" + p3 + " 0 R]"), i6(">>"), i6("endobj"), r3.isAlreadyPutted = true;
        }
      })(e3);
    }]);
    e2.events.push(["putFont", function(e3) {
      (function(e4) {
        var { font: r3, out: i6, newObject: a3, putStream: o3 } = e4;
        if (r3.metadata instanceof t3.API.TTFFont && r3.encoding === "WinAnsiEncoding") {
          for (var s3 = r3.metadata.rawData, c4 = "", u3 = 0;u3 < s3.length; u3++)
            c4 += String.fromCharCode(s3[u3]);
          var h3 = a3();
          o3({ data: c4, addLength1: true, objectId: h3 }), i6("endobj");
          var l3 = a3();
          o3({ data: n3(r3.metadata.toUnicode), addLength1: true, objectId: l3 }), i6("endobj");
          var f3 = a3();
          i6("<<"), i6("/Descent " + r3.metadata.decender), i6("/CapHeight " + r3.metadata.capHeight), i6("/StemV " + r3.metadata.stemV), i6("/Type /FontDescriptor"), i6("/FontFile2 " + h3 + " 0 R"), i6("/Flags 96"), i6("/FontBBox " + t3.API.PDFObject.convert(r3.metadata.bbox)), i6("/FontName /" + F(r3.fontName)), i6("/ItalicAngle " + r3.metadata.italicAngle), i6("/Ascent " + r3.metadata.ascender), i6(">>"), i6("endobj"), r3.objectNumber = a3();
          for (var d2 = 0;d2 < r3.metadata.hmtx.widths.length; d2++)
            r3.metadata.hmtx.widths[d2] = parseInt(r3.metadata.hmtx.widths[d2] * (1000 / r3.metadata.head.unitsPerEm));
          i6("<</Subtype/TrueType/Type/Font/ToUnicode " + l3 + " 0 R/BaseFont/" + F(r3.fontName) + "/FontDescriptor " + f3 + " 0 R/Encoding/" + r3.encoding + " /FirstChar 29 /LastChar 255 /Widths " + t3.API.PDFObject.convert(r3.metadata.hmtx.widths) + ">>"), i6("endobj"), r3.isAlreadyPutted = true;
        }
      })(e3);
    }]);
    var i5 = function(t4) {
      var e3, n4 = t4.text || "", i6 = t4.x, a3 = t4.y, o3 = t4.options || {}, s3 = t4.mutex || {}, c4 = s3.pdfEscape, u3 = s3.activeFontKey, h3 = s3.fonts, l3 = u3, f3 = "", d2 = 0, p3 = "", g2 = h3[l3].encoding;
      if (h3[l3].encoding !== "Identity-H")
        return { text: n4, x: i6, y: a3, options: o3, mutex: s3 };
      for (p3 = n4, l3 = u3, Array.isArray(n4) && (p3 = n4[0]), d2 = 0;d2 < p3.length; d2 += 1)
        h3[l3].metadata.hasOwnProperty("cmap") && (e3 = h3[l3].metadata.cmap.unicode.codeMap[p3[d2].charCodeAt(0)]), e3 || p3[d2].charCodeAt(0) < 256 && h3[l3].metadata.hasOwnProperty("Unicode") ? f3 += p3[d2] : f3 += "";
      var m4 = "";
      return parseInt(l3.slice(1)) < 14 || g2 === "WinAnsiEncoding" ? m4 = c4(f3, l3).split("").map(function(t5) {
        return t5.charCodeAt(0).toString(16);
      }).join("") : g2 === "Identity-H" && (m4 = r2(f3, h3[l3])), s3.isHex = true, { text: m4, x: i6, y: a3, options: o3, mutex: s3 };
    };
    e2.events.push(["postProcessText", function(t4) {
      var e3 = t4.text || "", r3 = [], n4 = { text: e3, x: t4.x, y: t4.y, options: t4.options, mutex: t4.mutex };
      if (Array.isArray(e3)) {
        var a3 = 0;
        for (a3 = 0;a3 < e3.length; a3 += 1)
          Array.isArray(e3[a3]) && e3[a3].length === 3 ? r3.push([i5(Object.assign({}, n4, { text: e3[a3][0] })).text, e3[a3][1], e3[a3][2]]) : r3.push(i5(Object.assign({}, n4, { text: e3[a3] })).text);
        t4.text = r3;
      } else
        t4.text = i5(Object.assign({}, n4, { text: e3 })).text;
    }]);
  }(E), function(t3) {
    var e2 = function() {
      return this.internal.vFS === undefined && (this.internal.vFS = {}), true;
    };
    t3.existsFileInVFS = function(t4) {
      return e2.call(this), this.internal.vFS[t4] !== undefined;
    }, t3.addFileToVFS = function(t4, r2) {
      return e2.call(this), this.internal.vFS[t4] = r2, this;
    }, t3.getFileFromVFS = function(t4) {
      return e2.call(this), this.internal.vFS[t4] !== undefined ? this.internal.vFS[t4] : null;
    };
  }(E.API), function(t3) {
    t3.__bidiEngine__ = t3.prototype.__bidiEngine__ = function(t4) {
      var r3, n3, i5, a3, o3, s3, c4, u3 = e2, h3 = [[0, 3, 0, 1, 0, 0, 0], [0, 3, 0, 1, 2, 2, 0], [0, 3, 0, 17, 2, 0, 1], [0, 3, 5, 5, 4, 1, 0], [0, 3, 21, 21, 4, 0, 1], [0, 3, 5, 5, 4, 2, 0]], l3 = [[2, 0, 1, 1, 0, 1, 0], [2, 0, 1, 1, 0, 2, 0], [2, 0, 2, 1, 3, 2, 0], [2, 0, 2, 33, 3, 1, 1]], f3 = { L: 0, R: 1, EN: 2, AN: 3, N: 4, B: 5, S: 6 }, d2 = { 0: 0, 5: 1, 6: 2, 7: 3, 32: 4, 251: 5, 254: 6, 255: 7 }, p3 = ["(", ")", "(", "<", ">", "<", "[", "]", "[", "{", "}", "{", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], g2 = new RegExp(/^([1-4|9]|1[0-9]|2[0-9]|3[0168]|4[04589]|5[012]|7[78]|159|16[0-9]|17[0-2]|21[569]|22[03489]|250)$/), m4 = false, v3 = 0;
      this.__bidiEngine__ = {};
      var b2 = function(t5) {
        var e3 = t5.charCodeAt(), r4 = e3 >> 8, n4 = d2[r4];
        return n4 !== undefined ? u3[256 * n4 + (255 & e3)] : r4 === 252 || r4 === 253 ? "AL" : g2.test(r4) ? "L" : r4 === 8 ? "R" : "N";
      }, y3 = function(t5) {
        for (var e3, r4 = 0;r4 < t5.length; r4++) {
          if ((e3 = b2(t5.charAt(r4))) === "L")
            return false;
          if (e3 === "R")
            return true;
        }
        return false;
      }, w2 = function(t5, e3, o4, s4) {
        var c5, u4, h4, l4, f4 = e3[s4];
        switch (f4) {
          case "L":
          case "R":
            m4 = false;
            break;
          case "N":
          case "AN":
            break;
          case "EN":
            m4 && (f4 = "AN");
            break;
          case "AL":
            m4 = true, f4 = "R";
            break;
          case "WS":
            f4 = "N";
            break;
          case "CS":
            s4 < 1 || s4 + 1 >= e3.length || (c5 = o4[s4 - 1]) !== "EN" && c5 !== "AN" || (u4 = e3[s4 + 1]) !== "EN" && u4 !== "AN" ? f4 = "N" : m4 && (u4 = "AN"), f4 = u4 === c5 ? u4 : "N";
            break;
          case "ES":
            f4 = (c5 = s4 > 0 ? o4[s4 - 1] : "B") === "EN" && s4 + 1 < e3.length && e3[s4 + 1] === "EN" ? "EN" : "N";
            break;
          case "ET":
            if (s4 > 0 && o4[s4 - 1] === "EN") {
              f4 = "EN";
              break;
            }
            if (m4) {
              f4 = "N";
              break;
            }
            for (h4 = s4 + 1, l4 = e3.length;h4 < l4 && e3[h4] === "ET"; )
              h4++;
            f4 = h4 < l4 && e3[h4] === "EN" ? "EN" : "N";
            break;
          case "NSM":
            if (i5 && !a3) {
              for (l4 = e3.length, h4 = s4 + 1;h4 < l4 && e3[h4] === "NSM"; )
                h4++;
              if (h4 < l4) {
                var d3 = t5[s4], p4 = d3 >= 1425 && d3 <= 2303 || d3 === 64286;
                if (c5 = e3[h4], p4 && (c5 === "R" || c5 === "AL")) {
                  f4 = "R";
                  break;
                }
              }
            }
            f4 = s4 < 1 || (c5 = e3[s4 - 1]) === "B" ? "N" : o4[s4 - 1];
            break;
          case "B":
            m4 = false, r3 = true, f4 = v3;
            break;
          case "S":
            n3 = true, f4 = "N";
            break;
          case "LRE":
          case "RLE":
          case "LRO":
          case "RLO":
          case "PDF":
            m4 = false;
            break;
          case "BN":
            f4 = "N";
        }
        return f4;
      }, N3 = function(t5, e3, r4) {
        var n4 = t5.split("");
        return r4 && L2(n4, r4, { hiLevel: v3 }), n4.reverse(), e3 && e3.reverse(), n4.join("");
      }, L2 = function(t5, e3, i6) {
        var a4, o4, s4, c5, u4, d3 = -1, p4 = t5.length, g3 = 0, y4 = [], N4 = v3 ? l3 : h3, L3 = [];
        for (m4 = false, r3 = false, n3 = false, o4 = 0;o4 < p4; o4++)
          L3[o4] = b2(t5[o4]);
        for (s4 = 0;s4 < p4; s4++) {
          if (u4 = g3, y4[s4] = w2(t5, L3, y4, s4), a4 = 240 & (g3 = N4[u4][f3[y4[s4]]]), g3 &= 15, e3[s4] = c5 = N4[g3][5], a4 > 0)
            if (a4 === 16) {
              for (o4 = d3;o4 < s4; o4++)
                e3[o4] = 1;
              d3 = -1;
            } else
              d3 = -1;
          if (N4[g3][6])
            d3 === -1 && (d3 = s4);
          else if (d3 > -1) {
            for (o4 = d3;o4 < s4; o4++)
              e3[o4] = c5;
            d3 = -1;
          }
          L3[s4] === "B" && (e3[s4] = 0), i6.hiLevel |= c5;
        }
        n3 && function(t6, e4, r4) {
          for (var n4 = 0;n4 < r4; n4++)
            if (t6[n4] === "S") {
              e4[n4] = v3;
              for (var i7 = n4 - 1;i7 >= 0 && t6[i7] === "WS"; i7--)
                e4[i7] = v3;
            }
        }(L3, e3, p4);
      }, A2 = function(t5, e3, n4, i6, a4) {
        if (!(a4.hiLevel < t5)) {
          if (t5 === 1 && v3 === 1 && !r3)
            return e3.reverse(), void (n4 && n4.reverse());
          for (var o4, s4, c5, u4, h4 = e3.length, l4 = 0;l4 < h4; ) {
            if (i6[l4] >= t5) {
              for (c5 = l4 + 1;c5 < h4 && i6[c5] >= t5; )
                c5++;
              for (u4 = l4, s4 = c5 - 1;u4 < s4; u4++, s4--)
                o4 = e3[u4], e3[u4] = e3[s4], e3[s4] = o4, n4 && (o4 = n4[u4], n4[u4] = n4[s4], n4[s4] = o4);
              l4 = c5;
            }
            l4++;
          }
        }
      }, x3 = function(t5, e3, r4) {
        var n4 = t5.split(""), i6 = { hiLevel: v3 };
        return r4 || (r4 = []), L2(n4, r4, i6), function(t6, e4, r5) {
          if (r5.hiLevel !== 0 && c4)
            for (var n5, i7 = 0;i7 < t6.length; i7++)
              e4[i7] === 1 && (n5 = p3.indexOf(t6[i7])) >= 0 && (t6[i7] = p3[n5 + 1]);
        }(n4, r4, i6), A2(2, n4, e3, r4, i6), A2(1, n4, e3, r4, i6), n4.join("");
      };
      return this.__bidiEngine__.doBidiReorder = function(t5, e3, r4) {
        if (function(t6, e4) {
          if (e4)
            for (var r5 = 0;r5 < t6.length; r5++)
              e4[r5] = r5;
          a3 === undefined && (a3 = y3(t6)), s3 === undefined && (s3 = y3(t6));
        }(t5, e3), i5 || !o3 || s3)
          if (i5 && o3 && a3 ^ s3)
            v3 = a3 ? 1 : 0, t5 = N3(t5, e3, r4);
          else if (!i5 && o3 && s3)
            v3 = a3 ? 1 : 0, t5 = x3(t5, e3, r4), t5 = N3(t5, e3);
          else if (!i5 || a3 || o3 || s3) {
            if (i5 && !o3 && a3 ^ s3)
              t5 = N3(t5, e3), a3 ? (v3 = 0, t5 = x3(t5, e3, r4)) : (v3 = 1, t5 = x3(t5, e3, r4), t5 = N3(t5, e3));
            else if (i5 && a3 && !o3 && s3)
              v3 = 1, t5 = x3(t5, e3, r4), t5 = N3(t5, e3);
            else if (!i5 && !o3 && a3 ^ s3) {
              var n4 = c4;
              a3 ? (v3 = 1, t5 = x3(t5, e3, r4), v3 = 0, c4 = false, t5 = x3(t5, e3, r4), c4 = n4) : (v3 = 0, t5 = x3(t5, e3, r4), t5 = N3(t5, e3), v3 = 1, c4 = false, t5 = x3(t5, e3, r4), c4 = n4, t5 = N3(t5, e3));
            }
          } else
            v3 = 0, t5 = x3(t5, e3, r4);
        else
          v3 = a3 ? 1 : 0, t5 = x3(t5, e3, r4);
        return t5;
      }, this.__bidiEngine__.setOptions = function(t5) {
        t5 && (i5 = t5.isInputVisual, o3 = t5.isOutputVisual, a3 = t5.isInputRtl, s3 = t5.isOutputRtl, c4 = t5.isSymmetricSwapping);
      }, this.__bidiEngine__.setOptions(t4), this.__bidiEngine__;
    };
    var e2 = ["BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "S", "B", "S", "WS", "B", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "B", "B", "B", "S", "WS", "N", "N", "ET", "ET", "ET", "N", "N", "N", "N", "N", "ES", "CS", "ES", "CS", "CS", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "CS", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "BN", "BN", "BN", "BN", "BN", "BN", "B", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "CS", "N", "ET", "ET", "ET", "ET", "N", "N", "N", "N", "L", "N", "N", "BN", "N", "N", "ET", "ET", "EN", "EN", "N", "L", "N", "N", "N", "EN", "L", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "L", "L", "L", "L", "L", "L", "L", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "L", "N", "N", "N", "N", "N", "ET", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "R", "NSM", "R", "NSM", "NSM", "R", "NSM", "NSM", "R", "NSM", "N", "N", "N", "N", "N", "N", "N", "N", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "N", "N", "N", "N", "N", "R", "R", "R", "R", "R", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "AN", "AN", "AN", "AN", "AN", "AN", "N", "N", "AL", "ET", "ET", "AL", "CS", "AL", "N", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "N", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "ET", "AN", "AN", "AL", "AL", "AL", "NSM", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AN", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "NSM", "NSM", "N", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "N", "AL", "AL", "NSM", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "N", "N", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AL", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "R", "R", "N", "N", "N", "N", "R", "N", "N", "N", "N", "N", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "BN", "BN", "BN", "L", "R", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "WS", "B", "LRE", "RLE", "PDF", "LRO", "RLO", "CS", "ET", "ET", "ET", "ET", "ET", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "CS", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "WS", "BN", "BN", "BN", "BN", "BN", "N", "LRI", "RLI", "FSI", "PDI", "BN", "BN", "BN", "BN", "BN", "BN", "EN", "L", "N", "N", "EN", "EN", "EN", "EN", "EN", "EN", "ES", "ES", "N", "N", "N", "L", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "ES", "ES", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "R", "NSM", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "ES", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "N", "R", "R", "R", "R", "R", "N", "R", "N", "R", "R", "N", "R", "R", "N", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "CS", "N", "CS", "N", "N", "CS", "N", "N", "N", "N", "N", "N", "N", "N", "N", "ET", "N", "N", "ES", "ES", "N", "N", "N", "N", "N", "ET", "ET", "N", "N", "N", "N", "N", "AL", "AL", "AL", "AL", "AL", "N", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "N", "N", "BN", "N", "N", "N", "ET", "ET", "ET", "N", "N", "N", "N", "N", "ES", "CS", "ES", "CS", "CS", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "CS", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "L", "L", "L", "L", "L", "L", "N", "N", "L", "L", "L", "L", "L", "L", "N", "N", "L", "L", "L", "L", "L", "L", "N", "N", "L", "L", "L", "N", "N", "N", "ET", "ET", "N", "N", "N", "ET", "ET", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N"], r2 = new t3.__bidiEngine__({ isInputVisual: true });
    t3.API.events.push(["postProcessText", function(t4) {
      var e3 = t4.text, n3 = (t4.x, t4.y, t4.options || {}), i5 = (t4.mutex, n3.lang, []);
      if (n3.isInputVisual = typeof n3.isInputVisual != "boolean" || n3.isInputVisual, r2.setOptions(n3), Object.prototype.toString.call(e3) === "[object Array]") {
        var a3 = 0;
        for (i5 = [], a3 = 0;a3 < e3.length; a3 += 1)
          Object.prototype.toString.call(e3[a3]) === "[object Array]" ? i5.push([r2.doBidiReorder(e3[a3][0]), e3[a3][1], e3[a3][2]]) : i5.push([r2.doBidiReorder(e3[a3])]);
        t4.text = i5;
      } else
        t4.text = r2.doBidiReorder(e3);
      r2.setOptions({ isInputVisual: true });
    }]);
  }(E), E.API.TTFFont = function() {
    function t3(t4) {
      var e2;
      if (this.rawData = t4, e2 = this.contents = new ne(t4), this.contents.pos = 4, e2.readString(4) === "ttcf")
        throw new Error("TTCF not supported.");
      e2.pos = 0, this.parse(), this.subset = new Le(this), this.registerTTF();
    }
    return t3.open = function(e2) {
      return new t3(e2);
    }, t3.prototype.parse = function() {
      return this.directory = new ie3(this.contents), this.head = new se(this), this.name = new pe(this), this.cmap = new ue(this), this.toUnicode = {}, this.hhea = new he(this), this.maxp = new ge(this), this.hmtx = new me(this), this.post = new fe(this), this.os2 = new le(this), this.loca = new Ne(this), this.glyf = new be(this), this.ascender = this.os2.exists && this.os2.ascender || this.hhea.ascender, this.decender = this.os2.exists && this.os2.decender || this.hhea.decender, this.lineGap = this.os2.exists && this.os2.lineGap || this.hhea.lineGap, this.bbox = [this.head.xMin, this.head.yMin, this.head.xMax, this.head.yMax];
    }, t3.prototype.registerTTF = function() {
      var t4, e2, r2, n3, i5;
      if (this.scaleFactor = 1000 / this.head.unitsPerEm, this.bbox = function() {
        var e3, r3, n4, i6;
        for (i6 = [], e3 = 0, r3 = (n4 = this.bbox).length;e3 < r3; e3++)
          t4 = n4[e3], i6.push(Math.round(t4 * this.scaleFactor));
        return i6;
      }.call(this), this.stemV = 0, this.post.exists ? (r2 = 255 & (n3 = this.post.italic_angle), (32768 & (e2 = n3 >> 16)) != 0 && (e2 = -(1 + (65535 ^ e2))), this.italicAngle = +(e2 + "." + r2)) : this.italicAngle = 0, this.ascender = Math.round(this.ascender * this.scaleFactor), this.decender = Math.round(this.decender * this.scaleFactor), this.lineGap = Math.round(this.lineGap * this.scaleFactor), this.capHeight = this.os2.exists && this.os2.capHeight || this.ascender, this.xHeight = this.os2.exists && this.os2.xHeight || 0, this.familyClass = (this.os2.exists && this.os2.familyClass || 0) >> 8, this.isSerif = (i5 = this.familyClass) === 1 || i5 === 2 || i5 === 3 || i5 === 4 || i5 === 5 || i5 === 7, this.isScript = this.familyClass === 10, this.flags = 0, this.post.isFixedPitch && (this.flags |= 1), this.isSerif && (this.flags |= 2), this.isScript && (this.flags |= 8), this.italicAngle !== 0 && (this.flags |= 64), this.flags |= 32, !this.cmap.unicode)
        throw new Error("No unicode cmap for font");
    }, t3.prototype.characterToGlyph = function(t4) {
      var e2;
      return ((e2 = this.cmap.unicode) != null ? e2.codeMap[t4] : undefined) || 0;
    }, t3.prototype.widthOfGlyph = function(t4) {
      var e2;
      return e2 = 1000 / this.head.unitsPerEm, this.hmtx.forGlyph(t4).advance * e2;
    }, t3.prototype.widthOfString = function(t4, e2, r2) {
      var n3, i5, a3, o3;
      for (a3 = 0, i5 = 0, o3 = (t4 = "" + t4).length;0 <= o3 ? i5 < o3 : i5 > o3; i5 = 0 <= o3 ? ++i5 : --i5)
        n3 = t4.charCodeAt(i5), a3 += this.widthOfGlyph(this.characterToGlyph(n3)) + r2 * (1000 / e2) || 0;
      return a3 * (e2 / 1000);
    }, t3.prototype.lineHeight = function(t4, e2) {
      var r2;
      return e2 == null && (e2 = false), r2 = e2 ? this.lineGap : 0, (this.ascender + r2 - this.decender) / 1000 * t4;
    }, t3;
  }();
  ne = function() {
    function t3(t4) {
      this.data = t4 != null ? t4 : [], this.pos = 0, this.length = this.data.length;
    }
    return t3.prototype.readByte = function() {
      return this.data[this.pos++];
    }, t3.prototype.writeByte = function(t4) {
      return this.data[this.pos++] = t4;
    }, t3.prototype.readUInt32 = function() {
      return 16777216 * this.readByte() + (this.readByte() << 16) + (this.readByte() << 8) + this.readByte();
    }, t3.prototype.writeUInt32 = function(t4) {
      return this.writeByte(t4 >>> 24 & 255), this.writeByte(t4 >> 16 & 255), this.writeByte(t4 >> 8 & 255), this.writeByte(255 & t4);
    }, t3.prototype.readInt32 = function() {
      var t4;
      return (t4 = this.readUInt32()) >= 2147483648 ? t4 - 4294967296 : t4;
    }, t3.prototype.writeInt32 = function(t4) {
      return t4 < 0 && (t4 += 4294967296), this.writeUInt32(t4);
    }, t3.prototype.readUInt16 = function() {
      return this.readByte() << 8 | this.readByte();
    }, t3.prototype.writeUInt16 = function(t4) {
      return this.writeByte(t4 >> 8 & 255), this.writeByte(255 & t4);
    }, t3.prototype.readInt16 = function() {
      var t4;
      return (t4 = this.readUInt16()) >= 32768 ? t4 - 65536 : t4;
    }, t3.prototype.writeInt16 = function(t4) {
      return t4 < 0 && (t4 += 65536), this.writeUInt16(t4);
    }, t3.prototype.readString = function(t4) {
      var e2, r2;
      for (r2 = [], e2 = 0;0 <= t4 ? e2 < t4 : e2 > t4; e2 = 0 <= t4 ? ++e2 : --e2)
        r2[e2] = String.fromCharCode(this.readByte());
      return r2.join("");
    }, t3.prototype.writeString = function(t4) {
      var e2, r2, n3;
      for (n3 = [], e2 = 0, r2 = t4.length;0 <= r2 ? e2 < r2 : e2 > r2; e2 = 0 <= r2 ? ++e2 : --e2)
        n3.push(this.writeByte(t4.charCodeAt(e2)));
      return n3;
    }, t3.prototype.readShort = function() {
      return this.readInt16();
    }, t3.prototype.writeShort = function(t4) {
      return this.writeInt16(t4);
    }, t3.prototype.readLongLong = function() {
      var t4, e2, r2, n3, i5, a3, o3, s3;
      return t4 = this.readByte(), e2 = this.readByte(), r2 = this.readByte(), n3 = this.readByte(), i5 = this.readByte(), a3 = this.readByte(), o3 = this.readByte(), s3 = this.readByte(), 128 & t4 ? -1 * (72057594037927940 * (255 ^ t4) + 281474976710656 * (255 ^ e2) + 1099511627776 * (255 ^ r2) + 4294967296 * (255 ^ n3) + 16777216 * (255 ^ i5) + 65536 * (255 ^ a3) + 256 * (255 ^ o3) + (255 ^ s3) + 1) : 72057594037927940 * t4 + 281474976710656 * e2 + 1099511627776 * r2 + 4294967296 * n3 + 16777216 * i5 + 65536 * a3 + 256 * o3 + s3;
    }, t3.prototype.writeLongLong = function(t4) {
      var e2, r2;
      return e2 = Math.floor(t4 / 4294967296), r2 = 4294967295 & t4, this.writeByte(e2 >> 24 & 255), this.writeByte(e2 >> 16 & 255), this.writeByte(e2 >> 8 & 255), this.writeByte(255 & e2), this.writeByte(r2 >> 24 & 255), this.writeByte(r2 >> 16 & 255), this.writeByte(r2 >> 8 & 255), this.writeByte(255 & r2);
    }, t3.prototype.readInt = function() {
      return this.readInt32();
    }, t3.prototype.writeInt = function(t4) {
      return this.writeInt32(t4);
    }, t3.prototype.read = function(t4) {
      var e2, r2;
      for (e2 = [], r2 = 0;0 <= t4 ? r2 < t4 : r2 > t4; r2 = 0 <= t4 ? ++r2 : --r2)
        e2.push(this.readByte());
      return e2;
    }, t3.prototype.write = function(t4) {
      var e2, r2, n3, i5;
      for (i5 = [], r2 = 0, n3 = t4.length;r2 < n3; r2++)
        e2 = t4[r2], i5.push(this.writeByte(e2));
      return i5;
    }, t3;
  }();
  ie3 = function() {
    var t3;
    function e2(t4) {
      var e3, r2, n3;
      for (this.scalarType = t4.readInt(), this.tableCount = t4.readShort(), this.searchRange = t4.readShort(), this.entrySelector = t4.readShort(), this.rangeShift = t4.readShort(), this.tables = {}, r2 = 0, n3 = this.tableCount;0 <= n3 ? r2 < n3 : r2 > n3; r2 = 0 <= n3 ? ++r2 : --r2)
        e3 = { tag: t4.readString(4), checksum: t4.readInt(), offset: t4.readInt(), length: t4.readInt() }, this.tables[e3.tag] = e3;
    }
    return e2.prototype.encode = function(e3) {
      var r2, n3, i5, a3, o3, s3, c4, u3, h3, l3, f3, d2, p3;
      for (p3 in f3 = Object.keys(e3).length, s3 = Math.log(2), h3 = 16 * Math.floor(Math.log(f3) / s3), a3 = Math.floor(h3 / s3), u3 = 16 * f3 - h3, (n3 = new ne).writeInt(this.scalarType), n3.writeShort(f3), n3.writeShort(h3), n3.writeShort(a3), n3.writeShort(u3), i5 = 16 * f3, c4 = n3.pos + i5, o3 = null, d2 = [], e3)
        for (l3 = e3[p3], n3.writeString(p3), n3.writeInt(t3(l3)), n3.writeInt(c4), n3.writeInt(l3.length), d2 = d2.concat(l3), p3 === "head" && (o3 = c4), c4 += l3.length;c4 % 4; )
          d2.push(0), c4++;
      return n3.write(d2), r2 = 2981146554 - t3(n3.data), n3.pos = o3 + 8, n3.writeUInt32(r2), n3.data;
    }, t3 = function(t4) {
      var e3, r2, n3, i5;
      for (t4 = ve.call(t4);t4.length % 4; )
        t4.push(0);
      for (n3 = new ne(t4), r2 = 0, e3 = 0, i5 = t4.length;e3 < i5; e3 = e3 += 4)
        r2 += n3.readUInt32();
      return 4294967295 & r2;
    }, e2;
  }();
  ae = {}.hasOwnProperty;
  re = function() {
    function t3(t4) {
      var e2;
      this.file = t4, e2 = this.file.directory.tables[this.tag], this.exists = !!e2, e2 && (this.offset = e2.offset, this.length = e2.length, this.parse(this.file.contents));
    }
    return t3.prototype.parse = function() {}, t3.prototype.encode = function() {}, t3.prototype.raw = function() {
      return this.exists ? (this.file.contents.pos = this.offset, this.file.contents.read(this.length)) : null;
    }, t3;
  }();
  se = function(t3) {
    function e2() {
      return e2.__super__.constructor.apply(this, arguments);
    }
    return oe(e2, re), e2.prototype.tag = "head", e2.prototype.parse = function(t4) {
      return t4.pos = this.offset, this.version = t4.readInt(), this.revision = t4.readInt(), this.checkSumAdjustment = t4.readInt(), this.magicNumber = t4.readInt(), this.flags = t4.readShort(), this.unitsPerEm = t4.readShort(), this.created = t4.readLongLong(), this.modified = t4.readLongLong(), this.xMin = t4.readShort(), this.yMin = t4.readShort(), this.xMax = t4.readShort(), this.yMax = t4.readShort(), this.macStyle = t4.readShort(), this.lowestRecPPEM = t4.readShort(), this.fontDirectionHint = t4.readShort(), this.indexToLocFormat = t4.readShort(), this.glyphDataFormat = t4.readShort();
    }, e2.prototype.encode = function(t4) {
      var e3;
      return (e3 = new ne).writeInt(this.version), e3.writeInt(this.revision), e3.writeInt(this.checkSumAdjustment), e3.writeInt(this.magicNumber), e3.writeShort(this.flags), e3.writeShort(this.unitsPerEm), e3.writeLongLong(this.created), e3.writeLongLong(this.modified), e3.writeShort(this.xMin), e3.writeShort(this.yMin), e3.writeShort(this.xMax), e3.writeShort(this.yMax), e3.writeShort(this.macStyle), e3.writeShort(this.lowestRecPPEM), e3.writeShort(this.fontDirectionHint), e3.writeShort(t4), e3.writeShort(this.glyphDataFormat), e3.data;
    }, e2;
  }();
  ce = function() {
    function t3(t4, e2) {
      var r2, n3, i5, a3, o3, s3, c4, u3, h3, l3, f3, d2, p3, g2, m4, v3, b2;
      switch (this.platformID = t4.readUInt16(), this.encodingID = t4.readShort(), this.offset = e2 + t4.readInt(), h3 = t4.pos, t4.pos = this.offset, this.format = t4.readUInt16(), this.length = t4.readUInt16(), this.language = t4.readUInt16(), this.isUnicode = this.platformID === 3 && this.encodingID === 1 && this.format === 4 || this.platformID === 0 && this.format === 4, this.codeMap = {}, this.format) {
        case 0:
          for (s3 = 0;s3 < 256; ++s3)
            this.codeMap[s3] = t4.readByte();
          break;
        case 4:
          for (f3 = t4.readUInt16(), l3 = f3 / 2, t4.pos += 6, i5 = function() {
            var e3, r3;
            for (r3 = [], s3 = e3 = 0;0 <= l3 ? e3 < l3 : e3 > l3; s3 = 0 <= l3 ? ++e3 : --e3)
              r3.push(t4.readUInt16());
            return r3;
          }(), t4.pos += 2, p3 = function() {
            var e3, r3;
            for (r3 = [], s3 = e3 = 0;0 <= l3 ? e3 < l3 : e3 > l3; s3 = 0 <= l3 ? ++e3 : --e3)
              r3.push(t4.readUInt16());
            return r3;
          }(), c4 = function() {
            var e3, r3;
            for (r3 = [], s3 = e3 = 0;0 <= l3 ? e3 < l3 : e3 > l3; s3 = 0 <= l3 ? ++e3 : --e3)
              r3.push(t4.readUInt16());
            return r3;
          }(), u3 = function() {
            var e3, r3;
            for (r3 = [], s3 = e3 = 0;0 <= l3 ? e3 < l3 : e3 > l3; s3 = 0 <= l3 ? ++e3 : --e3)
              r3.push(t4.readUInt16());
            return r3;
          }(), n3 = (this.length - t4.pos + this.offset) / 2, o3 = function() {
            var e3, r3;
            for (r3 = [], s3 = e3 = 0;0 <= n3 ? e3 < n3 : e3 > n3; s3 = 0 <= n3 ? ++e3 : --e3)
              r3.push(t4.readUInt16());
            return r3;
          }(), s3 = m4 = 0, b2 = i5.length;m4 < b2; s3 = ++m4)
            for (g2 = i5[s3], r2 = v3 = d2 = p3[s3];d2 <= g2 ? v3 <= g2 : v3 >= g2; r2 = d2 <= g2 ? ++v3 : --v3)
              u3[s3] === 0 ? a3 = r2 + c4[s3] : (a3 = o3[u3[s3] / 2 + (r2 - d2) - (l3 - s3)] || 0) !== 0 && (a3 += c4[s3]), this.codeMap[r2] = 65535 & a3;
      }
      t4.pos = h3;
    }
    return t3.encode = function(t4, e2) {
      var r2, n3, i5, a3, o3, s3, c4, u3, h3, l3, f3, d2, p3, g2, m4, v3, b2, y3, w2, N3, L2, A2, x3, S2, _3, P2, k2, I2, F2, C2, j2, O3, B2, M2, E2, q2, D2, R2, T3, U2, z2, H2, W2, V2, G2, Y2;
      switch (I2 = new ne, a3 = Object.keys(t4).sort(function(t5, e3) {
        return t5 - e3;
      }), e2) {
        case "macroman":
          for (p3 = 0, g2 = function() {
            var t5 = [];
            for (d2 = 0;d2 < 256; ++d2)
              t5.push(0);
            return t5;
          }(), v3 = { 0: 0 }, i5 = {}, F2 = 0, B2 = a3.length;F2 < B2; F2++)
            v3[W2 = t4[n3 = a3[F2]]] == null && (v3[W2] = ++p3), i5[n3] = { old: t4[n3], new: v3[t4[n3]] }, g2[n3] = v3[t4[n3]];
          return I2.writeUInt16(1), I2.writeUInt16(0), I2.writeUInt32(12), I2.writeUInt16(0), I2.writeUInt16(262), I2.writeUInt16(0), I2.write(g2), { charMap: i5, subtable: I2.data, maxGlyphID: p3 + 1 };
        case "unicode":
          for (P2 = [], h3 = [], b2 = 0, v3 = {}, r2 = {}, m4 = c4 = null, C2 = 0, M2 = a3.length;C2 < M2; C2++)
            v3[w2 = t4[n3 = a3[C2]]] == null && (v3[w2] = ++b2), r2[n3] = { old: w2, new: v3[w2] }, o3 = v3[w2] - n3, m4 != null && o3 === c4 || (m4 && h3.push(m4), P2.push(n3), c4 = o3), m4 = n3;
          for (m4 && h3.push(m4), h3.push(65535), P2.push(65535), S2 = 2 * (x3 = P2.length), A2 = 2 * Math.pow(Math.log(x3) / Math.LN2, 2), l3 = Math.log(A2 / 2) / Math.LN2, L2 = 2 * x3 - A2, s3 = [], N3 = [], f3 = [], d2 = j2 = 0, E2 = P2.length;j2 < E2; d2 = ++j2) {
            if (_3 = P2[d2], u3 = h3[d2], _3 === 65535) {
              s3.push(0), N3.push(0);
              break;
            }
            if (_3 - (k2 = r2[_3].new) >= 32768)
              for (s3.push(0), N3.push(2 * (f3.length + x3 - d2)), n3 = O3 = _3;_3 <= u3 ? O3 <= u3 : O3 >= u3; n3 = _3 <= u3 ? ++O3 : --O3)
                f3.push(r2[n3].new);
            else
              s3.push(k2 - _3), N3.push(0);
          }
          for (I2.writeUInt16(3), I2.writeUInt16(1), I2.writeUInt32(12), I2.writeUInt16(4), I2.writeUInt16(16 + 8 * x3 + 2 * f3.length), I2.writeUInt16(0), I2.writeUInt16(S2), I2.writeUInt16(A2), I2.writeUInt16(l3), I2.writeUInt16(L2), z2 = 0, q2 = h3.length;z2 < q2; z2++)
            n3 = h3[z2], I2.writeUInt16(n3);
          for (I2.writeUInt16(0), H2 = 0, D2 = P2.length;H2 < D2; H2++)
            n3 = P2[H2], I2.writeUInt16(n3);
          for (V2 = 0, R2 = s3.length;V2 < R2; V2++)
            o3 = s3[V2], I2.writeUInt16(o3);
          for (G2 = 0, T3 = N3.length;G2 < T3; G2++)
            y3 = N3[G2], I2.writeUInt16(y3);
          for (Y2 = 0, U2 = f3.length;Y2 < U2; Y2++)
            p3 = f3[Y2], I2.writeUInt16(p3);
          return { charMap: r2, subtable: I2.data, maxGlyphID: b2 + 1 };
      }
    }, t3;
  }();
  ue = function(t3) {
    function e2() {
      return e2.__super__.constructor.apply(this, arguments);
    }
    return oe(e2, re), e2.prototype.tag = "cmap", e2.prototype.parse = function(t4) {
      var e3, r2, n3;
      for (t4.pos = this.offset, this.version = t4.readUInt16(), n3 = t4.readUInt16(), this.tables = [], this.unicode = null, r2 = 0;0 <= n3 ? r2 < n3 : r2 > n3; r2 = 0 <= n3 ? ++r2 : --r2)
        e3 = new ce(t4, this.offset), this.tables.push(e3), e3.isUnicode && this.unicode == null && (this.unicode = e3);
      return true;
    }, e2.encode = function(t4, e3) {
      var r2, n3;
      return e3 == null && (e3 = "macroman"), r2 = ce.encode(t4, e3), (n3 = new ne).writeUInt16(0), n3.writeUInt16(1), r2.table = n3.data.concat(r2.subtable), r2;
    }, e2;
  }();
  he = function(t3) {
    function e2() {
      return e2.__super__.constructor.apply(this, arguments);
    }
    return oe(e2, re), e2.prototype.tag = "hhea", e2.prototype.parse = function(t4) {
      return t4.pos = this.offset, this.version = t4.readInt(), this.ascender = t4.readShort(), this.decender = t4.readShort(), this.lineGap = t4.readShort(), this.advanceWidthMax = t4.readShort(), this.minLeftSideBearing = t4.readShort(), this.minRightSideBearing = t4.readShort(), this.xMaxExtent = t4.readShort(), this.caretSlopeRise = t4.readShort(), this.caretSlopeRun = t4.readShort(), this.caretOffset = t4.readShort(), t4.pos += 8, this.metricDataFormat = t4.readShort(), this.numberOfMetrics = t4.readUInt16();
    }, e2;
  }();
  le = function(t3) {
    function e2() {
      return e2.__super__.constructor.apply(this, arguments);
    }
    return oe(e2, re), e2.prototype.tag = "OS/2", e2.prototype.parse = function(t4) {
      if (t4.pos = this.offset, this.version = t4.readUInt16(), this.averageCharWidth = t4.readShort(), this.weightClass = t4.readUInt16(), this.widthClass = t4.readUInt16(), this.type = t4.readShort(), this.ySubscriptXSize = t4.readShort(), this.ySubscriptYSize = t4.readShort(), this.ySubscriptXOffset = t4.readShort(), this.ySubscriptYOffset = t4.readShort(), this.ySuperscriptXSize = t4.readShort(), this.ySuperscriptYSize = t4.readShort(), this.ySuperscriptXOffset = t4.readShort(), this.ySuperscriptYOffset = t4.readShort(), this.yStrikeoutSize = t4.readShort(), this.yStrikeoutPosition = t4.readShort(), this.familyClass = t4.readShort(), this.panose = function() {
        var e3, r2;
        for (r2 = [], e3 = 0;e3 < 10; ++e3)
          r2.push(t4.readByte());
        return r2;
      }(), this.charRange = function() {
        var e3, r2;
        for (r2 = [], e3 = 0;e3 < 4; ++e3)
          r2.push(t4.readInt());
        return r2;
      }(), this.vendorID = t4.readString(4), this.selection = t4.readShort(), this.firstCharIndex = t4.readShort(), this.lastCharIndex = t4.readShort(), this.version > 0 && (this.ascent = t4.readShort(), this.descent = t4.readShort(), this.lineGap = t4.readShort(), this.winAscent = t4.readShort(), this.winDescent = t4.readShort(), this.codePageRange = function() {
        var e3, r2;
        for (r2 = [], e3 = 0;e3 < 2; e3 = ++e3)
          r2.push(t4.readInt());
        return r2;
      }(), this.version > 1))
        return this.xHeight = t4.readShort(), this.capHeight = t4.readShort(), this.defaultChar = t4.readShort(), this.breakChar = t4.readShort(), this.maxContext = t4.readShort();
    }, e2;
  }();
  fe = function(t3) {
    function e2() {
      return e2.__super__.constructor.apply(this, arguments);
    }
    return oe(e2, re), e2.prototype.tag = "post", e2.prototype.parse = function(t4) {
      var e3, r2, n3;
      switch (t4.pos = this.offset, this.format = t4.readInt(), this.italicAngle = t4.readInt(), this.underlinePosition = t4.readShort(), this.underlineThickness = t4.readShort(), this.isFixedPitch = t4.readInt(), this.minMemType42 = t4.readInt(), this.maxMemType42 = t4.readInt(), this.minMemType1 = t4.readInt(), this.maxMemType1 = t4.readInt(), this.format) {
        case 65536:
          break;
        case 131072:
          var i5;
          for (r2 = t4.readUInt16(), this.glyphNameIndex = [], i5 = 0;0 <= r2 ? i5 < r2 : i5 > r2; i5 = 0 <= r2 ? ++i5 : --i5)
            this.glyphNameIndex.push(t4.readUInt16());
          for (this.names = [], n3 = [];t4.pos < this.offset + this.length; )
            e3 = t4.readByte(), n3.push(this.names.push(t4.readString(e3)));
          return n3;
        case 151552:
          return r2 = t4.readUInt16(), this.offsets = t4.read(r2);
        case 196608:
          break;
        case 262144:
          return this.map = function() {
            var e4, r3, n4;
            for (n4 = [], i5 = e4 = 0, r3 = this.file.maxp.numGlyphs;0 <= r3 ? e4 < r3 : e4 > r3; i5 = 0 <= r3 ? ++e4 : --e4)
              n4.push(t4.readUInt32());
            return n4;
          }.call(this);
      }
    }, e2;
  }();
  pe = function(t3) {
    function e2() {
      return e2.__super__.constructor.apply(this, arguments);
    }
    return oe(e2, re), e2.prototype.tag = "name", e2.prototype.parse = function(t4) {
      var e3, r2, n3, i5, a3, o3, s3, c4, u3, h3, l3;
      for (t4.pos = this.offset, t4.readShort(), e3 = t4.readShort(), o3 = t4.readShort(), r2 = [], i5 = 0;0 <= e3 ? i5 < e3 : i5 > e3; i5 = 0 <= e3 ? ++i5 : --i5)
        r2.push({ platformID: t4.readShort(), encodingID: t4.readShort(), languageID: t4.readShort(), nameID: t4.readShort(), length: t4.readShort(), offset: this.offset + o3 + t4.readShort() });
      for (s3 = {}, i5 = u3 = 0, h3 = r2.length;u3 < h3; i5 = ++u3)
        n3 = r2[i5], t4.pos = n3.offset, c4 = t4.readString(n3.length), a3 = new de(c4, n3), s3[l3 = n3.nameID] == null && (s3[l3] = []), s3[n3.nameID].push(a3);
      this.strings = s3, this.copyright = s3[0], this.fontFamily = s3[1], this.fontSubfamily = s3[2], this.uniqueSubfamily = s3[3], this.fontName = s3[4], this.version = s3[5];
      try {
        this.postscriptName = s3[6][0].raw.replace(/[\x00-\x19\x80-\xff]/g, "");
      } catch (t5) {
        this.postscriptName = s3[4][0].raw.replace(/[\x00-\x19\x80-\xff]/g, "");
      }
      return this.trademark = s3[7], this.manufacturer = s3[8], this.designer = s3[9], this.description = s3[10], this.vendorUrl = s3[11], this.designerUrl = s3[12], this.license = s3[13], this.licenseUrl = s3[14], this.preferredFamily = s3[15], this.preferredSubfamily = s3[17], this.compatibleFull = s3[18], this.sampleText = s3[19];
    }, e2;
  }();
  ge = function(t3) {
    function e2() {
      return e2.__super__.constructor.apply(this, arguments);
    }
    return oe(e2, re), e2.prototype.tag = "maxp", e2.prototype.parse = function(t4) {
      return t4.pos = this.offset, this.version = t4.readInt(), this.numGlyphs = t4.readUInt16(), this.maxPoints = t4.readUInt16(), this.maxContours = t4.readUInt16(), this.maxCompositePoints = t4.readUInt16(), this.maxComponentContours = t4.readUInt16(), this.maxZones = t4.readUInt16(), this.maxTwilightPoints = t4.readUInt16(), this.maxStorage = t4.readUInt16(), this.maxFunctionDefs = t4.readUInt16(), this.maxInstructionDefs = t4.readUInt16(), this.maxStackElements = t4.readUInt16(), this.maxSizeOfInstructions = t4.readUInt16(), this.maxComponentElements = t4.readUInt16(), this.maxComponentDepth = t4.readUInt16();
    }, e2;
  }();
  me = function(t3) {
    function e2() {
      return e2.__super__.constructor.apply(this, arguments);
    }
    return oe(e2, re), e2.prototype.tag = "hmtx", e2.prototype.parse = function(t4) {
      var e3, r2, n3, i5, a3, o3, s3;
      for (t4.pos = this.offset, this.metrics = [], e3 = 0, o3 = this.file.hhea.numberOfMetrics;0 <= o3 ? e3 < o3 : e3 > o3; e3 = 0 <= o3 ? ++e3 : --e3)
        this.metrics.push({ advance: t4.readUInt16(), lsb: t4.readInt16() });
      for (n3 = this.file.maxp.numGlyphs - this.file.hhea.numberOfMetrics, this.leftSideBearings = function() {
        var r3, i6;
        for (i6 = [], e3 = r3 = 0;0 <= n3 ? r3 < n3 : r3 > n3; e3 = 0 <= n3 ? ++r3 : --r3)
          i6.push(t4.readInt16());
        return i6;
      }(), this.widths = function() {
        var t5, e4, r3, n4;
        for (n4 = [], t5 = 0, e4 = (r3 = this.metrics).length;t5 < e4; t5++)
          i5 = r3[t5], n4.push(i5.advance);
        return n4;
      }.call(this), r2 = this.widths[this.widths.length - 1], s3 = [], e3 = a3 = 0;0 <= n3 ? a3 < n3 : a3 > n3; e3 = 0 <= n3 ? ++a3 : --a3)
        s3.push(this.widths.push(r2));
      return s3;
    }, e2.prototype.forGlyph = function(t4) {
      return t4 in this.metrics ? this.metrics[t4] : { advance: this.metrics[this.metrics.length - 1].advance, lsb: this.leftSideBearings[t4 - this.metrics.length] };
    }, e2;
  }();
  ve = [].slice;
  be = function(t3) {
    function e2() {
      return e2.__super__.constructor.apply(this, arguments);
    }
    return oe(e2, re), e2.prototype.tag = "glyf", e2.prototype.parse = function() {
      return this.cache = {};
    }, e2.prototype.glyphFor = function(t4) {
      var e3, r2, n3, i5, a3, o3, s3, c4, u3, h3;
      return t4 in this.cache ? this.cache[t4] : (i5 = this.file.loca, e3 = this.file.contents, r2 = i5.indexOf(t4), (n3 = i5.lengthOf(t4)) === 0 ? this.cache[t4] = null : (e3.pos = this.offset + r2, a3 = (o3 = new ne(e3.read(n3))).readShort(), c4 = o3.readShort(), h3 = o3.readShort(), s3 = o3.readShort(), u3 = o3.readShort(), this.cache[t4] = a3 === -1 ? new we(o3, c4, h3, s3, u3) : new ye(o3, a3, c4, h3, s3, u3), this.cache[t4]));
    }, e2.prototype.encode = function(t4, e3, r2) {
      var n3, i5, a3, o3, s3;
      for (a3 = [], i5 = [], o3 = 0, s3 = e3.length;o3 < s3; o3++)
        n3 = t4[e3[o3]], i5.push(a3.length), n3 && (a3 = a3.concat(n3.encode(r2)));
      return i5.push(a3.length), { table: a3, offsets: i5 };
    }, e2;
  }();
  ye = function() {
    function t3(t4, e2, r2, n3, i5, a3) {
      this.raw = t4, this.numberOfContours = e2, this.xMin = r2, this.yMin = n3, this.xMax = i5, this.yMax = a3, this.compound = false;
    }
    return t3.prototype.encode = function() {
      return this.raw.data;
    }, t3;
  }();
  we = function() {
    function t3(t4, e2, r2, n3, i5) {
      var a3, o3;
      for (this.raw = t4, this.xMin = e2, this.yMin = r2, this.xMax = n3, this.yMax = i5, this.compound = true, this.glyphIDs = [], this.glyphOffsets = [], a3 = this.raw;o3 = a3.readShort(), this.glyphOffsets.push(a3.pos), this.glyphIDs.push(a3.readUInt16()), 32 & o3; )
        a3.pos += 1 & o3 ? 4 : 2, 128 & o3 ? a3.pos += 8 : 64 & o3 ? a3.pos += 4 : 8 & o3 && (a3.pos += 2);
    }
    return 1, 8, 32, 64, 128, t3.prototype.encode = function() {
      var t4, e2, r2;
      for (e2 = new ne(ve.call(this.raw.data)), t4 = 0, r2 = this.glyphIDs.length;t4 < r2; ++t4)
        e2.pos = this.glyphOffsets[t4];
      return e2.data;
    }, t3;
  }();
  Ne = function(t3) {
    function e2() {
      return e2.__super__.constructor.apply(this, arguments);
    }
    return oe(e2, re), e2.prototype.tag = "loca", e2.prototype.parse = function(t4) {
      var e3, r2;
      return t4.pos = this.offset, e3 = this.file.head.indexToLocFormat, this.offsets = e3 === 0 ? function() {
        var e4, n3;
        for (n3 = [], r2 = 0, e4 = this.length;r2 < e4; r2 += 2)
          n3.push(2 * t4.readUInt16());
        return n3;
      }.call(this) : function() {
        var e4, n3;
        for (n3 = [], r2 = 0, e4 = this.length;r2 < e4; r2 += 4)
          n3.push(t4.readUInt32());
        return n3;
      }.call(this);
    }, e2.prototype.indexOf = function(t4) {
      return this.offsets[t4];
    }, e2.prototype.lengthOf = function(t4) {
      return this.offsets[t4 + 1] - this.offsets[t4];
    }, e2.prototype.encode = function(t4, e3) {
      for (var r2 = new Uint32Array(this.offsets.length), n3 = 0, i5 = 0, a3 = 0;a3 < r2.length; ++a3)
        if (r2[a3] = n3, i5 < e3.length && e3[i5] == a3) {
          ++i5, r2[a3] = n3;
          var o3 = this.offsets[a3], s3 = this.offsets[a3 + 1] - o3;
          s3 > 0 && (n3 += s3);
        }
      for (var c4 = new Array(4 * r2.length), u3 = 0;u3 < r2.length; ++u3)
        c4[4 * u3 + 3] = 255 & r2[u3], c4[4 * u3 + 2] = (65280 & r2[u3]) >> 8, c4[4 * u3 + 1] = (16711680 & r2[u3]) >> 16, c4[4 * u3] = (4278190080 & r2[u3]) >> 24;
      return c4;
    }, e2;
  }();
  Le = function() {
    function t3(t4) {
      this.font = t4, this.subset = {}, this.unicodes = {}, this.next = 33;
    }
    return t3.prototype.generateCmap = function() {
      var t4, e2, r2, n3, i5;
      for (e2 in n3 = this.font.cmap.tables[0].codeMap, t4 = {}, i5 = this.subset)
        r2 = i5[e2], t4[e2] = n3[r2];
      return t4;
    }, t3.prototype.glyphsFor = function(t4) {
      var e2, r2, n3, i5, a3, o3, s3;
      for (n3 = {}, a3 = 0, o3 = t4.length;a3 < o3; a3++)
        n3[i5 = t4[a3]] = this.font.glyf.glyphFor(i5);
      for (i5 in e2 = [], n3)
        ((r2 = n3[i5]) != null ? r2.compound : undefined) && e2.push.apply(e2, r2.glyphIDs);
      if (e2.length > 0)
        for (i5 in s3 = this.glyphsFor(e2))
          r2 = s3[i5], n3[i5] = r2;
      return n3;
    }, t3.prototype.encode = function(t4, e2) {
      var r2, n3, i5, a3, o3, s3, c4, u3, h3, l3, f3, d2, p3, g2, m4;
      for (n3 in r2 = ue.encode(this.generateCmap(), "unicode"), a3 = this.glyphsFor(t4), f3 = { 0: 0 }, m4 = r2.charMap)
        f3[(s3 = m4[n3]).old] = s3.new;
      for (d2 in l3 = r2.maxGlyphID, a3)
        d2 in f3 || (f3[d2] = l3++);
      return u3 = function(t5) {
        var e3, r3;
        for (e3 in r3 = {}, t5)
          r3[t5[e3]] = e3;
        return r3;
      }(f3), h3 = Object.keys(u3).sort(function(t5, e3) {
        return t5 - e3;
      }), p3 = function() {
        var t5, e3, r3;
        for (r3 = [], t5 = 0, e3 = h3.length;t5 < e3; t5++)
          o3 = h3[t5], r3.push(u3[o3]);
        return r3;
      }(), i5 = this.font.glyf.encode(a3, p3, f3), c4 = this.font.loca.encode(i5.offsets, p3), g2 = { cmap: this.font.cmap.raw(), glyf: i5.table, loca: c4, hmtx: this.font.hmtx.raw(), hhea: this.font.hhea.raw(), maxp: this.font.maxp.raw(), post: this.font.post.raw(), name: this.font.name.raw(), head: this.font.head.encode(e2) }, this.font.os2.exists && (g2["OS/2"] = this.font.os2.raw()), this.font.directory.encode(g2);
    }, t3;
  }();
  E.API.PDFObject = function() {
    var t3;
    function e2() {}
    return t3 = function(t4, e3) {
      return (Array(e3 + 1).join("0") + t4).slice(-e3);
    }, e2.convert = function(r2) {
      var n3, i5, a3, o3;
      if (Array.isArray(r2))
        return "[" + function() {
          var t4, i6, a4;
          for (a4 = [], t4 = 0, i6 = r2.length;t4 < i6; t4++)
            n3 = r2[t4], a4.push(e2.convert(n3));
          return a4;
        }().join(" ") + "]";
      if (typeof r2 == "string")
        return "/" + r2;
      if (r2 != null ? r2.isString : undefined)
        return "(" + r2 + ")";
      if (r2 instanceof Date)
        return "(D:" + t3(r2.getUTCFullYear(), 4) + t3(r2.getUTCMonth(), 2) + t3(r2.getUTCDate(), 2) + t3(r2.getUTCHours(), 2) + t3(r2.getUTCMinutes(), 2) + t3(r2.getUTCSeconds(), 2) + "Z)";
      if ({}.toString.call(r2) === "[object Object]") {
        for (i5 in a3 = ["<<"], r2)
          o3 = r2[i5], a3.push("/" + i5 + " " + e2.convert(o3));
        return a3.push(">>"), a3.join(`
`);
      }
      return "" + r2;
    }, e2;
  }();
  jspdf_es_min_default = E;
});

// node_modules/orderedmap/dist/index.js
function OrderedMap(content) {
  this.content = content;
}
OrderedMap.prototype = {
  constructor: OrderedMap,
  find: function(key) {
    for (var i = 0;i < this.content.length; i += 2)
      if (this.content[i] === key)
        return i;
    return -1;
  },
  get: function(key) {
    var found = this.find(key);
    return found == -1 ? undefined : this.content[found + 1];
  },
  update: function(key, value, newKey) {
    var self2 = newKey && newKey != key ? this.remove(newKey) : this;
    var found = self2.find(key), content = self2.content.slice();
    if (found == -1) {
      content.push(newKey || key, value);
    } else {
      content[found + 1] = value;
      if (newKey)
        content[found] = newKey;
    }
    return new OrderedMap(content);
  },
  remove: function(key) {
    var found = this.find(key);
    if (found == -1)
      return this;
    var content = this.content.slice();
    content.splice(found, 2);
    return new OrderedMap(content);
  },
  addToStart: function(key, value) {
    return new OrderedMap([key, value].concat(this.remove(key).content));
  },
  addToEnd: function(key, value) {
    var content = this.remove(key).content.slice();
    content.push(key, value);
    return new OrderedMap(content);
  },
  addBefore: function(place, key, value) {
    var without = this.remove(key), content = without.content.slice();
    var found = without.find(place);
    content.splice(found == -1 ? content.length : found, 0, key, value);
    return new OrderedMap(content);
  },
  forEach: function(f) {
    for (var i = 0;i < this.content.length; i += 2)
      f(this.content[i], this.content[i + 1]);
  },
  prepend: function(map) {
    map = OrderedMap.from(map);
    if (!map.size)
      return this;
    return new OrderedMap(map.content.concat(this.subtract(map).content));
  },
  append: function(map) {
    map = OrderedMap.from(map);
    if (!map.size)
      return this;
    return new OrderedMap(this.subtract(map).content.concat(map.content));
  },
  subtract: function(map) {
    var result = this;
    map = OrderedMap.from(map);
    for (var i = 0;i < map.content.length; i += 2)
      result = result.remove(map.content[i]);
    return result;
  },
  toObject: function() {
    var result = {};
    this.forEach(function(key, value) {
      result[key] = value;
    });
    return result;
  },
  get size() {
    return this.content.length >> 1;
  }
};
OrderedMap.from = function(value) {
  if (value instanceof OrderedMap)
    return value;
  var content = [];
  if (value)
    for (var prop in value)
      content.push(prop, value[prop]);
  return new OrderedMap(content);
};
var dist_default = OrderedMap;

// node_modules/prosemirror-model/dist/index.js
function findDiffStart(a, b, pos) {
  for (let i = 0;; i++) {
    if (i == a.childCount || i == b.childCount)
      return a.childCount == b.childCount ? null : pos;
    let childA = a.child(i), childB = b.child(i);
    if (childA == childB) {
      pos += childA.nodeSize;
      continue;
    }
    if (!childA.sameMarkup(childB))
      return pos;
    if (childA.isText && childA.text != childB.text) {
      for (let j = 0;childA.text[j] == childB.text[j]; j++)
        pos++;
      return pos;
    }
    if (childA.content.size || childB.content.size) {
      let inner = findDiffStart(childA.content, childB.content, pos + 1);
      if (inner != null)
        return inner;
    }
    pos += childA.nodeSize;
  }
}
function findDiffEnd(a, b, posA, posB) {
  for (let iA = a.childCount, iB = b.childCount;; ) {
    if (iA == 0 || iB == 0)
      return iA == iB ? null : { a: posA, b: posB };
    let childA = a.child(--iA), childB = b.child(--iB), size = childA.nodeSize;
    if (childA == childB) {
      posA -= size;
      posB -= size;
      continue;
    }
    if (!childA.sameMarkup(childB))
      return { a: posA, b: posB };
    if (childA.isText && childA.text != childB.text) {
      let same = 0, minSize = Math.min(childA.text.length, childB.text.length);
      while (same < minSize && childA.text[childA.text.length - same - 1] == childB.text[childB.text.length - same - 1]) {
        same++;
        posA--;
        posB--;
      }
      return { a: posA, b: posB };
    }
    if (childA.content.size || childB.content.size) {
      let inner = findDiffEnd(childA.content, childB.content, posA - 1, posB - 1);
      if (inner)
        return inner;
    }
    posA -= size;
    posB -= size;
  }
}

class Fragment {
  constructor(content, size) {
    this.content = content;
    this.size = size || 0;
    if (size == null)
      for (let i = 0;i < content.length; i++)
        this.size += content[i].nodeSize;
  }
  nodesBetween(from, to, f, nodeStart = 0, parent) {
    for (let i = 0, pos = 0;pos < to; i++) {
      let child = this.content[i], end = pos + child.nodeSize;
      if (end > from && f(child, nodeStart + pos, parent || null, i) !== false && child.content.size) {
        let start = pos + 1;
        child.nodesBetween(Math.max(0, from - start), Math.min(child.content.size, to - start), f, nodeStart + start);
      }
      pos = end;
    }
  }
  descendants(f) {
    this.nodesBetween(0, this.size, f);
  }
  textBetween(from, to, blockSeparator, leafText) {
    let text = "", first = true;
    this.nodesBetween(from, to, (node, pos) => {
      let nodeText = node.isText ? node.text.slice(Math.max(from, pos) - pos, to - pos) : !node.isLeaf ? "" : leafText ? typeof leafText === "function" ? leafText(node) : leafText : node.type.spec.leafText ? node.type.spec.leafText(node) : "";
      if (node.isBlock && (node.isLeaf && nodeText || node.isTextblock) && blockSeparator) {
        if (first)
          first = false;
        else
          text += blockSeparator;
      }
      text += nodeText;
    }, 0);
    return text;
  }
  append(other) {
    if (!other.size)
      return this;
    if (!this.size)
      return other;
    let last = this.lastChild, first = other.firstChild, content = this.content.slice(), i = 0;
    if (last.isText && last.sameMarkup(first)) {
      content[content.length - 1] = last.withText(last.text + first.text);
      i = 1;
    }
    for (;i < other.content.length; i++)
      content.push(other.content[i]);
    return new Fragment(content, this.size + other.size);
  }
  cut(from, to = this.size) {
    if (from == 0 && to == this.size)
      return this;
    let result = [], size = 0;
    if (to > from)
      for (let i = 0, pos = 0;pos < to; i++) {
        let child = this.content[i], end = pos + child.nodeSize;
        if (end > from) {
          if (pos < from || end > to) {
            if (child.isText)
              child = child.cut(Math.max(0, from - pos), Math.min(child.text.length, to - pos));
            else
              child = child.cut(Math.max(0, from - pos - 1), Math.min(child.content.size, to - pos - 1));
          }
          result.push(child);
          size += child.nodeSize;
        }
        pos = end;
      }
    return new Fragment(result, size);
  }
  cutByIndex(from, to) {
    if (from == to)
      return Fragment.empty;
    if (from == 0 && to == this.content.length)
      return this;
    return new Fragment(this.content.slice(from, to));
  }
  replaceChild(index, node) {
    let current = this.content[index];
    if (current == node)
      return this;
    let copy = this.content.slice();
    let size = this.size + node.nodeSize - current.nodeSize;
    copy[index] = node;
    return new Fragment(copy, size);
  }
  addToStart(node) {
    return new Fragment([node].concat(this.content), this.size + node.nodeSize);
  }
  addToEnd(node) {
    return new Fragment(this.content.concat(node), this.size + node.nodeSize);
  }
  eq(other) {
    if (this.content.length != other.content.length)
      return false;
    for (let i = 0;i < this.content.length; i++)
      if (!this.content[i].eq(other.content[i]))
        return false;
    return true;
  }
  get firstChild() {
    return this.content.length ? this.content[0] : null;
  }
  get lastChild() {
    return this.content.length ? this.content[this.content.length - 1] : null;
  }
  get childCount() {
    return this.content.length;
  }
  child(index) {
    let found = this.content[index];
    if (!found)
      throw new RangeError("Index " + index + " out of range for " + this);
    return found;
  }
  maybeChild(index) {
    return this.content[index] || null;
  }
  forEach(f) {
    for (let i = 0, p = 0;i < this.content.length; i++) {
      let child = this.content[i];
      f(child, p, i);
      p += child.nodeSize;
    }
  }
  findDiffStart(other, pos = 0) {
    return findDiffStart(this, other, pos);
  }
  findDiffEnd(other, pos = this.size, otherPos = other.size) {
    return findDiffEnd(this, other, pos, otherPos);
  }
  findIndex(pos) {
    if (pos == 0)
      return retIndex(0, pos);
    if (pos == this.size)
      return retIndex(this.content.length, pos);
    if (pos > this.size || pos < 0)
      throw new RangeError(`Position ${pos} outside of fragment (${this})`);
    for (let i = 0, curPos = 0;; i++) {
      let cur = this.child(i), end = curPos + cur.nodeSize;
      if (end >= pos) {
        if (end == pos)
          return retIndex(i + 1, end);
        return retIndex(i, curPos);
      }
      curPos = end;
    }
  }
  toString() {
    return "<" + this.toStringInner() + ">";
  }
  toStringInner() {
    return this.content.join(", ");
  }
  toJSON() {
    return this.content.length ? this.content.map((n) => n.toJSON()) : null;
  }
  static fromJSON(schema, value) {
    if (!value)
      return Fragment.empty;
    if (!Array.isArray(value))
      throw new RangeError("Invalid input for Fragment.fromJSON");
    return new Fragment(value.map(schema.nodeFromJSON));
  }
  static fromArray(array) {
    if (!array.length)
      return Fragment.empty;
    let joined, size = 0;
    for (let i = 0;i < array.length; i++) {
      let node = array[i];
      size += node.nodeSize;
      if (i && node.isText && array[i - 1].sameMarkup(node)) {
        if (!joined)
          joined = array.slice(0, i);
        joined[joined.length - 1] = node.withText(joined[joined.length - 1].text + node.text);
      } else if (joined) {
        joined.push(node);
      }
    }
    return new Fragment(joined || array, size);
  }
  static from(nodes) {
    if (!nodes)
      return Fragment.empty;
    if (nodes instanceof Fragment)
      return nodes;
    if (Array.isArray(nodes))
      return this.fromArray(nodes);
    if (nodes.attrs)
      return new Fragment([nodes], nodes.nodeSize);
    throw new RangeError("Can not convert " + nodes + " to a Fragment" + (nodes.nodesBetween ? " (looks like multiple versions of prosemirror-model were loaded)" : ""));
  }
}
Fragment.empty = new Fragment([], 0);
var found = { index: 0, offset: 0 };
function retIndex(index, offset) {
  found.index = index;
  found.offset = offset;
  return found;
}
function compareDeep(a, b) {
  if (a === b)
    return true;
  if (!(a && typeof a == "object") || !(b && typeof b == "object"))
    return false;
  let array = Array.isArray(a);
  if (Array.isArray(b) != array)
    return false;
  if (array) {
    if (a.length != b.length)
      return false;
    for (let i = 0;i < a.length; i++)
      if (!compareDeep(a[i], b[i]))
        return false;
  } else {
    for (let p in a)
      if (!(p in b) || !compareDeep(a[p], b[p]))
        return false;
    for (let p in b)
      if (!(p in a))
        return false;
  }
  return true;
}

class Mark {
  constructor(type, attrs) {
    this.type = type;
    this.attrs = attrs;
  }
  addToSet(set) {
    let copy, placed = false;
    for (let i = 0;i < set.length; i++) {
      let other = set[i];
      if (this.eq(other))
        return set;
      if (this.type.excludes(other.type)) {
        if (!copy)
          copy = set.slice(0, i);
      } else if (other.type.excludes(this.type)) {
        return set;
      } else {
        if (!placed && other.type.rank > this.type.rank) {
          if (!copy)
            copy = set.slice(0, i);
          copy.push(this);
          placed = true;
        }
        if (copy)
          copy.push(other);
      }
    }
    if (!copy)
      copy = set.slice();
    if (!placed)
      copy.push(this);
    return copy;
  }
  removeFromSet(set) {
    for (let i = 0;i < set.length; i++)
      if (this.eq(set[i]))
        return set.slice(0, i).concat(set.slice(i + 1));
    return set;
  }
  isInSet(set) {
    for (let i = 0;i < set.length; i++)
      if (this.eq(set[i]))
        return true;
    return false;
  }
  eq(other) {
    return this == other || this.type == other.type && compareDeep(this.attrs, other.attrs);
  }
  toJSON() {
    let obj = { type: this.type.name };
    for (let _ in this.attrs) {
      obj.attrs = this.attrs;
      break;
    }
    return obj;
  }
  static fromJSON(schema, json) {
    if (!json)
      throw new RangeError("Invalid input for Mark.fromJSON");
    let type = schema.marks[json.type];
    if (!type)
      throw new RangeError(`There is no mark type ${json.type} in this schema`);
    let mark = type.create(json.attrs);
    type.checkAttrs(mark.attrs);
    return mark;
  }
  static sameSet(a, b) {
    if (a == b)
      return true;
    if (a.length != b.length)
      return false;
    for (let i = 0;i < a.length; i++)
      if (!a[i].eq(b[i]))
        return false;
    return true;
  }
  static setFrom(marks) {
    if (!marks || Array.isArray(marks) && marks.length == 0)
      return Mark.none;
    if (marks instanceof Mark)
      return [marks];
    let copy = marks.slice();
    copy.sort((a, b) => a.type.rank - b.type.rank);
    return copy;
  }
}
Mark.none = [];

class ReplaceError extends Error {
}

class Slice {
  constructor(content, openStart, openEnd) {
    this.content = content;
    this.openStart = openStart;
    this.openEnd = openEnd;
  }
  get size() {
    return this.content.size - this.openStart - this.openEnd;
  }
  insertAt(pos, fragment) {
    let content = insertInto(this.content, pos + this.openStart, fragment);
    return content && new Slice(content, this.openStart, this.openEnd);
  }
  removeBetween(from, to) {
    return new Slice(removeRange(this.content, from + this.openStart, to + this.openStart), this.openStart, this.openEnd);
  }
  eq(other) {
    return this.content.eq(other.content) && this.openStart == other.openStart && this.openEnd == other.openEnd;
  }
  toString() {
    return this.content + "(" + this.openStart + "," + this.openEnd + ")";
  }
  toJSON() {
    if (!this.content.size)
      return null;
    let json = { content: this.content.toJSON() };
    if (this.openStart > 0)
      json.openStart = this.openStart;
    if (this.openEnd > 0)
      json.openEnd = this.openEnd;
    return json;
  }
  static fromJSON(schema, json) {
    if (!json)
      return Slice.empty;
    let openStart = json.openStart || 0, openEnd = json.openEnd || 0;
    if (typeof openStart != "number" || typeof openEnd != "number")
      throw new RangeError("Invalid input for Slice.fromJSON");
    return new Slice(Fragment.fromJSON(schema, json.content), openStart, openEnd);
  }
  static maxOpen(fragment, openIsolating = true) {
    let openStart = 0, openEnd = 0;
    for (let n = fragment.firstChild;n && !n.isLeaf && (openIsolating || !n.type.spec.isolating); n = n.firstChild)
      openStart++;
    for (let n = fragment.lastChild;n && !n.isLeaf && (openIsolating || !n.type.spec.isolating); n = n.lastChild)
      openEnd++;
    return new Slice(fragment, openStart, openEnd);
  }
}
Slice.empty = new Slice(Fragment.empty, 0, 0);
function removeRange(content, from, to) {
  let { index, offset } = content.findIndex(from), child = content.maybeChild(index);
  let { index: indexTo, offset: offsetTo } = content.findIndex(to);
  if (offset == from || child.isText) {
    if (offsetTo != to && !content.child(indexTo).isText)
      throw new RangeError("Removing non-flat range");
    return content.cut(0, from).append(content.cut(to));
  }
  if (index != indexTo)
    throw new RangeError("Removing non-flat range");
  return content.replaceChild(index, child.copy(removeRange(child.content, from - offset - 1, to - offset - 1)));
}
function insertInto(content, dist, insert, parent) {
  let { index, offset } = content.findIndex(dist), child = content.maybeChild(index);
  if (offset == dist || child.isText) {
    if (parent && !parent.canReplace(index, index, insert))
      return null;
    return content.cut(0, dist).append(insert).append(content.cut(dist));
  }
  let inner = insertInto(child.content, dist - offset - 1, insert, child);
  return inner && content.replaceChild(index, child.copy(inner));
}
function replace($from, $to, slice) {
  if (slice.openStart > $from.depth)
    throw new ReplaceError("Inserted content deeper than insertion position");
  if ($from.depth - slice.openStart != $to.depth - slice.openEnd)
    throw new ReplaceError("Inconsistent open depths");
  return replaceOuter($from, $to, slice, 0);
}
function replaceOuter($from, $to, slice, depth) {
  let index = $from.index(depth), node = $from.node(depth);
  if (index == $to.index(depth) && depth < $from.depth - slice.openStart) {
    let inner = replaceOuter($from, $to, slice, depth + 1);
    return node.copy(node.content.replaceChild(index, inner));
  } else if (!slice.content.size) {
    return close(node, replaceTwoWay($from, $to, depth));
  } else if (!slice.openStart && !slice.openEnd && $from.depth == depth && $to.depth == depth) {
    let parent = $from.parent, content = parent.content;
    return close(parent, content.cut(0, $from.parentOffset).append(slice.content).append(content.cut($to.parentOffset)));
  } else {
    let { start, end } = prepareSliceForReplace(slice, $from);
    return close(node, replaceThreeWay($from, start, end, $to, depth));
  }
}
function checkJoin(main, sub) {
  if (!sub.type.compatibleContent(main.type))
    throw new ReplaceError("Cannot join " + sub.type.name + " onto " + main.type.name);
}
function joinable($before, $after, depth) {
  let node = $before.node(depth);
  checkJoin(node, $after.node(depth));
  return node;
}
function addNode(child, target) {
  let last = target.length - 1;
  if (last >= 0 && child.isText && child.sameMarkup(target[last]))
    target[last] = child.withText(target[last].text + child.text);
  else
    target.push(child);
}
function addRange($start, $end, depth, target) {
  let node = ($end || $start).node(depth);
  let startIndex = 0, endIndex = $end ? $end.index(depth) : node.childCount;
  if ($start) {
    startIndex = $start.index(depth);
    if ($start.depth > depth) {
      startIndex++;
    } else if ($start.textOffset) {
      addNode($start.nodeAfter, target);
      startIndex++;
    }
  }
  for (let i = startIndex;i < endIndex; i++)
    addNode(node.child(i), target);
  if ($end && $end.depth == depth && $end.textOffset)
    addNode($end.nodeBefore, target);
}
function close(node, content) {
  node.type.checkContent(content);
  return node.copy(content);
}
function replaceThreeWay($from, $start, $end, $to, depth) {
  let openStart = $from.depth > depth && joinable($from, $start, depth + 1);
  let openEnd = $to.depth > depth && joinable($end, $to, depth + 1);
  let content = [];
  addRange(null, $from, depth, content);
  if (openStart && openEnd && $start.index(depth) == $end.index(depth)) {
    checkJoin(openStart, openEnd);
    addNode(close(openStart, replaceThreeWay($from, $start, $end, $to, depth + 1)), content);
  } else {
    if (openStart)
      addNode(close(openStart, replaceTwoWay($from, $start, depth + 1)), content);
    addRange($start, $end, depth, content);
    if (openEnd)
      addNode(close(openEnd, replaceTwoWay($end, $to, depth + 1)), content);
  }
  addRange($to, null, depth, content);
  return new Fragment(content);
}
function replaceTwoWay($from, $to, depth) {
  let content = [];
  addRange(null, $from, depth, content);
  if ($from.depth > depth) {
    let type = joinable($from, $to, depth + 1);
    addNode(close(type, replaceTwoWay($from, $to, depth + 1)), content);
  }
  addRange($to, null, depth, content);
  return new Fragment(content);
}
function prepareSliceForReplace(slice, $along) {
  let extra = $along.depth - slice.openStart, parent = $along.node(extra);
  let node = parent.copy(slice.content);
  for (let i = extra - 1;i >= 0; i--)
    node = $along.node(i).copy(Fragment.from(node));
  return {
    start: node.resolveNoCache(slice.openStart + extra),
    end: node.resolveNoCache(node.content.size - slice.openEnd - extra)
  };
}

class ResolvedPos {
  constructor(pos, path, parentOffset) {
    this.pos = pos;
    this.path = path;
    this.parentOffset = parentOffset;
    this.depth = path.length / 3 - 1;
  }
  resolveDepth(val) {
    if (val == null)
      return this.depth;
    if (val < 0)
      return this.depth + val;
    return val;
  }
  get parent() {
    return this.node(this.depth);
  }
  get doc() {
    return this.node(0);
  }
  node(depth) {
    return this.path[this.resolveDepth(depth) * 3];
  }
  index(depth) {
    return this.path[this.resolveDepth(depth) * 3 + 1];
  }
  indexAfter(depth) {
    depth = this.resolveDepth(depth);
    return this.index(depth) + (depth == this.depth && !this.textOffset ? 0 : 1);
  }
  start(depth) {
    depth = this.resolveDepth(depth);
    return depth == 0 ? 0 : this.path[depth * 3 - 1] + 1;
  }
  end(depth) {
    depth = this.resolveDepth(depth);
    return this.start(depth) + this.node(depth).content.size;
  }
  before(depth) {
    depth = this.resolveDepth(depth);
    if (!depth)
      throw new RangeError("There is no position before the top-level node");
    return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1];
  }
  after(depth) {
    depth = this.resolveDepth(depth);
    if (!depth)
      throw new RangeError("There is no position after the top-level node");
    return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1] + this.path[depth * 3].nodeSize;
  }
  get textOffset() {
    return this.pos - this.path[this.path.length - 1];
  }
  get nodeAfter() {
    let parent = this.parent, index = this.index(this.depth);
    if (index == parent.childCount)
      return null;
    let dOff = this.pos - this.path[this.path.length - 1], child = parent.child(index);
    return dOff ? parent.child(index).cut(dOff) : child;
  }
  get nodeBefore() {
    let index = this.index(this.depth);
    let dOff = this.pos - this.path[this.path.length - 1];
    if (dOff)
      return this.parent.child(index).cut(0, dOff);
    return index == 0 ? null : this.parent.child(index - 1);
  }
  posAtIndex(index, depth) {
    depth = this.resolveDepth(depth);
    let node = this.path[depth * 3], pos = depth == 0 ? 0 : this.path[depth * 3 - 1] + 1;
    for (let i = 0;i < index; i++)
      pos += node.child(i).nodeSize;
    return pos;
  }
  marks() {
    let parent = this.parent, index = this.index();
    if (parent.content.size == 0)
      return Mark.none;
    if (this.textOffset)
      return parent.child(index).marks;
    let main = parent.maybeChild(index - 1), other = parent.maybeChild(index);
    if (!main) {
      let tmp = main;
      main = other;
      other = tmp;
    }
    let marks = main.marks;
    for (var i = 0;i < marks.length; i++)
      if (marks[i].type.spec.inclusive === false && (!other || !marks[i].isInSet(other.marks)))
        marks = marks[i--].removeFromSet(marks);
    return marks;
  }
  marksAcross($end) {
    let after = this.parent.maybeChild(this.index());
    if (!after || !after.isInline)
      return null;
    let marks = after.marks, next = $end.parent.maybeChild($end.index());
    for (var i = 0;i < marks.length; i++)
      if (marks[i].type.spec.inclusive === false && (!next || !marks[i].isInSet(next.marks)))
        marks = marks[i--].removeFromSet(marks);
    return marks;
  }
  sharedDepth(pos) {
    for (let depth = this.depth;depth > 0; depth--)
      if (this.start(depth) <= pos && this.end(depth) >= pos)
        return depth;
    return 0;
  }
  blockRange(other = this, pred) {
    if (other.pos < this.pos)
      return other.blockRange(this);
    for (let d = this.depth - (this.parent.inlineContent || this.pos == other.pos ? 1 : 0);d >= 0; d--)
      if (other.pos <= this.end(d) && (!pred || pred(this.node(d))))
        return new NodeRange(this, other, d);
    return null;
  }
  sameParent(other) {
    return this.pos - this.parentOffset == other.pos - other.parentOffset;
  }
  max(other) {
    return other.pos > this.pos ? other : this;
  }
  min(other) {
    return other.pos < this.pos ? other : this;
  }
  toString() {
    let str = "";
    for (let i = 1;i <= this.depth; i++)
      str += (str ? "/" : "") + this.node(i).type.name + "_" + this.index(i - 1);
    return str + ":" + this.parentOffset;
  }
  static resolve(doc, pos) {
    if (!(pos >= 0 && pos <= doc.content.size))
      throw new RangeError("Position " + pos + " out of range");
    let path = [];
    let start = 0, parentOffset = pos;
    for (let node = doc;; ) {
      let { index, offset } = node.content.findIndex(parentOffset);
      let rem = parentOffset - offset;
      path.push(node, index, start + offset);
      if (!rem)
        break;
      node = node.child(index);
      if (node.isText)
        break;
      parentOffset = rem - 1;
      start += offset + 1;
    }
    return new ResolvedPos(pos, path, parentOffset);
  }
  static resolveCached(doc, pos) {
    let cache = resolveCache.get(doc);
    if (cache) {
      for (let i = 0;i < cache.elts.length; i++) {
        let elt = cache.elts[i];
        if (elt.pos == pos)
          return elt;
      }
    } else {
      resolveCache.set(doc, cache = new ResolveCache);
    }
    let result = cache.elts[cache.i] = ResolvedPos.resolve(doc, pos);
    cache.i = (cache.i + 1) % resolveCacheSize;
    return result;
  }
}

class ResolveCache {
  constructor() {
    this.elts = [];
    this.i = 0;
  }
}
var resolveCacheSize = 12;
var resolveCache = new WeakMap;

class NodeRange {
  constructor($from, $to, depth) {
    this.$from = $from;
    this.$to = $to;
    this.depth = depth;
  }
  get start() {
    return this.$from.before(this.depth + 1);
  }
  get end() {
    return this.$to.after(this.depth + 1);
  }
  get parent() {
    return this.$from.node(this.depth);
  }
  get startIndex() {
    return this.$from.index(this.depth);
  }
  get endIndex() {
    return this.$to.indexAfter(this.depth);
  }
}
var emptyAttrs = Object.create(null);

class Node2 {
  constructor(type, attrs, content, marks = Mark.none) {
    this.type = type;
    this.attrs = attrs;
    this.marks = marks;
    this.content = content || Fragment.empty;
  }
  get children() {
    return this.content.content;
  }
  get nodeSize() {
    return this.isLeaf ? 1 : 2 + this.content.size;
  }
  get childCount() {
    return this.content.childCount;
  }
  child(index) {
    return this.content.child(index);
  }
  maybeChild(index) {
    return this.content.maybeChild(index);
  }
  forEach(f) {
    this.content.forEach(f);
  }
  nodesBetween(from, to, f, startPos = 0) {
    this.content.nodesBetween(from, to, f, startPos, this);
  }
  descendants(f) {
    this.nodesBetween(0, this.content.size, f);
  }
  get textContent() {
    return this.isLeaf && this.type.spec.leafText ? this.type.spec.leafText(this) : this.textBetween(0, this.content.size, "");
  }
  textBetween(from, to, blockSeparator, leafText) {
    return this.content.textBetween(from, to, blockSeparator, leafText);
  }
  get firstChild() {
    return this.content.firstChild;
  }
  get lastChild() {
    return this.content.lastChild;
  }
  eq(other) {
    return this == other || this.sameMarkup(other) && this.content.eq(other.content);
  }
  sameMarkup(other) {
    return this.hasMarkup(other.type, other.attrs, other.marks);
  }
  hasMarkup(type, attrs, marks) {
    return this.type == type && compareDeep(this.attrs, attrs || type.defaultAttrs || emptyAttrs) && Mark.sameSet(this.marks, marks || Mark.none);
  }
  copy(content = null) {
    if (content == this.content)
      return this;
    return new Node2(this.type, this.attrs, content, this.marks);
  }
  mark(marks) {
    return marks == this.marks ? this : new Node2(this.type, this.attrs, this.content, marks);
  }
  cut(from, to = this.content.size) {
    if (from == 0 && to == this.content.size)
      return this;
    return this.copy(this.content.cut(from, to));
  }
  slice(from, to = this.content.size, includeParents = false) {
    if (from == to)
      return Slice.empty;
    let $from = this.resolve(from), $to = this.resolve(to);
    let depth = includeParents ? 0 : $from.sharedDepth(to);
    let start = $from.start(depth), node = $from.node(depth);
    let content = node.content.cut($from.pos - start, $to.pos - start);
    return new Slice(content, $from.depth - depth, $to.depth - depth);
  }
  replace(from, to, slice) {
    return replace(this.resolve(from), this.resolve(to), slice);
  }
  nodeAt(pos) {
    for (let node = this;; ) {
      let { index, offset } = node.content.findIndex(pos);
      node = node.maybeChild(index);
      if (!node)
        return null;
      if (offset == pos || node.isText)
        return node;
      pos -= offset + 1;
    }
  }
  childAfter(pos) {
    let { index, offset } = this.content.findIndex(pos);
    return { node: this.content.maybeChild(index), index, offset };
  }
  childBefore(pos) {
    if (pos == 0)
      return { node: null, index: 0, offset: 0 };
    let { index, offset } = this.content.findIndex(pos);
    if (offset < pos)
      return { node: this.content.child(index), index, offset };
    let node = this.content.child(index - 1);
    return { node, index: index - 1, offset: offset - node.nodeSize };
  }
  resolve(pos) {
    return ResolvedPos.resolveCached(this, pos);
  }
  resolveNoCache(pos) {
    return ResolvedPos.resolve(this, pos);
  }
  rangeHasMark(from, to, type) {
    let found2 = false;
    if (to > from)
      this.nodesBetween(from, to, (node) => {
        if (type.isInSet(node.marks))
          found2 = true;
        return !found2;
      });
    return found2;
  }
  get isBlock() {
    return this.type.isBlock;
  }
  get isTextblock() {
    return this.type.isTextblock;
  }
  get inlineContent() {
    return this.type.inlineContent;
  }
  get isInline() {
    return this.type.isInline;
  }
  get isText() {
    return this.type.isText;
  }
  get isLeaf() {
    return this.type.isLeaf;
  }
  get isAtom() {
    return this.type.isAtom;
  }
  toString() {
    if (this.type.spec.toDebugString)
      return this.type.spec.toDebugString(this);
    let name = this.type.name;
    if (this.content.size)
      name += "(" + this.content.toStringInner() + ")";
    return wrapMarks(this.marks, name);
  }
  contentMatchAt(index) {
    let match = this.type.contentMatch.matchFragment(this.content, 0, index);
    if (!match)
      throw new Error("Called contentMatchAt on a node with invalid content");
    return match;
  }
  canReplace(from, to, replacement = Fragment.empty, start = 0, end = replacement.childCount) {
    let one = this.contentMatchAt(from).matchFragment(replacement, start, end);
    let two = one && one.matchFragment(this.content, to);
    if (!two || !two.validEnd)
      return false;
    for (let i = start;i < end; i++)
      if (!this.type.allowsMarks(replacement.child(i).marks))
        return false;
    return true;
  }
  canReplaceWith(from, to, type, marks) {
    if (marks && !this.type.allowsMarks(marks))
      return false;
    let start = this.contentMatchAt(from).matchType(type);
    let end = start && start.matchFragment(this.content, to);
    return end ? end.validEnd : false;
  }
  canAppend(other) {
    if (other.content.size)
      return this.canReplace(this.childCount, this.childCount, other.content);
    else
      return this.type.compatibleContent(other.type);
  }
  check() {
    this.type.checkContent(this.content);
    this.type.checkAttrs(this.attrs);
    let copy = Mark.none;
    for (let i = 0;i < this.marks.length; i++) {
      let mark = this.marks[i];
      mark.type.checkAttrs(mark.attrs);
      copy = mark.addToSet(copy);
    }
    if (!Mark.sameSet(copy, this.marks))
      throw new RangeError(`Invalid collection of marks for node ${this.type.name}: ${this.marks.map((m) => m.type.name)}`);
    this.content.forEach((node) => node.check());
  }
  toJSON() {
    let obj = { type: this.type.name };
    for (let _ in this.attrs) {
      obj.attrs = this.attrs;
      break;
    }
    if (this.content.size)
      obj.content = this.content.toJSON();
    if (this.marks.length)
      obj.marks = this.marks.map((n) => n.toJSON());
    return obj;
  }
  static fromJSON(schema, json) {
    if (!json)
      throw new RangeError("Invalid input for Node.fromJSON");
    let marks = undefined;
    if (json.marks) {
      if (!Array.isArray(json.marks))
        throw new RangeError("Invalid mark data for Node.fromJSON");
      marks = json.marks.map(schema.markFromJSON);
    }
    if (json.type == "text") {
      if (typeof json.text != "string")
        throw new RangeError("Invalid text node in JSON");
      return schema.text(json.text, marks);
    }
    let content = Fragment.fromJSON(schema, json.content);
    let node = schema.nodeType(json.type).create(json.attrs, content, marks);
    node.type.checkAttrs(node.attrs);
    return node;
  }
}
Node2.prototype.text = undefined;

class TextNode extends Node2 {
  constructor(type, attrs, content, marks) {
    super(type, attrs, null, marks);
    if (!content)
      throw new RangeError("Empty text nodes are not allowed");
    this.text = content;
  }
  toString() {
    if (this.type.spec.toDebugString)
      return this.type.spec.toDebugString(this);
    return wrapMarks(this.marks, JSON.stringify(this.text));
  }
  get textContent() {
    return this.text;
  }
  textBetween(from, to) {
    return this.text.slice(from, to);
  }
  get nodeSize() {
    return this.text.length;
  }
  mark(marks) {
    return marks == this.marks ? this : new TextNode(this.type, this.attrs, this.text, marks);
  }
  withText(text) {
    if (text == this.text)
      return this;
    return new TextNode(this.type, this.attrs, text, this.marks);
  }
  cut(from = 0, to = this.text.length) {
    if (from == 0 && to == this.text.length)
      return this;
    return this.withText(this.text.slice(from, to));
  }
  eq(other) {
    return this.sameMarkup(other) && this.text == other.text;
  }
  toJSON() {
    let base = super.toJSON();
    base.text = this.text;
    return base;
  }
}
function wrapMarks(marks, str) {
  for (let i = marks.length - 1;i >= 0; i--)
    str = marks[i].type.name + "(" + str + ")";
  return str;
}

class ContentMatch {
  constructor(validEnd) {
    this.validEnd = validEnd;
    this.next = [];
    this.wrapCache = [];
  }
  static parse(string, nodeTypes) {
    let stream = new TokenStream(string, nodeTypes);
    if (stream.next == null)
      return ContentMatch.empty;
    let expr = parseExpr(stream);
    if (stream.next)
      stream.err("Unexpected trailing text");
    let match = dfa(nfa(expr));
    checkForDeadEnds(match, stream);
    return match;
  }
  matchType(type) {
    for (let i = 0;i < this.next.length; i++)
      if (this.next[i].type == type)
        return this.next[i].next;
    return null;
  }
  matchFragment(frag, start = 0, end = frag.childCount) {
    let cur = this;
    for (let i = start;cur && i < end; i++)
      cur = cur.matchType(frag.child(i).type);
    return cur;
  }
  get inlineContent() {
    return this.next.length != 0 && this.next[0].type.isInline;
  }
  get defaultType() {
    for (let i = 0;i < this.next.length; i++) {
      let { type } = this.next[i];
      if (!(type.isText || type.hasRequiredAttrs()))
        return type;
    }
    return null;
  }
  compatible(other) {
    for (let i = 0;i < this.next.length; i++)
      for (let j = 0;j < other.next.length; j++)
        if (this.next[i].type == other.next[j].type)
          return true;
    return false;
  }
  fillBefore(after, toEnd = false, startIndex = 0) {
    let seen = [this];
    function search(match, types) {
      let finished = match.matchFragment(after, startIndex);
      if (finished && (!toEnd || finished.validEnd))
        return Fragment.from(types.map((tp) => tp.createAndFill()));
      for (let i = 0;i < match.next.length; i++) {
        let { type, next } = match.next[i];
        if (!(type.isText || type.hasRequiredAttrs()) && seen.indexOf(next) == -1) {
          seen.push(next);
          let found2 = search(next, types.concat(type));
          if (found2)
            return found2;
        }
      }
      return null;
    }
    return search(this, []);
  }
  findWrapping(target) {
    for (let i = 0;i < this.wrapCache.length; i += 2)
      if (this.wrapCache[i] == target)
        return this.wrapCache[i + 1];
    let computed = this.computeWrapping(target);
    this.wrapCache.push(target, computed);
    return computed;
  }
  computeWrapping(target) {
    let seen = Object.create(null), active = [{ match: this, type: null, via: null }];
    while (active.length) {
      let current = active.shift(), match = current.match;
      if (match.matchType(target)) {
        let result = [];
        for (let obj = current;obj.type; obj = obj.via)
          result.push(obj.type);
        return result.reverse();
      }
      for (let i = 0;i < match.next.length; i++) {
        let { type, next } = match.next[i];
        if (!type.isLeaf && !type.hasRequiredAttrs() && !(type.name in seen) && (!current.type || next.validEnd)) {
          active.push({ match: type.contentMatch, type, via: current });
          seen[type.name] = true;
        }
      }
    }
    return null;
  }
  get edgeCount() {
    return this.next.length;
  }
  edge(n) {
    if (n >= this.next.length)
      throw new RangeError(`There's no ${n}th edge in this content match`);
    return this.next[n];
  }
  toString() {
    let seen = [];
    function scan(m) {
      seen.push(m);
      for (let i = 0;i < m.next.length; i++)
        if (seen.indexOf(m.next[i].next) == -1)
          scan(m.next[i].next);
    }
    scan(this);
    return seen.map((m, i) => {
      let out = i + (m.validEnd ? "*" : " ") + " ";
      for (let i2 = 0;i2 < m.next.length; i2++)
        out += (i2 ? ", " : "") + m.next[i2].type.name + "->" + seen.indexOf(m.next[i2].next);
      return out;
    }).join(`
`);
  }
}
ContentMatch.empty = new ContentMatch(true);

class TokenStream {
  constructor(string, nodeTypes) {
    this.string = string;
    this.nodeTypes = nodeTypes;
    this.inline = null;
    this.pos = 0;
    this.tokens = string.split(/\s*(?=\b|\W|$)/);
    if (this.tokens[this.tokens.length - 1] == "")
      this.tokens.pop();
    if (this.tokens[0] == "")
      this.tokens.shift();
  }
  get next() {
    return this.tokens[this.pos];
  }
  eat(tok) {
    return this.next == tok && (this.pos++ || true);
  }
  err(str) {
    throw new SyntaxError(str + " (in content expression '" + this.string + "')");
  }
}
function parseExpr(stream) {
  let exprs = [];
  do {
    exprs.push(parseExprSeq(stream));
  } while (stream.eat("|"));
  return exprs.length == 1 ? exprs[0] : { type: "choice", exprs };
}
function parseExprSeq(stream) {
  let exprs = [];
  do {
    exprs.push(parseExprSubscript(stream));
  } while (stream.next && stream.next != ")" && stream.next != "|");
  return exprs.length == 1 ? exprs[0] : { type: "seq", exprs };
}
function parseExprSubscript(stream) {
  let expr = parseExprAtom(stream);
  for (;; ) {
    if (stream.eat("+"))
      expr = { type: "plus", expr };
    else if (stream.eat("*"))
      expr = { type: "star", expr };
    else if (stream.eat("?"))
      expr = { type: "opt", expr };
    else if (stream.eat("{"))
      expr = parseExprRange(stream, expr);
    else
      break;
  }
  return expr;
}
function parseNum(stream) {
  if (/\D/.test(stream.next))
    stream.err("Expected number, got '" + stream.next + "'");
  let result = Number(stream.next);
  stream.pos++;
  return result;
}
function parseExprRange(stream, expr) {
  let min = parseNum(stream), max = min;
  if (stream.eat(",")) {
    if (stream.next != "}")
      max = parseNum(stream);
    else
      max = -1;
  }
  if (!stream.eat("}"))
    stream.err("Unclosed braced range");
  return { type: "range", min, max, expr };
}
function resolveName(stream, name) {
  let types = stream.nodeTypes, type = types[name];
  if (type)
    return [type];
  let result = [];
  for (let typeName in types) {
    let type2 = types[typeName];
    if (type2.isInGroup(name))
      result.push(type2);
  }
  if (result.length == 0)
    stream.err("No node type or group '" + name + "' found");
  return result;
}
function parseExprAtom(stream) {
  if (stream.eat("(")) {
    let expr = parseExpr(stream);
    if (!stream.eat(")"))
      stream.err("Missing closing paren");
    return expr;
  } else if (!/\W/.test(stream.next)) {
    let exprs = resolveName(stream, stream.next).map((type) => {
      if (stream.inline == null)
        stream.inline = type.isInline;
      else if (stream.inline != type.isInline)
        stream.err("Mixing inline and block content");
      return { type: "name", value: type };
    });
    stream.pos++;
    return exprs.length == 1 ? exprs[0] : { type: "choice", exprs };
  } else {
    stream.err("Unexpected token '" + stream.next + "'");
  }
}
function nfa(expr) {
  let nfa2 = [[]];
  connect(compile(expr, 0), node());
  return nfa2;
  function node() {
    return nfa2.push([]) - 1;
  }
  function edge(from, to, term) {
    let edge2 = { term, to };
    nfa2[from].push(edge2);
    return edge2;
  }
  function connect(edges, to) {
    edges.forEach((edge2) => edge2.to = to);
  }
  function compile(expr2, from) {
    if (expr2.type == "choice") {
      return expr2.exprs.reduce((out, expr3) => out.concat(compile(expr3, from)), []);
    } else if (expr2.type == "seq") {
      for (let i = 0;; i++) {
        let next = compile(expr2.exprs[i], from);
        if (i == expr2.exprs.length - 1)
          return next;
        connect(next, from = node());
      }
    } else if (expr2.type == "star") {
      let loop = node();
      edge(from, loop);
      connect(compile(expr2.expr, loop), loop);
      return [edge(loop)];
    } else if (expr2.type == "plus") {
      let loop = node();
      connect(compile(expr2.expr, from), loop);
      connect(compile(expr2.expr, loop), loop);
      return [edge(loop)];
    } else if (expr2.type == "opt") {
      return [edge(from)].concat(compile(expr2.expr, from));
    } else if (expr2.type == "range") {
      let cur = from;
      for (let i = 0;i < expr2.min; i++) {
        let next = node();
        connect(compile(expr2.expr, cur), next);
        cur = next;
      }
      if (expr2.max == -1) {
        connect(compile(expr2.expr, cur), cur);
      } else {
        for (let i = expr2.min;i < expr2.max; i++) {
          let next = node();
          edge(cur, next);
          connect(compile(expr2.expr, cur), next);
          cur = next;
        }
      }
      return [edge(cur)];
    } else if (expr2.type == "name") {
      return [edge(from, undefined, expr2.value)];
    } else {
      throw new Error("Unknown expr type");
    }
  }
}
function cmp(a, b) {
  return b - a;
}
function nullFrom(nfa2, node) {
  let result = [];
  scan(node);
  return result.sort(cmp);
  function scan(node2) {
    let edges = nfa2[node2];
    if (edges.length == 1 && !edges[0].term)
      return scan(edges[0].to);
    result.push(node2);
    for (let i = 0;i < edges.length; i++) {
      let { term, to } = edges[i];
      if (!term && result.indexOf(to) == -1)
        scan(to);
    }
  }
}
function dfa(nfa2) {
  let labeled = Object.create(null);
  return explore(nullFrom(nfa2, 0));
  function explore(states) {
    let out = [];
    states.forEach((node) => {
      nfa2[node].forEach(({ term, to }) => {
        if (!term)
          return;
        let set;
        for (let i = 0;i < out.length; i++)
          if (out[i][0] == term)
            set = out[i][1];
        nullFrom(nfa2, to).forEach((node2) => {
          if (!set)
            out.push([term, set = []]);
          if (set.indexOf(node2) == -1)
            set.push(node2);
        });
      });
    });
    let state = labeled[states.join(",")] = new ContentMatch(states.indexOf(nfa2.length - 1) > -1);
    for (let i = 0;i < out.length; i++) {
      let states2 = out[i][1].sort(cmp);
      state.next.push({ type: out[i][0], next: labeled[states2.join(",")] || explore(states2) });
    }
    return state;
  }
}
function checkForDeadEnds(match, stream) {
  for (let i = 0, work = [match];i < work.length; i++) {
    let state = work[i], dead = !state.validEnd, nodes = [];
    for (let j = 0;j < state.next.length; j++) {
      let { type, next } = state.next[j];
      nodes.push(type.name);
      if (dead && !(type.isText || type.hasRequiredAttrs()))
        dead = false;
      if (work.indexOf(next) == -1)
        work.push(next);
    }
    if (dead)
      stream.err("Only non-generatable nodes (" + nodes.join(", ") + ") in a required position (see https://prosemirror.net/docs/guide/#generatable)");
  }
}
function defaultAttrs(attrs) {
  let defaults = Object.create(null);
  for (let attrName in attrs) {
    let attr = attrs[attrName];
    if (!attr.hasDefault)
      return null;
    defaults[attrName] = attr.default;
  }
  return defaults;
}
function computeAttrs(attrs, value) {
  let built = Object.create(null);
  for (let name in attrs) {
    let given = value && value[name];
    if (given === undefined) {
      let attr = attrs[name];
      if (attr.hasDefault)
        given = attr.default;
      else
        throw new RangeError("No value supplied for attribute " + name);
    }
    built[name] = given;
  }
  return built;
}
function checkAttrs(attrs, values, type, name) {
  for (let name2 in values)
    if (!(name2 in attrs))
      throw new RangeError(`Unsupported attribute ${name2} for ${type} of type ${name2}`);
  for (let name2 in attrs) {
    let attr = attrs[name2];
    if (attr.validate)
      attr.validate(values[name2]);
  }
}
function initAttrs(typeName, attrs) {
  let result = Object.create(null);
  if (attrs)
    for (let name in attrs)
      result[name] = new Attribute(typeName, name, attrs[name]);
  return result;
}

class NodeType {
  constructor(name, schema, spec) {
    this.name = name;
    this.schema = schema;
    this.spec = spec;
    this.markSet = null;
    this.groups = spec.group ? spec.group.split(" ") : [];
    this.attrs = initAttrs(name, spec.attrs);
    this.defaultAttrs = defaultAttrs(this.attrs);
    this.contentMatch = null;
    this.inlineContent = null;
    this.isBlock = !(spec.inline || name == "text");
    this.isText = name == "text";
  }
  get isInline() {
    return !this.isBlock;
  }
  get isTextblock() {
    return this.isBlock && this.inlineContent;
  }
  get isLeaf() {
    return this.contentMatch == ContentMatch.empty;
  }
  get isAtom() {
    return this.isLeaf || !!this.spec.atom;
  }
  isInGroup(group) {
    return this.groups.indexOf(group) > -1;
  }
  get whitespace() {
    return this.spec.whitespace || (this.spec.code ? "pre" : "normal");
  }
  hasRequiredAttrs() {
    for (let n in this.attrs)
      if (this.attrs[n].isRequired)
        return true;
    return false;
  }
  compatibleContent(other) {
    return this == other || this.contentMatch.compatible(other.contentMatch);
  }
  computeAttrs(attrs) {
    if (!attrs && this.defaultAttrs)
      return this.defaultAttrs;
    else
      return computeAttrs(this.attrs, attrs);
  }
  create(attrs = null, content, marks) {
    if (this.isText)
      throw new Error("NodeType.create can't construct text nodes");
    return new Node2(this, this.computeAttrs(attrs), Fragment.from(content), Mark.setFrom(marks));
  }
  createChecked(attrs = null, content, marks) {
    content = Fragment.from(content);
    this.checkContent(content);
    return new Node2(this, this.computeAttrs(attrs), content, Mark.setFrom(marks));
  }
  createAndFill(attrs = null, content, marks) {
    attrs = this.computeAttrs(attrs);
    content = Fragment.from(content);
    if (content.size) {
      let before = this.contentMatch.fillBefore(content);
      if (!before)
        return null;
      content = before.append(content);
    }
    let matched = this.contentMatch.matchFragment(content);
    let after = matched && matched.fillBefore(Fragment.empty, true);
    if (!after)
      return null;
    return new Node2(this, attrs, content.append(after), Mark.setFrom(marks));
  }
  validContent(content) {
    let result = this.contentMatch.matchFragment(content);
    if (!result || !result.validEnd)
      return false;
    for (let i = 0;i < content.childCount; i++)
      if (!this.allowsMarks(content.child(i).marks))
        return false;
    return true;
  }
  checkContent(content) {
    if (!this.validContent(content))
      throw new RangeError(`Invalid content for node ${this.name}: ${content.toString().slice(0, 50)}`);
  }
  checkAttrs(attrs) {
    checkAttrs(this.attrs, attrs, "node", this.name);
  }
  allowsMarkType(markType) {
    return this.markSet == null || this.markSet.indexOf(markType) > -1;
  }
  allowsMarks(marks) {
    if (this.markSet == null)
      return true;
    for (let i = 0;i < marks.length; i++)
      if (!this.allowsMarkType(marks[i].type))
        return false;
    return true;
  }
  allowedMarks(marks) {
    if (this.markSet == null)
      return marks;
    let copy;
    for (let i = 0;i < marks.length; i++) {
      if (!this.allowsMarkType(marks[i].type)) {
        if (!copy)
          copy = marks.slice(0, i);
      } else if (copy) {
        copy.push(marks[i]);
      }
    }
    return !copy ? marks : copy.length ? copy : Mark.none;
  }
  static compile(nodes, schema) {
    let result = Object.create(null);
    nodes.forEach((name, spec) => result[name] = new NodeType(name, schema, spec));
    let topType = schema.spec.topNode || "doc";
    if (!result[topType])
      throw new RangeError("Schema is missing its top node type ('" + topType + "')");
    if (!result.text)
      throw new RangeError("Every schema needs a 'text' type");
    for (let _ in result.text.attrs)
      throw new RangeError("The text node type should not have attributes");
    return result;
  }
}
function validateType(typeName, attrName, type) {
  let types = type.split("|");
  return (value) => {
    let name = value === null ? "null" : typeof value;
    if (types.indexOf(name) < 0)
      throw new RangeError(`Expected value of type ${types} for attribute ${attrName} on type ${typeName}, got ${name}`);
  };
}

class Attribute {
  constructor(typeName, attrName, options) {
    this.hasDefault = Object.prototype.hasOwnProperty.call(options, "default");
    this.default = options.default;
    this.validate = typeof options.validate == "string" ? validateType(typeName, attrName, options.validate) : options.validate;
  }
  get isRequired() {
    return !this.hasDefault;
  }
}

class MarkType {
  constructor(name, rank, schema, spec) {
    this.name = name;
    this.rank = rank;
    this.schema = schema;
    this.spec = spec;
    this.attrs = initAttrs(name, spec.attrs);
    this.excluded = null;
    let defaults = defaultAttrs(this.attrs);
    this.instance = defaults ? new Mark(this, defaults) : null;
  }
  create(attrs = null) {
    if (!attrs && this.instance)
      return this.instance;
    return new Mark(this, computeAttrs(this.attrs, attrs));
  }
  static compile(marks, schema) {
    let result = Object.create(null), rank = 0;
    marks.forEach((name, spec) => result[name] = new MarkType(name, rank++, schema, spec));
    return result;
  }
  removeFromSet(set) {
    for (var i = 0;i < set.length; i++)
      if (set[i].type == this) {
        set = set.slice(0, i).concat(set.slice(i + 1));
        i--;
      }
    return set;
  }
  isInSet(set) {
    for (let i = 0;i < set.length; i++)
      if (set[i].type == this)
        return set[i];
  }
  checkAttrs(attrs) {
    checkAttrs(this.attrs, attrs, "mark", this.name);
  }
  excludes(other) {
    return this.excluded.indexOf(other) > -1;
  }
}

class Schema {
  constructor(spec) {
    this.linebreakReplacement = null;
    this.cached = Object.create(null);
    let instanceSpec = this.spec = {};
    for (let prop in spec)
      instanceSpec[prop] = spec[prop];
    instanceSpec.nodes = dist_default.from(spec.nodes), instanceSpec.marks = dist_default.from(spec.marks || {}), this.nodes = NodeType.compile(this.spec.nodes, this);
    this.marks = MarkType.compile(this.spec.marks, this);
    let contentExprCache = Object.create(null);
    for (let prop in this.nodes) {
      if (prop in this.marks)
        throw new RangeError(prop + " can not be both a node and a mark");
      let type = this.nodes[prop], contentExpr = type.spec.content || "", markExpr = type.spec.marks;
      type.contentMatch = contentExprCache[contentExpr] || (contentExprCache[contentExpr] = ContentMatch.parse(contentExpr, this.nodes));
      type.inlineContent = type.contentMatch.inlineContent;
      if (type.spec.linebreakReplacement) {
        if (this.linebreakReplacement)
          throw new RangeError("Multiple linebreak nodes defined");
        if (!type.isInline || !type.isLeaf)
          throw new RangeError("Linebreak replacement nodes must be inline leaf nodes");
        this.linebreakReplacement = type;
      }
      type.markSet = markExpr == "_" ? null : markExpr ? gatherMarks(this, markExpr.split(" ")) : markExpr == "" || !type.inlineContent ? [] : null;
    }
    for (let prop in this.marks) {
      let type = this.marks[prop], excl = type.spec.excludes;
      type.excluded = excl == null ? [type] : excl == "" ? [] : gatherMarks(this, excl.split(" "));
    }
    this.nodeFromJSON = (json) => Node2.fromJSON(this, json);
    this.markFromJSON = (json) => Mark.fromJSON(this, json);
    this.topNodeType = this.nodes[this.spec.topNode || "doc"];
    this.cached.wrappings = Object.create(null);
  }
  node(type, attrs = null, content, marks) {
    if (typeof type == "string")
      type = this.nodeType(type);
    else if (!(type instanceof NodeType))
      throw new RangeError("Invalid node type: " + type);
    else if (type.schema != this)
      throw new RangeError("Node type from different schema used (" + type.name + ")");
    return type.createChecked(attrs, content, marks);
  }
  text(text, marks) {
    let type = this.nodes.text;
    return new TextNode(type, type.defaultAttrs, text, Mark.setFrom(marks));
  }
  mark(type, attrs) {
    if (typeof type == "string")
      type = this.marks[type];
    return type.create(attrs);
  }
  nodeType(name) {
    let found2 = this.nodes[name];
    if (!found2)
      throw new RangeError("Unknown node type: " + name);
    return found2;
  }
}
function gatherMarks(schema, marks) {
  let found2 = [];
  for (let i = 0;i < marks.length; i++) {
    let name = marks[i], mark = schema.marks[name], ok = mark;
    if (mark) {
      found2.push(mark);
    } else {
      for (let prop in schema.marks) {
        let mark2 = schema.marks[prop];
        if (name == "_" || mark2.spec.group && mark2.spec.group.split(" ").indexOf(name) > -1)
          found2.push(ok = mark2);
      }
    }
    if (!ok)
      throw new SyntaxError("Unknown mark type: '" + marks[i] + "'");
  }
  return found2;
}
function isTagRule(rule) {
  return rule.tag != null;
}
function isStyleRule(rule) {
  return rule.style != null;
}

class DOMParser2 {
  constructor(schema, rules) {
    this.schema = schema;
    this.rules = rules;
    this.tags = [];
    this.styles = [];
    let matchedStyles = this.matchedStyles = [];
    rules.forEach((rule) => {
      if (isTagRule(rule)) {
        this.tags.push(rule);
      } else if (isStyleRule(rule)) {
        let prop = /[^=]*/.exec(rule.style)[0];
        if (matchedStyles.indexOf(prop) < 0)
          matchedStyles.push(prop);
        this.styles.push(rule);
      }
    });
    this.normalizeLists = !this.tags.some((r) => {
      if (!/^(ul|ol)\b/.test(r.tag) || !r.node)
        return false;
      let node = schema.nodes[r.node];
      return node.contentMatch.matchType(node);
    });
  }
  parse(dom, options = {}) {
    let context = new ParseContext(this, options, false);
    context.addAll(dom, Mark.none, options.from, options.to);
    return context.finish();
  }
  parseSlice(dom, options = {}) {
    let context = new ParseContext(this, options, true);
    context.addAll(dom, Mark.none, options.from, options.to);
    return Slice.maxOpen(context.finish());
  }
  matchTag(dom, context, after) {
    for (let i = after ? this.tags.indexOf(after) + 1 : 0;i < this.tags.length; i++) {
      let rule = this.tags[i];
      if (matches(dom, rule.tag) && (rule.namespace === undefined || dom.namespaceURI == rule.namespace) && (!rule.context || context.matchesContext(rule.context))) {
        if (rule.getAttrs) {
          let result = rule.getAttrs(dom);
          if (result === false)
            continue;
          rule.attrs = result || undefined;
        }
        return rule;
      }
    }
  }
  matchStyle(prop, value, context, after) {
    for (let i = after ? this.styles.indexOf(after) + 1 : 0;i < this.styles.length; i++) {
      let rule = this.styles[i], style = rule.style;
      if (style.indexOf(prop) != 0 || rule.context && !context.matchesContext(rule.context) || style.length > prop.length && (style.charCodeAt(prop.length) != 61 || style.slice(prop.length + 1) != value))
        continue;
      if (rule.getAttrs) {
        let result = rule.getAttrs(value);
        if (result === false)
          continue;
        rule.attrs = result || undefined;
      }
      return rule;
    }
  }
  static schemaRules(schema) {
    let result = [];
    function insert(rule) {
      let priority = rule.priority == null ? 50 : rule.priority, i = 0;
      for (;i < result.length; i++) {
        let next = result[i], nextPriority = next.priority == null ? 50 : next.priority;
        if (nextPriority < priority)
          break;
      }
      result.splice(i, 0, rule);
    }
    for (let name in schema.marks) {
      let rules = schema.marks[name].spec.parseDOM;
      if (rules)
        rules.forEach((rule) => {
          insert(rule = copy(rule));
          if (!(rule.mark || rule.ignore || rule.clearMark))
            rule.mark = name;
        });
    }
    for (let name in schema.nodes) {
      let rules = schema.nodes[name].spec.parseDOM;
      if (rules)
        rules.forEach((rule) => {
          insert(rule = copy(rule));
          if (!(rule.node || rule.ignore || rule.mark))
            rule.node = name;
        });
    }
    return result;
  }
  static fromSchema(schema) {
    return schema.cached.domParser || (schema.cached.domParser = new DOMParser2(schema, DOMParser2.schemaRules(schema)));
  }
}
var blockTags = {
  address: true,
  article: true,
  aside: true,
  blockquote: true,
  canvas: true,
  dd: true,
  div: true,
  dl: true,
  fieldset: true,
  figcaption: true,
  figure: true,
  footer: true,
  form: true,
  h1: true,
  h2: true,
  h3: true,
  h4: true,
  h5: true,
  h6: true,
  header: true,
  hgroup: true,
  hr: true,
  li: true,
  noscript: true,
  ol: true,
  output: true,
  p: true,
  pre: true,
  section: true,
  table: true,
  tfoot: true,
  ul: true
};
var ignoreTags = {
  head: true,
  noscript: true,
  object: true,
  script: true,
  style: true,
  title: true
};
var listTags = { ol: true, ul: true };
var OPT_PRESERVE_WS = 1;
var OPT_PRESERVE_WS_FULL = 2;
var OPT_OPEN_LEFT = 4;
function wsOptionsFor(type, preserveWhitespace, base) {
  if (preserveWhitespace != null)
    return (preserveWhitespace ? OPT_PRESERVE_WS : 0) | (preserveWhitespace === "full" ? OPT_PRESERVE_WS_FULL : 0);
  return type && type.whitespace == "pre" ? OPT_PRESERVE_WS | OPT_PRESERVE_WS_FULL : base & ~OPT_OPEN_LEFT;
}

class NodeContext {
  constructor(type, attrs, marks, solid, match, options) {
    this.type = type;
    this.attrs = attrs;
    this.marks = marks;
    this.solid = solid;
    this.options = options;
    this.content = [];
    this.activeMarks = Mark.none;
    this.match = match || (options & OPT_OPEN_LEFT ? null : type.contentMatch);
  }
  findWrapping(node) {
    if (!this.match) {
      if (!this.type)
        return [];
      let fill = this.type.contentMatch.fillBefore(Fragment.from(node));
      if (fill) {
        this.match = this.type.contentMatch.matchFragment(fill);
      } else {
        let start = this.type.contentMatch, wrap;
        if (wrap = start.findWrapping(node.type)) {
          this.match = start;
          return wrap;
        } else {
          return null;
        }
      }
    }
    return this.match.findWrapping(node.type);
  }
  finish(openEnd) {
    if (!(this.options & OPT_PRESERVE_WS)) {
      let last = this.content[this.content.length - 1], m;
      if (last && last.isText && (m = /[ \t\r\n\u000c]+$/.exec(last.text))) {
        let text = last;
        if (last.text.length == m[0].length)
          this.content.pop();
        else
          this.content[this.content.length - 1] = text.withText(text.text.slice(0, text.text.length - m[0].length));
      }
    }
    let content = Fragment.from(this.content);
    if (!openEnd && this.match)
      content = content.append(this.match.fillBefore(Fragment.empty, true));
    return this.type ? this.type.create(this.attrs, content, this.marks) : content;
  }
  inlineContext(node) {
    if (this.type)
      return this.type.inlineContent;
    if (this.content.length)
      return this.content[0].isInline;
    return node.parentNode && !blockTags.hasOwnProperty(node.parentNode.nodeName.toLowerCase());
  }
}

class ParseContext {
  constructor(parser, options, isOpen) {
    this.parser = parser;
    this.options = options;
    this.isOpen = isOpen;
    this.open = 0;
    this.localPreserveWS = false;
    let topNode = options.topNode, topContext;
    let topOptions = wsOptionsFor(null, options.preserveWhitespace, 0) | (isOpen ? OPT_OPEN_LEFT : 0);
    if (topNode)
      topContext = new NodeContext(topNode.type, topNode.attrs, Mark.none, true, options.topMatch || topNode.type.contentMatch, topOptions);
    else if (isOpen)
      topContext = new NodeContext(null, null, Mark.none, true, null, topOptions);
    else
      topContext = new NodeContext(parser.schema.topNodeType, null, Mark.none, true, null, topOptions);
    this.nodes = [topContext];
    this.find = options.findPositions;
    this.needsBlock = false;
  }
  get top() {
    return this.nodes[this.open];
  }
  addDOM(dom, marks) {
    if (dom.nodeType == 3)
      this.addTextNode(dom, marks);
    else if (dom.nodeType == 1)
      this.addElement(dom, marks);
  }
  addTextNode(dom, marks) {
    let value = dom.nodeValue;
    let top = this.top, preserveWS = top.options & OPT_PRESERVE_WS_FULL ? "full" : this.localPreserveWS || (top.options & OPT_PRESERVE_WS) > 0;
    let { schema } = this.parser;
    if (preserveWS === "full" || top.inlineContext(dom) || /[^ \t\r\n\u000c]/.test(value)) {
      if (!preserveWS) {
        value = value.replace(/[ \t\r\n\u000c]+/g, " ");
        if (/^[ \t\r\n\u000c]/.test(value) && this.open == this.nodes.length - 1) {
          let nodeBefore = top.content[top.content.length - 1];
          let domNodeBefore = dom.previousSibling;
          if (!nodeBefore || domNodeBefore && domNodeBefore.nodeName == "BR" || nodeBefore.isText && /[ \t\r\n\u000c]$/.test(nodeBefore.text))
            value = value.slice(1);
        }
      } else if (preserveWS === "full") {
        value = value.replace(/\r\n?/g, `
`);
      } else if (schema.linebreakReplacement && /[\r\n]/.test(value) && this.top.findWrapping(schema.linebreakReplacement.create())) {
        let lines = value.split(/\r?\n|\r/);
        for (let i = 0;i < lines.length; i++) {
          if (i)
            this.insertNode(schema.linebreakReplacement.create(), marks, true);
          if (lines[i])
            this.insertNode(schema.text(lines[i]), marks, !/\S/.test(lines[i]));
        }
        value = "";
      } else {
        value = value.replace(/\r?\n|\r/g, " ");
      }
      if (value)
        this.insertNode(schema.text(value), marks, !/\S/.test(value));
      this.findInText(dom);
    } else {
      this.findInside(dom);
    }
  }
  addElement(dom, marks, matchAfter) {
    let outerWS = this.localPreserveWS, top = this.top;
    if (dom.tagName == "PRE" || /pre/.test(dom.style && dom.style.whiteSpace))
      this.localPreserveWS = true;
    let name = dom.nodeName.toLowerCase(), ruleID;
    if (listTags.hasOwnProperty(name) && this.parser.normalizeLists)
      normalizeList(dom);
    let rule = this.options.ruleFromNode && this.options.ruleFromNode(dom) || (ruleID = this.parser.matchTag(dom, this, matchAfter));
    out:
      if (rule ? rule.ignore : ignoreTags.hasOwnProperty(name)) {
        this.findInside(dom);
        this.ignoreFallback(dom, marks);
      } else if (!rule || rule.skip || rule.closeParent) {
        if (rule && rule.closeParent)
          this.open = Math.max(0, this.open - 1);
        else if (rule && rule.skip.nodeType)
          dom = rule.skip;
        let sync, oldNeedsBlock = this.needsBlock;
        if (blockTags.hasOwnProperty(name)) {
          if (top.content.length && top.content[0].isInline && this.open) {
            this.open--;
            top = this.top;
          }
          sync = true;
          if (!top.type)
            this.needsBlock = true;
        } else if (!dom.firstChild) {
          this.leafFallback(dom, marks);
          break out;
        }
        let innerMarks = rule && rule.skip ? marks : this.readStyles(dom, marks);
        if (innerMarks)
          this.addAll(dom, innerMarks);
        if (sync)
          this.sync(top);
        this.needsBlock = oldNeedsBlock;
      } else {
        let innerMarks = this.readStyles(dom, marks);
        if (innerMarks)
          this.addElementByRule(dom, rule, innerMarks, rule.consuming === false ? ruleID : undefined);
      }
    this.localPreserveWS = outerWS;
  }
  leafFallback(dom, marks) {
    if (dom.nodeName == "BR" && this.top.type && this.top.type.inlineContent)
      this.addTextNode(dom.ownerDocument.createTextNode(`
`), marks);
  }
  ignoreFallback(dom, marks) {
    if (dom.nodeName == "BR" && (!this.top.type || !this.top.type.inlineContent))
      this.findPlace(this.parser.schema.text("-"), marks, true);
  }
  readStyles(dom, marks) {
    let styles = dom.style;
    if (styles && styles.length)
      for (let i = 0;i < this.parser.matchedStyles.length; i++) {
        let name = this.parser.matchedStyles[i], value = styles.getPropertyValue(name);
        if (value)
          for (let after = undefined;; ) {
            let rule = this.parser.matchStyle(name, value, this, after);
            if (!rule)
              break;
            if (rule.ignore)
              return null;
            if (rule.clearMark)
              marks = marks.filter((m) => !rule.clearMark(m));
            else
              marks = marks.concat(this.parser.schema.marks[rule.mark].create(rule.attrs));
            if (rule.consuming === false)
              after = rule;
            else
              break;
          }
      }
    return marks;
  }
  addElementByRule(dom, rule, marks, continueAfter) {
    let sync, nodeType;
    if (rule.node) {
      nodeType = this.parser.schema.nodes[rule.node];
      if (!nodeType.isLeaf) {
        let inner = this.enter(nodeType, rule.attrs || null, marks, rule.preserveWhitespace);
        if (inner) {
          sync = true;
          marks = inner;
        }
      } else if (!this.insertNode(nodeType.create(rule.attrs), marks, dom.nodeName == "BR")) {
        this.leafFallback(dom, marks);
      }
    } else {
      let markType = this.parser.schema.marks[rule.mark];
      marks = marks.concat(markType.create(rule.attrs));
    }
    let startIn = this.top;
    if (nodeType && nodeType.isLeaf) {
      this.findInside(dom);
    } else if (continueAfter) {
      this.addElement(dom, marks, continueAfter);
    } else if (rule.getContent) {
      this.findInside(dom);
      rule.getContent(dom, this.parser.schema).forEach((node) => this.insertNode(node, marks, false));
    } else {
      let contentDOM = dom;
      if (typeof rule.contentElement == "string")
        contentDOM = dom.querySelector(rule.contentElement);
      else if (typeof rule.contentElement == "function")
        contentDOM = rule.contentElement(dom);
      else if (rule.contentElement)
        contentDOM = rule.contentElement;
      this.findAround(dom, contentDOM, true);
      this.addAll(contentDOM, marks);
      this.findAround(dom, contentDOM, false);
    }
    if (sync && this.sync(startIn))
      this.open--;
  }
  addAll(parent, marks, startIndex, endIndex) {
    let index = startIndex || 0;
    for (let dom = startIndex ? parent.childNodes[startIndex] : parent.firstChild, end = endIndex == null ? null : parent.childNodes[endIndex];dom != end; dom = dom.nextSibling, ++index) {
      this.findAtPoint(parent, index);
      this.addDOM(dom, marks);
    }
    this.findAtPoint(parent, index);
  }
  findPlace(node, marks, cautious) {
    let route, sync;
    for (let depth = this.open, penalty = 0;depth >= 0; depth--) {
      let cx = this.nodes[depth];
      let found2 = cx.findWrapping(node);
      if (found2 && (!route || route.length > found2.length + penalty)) {
        route = found2;
        sync = cx;
        if (!found2.length)
          break;
      }
      if (cx.solid) {
        if (cautious)
          break;
        penalty += 2;
      }
    }
    if (!route)
      return null;
    this.sync(sync);
    for (let i = 0;i < route.length; i++)
      marks = this.enterInner(route[i], null, marks, false);
    return marks;
  }
  insertNode(node, marks, cautious) {
    if (node.isInline && this.needsBlock && !this.top.type) {
      let block = this.textblockFromContext();
      if (block)
        marks = this.enterInner(block, null, marks);
    }
    let innerMarks = this.findPlace(node, marks, cautious);
    if (innerMarks) {
      this.closeExtra();
      let top = this.top;
      if (top.match)
        top.match = top.match.matchType(node.type);
      let nodeMarks = Mark.none;
      for (let m of innerMarks.concat(node.marks))
        if (top.type ? top.type.allowsMarkType(m.type) : markMayApply(m.type, node.type))
          nodeMarks = m.addToSet(nodeMarks);
      top.content.push(node.mark(nodeMarks));
      return true;
    }
    return false;
  }
  enter(type, attrs, marks, preserveWS) {
    let innerMarks = this.findPlace(type.create(attrs), marks, false);
    if (innerMarks)
      innerMarks = this.enterInner(type, attrs, marks, true, preserveWS);
    return innerMarks;
  }
  enterInner(type, attrs, marks, solid = false, preserveWS) {
    this.closeExtra();
    let top = this.top;
    top.match = top.match && top.match.matchType(type);
    let options = wsOptionsFor(type, preserveWS, top.options);
    if (top.options & OPT_OPEN_LEFT && top.content.length == 0)
      options |= OPT_OPEN_LEFT;
    let applyMarks = Mark.none;
    marks = marks.filter((m) => {
      if (top.type ? top.type.allowsMarkType(m.type) : markMayApply(m.type, type)) {
        applyMarks = m.addToSet(applyMarks);
        return false;
      }
      return true;
    });
    this.nodes.push(new NodeContext(type, attrs, applyMarks, solid, null, options));
    this.open++;
    return marks;
  }
  closeExtra(openEnd = false) {
    let i = this.nodes.length - 1;
    if (i > this.open) {
      for (;i > this.open; i--)
        this.nodes[i - 1].content.push(this.nodes[i].finish(openEnd));
      this.nodes.length = this.open + 1;
    }
  }
  finish() {
    this.open = 0;
    this.closeExtra(this.isOpen);
    return this.nodes[0].finish(!!(this.isOpen || this.options.topOpen));
  }
  sync(to) {
    for (let i = this.open;i >= 0; i--) {
      if (this.nodes[i] == to) {
        this.open = i;
        return true;
      } else if (this.localPreserveWS) {
        this.nodes[i].options |= OPT_PRESERVE_WS;
      }
    }
    return false;
  }
  get currentPos() {
    this.closeExtra();
    let pos = 0;
    for (let i = this.open;i >= 0; i--) {
      let content = this.nodes[i].content;
      for (let j = content.length - 1;j >= 0; j--)
        pos += content[j].nodeSize;
      if (i)
        pos++;
    }
    return pos;
  }
  findAtPoint(parent, offset) {
    if (this.find)
      for (let i = 0;i < this.find.length; i++) {
        if (this.find[i].node == parent && this.find[i].offset == offset)
          this.find[i].pos = this.currentPos;
      }
  }
  findInside(parent) {
    if (this.find)
      for (let i = 0;i < this.find.length; i++) {
        if (this.find[i].pos == null && parent.nodeType == 1 && parent.contains(this.find[i].node))
          this.find[i].pos = this.currentPos;
      }
  }
  findAround(parent, content, before) {
    if (parent != content && this.find)
      for (let i = 0;i < this.find.length; i++) {
        if (this.find[i].pos == null && parent.nodeType == 1 && parent.contains(this.find[i].node)) {
          let pos = content.compareDocumentPosition(this.find[i].node);
          if (pos & (before ? 2 : 4))
            this.find[i].pos = this.currentPos;
        }
      }
  }
  findInText(textNode) {
    if (this.find)
      for (let i = 0;i < this.find.length; i++) {
        if (this.find[i].node == textNode)
          this.find[i].pos = this.currentPos - (textNode.nodeValue.length - this.find[i].offset);
      }
  }
  matchesContext(context) {
    if (context.indexOf("|") > -1)
      return context.split(/\s*\|\s*/).some(this.matchesContext, this);
    let parts = context.split("/");
    let option = this.options.context;
    let useRoot = !this.isOpen && (!option || option.parent.type == this.nodes[0].type);
    let minDepth = -(option ? option.depth + 1 : 0) + (useRoot ? 0 : 1);
    let match = (i, depth) => {
      for (;i >= 0; i--) {
        let part = parts[i];
        if (part == "") {
          if (i == parts.length - 1 || i == 0)
            continue;
          for (;depth >= minDepth; depth--)
            if (match(i - 1, depth))
              return true;
          return false;
        } else {
          let next = depth > 0 || depth == 0 && useRoot ? this.nodes[depth].type : option && depth >= minDepth ? option.node(depth - minDepth).type : null;
          if (!next || next.name != part && !next.isInGroup(part))
            return false;
          depth--;
        }
      }
      return true;
    };
    return match(parts.length - 1, this.open);
  }
  textblockFromContext() {
    let $context = this.options.context;
    if ($context)
      for (let d = $context.depth;d >= 0; d--) {
        let deflt = $context.node(d).contentMatchAt($context.indexAfter(d)).defaultType;
        if (deflt && deflt.isTextblock && deflt.defaultAttrs)
          return deflt;
      }
    for (let name in this.parser.schema.nodes) {
      let type = this.parser.schema.nodes[name];
      if (type.isTextblock && type.defaultAttrs)
        return type;
    }
  }
}
function normalizeList(dom) {
  for (let child = dom.firstChild, prevItem = null;child; child = child.nextSibling) {
    let name = child.nodeType == 1 ? child.nodeName.toLowerCase() : null;
    if (name && listTags.hasOwnProperty(name) && prevItem) {
      prevItem.appendChild(child);
      child = prevItem;
    } else if (name == "li") {
      prevItem = child;
    } else if (name) {
      prevItem = null;
    }
  }
}
function matches(dom, selector) {
  return (dom.matches || dom.msMatchesSelector || dom.webkitMatchesSelector || dom.mozMatchesSelector).call(dom, selector);
}
function copy(obj) {
  let copy2 = {};
  for (let prop in obj)
    copy2[prop] = obj[prop];
  return copy2;
}
function markMayApply(markType, nodeType) {
  let nodes = nodeType.schema.nodes;
  for (let name in nodes) {
    let parent = nodes[name];
    if (!parent.allowsMarkType(markType))
      continue;
    let seen = [], scan = (match) => {
      seen.push(match);
      for (let i = 0;i < match.edgeCount; i++) {
        let { type, next } = match.edge(i);
        if (type == nodeType)
          return true;
        if (seen.indexOf(next) < 0 && scan(next))
          return true;
      }
    };
    if (scan(parent.contentMatch))
      return true;
  }
}

class DOMSerializer {
  constructor(nodes, marks) {
    this.nodes = nodes;
    this.marks = marks;
  }
  serializeFragment(fragment, options = {}, target) {
    if (!target)
      target = doc(options).createDocumentFragment();
    let top = target, active = [];
    fragment.forEach((node) => {
      if (active.length || node.marks.length) {
        let keep = 0, rendered = 0;
        while (keep < active.length && rendered < node.marks.length) {
          let next = node.marks[rendered];
          if (!this.marks[next.type.name]) {
            rendered++;
            continue;
          }
          if (!next.eq(active[keep][0]) || next.type.spec.spanning === false)
            break;
          keep++;
          rendered++;
        }
        while (keep < active.length)
          top = active.pop()[1];
        while (rendered < node.marks.length) {
          let add = node.marks[rendered++];
          let markDOM = this.serializeMark(add, node.isInline, options);
          if (markDOM) {
            active.push([add, top]);
            top.appendChild(markDOM.dom);
            top = markDOM.contentDOM || markDOM.dom;
          }
        }
      }
      top.appendChild(this.serializeNodeInner(node, options));
    });
    return target;
  }
  serializeNodeInner(node, options) {
    let { dom, contentDOM } = renderSpec(doc(options), this.nodes[node.type.name](node), null, node.attrs);
    if (contentDOM) {
      if (node.isLeaf)
        throw new RangeError("Content hole not allowed in a leaf node spec");
      this.serializeFragment(node.content, options, contentDOM);
    }
    return dom;
  }
  serializeNode(node, options = {}) {
    let dom = this.serializeNodeInner(node, options);
    for (let i = node.marks.length - 1;i >= 0; i--) {
      let wrap = this.serializeMark(node.marks[i], node.isInline, options);
      if (wrap) {
        (wrap.contentDOM || wrap.dom).appendChild(dom);
        dom = wrap.dom;
      }
    }
    return dom;
  }
  serializeMark(mark, inline, options = {}) {
    let toDOM = this.marks[mark.type.name];
    return toDOM && renderSpec(doc(options), toDOM(mark, inline), null, mark.attrs);
  }
  static renderSpec(doc, structure, xmlNS = null, blockArraysIn) {
    return renderSpec(doc, structure, xmlNS, blockArraysIn);
  }
  static fromSchema(schema) {
    return schema.cached.domSerializer || (schema.cached.domSerializer = new DOMSerializer(this.nodesFromSchema(schema), this.marksFromSchema(schema)));
  }
  static nodesFromSchema(schema) {
    let result = gatherToDOM(schema.nodes);
    if (!result.text)
      result.text = (node) => node.text;
    return result;
  }
  static marksFromSchema(schema) {
    return gatherToDOM(schema.marks);
  }
}
function gatherToDOM(obj) {
  let result = {};
  for (let name in obj) {
    let toDOM = obj[name].spec.toDOM;
    if (toDOM)
      result[name] = toDOM;
  }
  return result;
}
function doc(options) {
  return options.document || window.document;
}
var suspiciousAttributeCache = new WeakMap;
function suspiciousAttributes(attrs) {
  let value = suspiciousAttributeCache.get(attrs);
  if (value === undefined)
    suspiciousAttributeCache.set(attrs, value = suspiciousAttributesInner(attrs));
  return value;
}
function suspiciousAttributesInner(attrs) {
  let result = null;
  function scan(value) {
    if (value && typeof value == "object") {
      if (Array.isArray(value)) {
        if (typeof value[0] == "string") {
          if (!result)
            result = [];
          result.push(value);
        } else {
          for (let i = 0;i < value.length; i++)
            scan(value[i]);
        }
      } else {
        for (let prop in value)
          scan(value[prop]);
      }
    }
  }
  scan(attrs);
  return result;
}
function renderSpec(doc2, structure, xmlNS, blockArraysIn) {
  if (typeof structure == "string")
    return { dom: doc2.createTextNode(structure) };
  if (structure.nodeType != null)
    return { dom: structure };
  if (structure.dom && structure.dom.nodeType != null)
    return structure;
  let tagName = structure[0], suspicious;
  if (typeof tagName != "string")
    throw new RangeError("Invalid array passed to renderSpec");
  if (blockArraysIn && (suspicious = suspiciousAttributes(blockArraysIn)) && suspicious.indexOf(structure) > -1)
    throw new RangeError("Using an array from an attribute object as a DOM spec. This may be an attempted cross site scripting attack.");
  let space = tagName.indexOf(" ");
  if (space > 0) {
    xmlNS = tagName.slice(0, space);
    tagName = tagName.slice(space + 1);
  }
  let contentDOM;
  let dom = xmlNS ? doc2.createElementNS(xmlNS, tagName) : doc2.createElement(tagName);
  let attrs = structure[1], start = 1;
  if (attrs && typeof attrs == "object" && attrs.nodeType == null && !Array.isArray(attrs)) {
    start = 2;
    for (let name in attrs)
      if (attrs[name] != null) {
        let space2 = name.indexOf(" ");
        if (space2 > 0)
          dom.setAttributeNS(name.slice(0, space2), name.slice(space2 + 1), attrs[name]);
        else if (name == "style" && dom.style)
          dom.style.cssText = attrs[name];
        else
          dom.setAttribute(name, attrs[name]);
      }
  }
  for (let i = start;i < structure.length; i++) {
    let child = structure[i];
    if (child === 0) {
      if (i < structure.length - 1 || i > start)
        throw new RangeError("Content hole must be the only child of its parent node");
      return { dom, contentDOM: dom };
    } else {
      let { dom: inner, contentDOM: innerContent } = renderSpec(doc2, child, xmlNS, blockArraysIn);
      dom.appendChild(inner);
      if (innerContent) {
        if (contentDOM)
          throw new RangeError("Multiple content holes");
        contentDOM = innerContent;
      }
    }
  }
  return { dom, contentDOM };
}

// node_modules/prosemirror-transform/dist/index.js
var lower16 = 65535;
var factor16 = Math.pow(2, 16);
function makeRecover(index, offset) {
  return index + offset * factor16;
}
function recoverIndex(value) {
  return value & lower16;
}
function recoverOffset(value) {
  return (value - (value & lower16)) / factor16;
}
var DEL_BEFORE = 1;
var DEL_AFTER = 2;
var DEL_ACROSS = 4;
var DEL_SIDE = 8;

class MapResult {
  constructor(pos, delInfo, recover) {
    this.pos = pos;
    this.delInfo = delInfo;
    this.recover = recover;
  }
  get deleted() {
    return (this.delInfo & DEL_SIDE) > 0;
  }
  get deletedBefore() {
    return (this.delInfo & (DEL_BEFORE | DEL_ACROSS)) > 0;
  }
  get deletedAfter() {
    return (this.delInfo & (DEL_AFTER | DEL_ACROSS)) > 0;
  }
  get deletedAcross() {
    return (this.delInfo & DEL_ACROSS) > 0;
  }
}

class StepMap {
  constructor(ranges, inverted = false) {
    this.ranges = ranges;
    this.inverted = inverted;
    if (!ranges.length && StepMap.empty)
      return StepMap.empty;
  }
  recover(value) {
    let diff = 0, index = recoverIndex(value);
    if (!this.inverted)
      for (let i = 0;i < index; i++)
        diff += this.ranges[i * 3 + 2] - this.ranges[i * 3 + 1];
    return this.ranges[index * 3] + diff + recoverOffset(value);
  }
  mapResult(pos, assoc = 1) {
    return this._map(pos, assoc, false);
  }
  map(pos, assoc = 1) {
    return this._map(pos, assoc, true);
  }
  _map(pos, assoc, simple) {
    let diff = 0, oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;
    for (let i = 0;i < this.ranges.length; i += 3) {
      let start = this.ranges[i] - (this.inverted ? diff : 0);
      if (start > pos)
        break;
      let oldSize = this.ranges[i + oldIndex], newSize = this.ranges[i + newIndex], end = start + oldSize;
      if (pos <= end) {
        let side = !oldSize ? assoc : pos == start ? -1 : pos == end ? 1 : assoc;
        let result = start + diff + (side < 0 ? 0 : newSize);
        if (simple)
          return result;
        let recover = pos == (assoc < 0 ? start : end) ? null : makeRecover(i / 3, pos - start);
        let del = pos == start ? DEL_AFTER : pos == end ? DEL_BEFORE : DEL_ACROSS;
        if (assoc < 0 ? pos != start : pos != end)
          del |= DEL_SIDE;
        return new MapResult(result, del, recover);
      }
      diff += newSize - oldSize;
    }
    return simple ? pos + diff : new MapResult(pos + diff, 0, null);
  }
  touches(pos, recover) {
    let diff = 0, index = recoverIndex(recover);
    let oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;
    for (let i = 0;i < this.ranges.length; i += 3) {
      let start = this.ranges[i] - (this.inverted ? diff : 0);
      if (start > pos)
        break;
      let oldSize = this.ranges[i + oldIndex], end = start + oldSize;
      if (pos <= end && i == index * 3)
        return true;
      diff += this.ranges[i + newIndex] - oldSize;
    }
    return false;
  }
  forEach(f) {
    let oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;
    for (let i = 0, diff = 0;i < this.ranges.length; i += 3) {
      let start = this.ranges[i], oldStart = start - (this.inverted ? diff : 0), newStart = start + (this.inverted ? 0 : diff);
      let oldSize = this.ranges[i + oldIndex], newSize = this.ranges[i + newIndex];
      f(oldStart, oldStart + oldSize, newStart, newStart + newSize);
      diff += newSize - oldSize;
    }
  }
  invert() {
    return new StepMap(this.ranges, !this.inverted);
  }
  toString() {
    return (this.inverted ? "-" : "") + JSON.stringify(this.ranges);
  }
  static offset(n) {
    return n == 0 ? StepMap.empty : new StepMap(n < 0 ? [0, -n, 0] : [0, 0, n]);
  }
}
StepMap.empty = new StepMap([]);

class Mapping {
  constructor(maps, mirror, from = 0, to = maps ? maps.length : 0) {
    this.mirror = mirror;
    this.from = from;
    this.to = to;
    this._maps = maps || [];
    this.ownData = !(maps || mirror);
  }
  get maps() {
    return this._maps;
  }
  slice(from = 0, to = this.maps.length) {
    return new Mapping(this._maps, this.mirror, from, to);
  }
  appendMap(map, mirrors) {
    if (!this.ownData) {
      this._maps = this._maps.slice();
      this.mirror = this.mirror && this.mirror.slice();
      this.ownData = true;
    }
    this.to = this._maps.push(map);
    if (mirrors != null)
      this.setMirror(this._maps.length - 1, mirrors);
  }
  appendMapping(mapping) {
    for (let i = 0, startSize = this._maps.length;i < mapping._maps.length; i++) {
      let mirr = mapping.getMirror(i);
      this.appendMap(mapping._maps[i], mirr != null && mirr < i ? startSize + mirr : undefined);
    }
  }
  getMirror(n) {
    if (this.mirror) {
      for (let i = 0;i < this.mirror.length; i++)
        if (this.mirror[i] == n)
          return this.mirror[i + (i % 2 ? -1 : 1)];
    }
  }
  setMirror(n, m) {
    if (!this.mirror)
      this.mirror = [];
    this.mirror.push(n, m);
  }
  appendMappingInverted(mapping) {
    for (let i = mapping.maps.length - 1, totalSize = this._maps.length + mapping._maps.length;i >= 0; i--) {
      let mirr = mapping.getMirror(i);
      this.appendMap(mapping._maps[i].invert(), mirr != null && mirr > i ? totalSize - mirr - 1 : undefined);
    }
  }
  invert() {
    let inverse = new Mapping;
    inverse.appendMappingInverted(this);
    return inverse;
  }
  map(pos, assoc = 1) {
    if (this.mirror)
      return this._map(pos, assoc, true);
    for (let i = this.from;i < this.to; i++)
      pos = this._maps[i].map(pos, assoc);
    return pos;
  }
  mapResult(pos, assoc = 1) {
    return this._map(pos, assoc, false);
  }
  _map(pos, assoc, simple) {
    let delInfo = 0;
    for (let i = this.from;i < this.to; i++) {
      let map = this._maps[i], result = map.mapResult(pos, assoc);
      if (result.recover != null) {
        let corr = this.getMirror(i);
        if (corr != null && corr > i && corr < this.to) {
          i = corr;
          pos = this._maps[corr].recover(result.recover);
          continue;
        }
      }
      delInfo |= result.delInfo;
      pos = result.pos;
    }
    return simple ? pos : new MapResult(pos, delInfo, null);
  }
}
var stepsByID = Object.create(null);

class Step {
  getMap() {
    return StepMap.empty;
  }
  merge(other) {
    return null;
  }
  static fromJSON(schema, json) {
    if (!json || !json.stepType)
      throw new RangeError("Invalid input for Step.fromJSON");
    let type = stepsByID[json.stepType];
    if (!type)
      throw new RangeError(`No step type ${json.stepType} defined`);
    return type.fromJSON(schema, json);
  }
  static jsonID(id, stepClass) {
    if (id in stepsByID)
      throw new RangeError("Duplicate use of step JSON ID " + id);
    stepsByID[id] = stepClass;
    stepClass.prototype.jsonID = id;
    return stepClass;
  }
}

class StepResult {
  constructor(doc2, failed) {
    this.doc = doc2;
    this.failed = failed;
  }
  static ok(doc2) {
    return new StepResult(doc2, null);
  }
  static fail(message) {
    return new StepResult(null, message);
  }
  static fromReplace(doc2, from, to, slice) {
    try {
      return StepResult.ok(doc2.replace(from, to, slice));
    } catch (e) {
      if (e instanceof ReplaceError)
        return StepResult.fail(e.message);
      throw e;
    }
  }
}
function mapFragment(fragment, f, parent) {
  let mapped = [];
  for (let i = 0;i < fragment.childCount; i++) {
    let child = fragment.child(i);
    if (child.content.size)
      child = child.copy(mapFragment(child.content, f, child));
    if (child.isInline)
      child = f(child, parent, i);
    mapped.push(child);
  }
  return Fragment.fromArray(mapped);
}

class AddMarkStep extends Step {
  constructor(from, to, mark) {
    super();
    this.from = from;
    this.to = to;
    this.mark = mark;
  }
  apply(doc2) {
    let oldSlice = doc2.slice(this.from, this.to), $from = doc2.resolve(this.from);
    let parent = $from.node($from.sharedDepth(this.to));
    let slice = new Slice(mapFragment(oldSlice.content, (node, parent2) => {
      if (!node.isAtom || !parent2.type.allowsMarkType(this.mark.type))
        return node;
      return node.mark(this.mark.addToSet(node.marks));
    }, parent), oldSlice.openStart, oldSlice.openEnd);
    return StepResult.fromReplace(doc2, this.from, this.to, slice);
  }
  invert() {
    return new RemoveMarkStep(this.from, this.to, this.mark);
  }
  map(mapping) {
    let from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
    if (from.deleted && to.deleted || from.pos >= to.pos)
      return null;
    return new AddMarkStep(from.pos, to.pos, this.mark);
  }
  merge(other) {
    if (other instanceof AddMarkStep && other.mark.eq(this.mark) && this.from <= other.to && this.to >= other.from)
      return new AddMarkStep(Math.min(this.from, other.from), Math.max(this.to, other.to), this.mark);
    return null;
  }
  toJSON() {
    return {
      stepType: "addMark",
      mark: this.mark.toJSON(),
      from: this.from,
      to: this.to
    };
  }
  static fromJSON(schema, json) {
    if (typeof json.from != "number" || typeof json.to != "number")
      throw new RangeError("Invalid input for AddMarkStep.fromJSON");
    return new AddMarkStep(json.from, json.to, schema.markFromJSON(json.mark));
  }
}
Step.jsonID("addMark", AddMarkStep);

class RemoveMarkStep extends Step {
  constructor(from, to, mark) {
    super();
    this.from = from;
    this.to = to;
    this.mark = mark;
  }
  apply(doc2) {
    let oldSlice = doc2.slice(this.from, this.to);
    let slice = new Slice(mapFragment(oldSlice.content, (node) => {
      return node.mark(this.mark.removeFromSet(node.marks));
    }, doc2), oldSlice.openStart, oldSlice.openEnd);
    return StepResult.fromReplace(doc2, this.from, this.to, slice);
  }
  invert() {
    return new AddMarkStep(this.from, this.to, this.mark);
  }
  map(mapping) {
    let from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
    if (from.deleted && to.deleted || from.pos >= to.pos)
      return null;
    return new RemoveMarkStep(from.pos, to.pos, this.mark);
  }
  merge(other) {
    if (other instanceof RemoveMarkStep && other.mark.eq(this.mark) && this.from <= other.to && this.to >= other.from)
      return new RemoveMarkStep(Math.min(this.from, other.from), Math.max(this.to, other.to), this.mark);
    return null;
  }
  toJSON() {
    return {
      stepType: "removeMark",
      mark: this.mark.toJSON(),
      from: this.from,
      to: this.to
    };
  }
  static fromJSON(schema, json) {
    if (typeof json.from != "number" || typeof json.to != "number")
      throw new RangeError("Invalid input for RemoveMarkStep.fromJSON");
    return new RemoveMarkStep(json.from, json.to, schema.markFromJSON(json.mark));
  }
}
Step.jsonID("removeMark", RemoveMarkStep);

class AddNodeMarkStep extends Step {
  constructor(pos, mark) {
    super();
    this.pos = pos;
    this.mark = mark;
  }
  apply(doc2) {
    let node = doc2.nodeAt(this.pos);
    if (!node)
      return StepResult.fail("No node at mark step's position");
    let updated = node.type.create(node.attrs, null, this.mark.addToSet(node.marks));
    return StepResult.fromReplace(doc2, this.pos, this.pos + 1, new Slice(Fragment.from(updated), 0, node.isLeaf ? 0 : 1));
  }
  invert(doc2) {
    let node = doc2.nodeAt(this.pos);
    if (node) {
      let newSet = this.mark.addToSet(node.marks);
      if (newSet.length == node.marks.length) {
        for (let i = 0;i < node.marks.length; i++)
          if (!node.marks[i].isInSet(newSet))
            return new AddNodeMarkStep(this.pos, node.marks[i]);
        return new AddNodeMarkStep(this.pos, this.mark);
      }
    }
    return new RemoveNodeMarkStep(this.pos, this.mark);
  }
  map(mapping) {
    let pos = mapping.mapResult(this.pos, 1);
    return pos.deletedAfter ? null : new AddNodeMarkStep(pos.pos, this.mark);
  }
  toJSON() {
    return { stepType: "addNodeMark", pos: this.pos, mark: this.mark.toJSON() };
  }
  static fromJSON(schema, json) {
    if (typeof json.pos != "number")
      throw new RangeError("Invalid input for AddNodeMarkStep.fromJSON");
    return new AddNodeMarkStep(json.pos, schema.markFromJSON(json.mark));
  }
}
Step.jsonID("addNodeMark", AddNodeMarkStep);

class RemoveNodeMarkStep extends Step {
  constructor(pos, mark) {
    super();
    this.pos = pos;
    this.mark = mark;
  }
  apply(doc2) {
    let node = doc2.nodeAt(this.pos);
    if (!node)
      return StepResult.fail("No node at mark step's position");
    let updated = node.type.create(node.attrs, null, this.mark.removeFromSet(node.marks));
    return StepResult.fromReplace(doc2, this.pos, this.pos + 1, new Slice(Fragment.from(updated), 0, node.isLeaf ? 0 : 1));
  }
  invert(doc2) {
    let node = doc2.nodeAt(this.pos);
    if (!node || !this.mark.isInSet(node.marks))
      return this;
    return new AddNodeMarkStep(this.pos, this.mark);
  }
  map(mapping) {
    let pos = mapping.mapResult(this.pos, 1);
    return pos.deletedAfter ? null : new RemoveNodeMarkStep(pos.pos, this.mark);
  }
  toJSON() {
    return { stepType: "removeNodeMark", pos: this.pos, mark: this.mark.toJSON() };
  }
  static fromJSON(schema, json) {
    if (typeof json.pos != "number")
      throw new RangeError("Invalid input for RemoveNodeMarkStep.fromJSON");
    return new RemoveNodeMarkStep(json.pos, schema.markFromJSON(json.mark));
  }
}
Step.jsonID("removeNodeMark", RemoveNodeMarkStep);

class ReplaceStep extends Step {
  constructor(from, to, slice, structure = false) {
    super();
    this.from = from;
    this.to = to;
    this.slice = slice;
    this.structure = structure;
  }
  apply(doc2) {
    if (this.structure && contentBetween(doc2, this.from, this.to))
      return StepResult.fail("Structure replace would overwrite content");
    return StepResult.fromReplace(doc2, this.from, this.to, this.slice);
  }
  getMap() {
    return new StepMap([this.from, this.to - this.from, this.slice.size]);
  }
  invert(doc2) {
    return new ReplaceStep(this.from, this.from + this.slice.size, doc2.slice(this.from, this.to));
  }
  map(mapping) {
    let from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
    if (from.deletedAcross && to.deletedAcross)
      return null;
    return new ReplaceStep(from.pos, Math.max(from.pos, to.pos), this.slice, this.structure);
  }
  merge(other) {
    if (!(other instanceof ReplaceStep) || other.structure || this.structure)
      return null;
    if (this.from + this.slice.size == other.from && !this.slice.openEnd && !other.slice.openStart) {
      let slice = this.slice.size + other.slice.size == 0 ? Slice.empty : new Slice(this.slice.content.append(other.slice.content), this.slice.openStart, other.slice.openEnd);
      return new ReplaceStep(this.from, this.to + (other.to - other.from), slice, this.structure);
    } else if (other.to == this.from && !this.slice.openStart && !other.slice.openEnd) {
      let slice = this.slice.size + other.slice.size == 0 ? Slice.empty : new Slice(other.slice.content.append(this.slice.content), other.slice.openStart, this.slice.openEnd);
      return new ReplaceStep(other.from, this.to, slice, this.structure);
    } else {
      return null;
    }
  }
  toJSON() {
    let json = { stepType: "replace", from: this.from, to: this.to };
    if (this.slice.size)
      json.slice = this.slice.toJSON();
    if (this.structure)
      json.structure = true;
    return json;
  }
  static fromJSON(schema, json) {
    if (typeof json.from != "number" || typeof json.to != "number")
      throw new RangeError("Invalid input for ReplaceStep.fromJSON");
    return new ReplaceStep(json.from, json.to, Slice.fromJSON(schema, json.slice), !!json.structure);
  }
}
Step.jsonID("replace", ReplaceStep);

class ReplaceAroundStep extends Step {
  constructor(from, to, gapFrom, gapTo, slice, insert, structure = false) {
    super();
    this.from = from;
    this.to = to;
    this.gapFrom = gapFrom;
    this.gapTo = gapTo;
    this.slice = slice;
    this.insert = insert;
    this.structure = structure;
  }
  apply(doc2) {
    if (this.structure && (contentBetween(doc2, this.from, this.gapFrom) || contentBetween(doc2, this.gapTo, this.to)))
      return StepResult.fail("Structure gap-replace would overwrite content");
    let gap = doc2.slice(this.gapFrom, this.gapTo);
    if (gap.openStart || gap.openEnd)
      return StepResult.fail("Gap is not a flat range");
    let inserted = this.slice.insertAt(this.insert, gap.content);
    if (!inserted)
      return StepResult.fail("Content does not fit in gap");
    return StepResult.fromReplace(doc2, this.from, this.to, inserted);
  }
  getMap() {
    return new StepMap([
      this.from,
      this.gapFrom - this.from,
      this.insert,
      this.gapTo,
      this.to - this.gapTo,
      this.slice.size - this.insert
    ]);
  }
  invert(doc2) {
    let gap = this.gapTo - this.gapFrom;
    return new ReplaceAroundStep(this.from, this.from + this.slice.size + gap, this.from + this.insert, this.from + this.insert + gap, doc2.slice(this.from, this.to).removeBetween(this.gapFrom - this.from, this.gapTo - this.from), this.gapFrom - this.from, this.structure);
  }
  map(mapping) {
    let from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
    let gapFrom = this.from == this.gapFrom ? from.pos : mapping.map(this.gapFrom, -1);
    let gapTo = this.to == this.gapTo ? to.pos : mapping.map(this.gapTo, 1);
    if (from.deletedAcross && to.deletedAcross || gapFrom < from.pos || gapTo > to.pos)
      return null;
    return new ReplaceAroundStep(from.pos, to.pos, gapFrom, gapTo, this.slice, this.insert, this.structure);
  }
  toJSON() {
    let json = {
      stepType: "replaceAround",
      from: this.from,
      to: this.to,
      gapFrom: this.gapFrom,
      gapTo: this.gapTo,
      insert: this.insert
    };
    if (this.slice.size)
      json.slice = this.slice.toJSON();
    if (this.structure)
      json.structure = true;
    return json;
  }
  static fromJSON(schema, json) {
    if (typeof json.from != "number" || typeof json.to != "number" || typeof json.gapFrom != "number" || typeof json.gapTo != "number" || typeof json.insert != "number")
      throw new RangeError("Invalid input for ReplaceAroundStep.fromJSON");
    return new ReplaceAroundStep(json.from, json.to, json.gapFrom, json.gapTo, Slice.fromJSON(schema, json.slice), json.insert, !!json.structure);
  }
}
Step.jsonID("replaceAround", ReplaceAroundStep);
function contentBetween(doc2, from, to) {
  let $from = doc2.resolve(from), dist = to - from, depth = $from.depth;
  while (dist > 0 && depth > 0 && $from.indexAfter(depth) == $from.node(depth).childCount) {
    depth--;
    dist--;
  }
  if (dist > 0) {
    let next = $from.node(depth).maybeChild($from.indexAfter(depth));
    while (dist > 0) {
      if (!next || next.isLeaf)
        return true;
      next = next.firstChild;
      dist--;
    }
  }
  return false;
}
function addMark(tr, from, to, mark) {
  let removed = [], added = [];
  let removing, adding;
  tr.doc.nodesBetween(from, to, (node, pos, parent) => {
    if (!node.isInline)
      return;
    let marks = node.marks;
    if (!mark.isInSet(marks) && parent.type.allowsMarkType(mark.type)) {
      let start = Math.max(pos, from), end = Math.min(pos + node.nodeSize, to);
      let newSet = mark.addToSet(marks);
      for (let i = 0;i < marks.length; i++) {
        if (!marks[i].isInSet(newSet)) {
          if (removing && removing.to == start && removing.mark.eq(marks[i]))
            removing.to = end;
          else
            removed.push(removing = new RemoveMarkStep(start, end, marks[i]));
        }
      }
      if (adding && adding.to == start)
        adding.to = end;
      else
        added.push(adding = new AddMarkStep(start, end, mark));
    }
  });
  removed.forEach((s) => tr.step(s));
  added.forEach((s) => tr.step(s));
}
function removeMark(tr, from, to, mark) {
  let matched = [], step = 0;
  tr.doc.nodesBetween(from, to, (node, pos) => {
    if (!node.isInline)
      return;
    step++;
    let toRemove = null;
    if (mark instanceof MarkType) {
      let set = node.marks, found2;
      while (found2 = mark.isInSet(set)) {
        (toRemove || (toRemove = [])).push(found2);
        set = found2.removeFromSet(set);
      }
    } else if (mark) {
      if (mark.isInSet(node.marks))
        toRemove = [mark];
    } else {
      toRemove = node.marks;
    }
    if (toRemove && toRemove.length) {
      let end = Math.min(pos + node.nodeSize, to);
      for (let i = 0;i < toRemove.length; i++) {
        let style = toRemove[i], found2;
        for (let j = 0;j < matched.length; j++) {
          let m = matched[j];
          if (m.step == step - 1 && style.eq(matched[j].style))
            found2 = m;
        }
        if (found2) {
          found2.to = end;
          found2.step = step;
        } else {
          matched.push({ style, from: Math.max(pos, from), to: end, step });
        }
      }
    }
  });
  matched.forEach((m) => tr.step(new RemoveMarkStep(m.from, m.to, m.style)));
}
function clearIncompatible(tr, pos, parentType, match = parentType.contentMatch, clearNewlines = true) {
  let node = tr.doc.nodeAt(pos);
  let replSteps = [], cur = pos + 1;
  for (let i = 0;i < node.childCount; i++) {
    let child = node.child(i), end = cur + child.nodeSize;
    let allowed = match.matchType(child.type);
    if (!allowed) {
      replSteps.push(new ReplaceStep(cur, end, Slice.empty));
    } else {
      match = allowed;
      for (let j = 0;j < child.marks.length; j++)
        if (!parentType.allowsMarkType(child.marks[j].type))
          tr.step(new RemoveMarkStep(cur, end, child.marks[j]));
      if (clearNewlines && child.isText && parentType.whitespace != "pre") {
        let m, newline = /\r?\n|\r/g, slice;
        while (m = newline.exec(child.text)) {
          if (!slice)
            slice = new Slice(Fragment.from(parentType.schema.text(" ", parentType.allowedMarks(child.marks))), 0, 0);
          replSteps.push(new ReplaceStep(cur + m.index, cur + m.index + m[0].length, slice));
        }
      }
    }
    cur = end;
  }
  if (!match.validEnd) {
    let fill = match.fillBefore(Fragment.empty, true);
    tr.replace(cur, cur, new Slice(fill, 0, 0));
  }
  for (let i = replSteps.length - 1;i >= 0; i--)
    tr.step(replSteps[i]);
}
function canCut(node, start, end) {
  return (start == 0 || node.canReplace(start, node.childCount)) && (end == node.childCount || node.canReplace(0, end));
}
function liftTarget(range) {
  let parent = range.parent;
  let content = parent.content.cutByIndex(range.startIndex, range.endIndex);
  for (let depth = range.depth, contentBefore = 0, contentAfter = 0;; --depth) {
    let node = range.$from.node(depth);
    let index = range.$from.index(depth) + contentBefore, endIndex = range.$to.indexAfter(depth) - contentAfter;
    if (depth < range.depth && node.canReplace(index, endIndex, content))
      return depth;
    if (depth == 0 || node.type.spec.isolating || !canCut(node, index, endIndex))
      break;
    if (index)
      contentBefore = 1;
    if (endIndex < node.childCount)
      contentAfter = 1;
  }
  return null;
}
function lift(tr, range, target) {
  let { $from, $to, depth } = range;
  let gapStart = $from.before(depth + 1), gapEnd = $to.after(depth + 1);
  let start = gapStart, end = gapEnd;
  let before = Fragment.empty, openStart = 0;
  for (let d = depth, splitting = false;d > target; d--)
    if (splitting || $from.index(d) > 0) {
      splitting = true;
      before = Fragment.from($from.node(d).copy(before));
      openStart++;
    } else {
      start--;
    }
  let after = Fragment.empty, openEnd = 0;
  for (let d = depth, splitting = false;d > target; d--)
    if (splitting || $to.after(d + 1) < $to.end(d)) {
      splitting = true;
      after = Fragment.from($to.node(d).copy(after));
      openEnd++;
    } else {
      end++;
    }
  tr.step(new ReplaceAroundStep(start, end, gapStart, gapEnd, new Slice(before.append(after), openStart, openEnd), before.size - openStart, true));
}
function findWrapping(range, nodeType, attrs = null, innerRange = range) {
  let around = findWrappingOutside(range, nodeType);
  let inner = around && findWrappingInside(innerRange, nodeType);
  if (!inner)
    return null;
  return around.map(withAttrs).concat({ type: nodeType, attrs }).concat(inner.map(withAttrs));
}
function withAttrs(type) {
  return { type, attrs: null };
}
function findWrappingOutside(range, type) {
  let { parent, startIndex, endIndex } = range;
  let around = parent.contentMatchAt(startIndex).findWrapping(type);
  if (!around)
    return null;
  let outer = around.length ? around[0] : type;
  return parent.canReplaceWith(startIndex, endIndex, outer) ? around : null;
}
function findWrappingInside(range, type) {
  let { parent, startIndex, endIndex } = range;
  let inner = parent.child(startIndex);
  let inside = type.contentMatch.findWrapping(inner.type);
  if (!inside)
    return null;
  let lastType = inside.length ? inside[inside.length - 1] : type;
  let innerMatch = lastType.contentMatch;
  for (let i = startIndex;innerMatch && i < endIndex; i++)
    innerMatch = innerMatch.matchType(parent.child(i).type);
  if (!innerMatch || !innerMatch.validEnd)
    return null;
  return inside;
}
function wrap(tr, range, wrappers) {
  let content = Fragment.empty;
  for (let i = wrappers.length - 1;i >= 0; i--) {
    if (content.size) {
      let match = wrappers[i].type.contentMatch.matchFragment(content);
      if (!match || !match.validEnd)
        throw new RangeError("Wrapper type given to Transform.wrap does not form valid content of its parent wrapper");
    }
    content = Fragment.from(wrappers[i].type.create(wrappers[i].attrs, content));
  }
  let { start, end } = range;
  tr.step(new ReplaceAroundStep(start, end, start, end, new Slice(content, 0, 0), wrappers.length, true));
}
function setBlockType(tr, from, to, type, attrs) {
  if (!type.isTextblock)
    throw new RangeError("Type given to setBlockType should be a textblock");
  let mapFrom = tr.steps.length;
  tr.doc.nodesBetween(from, to, (node, pos) => {
    let attrsHere = typeof attrs == "function" ? attrs(node) : attrs;
    if (node.isTextblock && !node.hasMarkup(type, attrsHere) && canChangeType(tr.doc, tr.mapping.slice(mapFrom).map(pos), type)) {
      let convertNewlines = null;
      if (type.schema.linebreakReplacement) {
        let pre = type.whitespace == "pre", supportLinebreak = !!type.contentMatch.matchType(type.schema.linebreakReplacement);
        if (pre && !supportLinebreak)
          convertNewlines = false;
        else if (!pre && supportLinebreak)
          convertNewlines = true;
      }
      if (convertNewlines === false)
        replaceLinebreaks(tr, node, pos, mapFrom);
      clearIncompatible(tr, tr.mapping.slice(mapFrom).map(pos, 1), type, undefined, convertNewlines === null);
      let mapping = tr.mapping.slice(mapFrom);
      let startM = mapping.map(pos, 1), endM = mapping.map(pos + node.nodeSize, 1);
      tr.step(new ReplaceAroundStep(startM, endM, startM + 1, endM - 1, new Slice(Fragment.from(type.create(attrsHere, null, node.marks)), 0, 0), 1, true));
      if (convertNewlines === true)
        replaceNewlines(tr, node, pos, mapFrom);
      return false;
    }
  });
}
function replaceNewlines(tr, node, pos, mapFrom) {
  node.forEach((child, offset) => {
    if (child.isText) {
      let m, newline = /\r?\n|\r/g;
      while (m = newline.exec(child.text)) {
        let start = tr.mapping.slice(mapFrom).map(pos + 1 + offset + m.index);
        tr.replaceWith(start, start + 1, node.type.schema.linebreakReplacement.create());
      }
    }
  });
}
function replaceLinebreaks(tr, node, pos, mapFrom) {
  node.forEach((child, offset) => {
    if (child.type == child.type.schema.linebreakReplacement) {
      let start = tr.mapping.slice(mapFrom).map(pos + 1 + offset);
      tr.replaceWith(start, start + 1, node.type.schema.text(`
`));
    }
  });
}
function canChangeType(doc2, pos, type) {
  let $pos = doc2.resolve(pos), index = $pos.index();
  return $pos.parent.canReplaceWith(index, index + 1, type);
}
function setNodeMarkup(tr, pos, type, attrs, marks) {
  let node = tr.doc.nodeAt(pos);
  if (!node)
    throw new RangeError("No node at given position");
  if (!type)
    type = node.type;
  let newNode = type.create(attrs, null, marks || node.marks);
  if (node.isLeaf)
    return tr.replaceWith(pos, pos + node.nodeSize, newNode);
  if (!type.validContent(node.content))
    throw new RangeError("Invalid content for node type " + type.name);
  tr.step(new ReplaceAroundStep(pos, pos + node.nodeSize, pos + 1, pos + node.nodeSize - 1, new Slice(Fragment.from(newNode), 0, 0), 1, true));
}
function canSplit(doc2, pos, depth = 1, typesAfter) {
  let $pos = doc2.resolve(pos), base = $pos.depth - depth;
  let innerType = typesAfter && typesAfter[typesAfter.length - 1] || $pos.parent;
  if (base < 0 || $pos.parent.type.spec.isolating || !$pos.parent.canReplace($pos.index(), $pos.parent.childCount) || !innerType.type.validContent($pos.parent.content.cutByIndex($pos.index(), $pos.parent.childCount)))
    return false;
  for (let d = $pos.depth - 1, i = depth - 2;d > base; d--, i--) {
    let node = $pos.node(d), index2 = $pos.index(d);
    if (node.type.spec.isolating)
      return false;
    let rest = node.content.cutByIndex(index2, node.childCount);
    let overrideChild = typesAfter && typesAfter[i + 1];
    if (overrideChild)
      rest = rest.replaceChild(0, overrideChild.type.create(overrideChild.attrs));
    let after = typesAfter && typesAfter[i] || node;
    if (!node.canReplace(index2 + 1, node.childCount) || !after.type.validContent(rest))
      return false;
  }
  let index = $pos.indexAfter(base);
  let baseType = typesAfter && typesAfter[0];
  return $pos.node(base).canReplaceWith(index, index, baseType ? baseType.type : $pos.node(base + 1).type);
}
function split(tr, pos, depth = 1, typesAfter) {
  let $pos = tr.doc.resolve(pos), before = Fragment.empty, after = Fragment.empty;
  for (let d = $pos.depth, e = $pos.depth - depth, i = depth - 1;d > e; d--, i--) {
    before = Fragment.from($pos.node(d).copy(before));
    let typeAfter = typesAfter && typesAfter[i];
    after = Fragment.from(typeAfter ? typeAfter.type.create(typeAfter.attrs, after) : $pos.node(d).copy(after));
  }
  tr.step(new ReplaceStep(pos, pos, new Slice(before.append(after), depth, depth), true));
}
function canJoin(doc2, pos) {
  let $pos = doc2.resolve(pos), index = $pos.index();
  return joinable2($pos.nodeBefore, $pos.nodeAfter) && $pos.parent.canReplace(index, index + 1);
}
function canAppendWithSubstitutedLinebreaks(a, b) {
  if (!b.content.size)
    a.type.compatibleContent(b.type);
  let match = a.contentMatchAt(a.childCount);
  let { linebreakReplacement } = a.type.schema;
  for (let i = 0;i < b.childCount; i++) {
    let child = b.child(i);
    let type = child.type == linebreakReplacement ? a.type.schema.nodes.text : child.type;
    match = match.matchType(type);
    if (!match)
      return false;
    if (!a.type.allowsMarks(child.marks))
      return false;
  }
  return match.validEnd;
}
function joinable2(a, b) {
  return !!(a && b && !a.isLeaf && canAppendWithSubstitutedLinebreaks(a, b));
}
function joinPoint(doc2, pos, dir = -1) {
  let $pos = doc2.resolve(pos);
  for (let d = $pos.depth;; d--) {
    let before, after, index = $pos.index(d);
    if (d == $pos.depth) {
      before = $pos.nodeBefore;
      after = $pos.nodeAfter;
    } else if (dir > 0) {
      before = $pos.node(d + 1);
      index++;
      after = $pos.node(d).maybeChild(index);
    } else {
      before = $pos.node(d).maybeChild(index - 1);
      after = $pos.node(d + 1);
    }
    if (before && !before.isTextblock && joinable2(before, after) && $pos.node(d).canReplace(index, index + 1))
      return pos;
    if (d == 0)
      break;
    pos = dir < 0 ? $pos.before(d) : $pos.after(d);
  }
}
function join(tr, pos, depth) {
  let convertNewlines = null;
  let { linebreakReplacement } = tr.doc.type.schema;
  let $before = tr.doc.resolve(pos - depth), beforeType = $before.node().type;
  if (linebreakReplacement && beforeType.inlineContent) {
    let pre = beforeType.whitespace == "pre";
    let supportLinebreak = !!beforeType.contentMatch.matchType(linebreakReplacement);
    if (pre && !supportLinebreak)
      convertNewlines = false;
    else if (!pre && supportLinebreak)
      convertNewlines = true;
  }
  let mapFrom = tr.steps.length;
  if (convertNewlines === false) {
    let $after = tr.doc.resolve(pos + depth);
    replaceLinebreaks(tr, $after.node(), $after.before(), mapFrom);
  }
  if (beforeType.inlineContent)
    clearIncompatible(tr, pos + depth - 1, beforeType, $before.node().contentMatchAt($before.index()), convertNewlines == null);
  let mapping = tr.mapping.slice(mapFrom), start = mapping.map(pos - depth);
  tr.step(new ReplaceStep(start, mapping.map(pos + depth, -1), Slice.empty, true));
  if (convertNewlines === true) {
    let $full = tr.doc.resolve(start);
    replaceNewlines(tr, $full.node(), $full.before(), tr.steps.length);
  }
  return tr;
}
function insertPoint(doc2, pos, nodeType) {
  let $pos = doc2.resolve(pos);
  if ($pos.parent.canReplaceWith($pos.index(), $pos.index(), nodeType))
    return pos;
  if ($pos.parentOffset == 0)
    for (let d = $pos.depth - 1;d >= 0; d--) {
      let index = $pos.index(d);
      if ($pos.node(d).canReplaceWith(index, index, nodeType))
        return $pos.before(d + 1);
      if (index > 0)
        return null;
    }
  if ($pos.parentOffset == $pos.parent.content.size)
    for (let d = $pos.depth - 1;d >= 0; d--) {
      let index = $pos.indexAfter(d);
      if ($pos.node(d).canReplaceWith(index, index, nodeType))
        return $pos.after(d + 1);
      if (index < $pos.node(d).childCount)
        return null;
    }
  return null;
}
function dropPoint(doc2, pos, slice) {
  let $pos = doc2.resolve(pos);
  if (!slice.content.size)
    return pos;
  let content = slice.content;
  for (let i = 0;i < slice.openStart; i++)
    content = content.firstChild.content;
  for (let pass = 1;pass <= (slice.openStart == 0 && slice.size ? 2 : 1); pass++) {
    for (let d = $pos.depth;d >= 0; d--) {
      let bias = d == $pos.depth ? 0 : $pos.pos <= ($pos.start(d + 1) + $pos.end(d + 1)) / 2 ? -1 : 1;
      let insertPos = $pos.index(d) + (bias > 0 ? 1 : 0);
      let parent = $pos.node(d), fits = false;
      if (pass == 1) {
        fits = parent.canReplace(insertPos, insertPos, content);
      } else {
        let wrapping = parent.contentMatchAt(insertPos).findWrapping(content.firstChild.type);
        fits = wrapping && parent.canReplaceWith(insertPos, insertPos, wrapping[0]);
      }
      if (fits)
        return bias == 0 ? $pos.pos : bias < 0 ? $pos.before(d + 1) : $pos.after(d + 1);
    }
  }
  return null;
}
function replaceStep(doc2, from, to = from, slice = Slice.empty) {
  if (from == to && !slice.size)
    return null;
  let $from = doc2.resolve(from), $to = doc2.resolve(to);
  if (fitsTrivially($from, $to, slice))
    return new ReplaceStep(from, to, slice);
  return new Fitter($from, $to, slice).fit();
}
function fitsTrivially($from, $to, slice) {
  return !slice.openStart && !slice.openEnd && $from.start() == $to.start() && $from.parent.canReplace($from.index(), $to.index(), slice.content);
}

class Fitter {
  constructor($from, $to, unplaced) {
    this.$from = $from;
    this.$to = $to;
    this.unplaced = unplaced;
    this.frontier = [];
    this.placed = Fragment.empty;
    for (let i = 0;i <= $from.depth; i++) {
      let node = $from.node(i);
      this.frontier.push({
        type: node.type,
        match: node.contentMatchAt($from.indexAfter(i))
      });
    }
    for (let i = $from.depth;i > 0; i--)
      this.placed = Fragment.from($from.node(i).copy(this.placed));
  }
  get depth() {
    return this.frontier.length - 1;
  }
  fit() {
    while (this.unplaced.size) {
      let fit = this.findFittable();
      if (fit)
        this.placeNodes(fit);
      else
        this.openMore() || this.dropNode();
    }
    let moveInline = this.mustMoveInline(), placedSize = this.placed.size - this.depth - this.$from.depth;
    let $from = this.$from, $to = this.close(moveInline < 0 ? this.$to : $from.doc.resolve(moveInline));
    if (!$to)
      return null;
    let content = this.placed, openStart = $from.depth, openEnd = $to.depth;
    while (openStart && openEnd && content.childCount == 1) {
      content = content.firstChild.content;
      openStart--;
      openEnd--;
    }
    let slice = new Slice(content, openStart, openEnd);
    if (moveInline > -1)
      return new ReplaceAroundStep($from.pos, moveInline, this.$to.pos, this.$to.end(), slice, placedSize);
    if (slice.size || $from.pos != this.$to.pos)
      return new ReplaceStep($from.pos, $to.pos, slice);
    return null;
  }
  findFittable() {
    let startDepth = this.unplaced.openStart;
    for (let cur = this.unplaced.content, d = 0, openEnd = this.unplaced.openEnd;d < startDepth; d++) {
      let node = cur.firstChild;
      if (cur.childCount > 1)
        openEnd = 0;
      if (node.type.spec.isolating && openEnd <= d) {
        startDepth = d;
        break;
      }
      cur = node.content;
    }
    for (let pass = 1;pass <= 2; pass++) {
      for (let sliceDepth = pass == 1 ? startDepth : this.unplaced.openStart;sliceDepth >= 0; sliceDepth--) {
        let fragment, parent = null;
        if (sliceDepth) {
          parent = contentAt(this.unplaced.content, sliceDepth - 1).firstChild;
          fragment = parent.content;
        } else {
          fragment = this.unplaced.content;
        }
        let first = fragment.firstChild;
        for (let frontierDepth = this.depth;frontierDepth >= 0; frontierDepth--) {
          let { type, match } = this.frontier[frontierDepth], wrap2, inject = null;
          if (pass == 1 && (first ? match.matchType(first.type) || (inject = match.fillBefore(Fragment.from(first), false)) : parent && type.compatibleContent(parent.type)))
            return { sliceDepth, frontierDepth, parent, inject };
          else if (pass == 2 && first && (wrap2 = match.findWrapping(first.type)))
            return { sliceDepth, frontierDepth, parent, wrap: wrap2 };
          if (parent && match.matchType(parent.type))
            break;
        }
      }
    }
  }
  openMore() {
    let { content, openStart, openEnd } = this.unplaced;
    let inner = contentAt(content, openStart);
    if (!inner.childCount || inner.firstChild.isLeaf)
      return false;
    this.unplaced = new Slice(content, openStart + 1, Math.max(openEnd, inner.size + openStart >= content.size - openEnd ? openStart + 1 : 0));
    return true;
  }
  dropNode() {
    let { content, openStart, openEnd } = this.unplaced;
    let inner = contentAt(content, openStart);
    if (inner.childCount <= 1 && openStart > 0) {
      let openAtEnd = content.size - openStart <= openStart + inner.size;
      this.unplaced = new Slice(dropFromFragment(content, openStart - 1, 1), openStart - 1, openAtEnd ? openStart - 1 : openEnd);
    } else {
      this.unplaced = new Slice(dropFromFragment(content, openStart, 1), openStart, openEnd);
    }
  }
  placeNodes({ sliceDepth, frontierDepth, parent, inject, wrap: wrap2 }) {
    while (this.depth > frontierDepth)
      this.closeFrontierNode();
    if (wrap2)
      for (let i = 0;i < wrap2.length; i++)
        this.openFrontierNode(wrap2[i]);
    let slice = this.unplaced, fragment = parent ? parent.content : slice.content;
    let openStart = slice.openStart - sliceDepth;
    let taken = 0, add = [];
    let { match, type } = this.frontier[frontierDepth];
    if (inject) {
      for (let i = 0;i < inject.childCount; i++)
        add.push(inject.child(i));
      match = match.matchFragment(inject);
    }
    let openEndCount = fragment.size + sliceDepth - (slice.content.size - slice.openEnd);
    while (taken < fragment.childCount) {
      let next = fragment.child(taken), matches2 = match.matchType(next.type);
      if (!matches2)
        break;
      taken++;
      if (taken > 1 || openStart == 0 || next.content.size) {
        match = matches2;
        add.push(closeNodeStart(next.mark(type.allowedMarks(next.marks)), taken == 1 ? openStart : 0, taken == fragment.childCount ? openEndCount : -1));
      }
    }
    let toEnd = taken == fragment.childCount;
    if (!toEnd)
      openEndCount = -1;
    this.placed = addToFragment(this.placed, frontierDepth, Fragment.from(add));
    this.frontier[frontierDepth].match = match;
    if (toEnd && openEndCount < 0 && parent && parent.type == this.frontier[this.depth].type && this.frontier.length > 1)
      this.closeFrontierNode();
    for (let i = 0, cur = fragment;i < openEndCount; i++) {
      let node = cur.lastChild;
      this.frontier.push({ type: node.type, match: node.contentMatchAt(node.childCount) });
      cur = node.content;
    }
    this.unplaced = !toEnd ? new Slice(dropFromFragment(slice.content, sliceDepth, taken), slice.openStart, slice.openEnd) : sliceDepth == 0 ? Slice.empty : new Slice(dropFromFragment(slice.content, sliceDepth - 1, 1), sliceDepth - 1, openEndCount < 0 ? slice.openEnd : sliceDepth - 1);
  }
  mustMoveInline() {
    if (!this.$to.parent.isTextblock)
      return -1;
    let top = this.frontier[this.depth], level;
    if (!top.type.isTextblock || !contentAfterFits(this.$to, this.$to.depth, top.type, top.match, false) || this.$to.depth == this.depth && (level = this.findCloseLevel(this.$to)) && level.depth == this.depth)
      return -1;
    let { depth } = this.$to, after = this.$to.after(depth);
    while (depth > 1 && after == this.$to.end(--depth))
      ++after;
    return after;
  }
  findCloseLevel($to) {
    scan:
      for (let i = Math.min(this.depth, $to.depth);i >= 0; i--) {
        let { match, type } = this.frontier[i];
        let dropInner = i < $to.depth && $to.end(i + 1) == $to.pos + ($to.depth - (i + 1));
        let fit = contentAfterFits($to, i, type, match, dropInner);
        if (!fit)
          continue;
        for (let d = i - 1;d >= 0; d--) {
          let { match: match2, type: type2 } = this.frontier[d];
          let matches2 = contentAfterFits($to, d, type2, match2, true);
          if (!matches2 || matches2.childCount)
            continue scan;
        }
        return { depth: i, fit, move: dropInner ? $to.doc.resolve($to.after(i + 1)) : $to };
      }
  }
  close($to) {
    let close2 = this.findCloseLevel($to);
    if (!close2)
      return null;
    while (this.depth > close2.depth)
      this.closeFrontierNode();
    if (close2.fit.childCount)
      this.placed = addToFragment(this.placed, close2.depth, close2.fit);
    $to = close2.move;
    for (let d = close2.depth + 1;d <= $to.depth; d++) {
      let node = $to.node(d), add = node.type.contentMatch.fillBefore(node.content, true, $to.index(d));
      this.openFrontierNode(node.type, node.attrs, add);
    }
    return $to;
  }
  openFrontierNode(type, attrs = null, content) {
    let top = this.frontier[this.depth];
    top.match = top.match.matchType(type);
    this.placed = addToFragment(this.placed, this.depth, Fragment.from(type.create(attrs, content)));
    this.frontier.push({ type, match: type.contentMatch });
  }
  closeFrontierNode() {
    let open2 = this.frontier.pop();
    let add = open2.match.fillBefore(Fragment.empty, true);
    if (add.childCount)
      this.placed = addToFragment(this.placed, this.frontier.length, add);
  }
}
function dropFromFragment(fragment, depth, count) {
  if (depth == 0)
    return fragment.cutByIndex(count, fragment.childCount);
  return fragment.replaceChild(0, fragment.firstChild.copy(dropFromFragment(fragment.firstChild.content, depth - 1, count)));
}
function addToFragment(fragment, depth, content) {
  if (depth == 0)
    return fragment.append(content);
  return fragment.replaceChild(fragment.childCount - 1, fragment.lastChild.copy(addToFragment(fragment.lastChild.content, depth - 1, content)));
}
function contentAt(fragment, depth) {
  for (let i = 0;i < depth; i++)
    fragment = fragment.firstChild.content;
  return fragment;
}
function closeNodeStart(node, openStart, openEnd) {
  if (openStart <= 0)
    return node;
  let frag = node.content;
  if (openStart > 1)
    frag = frag.replaceChild(0, closeNodeStart(frag.firstChild, openStart - 1, frag.childCount == 1 ? openEnd - 1 : 0));
  if (openStart > 0) {
    frag = node.type.contentMatch.fillBefore(frag).append(frag);
    if (openEnd <= 0)
      frag = frag.append(node.type.contentMatch.matchFragment(frag).fillBefore(Fragment.empty, true));
  }
  return node.copy(frag);
}
function contentAfterFits($to, depth, type, match, open2) {
  let node = $to.node(depth), index = open2 ? $to.indexAfter(depth) : $to.index(depth);
  if (index == node.childCount && !type.compatibleContent(node.type))
    return null;
  let fit = match.fillBefore(node.content, true, index);
  return fit && !invalidMarks(type, node.content, index) ? fit : null;
}
function invalidMarks(type, fragment, start) {
  for (let i = start;i < fragment.childCount; i++)
    if (!type.allowsMarks(fragment.child(i).marks))
      return true;
  return false;
}
function definesContent(type) {
  return type.spec.defining || type.spec.definingForContent;
}
function replaceRange(tr, from, to, slice) {
  if (!slice.size)
    return tr.deleteRange(from, to);
  let $from = tr.doc.resolve(from), $to = tr.doc.resolve(to);
  if (fitsTrivially($from, $to, slice))
    return tr.step(new ReplaceStep(from, to, slice));
  let targetDepths = coveredDepths($from, $to);
  if (targetDepths[targetDepths.length - 1] == 0)
    targetDepths.pop();
  let preferredTarget = -($from.depth + 1);
  targetDepths.unshift(preferredTarget);
  for (let d = $from.depth, pos = $from.pos - 1;d > 0; d--, pos--) {
    let spec = $from.node(d).type.spec;
    if (spec.defining || spec.definingAsContext || spec.isolating)
      break;
    if (targetDepths.indexOf(d) > -1)
      preferredTarget = d;
    else if ($from.before(d) == pos)
      targetDepths.splice(1, 0, -d);
  }
  let preferredTargetIndex = targetDepths.indexOf(preferredTarget);
  let leftNodes = [], preferredDepth = slice.openStart;
  for (let content = slice.content, i = 0;; i++) {
    let node = content.firstChild;
    leftNodes.push(node);
    if (i == slice.openStart)
      break;
    content = node.content;
  }
  for (let d = preferredDepth - 1;d >= 0; d--) {
    let leftNode = leftNodes[d], def = definesContent(leftNode.type);
    if (def && !leftNode.sameMarkup($from.node(Math.abs(preferredTarget) - 1)))
      preferredDepth = d;
    else if (def || !leftNode.type.isTextblock)
      break;
  }
  for (let j = slice.openStart;j >= 0; j--) {
    let openDepth = (j + preferredDepth + 1) % (slice.openStart + 1);
    let insert = leftNodes[openDepth];
    if (!insert)
      continue;
    for (let i = 0;i < targetDepths.length; i++) {
      let targetDepth = targetDepths[(i + preferredTargetIndex) % targetDepths.length], expand = true;
      if (targetDepth < 0) {
        expand = false;
        targetDepth = -targetDepth;
      }
      let parent = $from.node(targetDepth - 1), index = $from.index(targetDepth - 1);
      if (parent.canReplaceWith(index, index, insert.type, insert.marks))
        return tr.replace($from.before(targetDepth), expand ? $to.after(targetDepth) : to, new Slice(closeFragment(slice.content, 0, slice.openStart, openDepth), openDepth, slice.openEnd));
    }
  }
  let startSteps = tr.steps.length;
  for (let i = targetDepths.length - 1;i >= 0; i--) {
    tr.replace(from, to, slice);
    if (tr.steps.length > startSteps)
      break;
    let depth = targetDepths[i];
    if (depth < 0)
      continue;
    from = $from.before(depth);
    to = $to.after(depth);
  }
}
function closeFragment(fragment, depth, oldOpen, newOpen, parent) {
  if (depth < oldOpen) {
    let first = fragment.firstChild;
    fragment = fragment.replaceChild(0, first.copy(closeFragment(first.content, depth + 1, oldOpen, newOpen, first)));
  }
  if (depth > newOpen) {
    let match = parent.contentMatchAt(0);
    let start = match.fillBefore(fragment).append(fragment);
    fragment = start.append(match.matchFragment(start).fillBefore(Fragment.empty, true));
  }
  return fragment;
}
function replaceRangeWith(tr, from, to, node) {
  if (!node.isInline && from == to && tr.doc.resolve(from).parent.content.size) {
    let point = insertPoint(tr.doc, from, node.type);
    if (point != null)
      from = to = point;
  }
  tr.replaceRange(from, to, new Slice(Fragment.from(node), 0, 0));
}
function deleteRange(tr, from, to) {
  let $from = tr.doc.resolve(from), $to = tr.doc.resolve(to);
  let covered = coveredDepths($from, $to);
  for (let i = 0;i < covered.length; i++) {
    let depth = covered[i], last = i == covered.length - 1;
    if (last && depth == 0 || $from.node(depth).type.contentMatch.validEnd)
      return tr.delete($from.start(depth), $to.end(depth));
    if (depth > 0 && (last || $from.node(depth - 1).canReplace($from.index(depth - 1), $to.indexAfter(depth - 1))))
      return tr.delete($from.before(depth), $to.after(depth));
  }
  for (let d = 1;d <= $from.depth && d <= $to.depth; d++) {
    if (from - $from.start(d) == $from.depth - d && to > $from.end(d) && $to.end(d) - to != $to.depth - d && $from.start(d - 1) == $to.start(d - 1) && $from.node(d - 1).canReplace($from.index(d - 1), $to.index(d - 1)))
      return tr.delete($from.before(d), to);
  }
  tr.delete(from, to);
}
function coveredDepths($from, $to) {
  let result = [], minDepth = Math.min($from.depth, $to.depth);
  for (let d = minDepth;d >= 0; d--) {
    let start = $from.start(d);
    if (start < $from.pos - ($from.depth - d) || $to.end(d) > $to.pos + ($to.depth - d) || $from.node(d).type.spec.isolating || $to.node(d).type.spec.isolating)
      break;
    if (start == $to.start(d) || d == $from.depth && d == $to.depth && $from.parent.inlineContent && $to.parent.inlineContent && d && $to.start(d - 1) == start - 1)
      result.push(d);
  }
  return result;
}

class AttrStep extends Step {
  constructor(pos, attr, value) {
    super();
    this.pos = pos;
    this.attr = attr;
    this.value = value;
  }
  apply(doc2) {
    let node = doc2.nodeAt(this.pos);
    if (!node)
      return StepResult.fail("No node at attribute step's position");
    let attrs = Object.create(null);
    for (let name in node.attrs)
      attrs[name] = node.attrs[name];
    attrs[this.attr] = this.value;
    let updated = node.type.create(attrs, null, node.marks);
    return StepResult.fromReplace(doc2, this.pos, this.pos + 1, new Slice(Fragment.from(updated), 0, node.isLeaf ? 0 : 1));
  }
  getMap() {
    return StepMap.empty;
  }
  invert(doc2) {
    return new AttrStep(this.pos, this.attr, doc2.nodeAt(this.pos).attrs[this.attr]);
  }
  map(mapping) {
    let pos = mapping.mapResult(this.pos, 1);
    return pos.deletedAfter ? null : new AttrStep(pos.pos, this.attr, this.value);
  }
  toJSON() {
    return { stepType: "attr", pos: this.pos, attr: this.attr, value: this.value };
  }
  static fromJSON(schema, json) {
    if (typeof json.pos != "number" || typeof json.attr != "string")
      throw new RangeError("Invalid input for AttrStep.fromJSON");
    return new AttrStep(json.pos, json.attr, json.value);
  }
}
Step.jsonID("attr", AttrStep);

class DocAttrStep extends Step {
  constructor(attr, value) {
    super();
    this.attr = attr;
    this.value = value;
  }
  apply(doc2) {
    let attrs = Object.create(null);
    for (let name in doc2.attrs)
      attrs[name] = doc2.attrs[name];
    attrs[this.attr] = this.value;
    let updated = doc2.type.create(attrs, doc2.content, doc2.marks);
    return StepResult.ok(updated);
  }
  getMap() {
    return StepMap.empty;
  }
  invert(doc2) {
    return new DocAttrStep(this.attr, doc2.attrs[this.attr]);
  }
  map(mapping) {
    return this;
  }
  toJSON() {
    return { stepType: "docAttr", attr: this.attr, value: this.value };
  }
  static fromJSON(schema, json) {
    if (typeof json.attr != "string")
      throw new RangeError("Invalid input for DocAttrStep.fromJSON");
    return new DocAttrStep(json.attr, json.value);
  }
}
Step.jsonID("docAttr", DocAttrStep);
var TransformError = class extends Error {
};
TransformError = function TransformError2(message) {
  let err = Error.call(this, message);
  err.__proto__ = TransformError2.prototype;
  return err;
};
TransformError.prototype = Object.create(Error.prototype);
TransformError.prototype.constructor = TransformError;
TransformError.prototype.name = "TransformError";

class Transform {
  constructor(doc2) {
    this.doc = doc2;
    this.steps = [];
    this.docs = [];
    this.mapping = new Mapping;
  }
  get before() {
    return this.docs.length ? this.docs[0] : this.doc;
  }
  step(step) {
    let result = this.maybeStep(step);
    if (result.failed)
      throw new TransformError(result.failed);
    return this;
  }
  maybeStep(step) {
    let result = step.apply(this.doc);
    if (!result.failed)
      this.addStep(step, result.doc);
    return result;
  }
  get docChanged() {
    return this.steps.length > 0;
  }
  changedRange() {
    let from = 1e9, to = -1e9;
    for (let i = 0;i < this.mapping.maps.length; i++) {
      let map = this.mapping.maps[i];
      if (i) {
        from = map.map(from, 1);
        to = map.map(to, -1);
      }
      map.forEach((_f, _t, fromB, toB) => {
        from = Math.min(from, fromB);
        to = Math.max(to, toB);
      });
    }
    return from == 1e9 ? null : { from, to };
  }
  addStep(step, doc2) {
    this.docs.push(this.doc);
    this.steps.push(step);
    this.mapping.appendMap(step.getMap());
    this.doc = doc2;
  }
  replace(from, to = from, slice = Slice.empty) {
    let step = replaceStep(this.doc, from, to, slice);
    if (step)
      this.step(step);
    return this;
  }
  replaceWith(from, to, content) {
    return this.replace(from, to, new Slice(Fragment.from(content), 0, 0));
  }
  delete(from, to) {
    return this.replace(from, to, Slice.empty);
  }
  insert(pos, content) {
    return this.replaceWith(pos, pos, content);
  }
  replaceRange(from, to, slice) {
    replaceRange(this, from, to, slice);
    return this;
  }
  replaceRangeWith(from, to, node) {
    replaceRangeWith(this, from, to, node);
    return this;
  }
  deleteRange(from, to) {
    deleteRange(this, from, to);
    return this;
  }
  lift(range, target) {
    lift(this, range, target);
    return this;
  }
  join(pos, depth = 1) {
    join(this, pos, depth);
    return this;
  }
  wrap(range, wrappers) {
    wrap(this, range, wrappers);
    return this;
  }
  setBlockType(from, to = from, type, attrs = null) {
    setBlockType(this, from, to, type, attrs);
    return this;
  }
  setNodeMarkup(pos, type, attrs = null, marks) {
    setNodeMarkup(this, pos, type, attrs, marks);
    return this;
  }
  setNodeAttribute(pos, attr, value) {
    this.step(new AttrStep(pos, attr, value));
    return this;
  }
  setDocAttribute(attr, value) {
    this.step(new DocAttrStep(attr, value));
    return this;
  }
  addNodeMark(pos, mark) {
    this.step(new AddNodeMarkStep(pos, mark));
    return this;
  }
  removeNodeMark(pos, mark) {
    let node = this.doc.nodeAt(pos);
    if (!node)
      throw new RangeError("No node at position " + pos);
    if (mark instanceof Mark) {
      if (mark.isInSet(node.marks))
        this.step(new RemoveNodeMarkStep(pos, mark));
    } else {
      let set = node.marks, found2, steps = [];
      while (found2 = mark.isInSet(set)) {
        steps.push(new RemoveNodeMarkStep(pos, found2));
        set = found2.removeFromSet(set);
      }
      for (let i = steps.length - 1;i >= 0; i--)
        this.step(steps[i]);
    }
    return this;
  }
  split(pos, depth = 1, typesAfter) {
    split(this, pos, depth, typesAfter);
    return this;
  }
  addMark(from, to, mark) {
    addMark(this, from, to, mark);
    return this;
  }
  removeMark(from, to, mark) {
    removeMark(this, from, to, mark);
    return this;
  }
  clearIncompatible(pos, parentType, match) {
    clearIncompatible(this, pos, parentType, match);
    return this;
  }
}

// node_modules/prosemirror-state/dist/index.js
var classesById = Object.create(null);

class Selection {
  constructor($anchor, $head, ranges) {
    this.$anchor = $anchor;
    this.$head = $head;
    this.ranges = ranges || [new SelectionRange($anchor.min($head), $anchor.max($head))];
  }
  get anchor() {
    return this.$anchor.pos;
  }
  get head() {
    return this.$head.pos;
  }
  get from() {
    return this.$from.pos;
  }
  get to() {
    return this.$to.pos;
  }
  get $from() {
    return this.ranges[0].$from;
  }
  get $to() {
    return this.ranges[0].$to;
  }
  get empty() {
    let ranges = this.ranges;
    for (let i = 0;i < ranges.length; i++)
      if (ranges[i].$from.pos != ranges[i].$to.pos)
        return false;
    return true;
  }
  content() {
    return this.$from.doc.slice(this.from, this.to, true);
  }
  replace(tr, content = Slice.empty) {
    let lastNode = content.content.lastChild, lastParent = null;
    for (let i = 0;i < content.openEnd; i++) {
      lastParent = lastNode;
      lastNode = lastNode.lastChild;
    }
    let mapFrom = tr.steps.length, ranges = this.ranges;
    for (let i = 0;i < ranges.length; i++) {
      let { $from, $to } = ranges[i], mapping = tr.mapping.slice(mapFrom);
      tr.replaceRange(mapping.map($from.pos), mapping.map($to.pos), i ? Slice.empty : content);
      if (i == 0)
        selectionToInsertionEnd(tr, mapFrom, (lastNode ? lastNode.isInline : lastParent && lastParent.isTextblock) ? -1 : 1);
    }
  }
  replaceWith(tr, node) {
    let mapFrom = tr.steps.length, ranges = this.ranges;
    for (let i = 0;i < ranges.length; i++) {
      let { $from, $to } = ranges[i], mapping = tr.mapping.slice(mapFrom);
      let from = mapping.map($from.pos), to = mapping.map($to.pos);
      if (i) {
        tr.deleteRange(from, to);
      } else {
        tr.replaceRangeWith(from, to, node);
        selectionToInsertionEnd(tr, mapFrom, node.isInline ? -1 : 1);
      }
    }
  }
  static findFrom($pos, dir, textOnly = false) {
    let inner = $pos.parent.inlineContent ? new TextSelection($pos) : findSelectionIn($pos.node(0), $pos.parent, $pos.pos, $pos.index(), dir, textOnly);
    if (inner)
      return inner;
    for (let depth = $pos.depth - 1;depth >= 0; depth--) {
      let found2 = dir < 0 ? findSelectionIn($pos.node(0), $pos.node(depth), $pos.before(depth + 1), $pos.index(depth), dir, textOnly) : findSelectionIn($pos.node(0), $pos.node(depth), $pos.after(depth + 1), $pos.index(depth) + 1, dir, textOnly);
      if (found2)
        return found2;
    }
    return null;
  }
  static near($pos, bias = 1) {
    return this.findFrom($pos, bias) || this.findFrom($pos, -bias) || new AllSelection($pos.node(0));
  }
  static atStart(doc2) {
    return findSelectionIn(doc2, doc2, 0, 0, 1) || new AllSelection(doc2);
  }
  static atEnd(doc2) {
    return findSelectionIn(doc2, doc2, doc2.content.size, doc2.childCount, -1) || new AllSelection(doc2);
  }
  static fromJSON(doc2, json) {
    if (!json || !json.type)
      throw new RangeError("Invalid input for Selection.fromJSON");
    let cls = classesById[json.type];
    if (!cls)
      throw new RangeError(`No selection type ${json.type} defined`);
    return cls.fromJSON(doc2, json);
  }
  static jsonID(id, selectionClass) {
    if (id in classesById)
      throw new RangeError("Duplicate use of selection JSON ID " + id);
    classesById[id] = selectionClass;
    selectionClass.prototype.jsonID = id;
    return selectionClass;
  }
  getBookmark() {
    return TextSelection.between(this.$anchor, this.$head).getBookmark();
  }
}
Selection.prototype.visible = true;

class SelectionRange {
  constructor($from, $to) {
    this.$from = $from;
    this.$to = $to;
  }
}
var warnedAboutTextSelection = false;
function checkTextSelection($pos) {
  if (!warnedAboutTextSelection && !$pos.parent.inlineContent) {
    warnedAboutTextSelection = true;
    console["warn"]("TextSelection endpoint not pointing into a node with inline content (" + $pos.parent.type.name + ")");
  }
}

class TextSelection extends Selection {
  constructor($anchor, $head = $anchor) {
    checkTextSelection($anchor);
    checkTextSelection($head);
    super($anchor, $head);
  }
  get $cursor() {
    return this.$anchor.pos == this.$head.pos ? this.$head : null;
  }
  map(doc2, mapping) {
    let $head = doc2.resolve(mapping.map(this.head));
    if (!$head.parent.inlineContent)
      return Selection.near($head);
    let $anchor = doc2.resolve(mapping.map(this.anchor));
    return new TextSelection($anchor.parent.inlineContent ? $anchor : $head, $head);
  }
  replace(tr, content = Slice.empty) {
    super.replace(tr, content);
    if (content == Slice.empty) {
      let marks = this.$from.marksAcross(this.$to);
      if (marks)
        tr.ensureMarks(marks);
    }
  }
  eq(other) {
    return other instanceof TextSelection && other.anchor == this.anchor && other.head == this.head;
  }
  getBookmark() {
    return new TextBookmark(this.anchor, this.head);
  }
  toJSON() {
    return { type: "text", anchor: this.anchor, head: this.head };
  }
  static fromJSON(doc2, json) {
    if (typeof json.anchor != "number" || typeof json.head != "number")
      throw new RangeError("Invalid input for TextSelection.fromJSON");
    return new TextSelection(doc2.resolve(json.anchor), doc2.resolve(json.head));
  }
  static create(doc2, anchor, head = anchor) {
    let $anchor = doc2.resolve(anchor);
    return new this($anchor, head == anchor ? $anchor : doc2.resolve(head));
  }
  static between($anchor, $head, bias) {
    let dPos = $anchor.pos - $head.pos;
    if (!bias || dPos)
      bias = dPos >= 0 ? 1 : -1;
    if (!$head.parent.inlineContent) {
      let found2 = Selection.findFrom($head, bias, true) || Selection.findFrom($head, -bias, true);
      if (found2)
        $head = found2.$head;
      else
        return Selection.near($head, bias);
    }
    if (!$anchor.parent.inlineContent) {
      if (dPos == 0) {
        $anchor = $head;
      } else {
        $anchor = (Selection.findFrom($anchor, -bias, true) || Selection.findFrom($anchor, bias, true)).$anchor;
        if ($anchor.pos < $head.pos != dPos < 0)
          $anchor = $head;
      }
    }
    return new TextSelection($anchor, $head);
  }
}
Selection.jsonID("text", TextSelection);

class TextBookmark {
  constructor(anchor, head) {
    this.anchor = anchor;
    this.head = head;
  }
  map(mapping) {
    return new TextBookmark(mapping.map(this.anchor), mapping.map(this.head));
  }
  resolve(doc2) {
    return TextSelection.between(doc2.resolve(this.anchor), doc2.resolve(this.head));
  }
}

class NodeSelection extends Selection {
  constructor($pos) {
    let node = $pos.nodeAfter;
    let $end = $pos.node(0).resolve($pos.pos + node.nodeSize);
    super($pos, $end);
    this.node = node;
  }
  map(doc2, mapping) {
    let { deleted, pos } = mapping.mapResult(this.anchor);
    let $pos = doc2.resolve(pos);
    if (deleted)
      return Selection.near($pos);
    return new NodeSelection($pos);
  }
  content() {
    return new Slice(Fragment.from(this.node), 0, 0);
  }
  eq(other) {
    return other instanceof NodeSelection && other.anchor == this.anchor;
  }
  toJSON() {
    return { type: "node", anchor: this.anchor };
  }
  getBookmark() {
    return new NodeBookmark(this.anchor);
  }
  static fromJSON(doc2, json) {
    if (typeof json.anchor != "number")
      throw new RangeError("Invalid input for NodeSelection.fromJSON");
    return new NodeSelection(doc2.resolve(json.anchor));
  }
  static create(doc2, from) {
    return new NodeSelection(doc2.resolve(from));
  }
  static isSelectable(node) {
    return !node.isText && node.type.spec.selectable !== false;
  }
}
NodeSelection.prototype.visible = false;
Selection.jsonID("node", NodeSelection);

class NodeBookmark {
  constructor(anchor) {
    this.anchor = anchor;
  }
  map(mapping) {
    let { deleted, pos } = mapping.mapResult(this.anchor);
    return deleted ? new TextBookmark(pos, pos) : new NodeBookmark(pos);
  }
  resolve(doc2) {
    let $pos = doc2.resolve(this.anchor), node = $pos.nodeAfter;
    if (node && NodeSelection.isSelectable(node))
      return new NodeSelection($pos);
    return Selection.near($pos);
  }
}

class AllSelection extends Selection {
  constructor(doc2) {
    super(doc2.resolve(0), doc2.resolve(doc2.content.size));
  }
  replace(tr, content = Slice.empty) {
    if (content == Slice.empty) {
      tr.delete(0, tr.doc.content.size);
      let sel = Selection.atStart(tr.doc);
      if (!sel.eq(tr.selection))
        tr.setSelection(sel);
    } else {
      super.replace(tr, content);
    }
  }
  toJSON() {
    return { type: "all" };
  }
  static fromJSON(doc2) {
    return new AllSelection(doc2);
  }
  map(doc2) {
    return new AllSelection(doc2);
  }
  eq(other) {
    return other instanceof AllSelection;
  }
  getBookmark() {
    return AllBookmark;
  }
}
Selection.jsonID("all", AllSelection);
var AllBookmark = {
  map() {
    return this;
  },
  resolve(doc2) {
    return new AllSelection(doc2);
  }
};
function findSelectionIn(doc2, node, pos, index, dir, text = false) {
  if (node.inlineContent)
    return TextSelection.create(doc2, pos);
  for (let i = index - (dir > 0 ? 0 : 1);dir > 0 ? i < node.childCount : i >= 0; i += dir) {
    let child = node.child(i);
    if (!child.isAtom) {
      let inner = findSelectionIn(doc2, child, pos + dir, dir < 0 ? child.childCount : 0, dir, text);
      if (inner)
        return inner;
    } else if (!text && NodeSelection.isSelectable(child)) {
      return NodeSelection.create(doc2, pos - (dir < 0 ? child.nodeSize : 0));
    }
    pos += child.nodeSize * dir;
  }
  return null;
}
function selectionToInsertionEnd(tr, startLen, bias) {
  let last = tr.steps.length - 1;
  if (last < startLen)
    return;
  let step = tr.steps[last];
  if (!(step instanceof ReplaceStep || step instanceof ReplaceAroundStep))
    return;
  let map = tr.mapping.maps[last], end;
  map.forEach((_from, _to, _newFrom, newTo) => {
    if (end == null)
      end = newTo;
  });
  tr.setSelection(Selection.near(tr.doc.resolve(end), bias));
}
var UPDATED_SEL = 1;
var UPDATED_MARKS = 2;
var UPDATED_SCROLL = 4;

class Transaction extends Transform {
  constructor(state) {
    super(state.doc);
    this.curSelectionFor = 0;
    this.updated = 0;
    this.meta = Object.create(null);
    this.time = Date.now();
    this.curSelection = state.selection;
    this.storedMarks = state.storedMarks;
  }
  get selection() {
    if (this.curSelectionFor < this.steps.length) {
      this.curSelection = this.curSelection.map(this.doc, this.mapping.slice(this.curSelectionFor));
      this.curSelectionFor = this.steps.length;
    }
    return this.curSelection;
  }
  setSelection(selection) {
    if (selection.$from.doc != this.doc)
      throw new RangeError("Selection passed to setSelection must point at the current document");
    this.curSelection = selection;
    this.curSelectionFor = this.steps.length;
    this.updated = (this.updated | UPDATED_SEL) & ~UPDATED_MARKS;
    this.storedMarks = null;
    return this;
  }
  get selectionSet() {
    return (this.updated & UPDATED_SEL) > 0;
  }
  setStoredMarks(marks) {
    this.storedMarks = marks;
    this.updated |= UPDATED_MARKS;
    return this;
  }
  ensureMarks(marks) {
    if (!Mark.sameSet(this.storedMarks || this.selection.$from.marks(), marks))
      this.setStoredMarks(marks);
    return this;
  }
  addStoredMark(mark) {
    return this.ensureMarks(mark.addToSet(this.storedMarks || this.selection.$head.marks()));
  }
  removeStoredMark(mark) {
    return this.ensureMarks(mark.removeFromSet(this.storedMarks || this.selection.$head.marks()));
  }
  get storedMarksSet() {
    return (this.updated & UPDATED_MARKS) > 0;
  }
  addStep(step, doc2) {
    super.addStep(step, doc2);
    this.updated = this.updated & ~UPDATED_MARKS;
    this.storedMarks = null;
  }
  setTime(time) {
    this.time = time;
    return this;
  }
  replaceSelection(slice) {
    this.selection.replace(this, slice);
    return this;
  }
  replaceSelectionWith(node, inheritMarks = true) {
    let selection = this.selection;
    if (inheritMarks)
      node = node.mark(this.storedMarks || (selection.empty ? selection.$from.marks() : selection.$from.marksAcross(selection.$to) || Mark.none));
    selection.replaceWith(this, node);
    return this;
  }
  deleteSelection() {
    this.selection.replace(this);
    return this;
  }
  insertText(text, from, to) {
    let schema = this.doc.type.schema;
    if (from == null) {
      if (!text)
        return this.deleteSelection();
      return this.replaceSelectionWith(schema.text(text), true);
    } else {
      if (to == null)
        to = from;
      if (!text)
        return this.deleteRange(from, to);
      let marks = this.storedMarks;
      if (!marks) {
        let $from = this.doc.resolve(from);
        marks = to == from ? $from.marks() : $from.marksAcross(this.doc.resolve(to));
      }
      this.replaceRangeWith(from, to, schema.text(text, marks));
      if (!this.selection.empty && this.selection.to == from + text.length)
        this.setSelection(Selection.near(this.selection.$to));
      return this;
    }
  }
  setMeta(key, value) {
    this.meta[typeof key == "string" ? key : key.key] = value;
    return this;
  }
  getMeta(key) {
    return this.meta[typeof key == "string" ? key : key.key];
  }
  get isGeneric() {
    for (let _ in this.meta)
      return false;
    return true;
  }
  scrollIntoView() {
    this.updated |= UPDATED_SCROLL;
    return this;
  }
  get scrolledIntoView() {
    return (this.updated & UPDATED_SCROLL) > 0;
  }
}
function bind(f, self2) {
  return !self2 || !f ? f : f.bind(self2);
}

class FieldDesc {
  constructor(name, desc, self2) {
    this.name = name;
    this.init = bind(desc.init, self2);
    this.apply = bind(desc.apply, self2);
  }
}
var baseFields = [
  new FieldDesc("doc", {
    init(config) {
      return config.doc || config.schema.topNodeType.createAndFill();
    },
    apply(tr) {
      return tr.doc;
    }
  }),
  new FieldDesc("selection", {
    init(config, instance) {
      return config.selection || Selection.atStart(instance.doc);
    },
    apply(tr) {
      return tr.selection;
    }
  }),
  new FieldDesc("storedMarks", {
    init(config) {
      return config.storedMarks || null;
    },
    apply(tr, _marks, _old, state) {
      return state.selection.$cursor ? tr.storedMarks : null;
    }
  }),
  new FieldDesc("scrollToSelection", {
    init() {
      return 0;
    },
    apply(tr, prev) {
      return tr.scrolledIntoView ? prev + 1 : prev;
    }
  })
];

class Configuration {
  constructor(schema, plugins) {
    this.schema = schema;
    this.plugins = [];
    this.pluginsByKey = Object.create(null);
    this.fields = baseFields.slice();
    if (plugins)
      plugins.forEach((plugin) => {
        if (this.pluginsByKey[plugin.key])
          throw new RangeError("Adding different instances of a keyed plugin (" + plugin.key + ")");
        this.plugins.push(plugin);
        this.pluginsByKey[plugin.key] = plugin;
        if (plugin.spec.state)
          this.fields.push(new FieldDesc(plugin.key, plugin.spec.state, plugin));
      });
  }
}

class EditorState {
  constructor(config) {
    this.config = config;
  }
  get schema() {
    return this.config.schema;
  }
  get plugins() {
    return this.config.plugins;
  }
  apply(tr) {
    return this.applyTransaction(tr).state;
  }
  filterTransaction(tr, ignore = -1) {
    for (let i = 0;i < this.config.plugins.length; i++)
      if (i != ignore) {
        let plugin = this.config.plugins[i];
        if (plugin.spec.filterTransaction && !plugin.spec.filterTransaction.call(plugin, tr, this))
          return false;
      }
    return true;
  }
  applyTransaction(rootTr) {
    if (!this.filterTransaction(rootTr))
      return { state: this, transactions: [] };
    let trs = [rootTr], newState = this.applyInner(rootTr), seen = null;
    for (;; ) {
      let haveNew = false;
      for (let i = 0;i < this.config.plugins.length; i++) {
        let plugin = this.config.plugins[i];
        if (plugin.spec.appendTransaction) {
          let n = seen ? seen[i].n : 0, oldState = seen ? seen[i].state : this;
          let tr = n < trs.length && plugin.spec.appendTransaction.call(plugin, n ? trs.slice(n) : trs, oldState, newState);
          if (tr && newState.filterTransaction(tr, i)) {
            tr.setMeta("appendedTransaction", rootTr);
            if (!seen) {
              seen = [];
              for (let j = 0;j < this.config.plugins.length; j++)
                seen.push(j < i ? { state: newState, n: trs.length } : { state: this, n: 0 });
            }
            trs.push(tr);
            newState = newState.applyInner(tr);
            haveNew = true;
          }
          if (seen)
            seen[i] = { state: newState, n: trs.length };
        }
      }
      if (!haveNew)
        return { state: newState, transactions: trs };
    }
  }
  applyInner(tr) {
    if (!tr.before.eq(this.doc))
      throw new RangeError("Applying a mismatched transaction");
    let newInstance = new EditorState(this.config), fields = this.config.fields;
    for (let i = 0;i < fields.length; i++) {
      let field = fields[i];
      newInstance[field.name] = field.apply(tr, this[field.name], this, newInstance);
    }
    return newInstance;
  }
  get tr() {
    return new Transaction(this);
  }
  static create(config) {
    let $config = new Configuration(config.doc ? config.doc.type.schema : config.schema, config.plugins);
    let instance = new EditorState($config);
    for (let i = 0;i < $config.fields.length; i++)
      instance[$config.fields[i].name] = $config.fields[i].init(config, instance);
    return instance;
  }
  reconfigure(config) {
    let $config = new Configuration(this.schema, config.plugins);
    let fields = $config.fields, instance = new EditorState($config);
    for (let i = 0;i < fields.length; i++) {
      let name = fields[i].name;
      instance[name] = this.hasOwnProperty(name) ? this[name] : fields[i].init(config, instance);
    }
    return instance;
  }
  toJSON(pluginFields) {
    let result = { doc: this.doc.toJSON(), selection: this.selection.toJSON() };
    if (this.storedMarks)
      result.storedMarks = this.storedMarks.map((m) => m.toJSON());
    if (pluginFields && typeof pluginFields == "object")
      for (let prop in pluginFields) {
        if (prop == "doc" || prop == "selection")
          throw new RangeError("The JSON fields `doc` and `selection` are reserved");
        let plugin = pluginFields[prop], state = plugin.spec.state;
        if (state && state.toJSON)
          result[prop] = state.toJSON.call(plugin, this[plugin.key]);
      }
    return result;
  }
  static fromJSON(config, json, pluginFields) {
    if (!json)
      throw new RangeError("Invalid input for EditorState.fromJSON");
    if (!config.schema)
      throw new RangeError("Required config field 'schema' missing");
    let $config = new Configuration(config.schema, config.plugins);
    let instance = new EditorState($config);
    $config.fields.forEach((field) => {
      if (field.name == "doc") {
        instance.doc = Node2.fromJSON(config.schema, json.doc);
      } else if (field.name == "selection") {
        instance.selection = Selection.fromJSON(instance.doc, json.selection);
      } else if (field.name == "storedMarks") {
        if (json.storedMarks)
          instance.storedMarks = json.storedMarks.map(config.schema.markFromJSON);
      } else {
        if (pluginFields)
          for (let prop in pluginFields) {
            let plugin = pluginFields[prop], state = plugin.spec.state;
            if (plugin.key == field.name && state && state.fromJSON && Object.prototype.hasOwnProperty.call(json, prop)) {
              instance[field.name] = state.fromJSON.call(plugin, config, json[prop], instance);
              return;
            }
          }
        instance[field.name] = field.init(config, instance);
      }
    });
    return instance;
  }
}
function bindProps(obj, self2, target) {
  for (let prop in obj) {
    let val = obj[prop];
    if (val instanceof Function)
      val = val.bind(self2);
    else if (prop == "handleDOMEvents")
      val = bindProps(val, self2, {});
    target[prop] = val;
  }
  return target;
}

class Plugin {
  constructor(spec) {
    this.spec = spec;
    this.props = {};
    if (spec.props)
      bindProps(spec.props, this, this.props);
    this.key = spec.key ? spec.key.key : createKey("plugin");
  }
  getState(state) {
    return state[this.key];
  }
}
var keys = Object.create(null);
function createKey(name) {
  if (name in keys)
    return name + "$" + ++keys[name];
  keys[name] = 0;
  return name + "$";
}

class PluginKey {
  constructor(name = "key") {
    this.key = createKey(name);
  }
  get(state) {
    return state.config.pluginsByKey[this.key];
  }
  getState(state) {
    return state[this.key];
  }
}
// node_modules/prosemirror-view/dist/index.js
var domIndex = function(node) {
  for (var index = 0;; index++) {
    node = node.previousSibling;
    if (!node)
      return index;
  }
};
var parentNode = function(node) {
  let parent = node.assignedSlot || node.parentNode;
  return parent && parent.nodeType == 11 ? parent.host : parent;
};
var reusedRange = null;
var textRange = function(node, from, to) {
  let range = reusedRange || (reusedRange = document.createRange());
  range.setEnd(node, to == null ? node.nodeValue.length : to);
  range.setStart(node, from || 0);
  return range;
};
var clearReusedRange = function() {
  reusedRange = null;
};
var isEquivalentPosition = function(node, off, targetNode, targetOff) {
  return targetNode && (scanFor(node, off, targetNode, targetOff, -1) || scanFor(node, off, targetNode, targetOff, 1));
};
var atomElements = /^(img|br|input|textarea|hr)$/i;
function scanFor(node, off, targetNode, targetOff, dir) {
  var _a;
  for (;; ) {
    if (node == targetNode && off == targetOff)
      return true;
    if (off == (dir < 0 ? 0 : nodeSize(node))) {
      let parent = node.parentNode;
      if (!parent || parent.nodeType != 1 || hasBlockDesc(node) || atomElements.test(node.nodeName) || node.contentEditable == "false")
        return false;
      off = domIndex(node) + (dir < 0 ? 0 : 1);
      node = parent;
    } else if (node.nodeType == 1) {
      let child = node.childNodes[off + (dir < 0 ? -1 : 0)];
      if (child.nodeType == 1 && child.contentEditable == "false") {
        if ((_a = child.pmViewDesc) === null || _a === undefined ? undefined : _a.ignoreForSelection)
          off += dir;
        else
          return false;
      } else {
        node = child;
        off = dir < 0 ? nodeSize(node) : 0;
      }
    } else {
      return false;
    }
  }
}
function nodeSize(node) {
  return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length;
}
function textNodeBefore$1(node, offset) {
  for (;; ) {
    if (node.nodeType == 3 && offset)
      return node;
    if (node.nodeType == 1 && offset > 0) {
      if (node.contentEditable == "false")
        return null;
      node = node.childNodes[offset - 1];
      offset = nodeSize(node);
    } else if (node.parentNode && !hasBlockDesc(node)) {
      offset = domIndex(node);
      node = node.parentNode;
    } else {
      return null;
    }
  }
}
function textNodeAfter$1(node, offset) {
  for (;; ) {
    if (node.nodeType == 3 && offset < node.nodeValue.length)
      return node;
    if (node.nodeType == 1 && offset < node.childNodes.length) {
      if (node.contentEditable == "false")
        return null;
      node = node.childNodes[offset];
      offset = 0;
    } else if (node.parentNode && !hasBlockDesc(node)) {
      offset = domIndex(node) + 1;
      node = node.parentNode;
    } else {
      return null;
    }
  }
}
function isOnEdge(node, offset, parent) {
  for (let atStart = offset == 0, atEnd = offset == nodeSize(node);atStart || atEnd; ) {
    if (node == parent)
      return true;
    let index = domIndex(node);
    node = node.parentNode;
    if (!node)
      return false;
    atStart = atStart && index == 0;
    atEnd = atEnd && index == nodeSize(node);
  }
}
function hasBlockDesc(dom) {
  let desc;
  for (let cur = dom;cur; cur = cur.parentNode)
    if (desc = cur.pmViewDesc)
      break;
  return desc && desc.node && desc.node.isBlock && (desc.dom == dom || desc.contentDOM == dom);
}
var selectionCollapsed = function(domSel) {
  return domSel.focusNode && isEquivalentPosition(domSel.focusNode, domSel.focusOffset, domSel.anchorNode, domSel.anchorOffset);
};
function keyEvent(keyCode, key) {
  let event = document.createEvent("Event");
  event.initEvent("keydown", true, true);
  event.keyCode = keyCode;
  event.key = event.code = key;
  return event;
}
function deepActiveElement(doc2) {
  let elt = doc2.activeElement;
  while (elt && elt.shadowRoot)
    elt = elt.shadowRoot.activeElement;
  return elt;
}
function caretFromPoint(doc2, x, y) {
  if (doc2.caretPositionFromPoint) {
    try {
      let pos = doc2.caretPositionFromPoint(x, y);
      if (pos)
        return { node: pos.offsetNode, offset: Math.min(nodeSize(pos.offsetNode), pos.offset) };
    } catch (_) {}
  }
  if (doc2.caretRangeFromPoint) {
    let range = doc2.caretRangeFromPoint(x, y);
    if (range)
      return { node: range.startContainer, offset: Math.min(nodeSize(range.startContainer), range.startOffset) };
  }
}
var nav = typeof navigator != "undefined" ? navigator : null;
var doc2 = typeof document != "undefined" ? document : null;
var agent = nav && nav.userAgent || "";
var ie_edge = /Edge\/(\d+)/.exec(agent);
var ie_upto10 = /MSIE \d/.exec(agent);
var ie_11up = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(agent);
var ie = !!(ie_upto10 || ie_11up || ie_edge);
var ie_version = ie_upto10 ? document.documentMode : ie_11up ? +ie_11up[1] : ie_edge ? +ie_edge[1] : 0;
var gecko = !ie && /gecko\/(\d+)/i.test(agent);
gecko && +(/Firefox\/(\d+)/.exec(agent) || [0, 0])[1];
var _chrome = !ie && /Chrome\/(\d+)/.exec(agent);
var chrome = !!_chrome;
var chrome_version = _chrome ? +_chrome[1] : 0;
var safari2 = !ie && !!nav && /Apple Computer/.test(nav.vendor);
var ios = safari2 && (/Mobile\/\w+/.test(agent) || !!nav && nav.maxTouchPoints > 2);
var mac = ios || (nav ? /Mac/.test(nav.platform) : false);
var windows = nav ? /Win/.test(nav.platform) : false;
var android = /Android \d/.test(agent);
var webkit = !!doc2 && "webkitFontSmoothing" in doc2.documentElement.style;
var webkit_version = webkit ? +(/\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0;
function windowRect(doc3) {
  let vp = doc3.defaultView && doc3.defaultView.visualViewport;
  if (vp)
    return {
      left: 0,
      right: vp.width,
      top: 0,
      bottom: vp.height
    };
  return {
    left: 0,
    right: doc3.documentElement.clientWidth,
    top: 0,
    bottom: doc3.documentElement.clientHeight
  };
}
function getSide(value, side) {
  return typeof value == "number" ? value : value[side];
}
function clientRect(node) {
  let rect = node.getBoundingClientRect();
  let scaleX = rect.width / node.offsetWidth || 1;
  let scaleY = rect.height / node.offsetHeight || 1;
  return {
    left: rect.left,
    right: rect.left + node.clientWidth * scaleX,
    top: rect.top,
    bottom: rect.top + node.clientHeight * scaleY
  };
}
function scrollRectIntoView(view, rect, startDOM) {
  let scrollThreshold = view.someProp("scrollThreshold") || 0, scrollMargin = view.someProp("scrollMargin") || 5;
  let doc3 = view.dom.ownerDocument;
  for (let parent = startDOM || view.dom;; ) {
    if (!parent)
      break;
    if (parent.nodeType != 1) {
      parent = parentNode(parent);
      continue;
    }
    let elt = parent;
    let atTop = elt == doc3.body;
    let bounding = atTop ? windowRect(doc3) : clientRect(elt);
    let moveX = 0, moveY = 0;
    if (rect.top < bounding.top + getSide(scrollThreshold, "top"))
      moveY = -(bounding.top - rect.top + getSide(scrollMargin, "top"));
    else if (rect.bottom > bounding.bottom - getSide(scrollThreshold, "bottom"))
      moveY = rect.bottom - rect.top > bounding.bottom - bounding.top ? rect.top + getSide(scrollMargin, "top") - bounding.top : rect.bottom - bounding.bottom + getSide(scrollMargin, "bottom");
    if (rect.left < bounding.left + getSide(scrollThreshold, "left"))
      moveX = -(bounding.left - rect.left + getSide(scrollMargin, "left"));
    else if (rect.right > bounding.right - getSide(scrollThreshold, "right"))
      moveX = rect.right - bounding.right + getSide(scrollMargin, "right");
    if (moveX || moveY) {
      if (atTop) {
        doc3.defaultView.scrollBy(moveX, moveY);
      } else {
        let { scrollLeft: startX, scrollTop: startY } = elt;
        if (moveY)
          elt.scrollTop += moveY;
        if (moveX)
          elt.scrollLeft += moveX;
        let dX = elt.scrollLeft - startX, dY = elt.scrollTop - startY;
        rect = { left: rect.left - dX, top: rect.top - dY, right: rect.right - dX, bottom: rect.bottom - dY };
      }
    }
    let pos = atTop ? "fixed" : getComputedStyle(parent).position;
    if (/^(fixed|sticky)$/.test(pos))
      break;
    parent = pos == "absolute" ? parent.offsetParent : parentNode(parent);
  }
}
function storeScrollPos(view) {
  let rect = view.dom.getBoundingClientRect(), startY = Math.max(0, rect.top);
  let refDOM, refTop;
  for (let x = (rect.left + rect.right) / 2, y = startY + 1;y < Math.min(innerHeight, rect.bottom); y += 5) {
    let dom = view.root.elementFromPoint(x, y);
    if (!dom || dom == view.dom || !view.dom.contains(dom))
      continue;
    let localRect = dom.getBoundingClientRect();
    if (localRect.top >= startY - 20) {
      refDOM = dom;
      refTop = localRect.top;
      break;
    }
  }
  return { refDOM, refTop, stack: scrollStack(view.dom) };
}
function scrollStack(dom) {
  let stack = [], doc3 = dom.ownerDocument;
  for (let cur = dom;cur; cur = parentNode(cur)) {
    stack.push({ dom: cur, top: cur.scrollTop, left: cur.scrollLeft });
    if (dom == doc3)
      break;
  }
  return stack;
}
function resetScrollPos({ refDOM, refTop, stack }) {
  let newRefTop = refDOM ? refDOM.getBoundingClientRect().top : 0;
  restoreScrollStack(stack, newRefTop == 0 ? 0 : newRefTop - refTop);
}
function restoreScrollStack(stack, dTop) {
  for (let i = 0;i < stack.length; i++) {
    let { dom, top, left } = stack[i];
    if (dom.scrollTop != top + dTop)
      dom.scrollTop = top + dTop;
    if (dom.scrollLeft != left)
      dom.scrollLeft = left;
  }
}
var preventScrollSupported = null;
function focusPreventScroll(dom) {
  if (dom.setActive)
    return dom.setActive();
  if (preventScrollSupported)
    return dom.focus(preventScrollSupported);
  let stored = scrollStack(dom);
  dom.focus(preventScrollSupported == null ? {
    get preventScroll() {
      preventScrollSupported = { preventScroll: true };
      return true;
    }
  } : undefined);
  if (!preventScrollSupported) {
    preventScrollSupported = false;
    restoreScrollStack(stored, 0);
  }
}
function findOffsetInNode(node, coords) {
  let closest, dxClosest = 200000000, coordsClosest, offset = 0;
  let { top: rowBot, top: rowTop } = coords;
  let firstBelow, coordsBelow;
  for (let child = node.firstChild, childIndex = 0;child; child = child.nextSibling, childIndex++) {
    let rects;
    if (child.nodeType == 1)
      rects = child.getClientRects();
    else if (child.nodeType == 3)
      rects = textRange(child).getClientRects();
    else
      continue;
    for (let i = 0;i < rects.length; i++) {
      let rect = rects[i];
      if (rect.top <= rowBot && rect.bottom >= rowTop) {
        rowBot = Math.max(rect.bottom, rowBot);
        rowTop = Math.min(rect.top, rowTop);
        let dx = rect.left > coords.left ? rect.left - coords.left : rect.right < coords.left ? coords.left - rect.right : 0;
        if (dx < dxClosest) {
          closest = child;
          dxClosest = dx;
          coordsClosest = dx && closest.nodeType == 3 ? {
            left: rect.right < coords.left ? rect.right : rect.left,
            top: coords.top
          } : coords;
          if (child.nodeType == 1 && dx)
            offset = childIndex + (coords.left >= (rect.left + rect.right) / 2 ? 1 : 0);
          continue;
        }
      } else if (rect.top > coords.top && !firstBelow && rect.left <= coords.left && rect.right >= coords.left) {
        firstBelow = child;
        coordsBelow = { left: Math.max(rect.left, Math.min(rect.right, coords.left)), top: rect.top };
      }
      if (!closest && (coords.left >= rect.right && coords.top >= rect.top || coords.left >= rect.left && coords.top >= rect.bottom))
        offset = childIndex + 1;
    }
  }
  if (!closest && firstBelow) {
    closest = firstBelow;
    coordsClosest = coordsBelow;
    dxClosest = 0;
  }
  if (closest && closest.nodeType == 3)
    return findOffsetInText(closest, coordsClosest);
  if (!closest || dxClosest && closest.nodeType == 1)
    return { node, offset };
  return findOffsetInNode(closest, coordsClosest);
}
function findOffsetInText(node, coords) {
  let len = node.nodeValue.length;
  let range = document.createRange(), result;
  for (let i = 0;i < len; i++) {
    range.setEnd(node, i + 1);
    range.setStart(node, i);
    let rect = singleRect(range, 1);
    if (rect.top == rect.bottom)
      continue;
    if (inRect(coords, rect)) {
      result = { node, offset: i + (coords.left >= (rect.left + rect.right) / 2 ? 1 : 0) };
      break;
    }
  }
  range.detach();
  return result || { node, offset: 0 };
}
function inRect(coords, rect) {
  return coords.left >= rect.left - 1 && coords.left <= rect.right + 1 && coords.top >= rect.top - 1 && coords.top <= rect.bottom + 1;
}
function targetKludge(dom, coords) {
  let parent = dom.parentNode;
  if (parent && /^li$/i.test(parent.nodeName) && coords.left < dom.getBoundingClientRect().left)
    return parent;
  return dom;
}
function posFromElement(view, elt, coords) {
  let { node, offset } = findOffsetInNode(elt, coords), bias = -1;
  if (node.nodeType == 1 && !node.firstChild) {
    let rect = node.getBoundingClientRect();
    bias = rect.left != rect.right && coords.left > (rect.left + rect.right) / 2 ? 1 : -1;
  }
  return view.docView.posFromDOM(node, offset, bias);
}
function posFromCaret(view, node, offset, coords) {
  let outsideBlock = -1;
  for (let cur = node, sawBlock = false;; ) {
    if (cur == view.dom)
      break;
    let desc = view.docView.nearestDesc(cur, true), rect;
    if (!desc)
      return null;
    if (desc.dom.nodeType == 1 && (desc.node.isBlock && desc.parent || !desc.contentDOM) && ((rect = desc.dom.getBoundingClientRect()).width || rect.height)) {
      if (desc.node.isBlock && desc.parent && !/^T(R|BODY|HEAD|FOOT)$/.test(desc.dom.nodeName)) {
        if (!sawBlock && rect.left > coords.left || rect.top > coords.top)
          outsideBlock = desc.posBefore;
        else if (!sawBlock && rect.right < coords.left || rect.bottom < coords.top)
          outsideBlock = desc.posAfter;
        sawBlock = true;
      }
      if (!desc.contentDOM && outsideBlock < 0 && !desc.node.isText) {
        let before = desc.node.isBlock ? coords.top < (rect.top + rect.bottom) / 2 : coords.left < (rect.left + rect.right) / 2;
        return before ? desc.posBefore : desc.posAfter;
      }
    }
    cur = desc.dom.parentNode;
  }
  return outsideBlock > -1 ? outsideBlock : view.docView.posFromDOM(node, offset, -1);
}
function elementFromPoint(element, coords, box) {
  let len = element.childNodes.length;
  if (len && box.top < box.bottom) {
    for (let startI = Math.max(0, Math.min(len - 1, Math.floor(len * (coords.top - box.top) / (box.bottom - box.top)) - 2)), i = startI;; ) {
      let child = element.childNodes[i];
      if (child.nodeType == 1) {
        let rects = child.getClientRects();
        for (let j = 0;j < rects.length; j++) {
          let rect = rects[j];
          if (inRect(coords, rect))
            return elementFromPoint(child, coords, rect);
        }
      }
      if ((i = (i + 1) % len) == startI)
        break;
    }
  }
  return element;
}
function posAtCoords(view, coords) {
  let doc3 = view.dom.ownerDocument, node, offset = 0;
  let caret = caretFromPoint(doc3, coords.left, coords.top);
  if (caret)
    ({ node, offset } = caret);
  let elt = (view.root.elementFromPoint ? view.root : doc3).elementFromPoint(coords.left, coords.top);
  let pos;
  if (!elt || !view.dom.contains(elt.nodeType != 1 ? elt.parentNode : elt)) {
    let box = view.dom.getBoundingClientRect();
    if (!inRect(coords, box))
      return null;
    elt = elementFromPoint(view.dom, coords, box);
    if (!elt)
      return null;
  }
  if (safari2) {
    for (let p = elt;node && p; p = parentNode(p))
      if (p.draggable)
        node = undefined;
  }
  elt = targetKludge(elt, coords);
  if (node) {
    if (gecko && node.nodeType == 1) {
      offset = Math.min(offset, node.childNodes.length);
      if (offset < node.childNodes.length) {
        let next = node.childNodes[offset], box;
        if (next.nodeName == "IMG" && (box = next.getBoundingClientRect()).right <= coords.left && box.bottom > coords.top)
          offset++;
      }
    }
    let prev;
    if (webkit && offset && node.nodeType == 1 && (prev = node.childNodes[offset - 1]).nodeType == 1 && prev.contentEditable == "false" && prev.getBoundingClientRect().top >= coords.top)
      offset--;
    if (node == view.dom && offset == node.childNodes.length - 1 && node.lastChild.nodeType == 1 && coords.top > node.lastChild.getBoundingClientRect().bottom)
      pos = view.state.doc.content.size;
    else if (offset == 0 || node.nodeType != 1 || node.childNodes[offset - 1].nodeName != "BR")
      pos = posFromCaret(view, node, offset, coords);
  }
  if (pos == null)
    pos = posFromElement(view, elt, coords);
  let desc = view.docView.nearestDesc(elt, true);
  return { pos, inside: desc ? desc.posAtStart - desc.border : -1 };
}
function nonZero(rect) {
  return rect.top < rect.bottom || rect.left < rect.right;
}
function singleRect(target, bias) {
  let rects = target.getClientRects();
  if (rects.length) {
    let first = rects[bias < 0 ? 0 : rects.length - 1];
    if (nonZero(first))
      return first;
  }
  return Array.prototype.find.call(rects, nonZero) || target.getBoundingClientRect();
}
var BIDI = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
function coordsAtPos(view, pos, side) {
  let { node, offset, atom } = view.docView.domFromPos(pos, side < 0 ? -1 : 1);
  let supportEmptyRange = webkit || gecko;
  if (node.nodeType == 3) {
    if (supportEmptyRange && (BIDI.test(node.nodeValue) || (side < 0 ? !offset : offset == node.nodeValue.length))) {
      let rect = singleRect(textRange(node, offset, offset), side);
      if (gecko && offset && /\s/.test(node.nodeValue[offset - 1]) && offset < node.nodeValue.length) {
        let rectBefore = singleRect(textRange(node, offset - 1, offset - 1), -1);
        if (rectBefore.top == rect.top) {
          let rectAfter = singleRect(textRange(node, offset, offset + 1), -1);
          if (rectAfter.top != rect.top)
            return flattenV(rectAfter, rectAfter.left < rectBefore.left);
        }
      }
      return rect;
    } else {
      let from = offset, to = offset, takeSide = side < 0 ? 1 : -1;
      if (side < 0 && !offset) {
        to++;
        takeSide = -1;
      } else if (side >= 0 && offset == node.nodeValue.length) {
        from--;
        takeSide = 1;
      } else if (side < 0) {
        from--;
      } else {
        to++;
      }
      return flattenV(singleRect(textRange(node, from, to), takeSide), takeSide < 0);
    }
  }
  let $dom = view.state.doc.resolve(pos - (atom || 0));
  if (!$dom.parent.inlineContent) {
    if (atom == null && offset && (side < 0 || offset == nodeSize(node))) {
      let before = node.childNodes[offset - 1];
      if (before.nodeType == 1)
        return flattenH(before.getBoundingClientRect(), false);
    }
    if (atom == null && offset < nodeSize(node)) {
      let after = node.childNodes[offset];
      if (after.nodeType == 1)
        return flattenH(after.getBoundingClientRect(), true);
    }
    return flattenH(node.getBoundingClientRect(), side >= 0);
  }
  if (atom == null && offset && (side < 0 || offset == nodeSize(node))) {
    let before = node.childNodes[offset - 1];
    let target = before.nodeType == 3 ? textRange(before, nodeSize(before) - (supportEmptyRange ? 0 : 1)) : before.nodeType == 1 && (before.nodeName != "BR" || !before.nextSibling) ? before : null;
    if (target)
      return flattenV(singleRect(target, 1), false);
  }
  if (atom == null && offset < nodeSize(node)) {
    let after = node.childNodes[offset];
    while (after.pmViewDesc && after.pmViewDesc.ignoreForCoords)
      after = after.nextSibling;
    let target = !after ? null : after.nodeType == 3 ? textRange(after, 0, supportEmptyRange ? 0 : 1) : after.nodeType == 1 ? after : null;
    if (target)
      return flattenV(singleRect(target, -1), true);
  }
  return flattenV(singleRect(node.nodeType == 3 ? textRange(node) : node, -side), side >= 0);
}
function flattenV(rect, left) {
  if (rect.width == 0)
    return rect;
  let x = left ? rect.left : rect.right;
  return { top: rect.top, bottom: rect.bottom, left: x, right: x };
}
function flattenH(rect, top) {
  if (rect.height == 0)
    return rect;
  let y = top ? rect.top : rect.bottom;
  return { top: y, bottom: y, left: rect.left, right: rect.right };
}
function withFlushedState(view, state, f) {
  let viewState = view.state, active = view.root.activeElement;
  if (viewState != state)
    view.updateState(state);
  if (active != view.dom)
    view.focus();
  try {
    return f();
  } finally {
    if (viewState != state)
      view.updateState(viewState);
    if (active != view.dom && active)
      active.focus();
  }
}
function endOfTextblockVertical(view, state, dir) {
  let sel = state.selection;
  let $pos = dir == "up" ? sel.$from : sel.$to;
  return withFlushedState(view, state, () => {
    let { node: dom } = view.docView.domFromPos($pos.pos, dir == "up" ? -1 : 1);
    for (;; ) {
      let nearest = view.docView.nearestDesc(dom, true);
      if (!nearest)
        break;
      if (nearest.node.isBlock) {
        dom = nearest.contentDOM || nearest.dom;
        break;
      }
      dom = nearest.dom.parentNode;
    }
    let coords = coordsAtPos(view, $pos.pos, 1);
    for (let child = dom.firstChild;child; child = child.nextSibling) {
      let boxes;
      if (child.nodeType == 1)
        boxes = child.getClientRects();
      else if (child.nodeType == 3)
        boxes = textRange(child, 0, child.nodeValue.length).getClientRects();
      else
        continue;
      for (let i = 0;i < boxes.length; i++) {
        let box = boxes[i];
        if (box.bottom > box.top + 1 && (dir == "up" ? coords.top - box.top > (box.bottom - coords.top) * 2 : box.bottom - coords.bottom > (coords.bottom - box.top) * 2))
          return false;
      }
    }
    return true;
  });
}
var maybeRTL = /[\u0590-\u08ac]/;
function endOfTextblockHorizontal(view, state, dir) {
  let { $head } = state.selection;
  if (!$head.parent.isTextblock)
    return false;
  let offset = $head.parentOffset, atStart = !offset, atEnd = offset == $head.parent.content.size;
  let sel = view.domSelection();
  if (!sel)
    return $head.pos == $head.start() || $head.pos == $head.end();
  if (!maybeRTL.test($head.parent.textContent) || !sel.modify)
    return dir == "left" || dir == "backward" ? atStart : atEnd;
  return withFlushedState(view, state, () => {
    let { focusNode: oldNode, focusOffset: oldOff, anchorNode, anchorOffset } = view.domSelectionRange();
    let oldBidiLevel = sel.caretBidiLevel;
    sel.modify("move", dir, "character");
    let parentDOM = $head.depth ? view.docView.domAfterPos($head.before()) : view.dom;
    let { focusNode: newNode, focusOffset: newOff } = view.domSelectionRange();
    let result = newNode && !parentDOM.contains(newNode.nodeType == 1 ? newNode : newNode.parentNode) || oldNode == newNode && oldOff == newOff;
    try {
      sel.collapse(anchorNode, anchorOffset);
      if (oldNode && (oldNode != anchorNode || oldOff != anchorOffset) && sel.extend)
        sel.extend(oldNode, oldOff);
    } catch (_) {}
    if (oldBidiLevel != null)
      sel.caretBidiLevel = oldBidiLevel;
    return result;
  });
}
var cachedState = null;
var cachedDir = null;
var cachedResult = false;
function endOfTextblock(view, state, dir) {
  if (cachedState == state && cachedDir == dir)
    return cachedResult;
  cachedState = state;
  cachedDir = dir;
  return cachedResult = dir == "up" || dir == "down" ? endOfTextblockVertical(view, state, dir) : endOfTextblockHorizontal(view, state, dir);
}
var NOT_DIRTY = 0;
var CHILD_DIRTY = 1;
var CONTENT_DIRTY = 2;
var NODE_DIRTY = 3;

class ViewDesc {
  constructor(parent, children, dom, contentDOM) {
    this.parent = parent;
    this.children = children;
    this.dom = dom;
    this.contentDOM = contentDOM;
    this.dirty = NOT_DIRTY;
    dom.pmViewDesc = this;
  }
  matchesWidget(widget) {
    return false;
  }
  matchesMark(mark) {
    return false;
  }
  matchesNode(node, outerDeco, innerDeco) {
    return false;
  }
  matchesHack(nodeName) {
    return false;
  }
  parseRule() {
    return null;
  }
  stopEvent(event) {
    return false;
  }
  get size() {
    let size = 0;
    for (let i = 0;i < this.children.length; i++)
      size += this.children[i].size;
    return size;
  }
  get border() {
    return 0;
  }
  destroy() {
    this.parent = undefined;
    if (this.dom.pmViewDesc == this)
      this.dom.pmViewDesc = undefined;
    for (let i = 0;i < this.children.length; i++)
      this.children[i].destroy();
  }
  posBeforeChild(child) {
    for (let i = 0, pos = this.posAtStart;; i++) {
      let cur = this.children[i];
      if (cur == child)
        return pos;
      pos += cur.size;
    }
  }
  get posBefore() {
    return this.parent.posBeforeChild(this);
  }
  get posAtStart() {
    return this.parent ? this.parent.posBeforeChild(this) + this.border : 0;
  }
  get posAfter() {
    return this.posBefore + this.size;
  }
  get posAtEnd() {
    return this.posAtStart + this.size - 2 * this.border;
  }
  localPosFromDOM(dom, offset, bias) {
    if (this.contentDOM && this.contentDOM.contains(dom.nodeType == 1 ? dom : dom.parentNode)) {
      if (bias < 0) {
        let domBefore, desc;
        if (dom == this.contentDOM) {
          domBefore = dom.childNodes[offset - 1];
        } else {
          while (dom.parentNode != this.contentDOM)
            dom = dom.parentNode;
          domBefore = dom.previousSibling;
        }
        while (domBefore && !((desc = domBefore.pmViewDesc) && desc.parent == this))
          domBefore = domBefore.previousSibling;
        return domBefore ? this.posBeforeChild(desc) + desc.size : this.posAtStart;
      } else {
        let domAfter, desc;
        if (dom == this.contentDOM) {
          domAfter = dom.childNodes[offset];
        } else {
          while (dom.parentNode != this.contentDOM)
            dom = dom.parentNode;
          domAfter = dom.nextSibling;
        }
        while (domAfter && !((desc = domAfter.pmViewDesc) && desc.parent == this))
          domAfter = domAfter.nextSibling;
        return domAfter ? this.posBeforeChild(desc) : this.posAtEnd;
      }
    }
    let atEnd;
    if (dom == this.dom && this.contentDOM) {
      atEnd = offset > domIndex(this.contentDOM);
    } else if (this.contentDOM && this.contentDOM != this.dom && this.dom.contains(this.contentDOM)) {
      atEnd = dom.compareDocumentPosition(this.contentDOM) & 2;
    } else if (this.dom.firstChild) {
      if (offset == 0)
        for (let search = dom;; search = search.parentNode) {
          if (search == this.dom) {
            atEnd = false;
            break;
          }
          if (search.previousSibling)
            break;
        }
      if (atEnd == null && offset == dom.childNodes.length)
        for (let search = dom;; search = search.parentNode) {
          if (search == this.dom) {
            atEnd = true;
            break;
          }
          if (search.nextSibling)
            break;
        }
    }
    return (atEnd == null ? bias > 0 : atEnd) ? this.posAtEnd : this.posAtStart;
  }
  nearestDesc(dom, onlyNodes = false) {
    for (let first = true, cur = dom;cur; cur = cur.parentNode) {
      let desc = this.getDesc(cur), nodeDOM;
      if (desc && (!onlyNodes || desc.node)) {
        if (first && (nodeDOM = desc.nodeDOM) && !(nodeDOM.nodeType == 1 ? nodeDOM.contains(dom.nodeType == 1 ? dom : dom.parentNode) : nodeDOM == dom))
          first = false;
        else
          return desc;
      }
    }
  }
  getDesc(dom) {
    let desc = dom.pmViewDesc;
    for (let cur = desc;cur; cur = cur.parent)
      if (cur == this)
        return desc;
  }
  posFromDOM(dom, offset, bias) {
    for (let scan = dom;scan; scan = scan.parentNode) {
      let desc = this.getDesc(scan);
      if (desc)
        return desc.localPosFromDOM(dom, offset, bias);
    }
    return -1;
  }
  descAt(pos) {
    for (let i = 0, offset = 0;i < this.children.length; i++) {
      let child = this.children[i], end = offset + child.size;
      if (offset == pos && end != offset) {
        while (!child.border && child.children.length) {
          for (let i2 = 0;i2 < child.children.length; i2++) {
            let inner = child.children[i2];
            if (inner.size) {
              child = inner;
              break;
            }
          }
        }
        return child;
      }
      if (pos < end)
        return child.descAt(pos - offset - child.border);
      offset = end;
    }
  }
  domFromPos(pos, side) {
    if (!this.contentDOM)
      return { node: this.dom, offset: 0, atom: pos + 1 };
    let i = 0, offset = 0;
    for (let curPos = 0;i < this.children.length; i++) {
      let child = this.children[i], end = curPos + child.size;
      if (end > pos || child instanceof TrailingHackViewDesc) {
        offset = pos - curPos;
        break;
      }
      curPos = end;
    }
    if (offset)
      return this.children[i].domFromPos(offset - this.children[i].border, side);
    for (let prev;i && !(prev = this.children[i - 1]).size && prev instanceof WidgetViewDesc && prev.side >= 0; i--) {}
    if (side <= 0) {
      let prev, enter = true;
      for (;; i--, enter = false) {
        prev = i ? this.children[i - 1] : null;
        if (!prev || prev.dom.parentNode == this.contentDOM)
          break;
      }
      if (prev && side && enter && !prev.border && !prev.domAtom)
        return prev.domFromPos(prev.size, side);
      return { node: this.contentDOM, offset: prev ? domIndex(prev.dom) + 1 : 0 };
    } else {
      let next, enter = true;
      for (;; i++, enter = false) {
        next = i < this.children.length ? this.children[i] : null;
        if (!next || next.dom.parentNode == this.contentDOM)
          break;
      }
      if (next && enter && !next.border && !next.domAtom)
        return next.domFromPos(0, side);
      return { node: this.contentDOM, offset: next ? domIndex(next.dom) : this.contentDOM.childNodes.length };
    }
  }
  parseRange(from, to, base = 0) {
    if (this.children.length == 0)
      return { node: this.contentDOM, from, to, fromOffset: 0, toOffset: this.contentDOM.childNodes.length };
    let fromOffset = -1, toOffset = -1;
    for (let offset = base, i = 0;; i++) {
      let child = this.children[i], end = offset + child.size;
      if (fromOffset == -1 && from <= end) {
        let childBase = offset + child.border;
        if (from >= childBase && to <= end - child.border && child.node && child.contentDOM && this.contentDOM.contains(child.contentDOM))
          return child.parseRange(from, to, childBase);
        from = offset;
        for (let j = i;j > 0; j--) {
          let prev = this.children[j - 1];
          if (prev.size && prev.dom.parentNode == this.contentDOM && !prev.emptyChildAt(1)) {
            fromOffset = domIndex(prev.dom) + 1;
            break;
          }
          from -= prev.size;
        }
        if (fromOffset == -1)
          fromOffset = 0;
      }
      if (fromOffset > -1 && (end > to || i == this.children.length - 1)) {
        to = end;
        for (let j = i + 1;j < this.children.length; j++) {
          let next = this.children[j];
          if (next.size && next.dom.parentNode == this.contentDOM && !next.emptyChildAt(-1)) {
            toOffset = domIndex(next.dom);
            break;
          }
          to += next.size;
        }
        if (toOffset == -1)
          toOffset = this.contentDOM.childNodes.length;
        break;
      }
      offset = end;
    }
    return { node: this.contentDOM, from, to, fromOffset, toOffset };
  }
  emptyChildAt(side) {
    if (this.border || !this.contentDOM || !this.children.length)
      return false;
    let child = this.children[side < 0 ? 0 : this.children.length - 1];
    return child.size == 0 || child.emptyChildAt(side);
  }
  domAfterPos(pos) {
    let { node, offset } = this.domFromPos(pos, 0);
    if (node.nodeType != 1 || offset == node.childNodes.length)
      throw new RangeError("No node after pos " + pos);
    return node.childNodes[offset];
  }
  setSelection(anchor, head, view, force = false) {
    let from = Math.min(anchor, head), to = Math.max(anchor, head);
    for (let i = 0, offset = 0;i < this.children.length; i++) {
      let child = this.children[i], end = offset + child.size;
      if (from > offset && to < end)
        return child.setSelection(anchor - offset - child.border, head - offset - child.border, view, force);
      offset = end;
    }
    let anchorDOM = this.domFromPos(anchor, anchor ? -1 : 1);
    let headDOM = head == anchor ? anchorDOM : this.domFromPos(head, head ? -1 : 1);
    let domSel = view.root.getSelection();
    let selRange = view.domSelectionRange();
    let brKludge = false;
    if ((gecko || safari2) && anchor == head) {
      let { node, offset } = anchorDOM;
      if (node.nodeType == 3) {
        brKludge = !!(offset && node.nodeValue[offset - 1] == `
`);
        if (brKludge && offset == node.nodeValue.length) {
          for (let scan = node, after;scan; scan = scan.parentNode) {
            if (after = scan.nextSibling) {
              if (after.nodeName == "BR")
                anchorDOM = headDOM = { node: after.parentNode, offset: domIndex(after) + 1 };
              break;
            }
            let desc = scan.pmViewDesc;
            if (desc && desc.node && desc.node.isBlock)
              break;
          }
        }
      } else {
        let prev = node.childNodes[offset - 1];
        brKludge = prev && (prev.nodeName == "BR" || prev.contentEditable == "false");
      }
    }
    if (gecko && selRange.focusNode && selRange.focusNode != headDOM.node && selRange.focusNode.nodeType == 1) {
      let after = selRange.focusNode.childNodes[selRange.focusOffset];
      if (after && after.contentEditable == "false")
        force = true;
    }
    if (!(force || brKludge && safari2) && isEquivalentPosition(anchorDOM.node, anchorDOM.offset, selRange.anchorNode, selRange.anchorOffset) && isEquivalentPosition(headDOM.node, headDOM.offset, selRange.focusNode, selRange.focusOffset))
      return;
    let domSelExtended = false;
    if ((domSel.extend || anchor == head) && !(brKludge && gecko)) {
      domSel.collapse(anchorDOM.node, anchorDOM.offset);
      try {
        if (anchor != head)
          domSel.extend(headDOM.node, headDOM.offset);
        domSelExtended = true;
      } catch (_) {}
    }
    if (!domSelExtended) {
      if (anchor > head) {
        let tmp = anchorDOM;
        anchorDOM = headDOM;
        headDOM = tmp;
      }
      let range = document.createRange();
      range.setEnd(headDOM.node, headDOM.offset);
      range.setStart(anchorDOM.node, anchorDOM.offset);
      domSel.removeAllRanges();
      domSel.addRange(range);
    }
  }
  ignoreMutation(mutation) {
    return !this.contentDOM && mutation.type != "selection";
  }
  get contentLost() {
    return this.contentDOM && this.contentDOM != this.dom && !this.dom.contains(this.contentDOM);
  }
  markDirty(from, to) {
    for (let offset = 0, i = 0;i < this.children.length; i++) {
      let child = this.children[i], end = offset + child.size;
      if (offset == end ? from <= end && to >= offset : from < end && to > offset) {
        let startInside = offset + child.border, endInside = end - child.border;
        if (from >= startInside && to <= endInside) {
          this.dirty = from == offset || to == end ? CONTENT_DIRTY : CHILD_DIRTY;
          if (from == startInside && to == endInside && (child.contentLost || child.dom.parentNode != this.contentDOM))
            child.dirty = NODE_DIRTY;
          else
            child.markDirty(from - startInside, to - startInside);
          return;
        } else {
          child.dirty = child.dom == child.contentDOM && child.dom.parentNode == this.contentDOM && !child.children.length ? CONTENT_DIRTY : NODE_DIRTY;
        }
      }
      offset = end;
    }
    this.dirty = CONTENT_DIRTY;
  }
  markParentsDirty() {
    let level = 1;
    for (let node = this.parent;node; node = node.parent, level++) {
      let dirty = level == 1 ? CONTENT_DIRTY : CHILD_DIRTY;
      if (node.dirty < dirty)
        node.dirty = dirty;
    }
  }
  get domAtom() {
    return false;
  }
  get ignoreForCoords() {
    return false;
  }
  get ignoreForSelection() {
    return false;
  }
  isText(text) {
    return false;
  }
}

class WidgetViewDesc extends ViewDesc {
  constructor(parent, widget, view, pos) {
    let self2, dom = widget.type.toDOM;
    if (typeof dom == "function")
      dom = dom(view, () => {
        if (!self2)
          return pos;
        if (self2.parent)
          return self2.parent.posBeforeChild(self2);
      });
    if (!widget.type.spec.raw) {
      if (dom.nodeType != 1) {
        let wrap2 = document.createElement("span");
        wrap2.appendChild(dom);
        dom = wrap2;
      }
      dom.contentEditable = "false";
      dom.classList.add("ProseMirror-widget");
    }
    super(parent, [], dom, null);
    this.widget = widget;
    this.widget = widget;
    self2 = this;
  }
  matchesWidget(widget) {
    return this.dirty == NOT_DIRTY && widget.type.eq(this.widget.type);
  }
  parseRule() {
    return { ignore: true };
  }
  stopEvent(event) {
    let stop = this.widget.spec.stopEvent;
    return stop ? stop(event) : false;
  }
  ignoreMutation(mutation) {
    return mutation.type != "selection" || this.widget.spec.ignoreSelection;
  }
  destroy() {
    this.widget.type.destroy(this.dom);
    super.destroy();
  }
  get domAtom() {
    return true;
  }
  get ignoreForSelection() {
    return !!this.widget.type.spec.relaxedSide;
  }
  get side() {
    return this.widget.type.side;
  }
}

class CompositionViewDesc extends ViewDesc {
  constructor(parent, dom, textDOM, text) {
    super(parent, [], dom, null);
    this.textDOM = textDOM;
    this.text = text;
  }
  get size() {
    return this.text.length;
  }
  localPosFromDOM(dom, offset) {
    if (dom != this.textDOM)
      return this.posAtStart + (offset ? this.size : 0);
    return this.posAtStart + offset;
  }
  domFromPos(pos) {
    return { node: this.textDOM, offset: pos };
  }
  ignoreMutation(mut) {
    return mut.type === "characterData" && mut.target.nodeValue == mut.oldValue;
  }
}

class MarkViewDesc extends ViewDesc {
  constructor(parent, mark, dom, contentDOM, spec) {
    super(parent, [], dom, contentDOM);
    this.mark = mark;
    this.spec = spec;
  }
  static create(parent, mark, inline, view) {
    let custom = view.nodeViews[mark.type.name];
    let spec = custom && custom(mark, view, inline);
    if (!spec || !spec.dom)
      spec = DOMSerializer.renderSpec(document, mark.type.spec.toDOM(mark, inline), null, mark.attrs);
    return new MarkViewDesc(parent, mark, spec.dom, spec.contentDOM || spec.dom, spec);
  }
  parseRule() {
    if (this.dirty & NODE_DIRTY || this.mark.type.spec.reparseInView)
      return null;
    return { mark: this.mark.type.name, attrs: this.mark.attrs, contentElement: this.contentDOM };
  }
  matchesMark(mark) {
    return this.dirty != NODE_DIRTY && this.mark.eq(mark);
  }
  markDirty(from, to) {
    super.markDirty(from, to);
    if (this.dirty != NOT_DIRTY) {
      let parent = this.parent;
      while (!parent.node)
        parent = parent.parent;
      if (parent.dirty < this.dirty)
        parent.dirty = this.dirty;
      this.dirty = NOT_DIRTY;
    }
  }
  slice(from, to, view) {
    let copy2 = MarkViewDesc.create(this.parent, this.mark, true, view);
    let nodes = this.children, size = this.size;
    if (to < size)
      nodes = replaceNodes(nodes, to, size, view);
    if (from > 0)
      nodes = replaceNodes(nodes, 0, from, view);
    for (let i = 0;i < nodes.length; i++)
      nodes[i].parent = copy2;
    copy2.children = nodes;
    return copy2;
  }
  ignoreMutation(mutation) {
    return this.spec.ignoreMutation ? this.spec.ignoreMutation(mutation) : super.ignoreMutation(mutation);
  }
  destroy() {
    if (this.spec.destroy)
      this.spec.destroy();
    super.destroy();
  }
}

class NodeViewDesc extends ViewDesc {
  constructor(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, view, pos) {
    super(parent, [], dom, contentDOM);
    this.node = node;
    this.outerDeco = outerDeco;
    this.innerDeco = innerDeco;
    this.nodeDOM = nodeDOM;
  }
  static create(parent, node, outerDeco, innerDeco, view, pos) {
    let custom = view.nodeViews[node.type.name], descObj;
    let spec = custom && custom(node, view, () => {
      if (!descObj)
        return pos;
      if (descObj.parent)
        return descObj.parent.posBeforeChild(descObj);
    }, outerDeco, innerDeco);
    let dom = spec && spec.dom, contentDOM = spec && spec.contentDOM;
    if (node.isText) {
      if (!dom)
        dom = document.createTextNode(node.text);
      else if (dom.nodeType != 3)
        throw new RangeError("Text must be rendered as a DOM text node");
    } else if (!dom) {
      let spec2 = DOMSerializer.renderSpec(document, node.type.spec.toDOM(node), null, node.attrs);
      ({ dom, contentDOM } = spec2);
    }
    if (!contentDOM && !node.isText && dom.nodeName != "BR") {
      if (!dom.hasAttribute("contenteditable"))
        dom.contentEditable = "false";
      if (node.type.spec.draggable)
        dom.draggable = true;
    }
    let nodeDOM = dom;
    dom = applyOuterDeco(dom, outerDeco, node);
    if (spec)
      return descObj = new CustomNodeViewDesc(parent, node, outerDeco, innerDeco, dom, contentDOM || null, nodeDOM, spec, view, pos + 1);
    else if (node.isText)
      return new TextViewDesc(parent, node, outerDeco, innerDeco, dom, nodeDOM, view);
    else
      return new NodeViewDesc(parent, node, outerDeco, innerDeco, dom, contentDOM || null, nodeDOM, view, pos + 1);
  }
  parseRule() {
    if (this.node.type.spec.reparseInView)
      return null;
    let rule = { node: this.node.type.name, attrs: this.node.attrs };
    if (this.node.type.whitespace == "pre")
      rule.preserveWhitespace = "full";
    if (!this.contentDOM) {
      rule.getContent = () => this.node.content;
    } else if (!this.contentLost) {
      rule.contentElement = this.contentDOM;
    } else {
      for (let i = this.children.length - 1;i >= 0; i--) {
        let child = this.children[i];
        if (this.dom.contains(child.dom.parentNode)) {
          rule.contentElement = child.dom.parentNode;
          break;
        }
      }
      if (!rule.contentElement)
        rule.getContent = () => Fragment.empty;
    }
    return rule;
  }
  matchesNode(node, outerDeco, innerDeco) {
    return this.dirty == NOT_DIRTY && node.eq(this.node) && sameOuterDeco(outerDeco, this.outerDeco) && innerDeco.eq(this.innerDeco);
  }
  get size() {
    return this.node.nodeSize;
  }
  get border() {
    return this.node.isLeaf ? 0 : 1;
  }
  updateChildren(view, pos) {
    let inline = this.node.inlineContent, off = pos;
    let composition = view.composing ? this.localCompositionInfo(view, pos) : null;
    let localComposition = composition && composition.pos > -1 ? composition : null;
    let compositionInChild = composition && composition.pos < 0;
    let updater = new ViewTreeUpdater(this, localComposition && localComposition.node, view);
    iterDeco(this.node, this.innerDeco, (widget, i, insideNode) => {
      if (widget.spec.marks)
        updater.syncToMarks(widget.spec.marks, inline, view, i);
      else if (widget.type.side >= 0 && !insideNode)
        updater.syncToMarks(i == this.node.childCount ? Mark.none : this.node.child(i).marks, inline, view, i);
      updater.placeWidget(widget, view, off);
    }, (child, outerDeco, innerDeco, i) => {
      updater.syncToMarks(child.marks, inline, view, i);
      let compIndex;
      if (updater.findNodeMatch(child, outerDeco, innerDeco, i))
        ;
      else if (compositionInChild && view.state.selection.from > off && view.state.selection.to < off + child.nodeSize && (compIndex = updater.findIndexWithChild(composition.node)) > -1 && updater.updateNodeAt(child, outerDeco, innerDeco, compIndex, view))
        ;
      else if (updater.updateNextNode(child, outerDeco, innerDeco, view, i, off))
        ;
      else {
        updater.addNode(child, outerDeco, innerDeco, view, off);
      }
      off += child.nodeSize;
    });
    updater.syncToMarks([], inline, view, 0);
    if (this.node.isTextblock)
      updater.addTextblockHacks();
    updater.destroyRest();
    if (updater.changed || this.dirty == CONTENT_DIRTY) {
      if (localComposition)
        this.protectLocalComposition(view, localComposition);
      renderDescs(this.contentDOM, this.children, view);
      if (ios)
        iosHacks(this.dom);
    }
  }
  localCompositionInfo(view, pos) {
    let { from, to } = view.state.selection;
    if (!(view.state.selection instanceof TextSelection) || from < pos || to > pos + this.node.content.size)
      return null;
    let textNode = view.input.compositionNode;
    if (!textNode || !this.dom.contains(textNode.parentNode))
      return null;
    if (this.node.inlineContent) {
      let text = textNode.nodeValue;
      let textPos = findTextInFragment(this.node.content, text, from - pos, to - pos);
      return textPos < 0 ? null : { node: textNode, pos: textPos, text };
    } else {
      return { node: textNode, pos: -1, text: "" };
    }
  }
  protectLocalComposition(view, { node, pos, text }) {
    if (this.getDesc(node))
      return;
    let topNode = node;
    for (;; topNode = topNode.parentNode) {
      if (topNode.parentNode == this.contentDOM)
        break;
      while (topNode.previousSibling)
        topNode.parentNode.removeChild(topNode.previousSibling);
      while (topNode.nextSibling)
        topNode.parentNode.removeChild(topNode.nextSibling);
      if (topNode.pmViewDesc)
        topNode.pmViewDesc = undefined;
    }
    let desc = new CompositionViewDesc(this, topNode, node, text);
    view.input.compositionNodes.push(desc);
    this.children = replaceNodes(this.children, pos, pos + text.length, view, desc);
  }
  update(node, outerDeco, innerDeco, view) {
    if (this.dirty == NODE_DIRTY || !node.sameMarkup(this.node))
      return false;
    this.updateInner(node, outerDeco, innerDeco, view);
    return true;
  }
  updateInner(node, outerDeco, innerDeco, view) {
    this.updateOuterDeco(outerDeco);
    this.node = node;
    this.innerDeco = innerDeco;
    if (this.contentDOM)
      this.updateChildren(view, this.posAtStart);
    this.dirty = NOT_DIRTY;
  }
  updateOuterDeco(outerDeco) {
    if (sameOuterDeco(outerDeco, this.outerDeco))
      return;
    let needsWrap = this.nodeDOM.nodeType != 1;
    let oldDOM = this.dom;
    this.dom = patchOuterDeco(this.dom, this.nodeDOM, computeOuterDeco(this.outerDeco, this.node, needsWrap), computeOuterDeco(outerDeco, this.node, needsWrap));
    if (this.dom != oldDOM) {
      oldDOM.pmViewDesc = undefined;
      this.dom.pmViewDesc = this;
    }
    this.outerDeco = outerDeco;
  }
  selectNode() {
    if (this.nodeDOM.nodeType == 1) {
      this.nodeDOM.classList.add("ProseMirror-selectednode");
      if (this.contentDOM || !this.node.type.spec.draggable)
        this.nodeDOM.draggable = true;
    }
  }
  deselectNode() {
    if (this.nodeDOM.nodeType == 1) {
      this.nodeDOM.classList.remove("ProseMirror-selectednode");
      if (this.contentDOM || !this.node.type.spec.draggable)
        this.nodeDOM.removeAttribute("draggable");
    }
  }
  get domAtom() {
    return this.node.isAtom;
  }
}
function docViewDesc(doc3, outerDeco, innerDeco, dom, view) {
  applyOuterDeco(dom, outerDeco, doc3);
  let docView = new NodeViewDesc(undefined, doc3, outerDeco, innerDeco, dom, dom, dom, view, 0);
  if (docView.contentDOM)
    docView.updateChildren(view, 0);
  return docView;
}

class TextViewDesc extends NodeViewDesc {
  constructor(parent, node, outerDeco, innerDeco, dom, nodeDOM, view) {
    super(parent, node, outerDeco, innerDeco, dom, null, nodeDOM, view, 0);
  }
  parseRule() {
    let skip = this.nodeDOM.parentNode;
    while (skip && skip != this.dom && !skip.pmIsDeco)
      skip = skip.parentNode;
    return { skip: skip || true };
  }
  update(node, outerDeco, innerDeco, view) {
    if (this.dirty == NODE_DIRTY || this.dirty != NOT_DIRTY && !this.inParent() || !node.sameMarkup(this.node))
      return false;
    this.updateOuterDeco(outerDeco);
    if ((this.dirty != NOT_DIRTY || node.text != this.node.text) && node.text != this.nodeDOM.nodeValue) {
      this.nodeDOM.nodeValue = node.text;
      if (view.trackWrites == this.nodeDOM)
        view.trackWrites = null;
    }
    this.node = node;
    this.dirty = NOT_DIRTY;
    return true;
  }
  inParent() {
    let parentDOM = this.parent.contentDOM;
    for (let n = this.nodeDOM;n; n = n.parentNode)
      if (n == parentDOM)
        return true;
    return false;
  }
  domFromPos(pos) {
    return { node: this.nodeDOM, offset: pos };
  }
  localPosFromDOM(dom, offset, bias) {
    if (dom == this.nodeDOM)
      return this.posAtStart + Math.min(offset, this.node.text.length);
    return super.localPosFromDOM(dom, offset, bias);
  }
  ignoreMutation(mutation) {
    return mutation.type != "characterData" && mutation.type != "selection";
  }
  slice(from, to, view) {
    let node = this.node.cut(from, to), dom = document.createTextNode(node.text);
    return new TextViewDesc(this.parent, node, this.outerDeco, this.innerDeco, dom, dom, view);
  }
  markDirty(from, to) {
    super.markDirty(from, to);
    if (this.dom != this.nodeDOM && (from == 0 || to == this.nodeDOM.nodeValue.length))
      this.dirty = NODE_DIRTY;
  }
  get domAtom() {
    return false;
  }
  isText(text) {
    return this.node.text == text;
  }
}

class TrailingHackViewDesc extends ViewDesc {
  parseRule() {
    return { ignore: true };
  }
  matchesHack(nodeName) {
    return this.dirty == NOT_DIRTY && this.dom.nodeName == nodeName;
  }
  get domAtom() {
    return true;
  }
  get ignoreForCoords() {
    return this.dom.nodeName == "IMG";
  }
}

class CustomNodeViewDesc extends NodeViewDesc {
  constructor(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, spec, view, pos) {
    super(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, view, pos);
    this.spec = spec;
  }
  update(node, outerDeco, innerDeco, view) {
    if (this.dirty == NODE_DIRTY)
      return false;
    if (this.spec.update && (this.node.type == node.type || this.spec.multiType)) {
      let result = this.spec.update(node, outerDeco, innerDeco);
      if (result)
        this.updateInner(node, outerDeco, innerDeco, view);
      return result;
    } else if (!this.contentDOM && !node.isLeaf) {
      return false;
    } else {
      return super.update(node, outerDeco, innerDeco, view);
    }
  }
  selectNode() {
    this.spec.selectNode ? this.spec.selectNode() : super.selectNode();
  }
  deselectNode() {
    this.spec.deselectNode ? this.spec.deselectNode() : super.deselectNode();
  }
  setSelection(anchor, head, view, force) {
    this.spec.setSelection ? this.spec.setSelection(anchor, head, view.root) : super.setSelection(anchor, head, view, force);
  }
  destroy() {
    if (this.spec.destroy)
      this.spec.destroy();
    super.destroy();
  }
  stopEvent(event) {
    return this.spec.stopEvent ? this.spec.stopEvent(event) : false;
  }
  ignoreMutation(mutation) {
    return this.spec.ignoreMutation ? this.spec.ignoreMutation(mutation) : super.ignoreMutation(mutation);
  }
}
function renderDescs(parentDOM, descs, view) {
  let dom = parentDOM.firstChild, written = false;
  for (let i = 0;i < descs.length; i++) {
    let desc = descs[i], childDOM = desc.dom;
    if (childDOM.parentNode == parentDOM) {
      while (childDOM != dom) {
        dom = rm(dom);
        written = true;
      }
      dom = dom.nextSibling;
    } else {
      written = true;
      parentDOM.insertBefore(childDOM, dom);
    }
    if (desc instanceof MarkViewDesc) {
      let pos = dom ? dom.previousSibling : parentDOM.lastChild;
      renderDescs(desc.contentDOM, desc.children, view);
      dom = pos ? pos.nextSibling : parentDOM.firstChild;
    }
  }
  while (dom) {
    dom = rm(dom);
    written = true;
  }
  if (written && view.trackWrites == parentDOM)
    view.trackWrites = null;
}
var OuterDecoLevel = function(nodeName) {
  if (nodeName)
    this.nodeName = nodeName;
};
OuterDecoLevel.prototype = Object.create(null);
var noDeco = [new OuterDecoLevel];
function computeOuterDeco(outerDeco, node, needsWrap) {
  if (outerDeco.length == 0)
    return noDeco;
  let top = needsWrap ? noDeco[0] : new OuterDecoLevel, result = [top];
  for (let i = 0;i < outerDeco.length; i++) {
    let attrs = outerDeco[i].type.attrs;
    if (!attrs)
      continue;
    if (attrs.nodeName)
      result.push(top = new OuterDecoLevel(attrs.nodeName));
    for (let name in attrs) {
      let val = attrs[name];
      if (val == null)
        continue;
      if (needsWrap && result.length == 1)
        result.push(top = new OuterDecoLevel(node.isInline ? "span" : "div"));
      if (name == "class")
        top.class = (top.class ? top.class + " " : "") + val;
      else if (name == "style")
        top.style = (top.style ? top.style + ";" : "") + val;
      else if (name != "nodeName")
        top[name] = val;
    }
  }
  return result;
}
function patchOuterDeco(outerDOM, nodeDOM, prevComputed, curComputed) {
  if (prevComputed == noDeco && curComputed == noDeco)
    return nodeDOM;
  let curDOM = nodeDOM;
  for (let i = 0;i < curComputed.length; i++) {
    let deco = curComputed[i], prev = prevComputed[i];
    if (i) {
      let parent;
      if (prev && prev.nodeName == deco.nodeName && curDOM != outerDOM && (parent = curDOM.parentNode) && parent.nodeName.toLowerCase() == deco.nodeName) {
        curDOM = parent;
      } else {
        parent = document.createElement(deco.nodeName);
        parent.pmIsDeco = true;
        parent.appendChild(curDOM);
        prev = noDeco[0];
        curDOM = parent;
      }
    }
    patchAttributes(curDOM, prev || noDeco[0], deco);
  }
  return curDOM;
}
function patchAttributes(dom, prev, cur) {
  for (let name in prev)
    if (name != "class" && name != "style" && name != "nodeName" && !(name in cur))
      dom.removeAttribute(name);
  for (let name in cur)
    if (name != "class" && name != "style" && name != "nodeName" && cur[name] != prev[name])
      dom.setAttribute(name, cur[name]);
  if (prev.class != cur.class) {
    let prevList = prev.class ? prev.class.split(" ").filter(Boolean) : [];
    let curList = cur.class ? cur.class.split(" ").filter(Boolean) : [];
    for (let i = 0;i < prevList.length; i++)
      if (curList.indexOf(prevList[i]) == -1)
        dom.classList.remove(prevList[i]);
    for (let i = 0;i < curList.length; i++)
      if (prevList.indexOf(curList[i]) == -1)
        dom.classList.add(curList[i]);
    if (dom.classList.length == 0)
      dom.removeAttribute("class");
  }
  if (prev.style != cur.style) {
    if (prev.style) {
      let prop = /\s*([\w\-\xa1-\uffff]+)\s*:(?:"(?:\\.|[^"])*"|'(?:\\.|[^'])*'|\(.*?\)|[^;])*/g, m;
      while (m = prop.exec(prev.style))
        dom.style.removeProperty(m[1]);
    }
    if (cur.style)
      dom.style.cssText += cur.style;
  }
}
function applyOuterDeco(dom, deco, node) {
  return patchOuterDeco(dom, dom, noDeco, computeOuterDeco(deco, node, dom.nodeType != 1));
}
function sameOuterDeco(a, b) {
  if (a.length != b.length)
    return false;
  for (let i = 0;i < a.length; i++)
    if (!a[i].type.eq(b[i].type))
      return false;
  return true;
}
function rm(dom) {
  let next = dom.nextSibling;
  dom.parentNode.removeChild(dom);
  return next;
}

class ViewTreeUpdater {
  constructor(top, lock, view) {
    this.lock = lock;
    this.view = view;
    this.index = 0;
    this.stack = [];
    this.changed = false;
    this.top = top;
    this.preMatch = preMatch(top.node.content, top);
  }
  destroyBetween(start, end) {
    if (start == end)
      return;
    for (let i = start;i < end; i++)
      this.top.children[i].destroy();
    this.top.children.splice(start, end - start);
    this.changed = true;
  }
  destroyRest() {
    this.destroyBetween(this.index, this.top.children.length);
  }
  syncToMarks(marks, inline, view, parentIndex) {
    let keep = 0, depth = this.stack.length >> 1;
    let maxKeep = Math.min(depth, marks.length);
    while (keep < maxKeep && (keep == depth - 1 ? this.top : this.stack[keep + 1 << 1]).matchesMark(marks[keep]) && marks[keep].type.spec.spanning !== false)
      keep++;
    while (keep < depth) {
      this.destroyRest();
      this.top.dirty = NOT_DIRTY;
      this.index = this.stack.pop();
      this.top = this.stack.pop();
      depth--;
    }
    while (depth < marks.length) {
      this.stack.push(this.top, this.index + 1);
      let found2 = -1, scanTo = this.top.children.length;
      if (parentIndex < this.preMatch.index)
        scanTo = Math.min(this.index + 3, scanTo);
      for (let i = this.index;i < scanTo; i++) {
        let next = this.top.children[i];
        if (next.matchesMark(marks[depth]) && !this.isLocked(next.dom)) {
          found2 = i;
          break;
        }
      }
      if (found2 > -1) {
        if (found2 > this.index) {
          this.changed = true;
          this.destroyBetween(this.index, found2);
        }
        this.top = this.top.children[this.index];
      } else {
        let markDesc = MarkViewDesc.create(this.top, marks[depth], inline, view);
        this.top.children.splice(this.index, 0, markDesc);
        this.top = markDesc;
        this.changed = true;
      }
      this.index = 0;
      depth++;
    }
  }
  findNodeMatch(node, outerDeco, innerDeco, index) {
    let found2 = -1, targetDesc;
    if (index >= this.preMatch.index && (targetDesc = this.preMatch.matches[index - this.preMatch.index]).parent == this.top && targetDesc.matchesNode(node, outerDeco, innerDeco)) {
      found2 = this.top.children.indexOf(targetDesc, this.index);
    } else {
      for (let i = this.index, e = Math.min(this.top.children.length, i + 5);i < e; i++) {
        let child = this.top.children[i];
        if (child.matchesNode(node, outerDeco, innerDeco) && !this.preMatch.matched.has(child)) {
          found2 = i;
          break;
        }
      }
    }
    if (found2 < 0)
      return false;
    this.destroyBetween(this.index, found2);
    this.index++;
    return true;
  }
  updateNodeAt(node, outerDeco, innerDeco, index, view) {
    let child = this.top.children[index];
    if (child.dirty == NODE_DIRTY && child.dom == child.contentDOM)
      child.dirty = CONTENT_DIRTY;
    if (!child.update(node, outerDeco, innerDeco, view))
      return false;
    this.destroyBetween(this.index, index);
    this.index++;
    return true;
  }
  findIndexWithChild(domNode) {
    for (;; ) {
      let parent = domNode.parentNode;
      if (!parent)
        return -1;
      if (parent == this.top.contentDOM) {
        let desc = domNode.pmViewDesc;
        if (desc)
          for (let i = this.index;i < this.top.children.length; i++) {
            if (this.top.children[i] == desc)
              return i;
          }
        return -1;
      }
      domNode = parent;
    }
  }
  updateNextNode(node, outerDeco, innerDeco, view, index, pos) {
    for (let i = this.index;i < this.top.children.length; i++) {
      let next = this.top.children[i];
      if (next instanceof NodeViewDesc) {
        let preMatch = this.preMatch.matched.get(next);
        if (preMatch != null && preMatch != index)
          return false;
        let nextDOM = next.dom, updated;
        let locked = this.isLocked(nextDOM) && !(node.isText && next.node && next.node.isText && next.nodeDOM.nodeValue == node.text && next.dirty != NODE_DIRTY && sameOuterDeco(outerDeco, next.outerDeco));
        if (!locked && next.update(node, outerDeco, innerDeco, view)) {
          this.destroyBetween(this.index, i);
          if (next.dom != nextDOM)
            this.changed = true;
          this.index++;
          return true;
        } else if (!locked && (updated = this.recreateWrapper(next, node, outerDeco, innerDeco, view, pos))) {
          this.destroyBetween(this.index, i);
          this.top.children[this.index] = updated;
          if (updated.contentDOM) {
            updated.dirty = CONTENT_DIRTY;
            updated.updateChildren(view, pos + 1);
            updated.dirty = NOT_DIRTY;
          }
          this.changed = true;
          this.index++;
          return true;
        }
        break;
      }
    }
    return false;
  }
  recreateWrapper(next, node, outerDeco, innerDeco, view, pos) {
    if (next.dirty || node.isAtom || !next.children.length || !next.node.content.eq(node.content) || !sameOuterDeco(outerDeco, next.outerDeco) || !innerDeco.eq(next.innerDeco))
      return null;
    let wrapper = NodeViewDesc.create(this.top, node, outerDeco, innerDeco, view, pos);
    if (wrapper.contentDOM) {
      wrapper.children = next.children;
      next.children = [];
      for (let ch of wrapper.children)
        ch.parent = wrapper;
    }
    next.destroy();
    return wrapper;
  }
  addNode(node, outerDeco, innerDeco, view, pos) {
    let desc = NodeViewDesc.create(this.top, node, outerDeco, innerDeco, view, pos);
    if (desc.contentDOM)
      desc.updateChildren(view, pos + 1);
    this.top.children.splice(this.index++, 0, desc);
    this.changed = true;
  }
  placeWidget(widget, view, pos) {
    let next = this.index < this.top.children.length ? this.top.children[this.index] : null;
    if (next && next.matchesWidget(widget) && (widget == next.widget || !next.widget.type.toDOM.parentNode)) {
      this.index++;
    } else {
      let desc = new WidgetViewDesc(this.top, widget, view, pos);
      this.top.children.splice(this.index++, 0, desc);
      this.changed = true;
    }
  }
  addTextblockHacks() {
    let lastChild = this.top.children[this.index - 1], parent = this.top;
    while (lastChild instanceof MarkViewDesc) {
      parent = lastChild;
      lastChild = parent.children[parent.children.length - 1];
    }
    if (!lastChild || !(lastChild instanceof TextViewDesc) || /\n$/.test(lastChild.node.text) || this.view.requiresGeckoHackNode && /\s$/.test(lastChild.node.text)) {
      if ((safari2 || chrome) && lastChild && lastChild.dom.contentEditable == "false")
        this.addHackNode("IMG", parent);
      this.addHackNode("BR", this.top);
    }
  }
  addHackNode(nodeName, parent) {
    if (parent == this.top && this.index < parent.children.length && parent.children[this.index].matchesHack(nodeName)) {
      this.index++;
    } else {
      let dom = document.createElement(nodeName);
      if (nodeName == "IMG") {
        dom.className = "ProseMirror-separator";
        dom.alt = "";
      }
      if (nodeName == "BR")
        dom.className = "ProseMirror-trailingBreak";
      let hack = new TrailingHackViewDesc(this.top, [], dom, null);
      if (parent != this.top)
        parent.children.push(hack);
      else
        parent.children.splice(this.index++, 0, hack);
      this.changed = true;
    }
  }
  isLocked(node) {
    return this.lock && (node == this.lock || node.nodeType == 1 && node.contains(this.lock.parentNode));
  }
}
function preMatch(frag, parentDesc) {
  let curDesc = parentDesc, descI = curDesc.children.length;
  let fI = frag.childCount, matched = new Map, matches2 = [];
  outer:
    while (fI > 0) {
      let desc;
      for (;; ) {
        if (descI) {
          let next = curDesc.children[descI - 1];
          if (next instanceof MarkViewDesc) {
            curDesc = next;
            descI = next.children.length;
          } else {
            desc = next;
            descI--;
            break;
          }
        } else if (curDesc == parentDesc) {
          break outer;
        } else {
          descI = curDesc.parent.children.indexOf(curDesc);
          curDesc = curDesc.parent;
        }
      }
      let node = desc.node;
      if (!node)
        continue;
      if (node != frag.child(fI - 1))
        break;
      --fI;
      matched.set(desc, fI);
      matches2.push(desc);
    }
  return { index: fI, matched, matches: matches2.reverse() };
}
function compareSide(a, b) {
  return a.type.side - b.type.side;
}
function iterDeco(parent, deco, onWidget, onNode) {
  let locals = deco.locals(parent), offset = 0;
  if (locals.length == 0) {
    for (let i = 0;i < parent.childCount; i++) {
      let child = parent.child(i);
      onNode(child, locals, deco.forChild(offset, child), i);
      offset += child.nodeSize;
    }
    return;
  }
  let decoIndex = 0, active = [], restNode = null;
  for (let parentIndex = 0;; ) {
    let widget, widgets;
    while (decoIndex < locals.length && locals[decoIndex].to == offset) {
      let next = locals[decoIndex++];
      if (next.widget) {
        if (!widget)
          widget = next;
        else
          (widgets || (widgets = [widget])).push(next);
      }
    }
    if (widget) {
      if (widgets) {
        widgets.sort(compareSide);
        for (let i = 0;i < widgets.length; i++)
          onWidget(widgets[i], parentIndex, !!restNode);
      } else {
        onWidget(widget, parentIndex, !!restNode);
      }
    }
    let child, index;
    if (restNode) {
      index = -1;
      child = restNode;
      restNode = null;
    } else if (parentIndex < parent.childCount) {
      index = parentIndex;
      child = parent.child(parentIndex++);
    } else {
      break;
    }
    for (let i = 0;i < active.length; i++)
      if (active[i].to <= offset)
        active.splice(i--, 1);
    while (decoIndex < locals.length && locals[decoIndex].from <= offset && locals[decoIndex].to > offset)
      active.push(locals[decoIndex++]);
    let end = offset + child.nodeSize;
    if (child.isText) {
      let cutAt = end;
      if (decoIndex < locals.length && locals[decoIndex].from < cutAt)
        cutAt = locals[decoIndex].from;
      for (let i = 0;i < active.length; i++)
        if (active[i].to < cutAt)
          cutAt = active[i].to;
      if (cutAt < end) {
        restNode = child.cut(cutAt - offset);
        child = child.cut(0, cutAt - offset);
        end = cutAt;
        index = -1;
      }
    } else {
      while (decoIndex < locals.length && locals[decoIndex].to < end)
        decoIndex++;
    }
    let outerDeco = child.isInline && !child.isLeaf ? active.filter((d) => !d.inline) : active.slice();
    onNode(child, outerDeco, deco.forChild(offset, child), index);
    offset = end;
  }
}
function iosHacks(dom) {
  if (dom.nodeName == "UL" || dom.nodeName == "OL") {
    let oldCSS = dom.style.cssText;
    dom.style.cssText = oldCSS + "; list-style: square !important";
    window.getComputedStyle(dom).listStyle;
    dom.style.cssText = oldCSS;
  }
}
function findTextInFragment(frag, text, from, to) {
  for (let i = 0, pos = 0;i < frag.childCount && pos <= to; ) {
    let child = frag.child(i++), childStart = pos;
    pos += child.nodeSize;
    if (!child.isText)
      continue;
    let str = child.text;
    while (i < frag.childCount) {
      let next = frag.child(i++);
      pos += next.nodeSize;
      if (!next.isText)
        break;
      str += next.text;
    }
    if (pos >= from) {
      if (pos >= to && str.slice(to - text.length - childStart, to - childStart) == text)
        return to - text.length;
      let found2 = childStart < to ? str.lastIndexOf(text, to - childStart - 1) : -1;
      if (found2 >= 0 && found2 + text.length + childStart >= from)
        return childStart + found2;
      if (from == to && str.length >= to + text.length - childStart && str.slice(to - childStart, to - childStart + text.length) == text)
        return to;
    }
  }
  return -1;
}
function replaceNodes(nodes, from, to, view, replacement) {
  let result = [];
  for (let i = 0, off = 0;i < nodes.length; i++) {
    let child = nodes[i], start = off, end = off += child.size;
    if (start >= to || end <= from) {
      result.push(child);
    } else {
      if (start < from)
        result.push(child.slice(0, from - start, view));
      if (replacement) {
        result.push(replacement);
        replacement = undefined;
      }
      if (end > to)
        result.push(child.slice(to - start, child.size, view));
    }
  }
  return result;
}
function selectionFromDOM(view, origin = null) {
  let domSel = view.domSelectionRange(), doc3 = view.state.doc;
  if (!domSel.focusNode)
    return null;
  let nearestDesc = view.docView.nearestDesc(domSel.focusNode), inWidget = nearestDesc && nearestDesc.size == 0;
  let head = view.docView.posFromDOM(domSel.focusNode, domSel.focusOffset, 1);
  if (head < 0)
    return null;
  let $head = doc3.resolve(head), anchor, selection;
  if (selectionCollapsed(domSel)) {
    anchor = head;
    while (nearestDesc && !nearestDesc.node)
      nearestDesc = nearestDesc.parent;
    let nearestDescNode = nearestDesc.node;
    if (nearestDesc && nearestDescNode.isAtom && NodeSelection.isSelectable(nearestDescNode) && nearestDesc.parent && !(nearestDescNode.isInline && isOnEdge(domSel.focusNode, domSel.focusOffset, nearestDesc.dom))) {
      let pos = nearestDesc.posBefore;
      selection = new NodeSelection(head == pos ? $head : doc3.resolve(pos));
    }
  } else {
    if (domSel instanceof view.dom.ownerDocument.defaultView.Selection && domSel.rangeCount > 1) {
      let min = head, max = head;
      for (let i = 0;i < domSel.rangeCount; i++) {
        let range = domSel.getRangeAt(i);
        min = Math.min(min, view.docView.posFromDOM(range.startContainer, range.startOffset, 1));
        max = Math.max(max, view.docView.posFromDOM(range.endContainer, range.endOffset, -1));
      }
      if (min < 0)
        return null;
      [anchor, head] = max == view.state.selection.anchor ? [max, min] : [min, max];
      $head = doc3.resolve(head);
    } else {
      anchor = view.docView.posFromDOM(domSel.anchorNode, domSel.anchorOffset, 1);
    }
    if (anchor < 0)
      return null;
  }
  let $anchor = doc3.resolve(anchor);
  if (!selection) {
    let bias = origin == "pointer" || view.state.selection.head < $head.pos && !inWidget ? 1 : -1;
    selection = selectionBetween(view, $anchor, $head, bias);
  }
  return selection;
}
function editorOwnsSelection(view) {
  return view.editable ? view.hasFocus() : hasSelection(view) && document.activeElement && document.activeElement.contains(view.dom);
}
function selectionToDOM(view, force = false) {
  let sel = view.state.selection;
  syncNodeSelection(view, sel);
  if (!editorOwnsSelection(view))
    return;
  if (!force && view.input.mouseDown && view.input.mouseDown.allowDefault && chrome) {
    let domSel = view.domSelectionRange(), curSel = view.domObserver.currentSelection;
    if (domSel.anchorNode && curSel.anchorNode && isEquivalentPosition(domSel.anchorNode, domSel.anchorOffset, curSel.anchorNode, curSel.anchorOffset)) {
      view.input.mouseDown.delayedSelectionSync = true;
      view.domObserver.setCurSelection();
      return;
    }
  }
  view.domObserver.disconnectSelection();
  if (view.cursorWrapper) {
    selectCursorWrapper(view);
  } else {
    let { anchor, head } = sel, resetEditableFrom, resetEditableTo;
    if (brokenSelectBetweenUneditable && !(sel instanceof TextSelection)) {
      if (!sel.$from.parent.inlineContent)
        resetEditableFrom = temporarilyEditableNear(view, sel.from);
      if (!sel.empty && !sel.$from.parent.inlineContent)
        resetEditableTo = temporarilyEditableNear(view, sel.to);
    }
    view.docView.setSelection(anchor, head, view, force);
    if (brokenSelectBetweenUneditable) {
      if (resetEditableFrom)
        resetEditable(resetEditableFrom);
      if (resetEditableTo)
        resetEditable(resetEditableTo);
    }
    if (sel.visible) {
      view.dom.classList.remove("ProseMirror-hideselection");
    } else {
      view.dom.classList.add("ProseMirror-hideselection");
      if ("onselectionchange" in document)
        removeClassOnSelectionChange(view);
    }
  }
  view.domObserver.setCurSelection();
  view.domObserver.connectSelection();
}
var brokenSelectBetweenUneditable = safari2 || chrome && chrome_version < 63;
function temporarilyEditableNear(view, pos) {
  let { node, offset } = view.docView.domFromPos(pos, 0);
  let after = offset < node.childNodes.length ? node.childNodes[offset] : null;
  let before = offset ? node.childNodes[offset - 1] : null;
  if (safari2 && after && after.contentEditable == "false")
    return setEditable(after);
  if ((!after || after.contentEditable == "false") && (!before || before.contentEditable == "false")) {
    if (after)
      return setEditable(after);
    else if (before)
      return setEditable(before);
  }
}
function setEditable(element) {
  element.contentEditable = "true";
  if (safari2 && element.draggable) {
    element.draggable = false;
    element.wasDraggable = true;
  }
  return element;
}
function resetEditable(element) {
  element.contentEditable = "false";
  if (element.wasDraggable) {
    element.draggable = true;
    element.wasDraggable = null;
  }
}
function removeClassOnSelectionChange(view) {
  let doc3 = view.dom.ownerDocument;
  doc3.removeEventListener("selectionchange", view.input.hideSelectionGuard);
  let domSel = view.domSelectionRange();
  let { anchorNode: node, anchorOffset: offset } = domSel;
  doc3.addEventListener("selectionchange", view.input.hideSelectionGuard = () => {
    if (domSel.anchorNode != node || domSel.anchorOffset != offset) {
      doc3.removeEventListener("selectionchange", view.input.hideSelectionGuard);
      setTimeout(() => {
        if (!editorOwnsSelection(view) || view.state.selection.visible)
          view.dom.classList.remove("ProseMirror-hideselection");
      }, 20);
    }
  });
}
function selectCursorWrapper(view) {
  let domSel = view.domSelection();
  if (!domSel)
    return;
  let node = view.cursorWrapper.dom, img = node.nodeName == "IMG";
  if (img)
    domSel.collapse(node.parentNode, domIndex(node) + 1);
  else
    domSel.collapse(node, 0);
  if (!img && !view.state.selection.visible && ie && ie_version <= 11) {
    node.disabled = true;
    node.disabled = false;
  }
}
function syncNodeSelection(view, sel) {
  if (sel instanceof NodeSelection) {
    let desc = view.docView.descAt(sel.from);
    if (desc != view.lastSelectedViewDesc) {
      clearNodeSelection(view);
      if (desc)
        desc.selectNode();
      view.lastSelectedViewDesc = desc;
    }
  } else {
    clearNodeSelection(view);
  }
}
function clearNodeSelection(view) {
  if (view.lastSelectedViewDesc) {
    if (view.lastSelectedViewDesc.parent)
      view.lastSelectedViewDesc.deselectNode();
    view.lastSelectedViewDesc = undefined;
  }
}
function selectionBetween(view, $anchor, $head, bias) {
  return view.someProp("createSelectionBetween", (f) => f(view, $anchor, $head)) || TextSelection.between($anchor, $head, bias);
}
function hasFocusAndSelection(view) {
  if (view.editable && !view.hasFocus())
    return false;
  return hasSelection(view);
}
function hasSelection(view) {
  let sel = view.domSelectionRange();
  if (!sel.anchorNode)
    return false;
  try {
    return view.dom.contains(sel.anchorNode.nodeType == 3 ? sel.anchorNode.parentNode : sel.anchorNode) && (view.editable || view.dom.contains(sel.focusNode.nodeType == 3 ? sel.focusNode.parentNode : sel.focusNode));
  } catch (_) {
    return false;
  }
}
function anchorInRightPlace(view) {
  let anchorDOM = view.docView.domFromPos(view.state.selection.anchor, 0);
  let domSel = view.domSelectionRange();
  return isEquivalentPosition(anchorDOM.node, anchorDOM.offset, domSel.anchorNode, domSel.anchorOffset);
}
function moveSelectionBlock(state, dir) {
  let { $anchor, $head } = state.selection;
  let $side = dir > 0 ? $anchor.max($head) : $anchor.min($head);
  let $start = !$side.parent.inlineContent ? $side : $side.depth ? state.doc.resolve(dir > 0 ? $side.after() : $side.before()) : null;
  return $start && Selection.findFrom($start, dir);
}
function apply(view, sel) {
  view.dispatch(view.state.tr.setSelection(sel).scrollIntoView());
  return true;
}
function selectHorizontally(view, dir, mods) {
  let sel = view.state.selection;
  if (sel instanceof TextSelection) {
    if (mods.indexOf("s") > -1) {
      let { $head } = sel, node = $head.textOffset ? null : dir < 0 ? $head.nodeBefore : $head.nodeAfter;
      if (!node || node.isText || !node.isLeaf)
        return false;
      let $newHead = view.state.doc.resolve($head.pos + node.nodeSize * (dir < 0 ? -1 : 1));
      return apply(view, new TextSelection(sel.$anchor, $newHead));
    } else if (!sel.empty) {
      return false;
    } else if (view.endOfTextblock(dir > 0 ? "forward" : "backward")) {
      let next = moveSelectionBlock(view.state, dir);
      if (next && next instanceof NodeSelection)
        return apply(view, next);
      return false;
    } else if (!(mac && mods.indexOf("m") > -1)) {
      let $head = sel.$head, node = $head.textOffset ? null : dir < 0 ? $head.nodeBefore : $head.nodeAfter, desc;
      if (!node || node.isText)
        return false;
      let nodePos = dir < 0 ? $head.pos - node.nodeSize : $head.pos;
      if (!(node.isAtom || (desc = view.docView.descAt(nodePos)) && !desc.contentDOM))
        return false;
      if (NodeSelection.isSelectable(node)) {
        return apply(view, new NodeSelection(dir < 0 ? view.state.doc.resolve($head.pos - node.nodeSize) : $head));
      } else if (webkit) {
        return apply(view, new TextSelection(view.state.doc.resolve(dir < 0 ? nodePos : nodePos + node.nodeSize)));
      } else {
        return false;
      }
    }
  } else if (sel instanceof NodeSelection && sel.node.isInline) {
    return apply(view, new TextSelection(dir > 0 ? sel.$to : sel.$from));
  } else {
    let next = moveSelectionBlock(view.state, dir);
    if (next)
      return apply(view, next);
    return false;
  }
}
function nodeLen(node) {
  return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length;
}
function isIgnorable(dom, dir) {
  let desc = dom.pmViewDesc;
  return desc && desc.size == 0 && (dir < 0 || dom.nextSibling || dom.nodeName != "BR");
}
function skipIgnoredNodes(view, dir) {
  return dir < 0 ? skipIgnoredNodesBefore(view) : skipIgnoredNodesAfter(view);
}
function skipIgnoredNodesBefore(view) {
  let sel = view.domSelectionRange();
  let { focusNode: node, focusOffset: offset } = sel;
  if (!node)
    return;
  let moveNode, moveOffset, force = false;
  if (gecko && node.nodeType == 1 && offset < nodeLen(node) && isIgnorable(node.childNodes[offset], -1))
    force = true;
  for (;; ) {
    if (offset > 0) {
      if (node.nodeType != 1) {
        break;
      } else {
        let before = node.childNodes[offset - 1];
        if (isIgnorable(before, -1)) {
          moveNode = node;
          moveOffset = --offset;
        } else if (before.nodeType == 3) {
          node = before;
          offset = node.nodeValue.length;
        } else
          break;
      }
    } else if (isBlockNode(node)) {
      break;
    } else {
      let prev = node.previousSibling;
      while (prev && isIgnorable(prev, -1)) {
        moveNode = node.parentNode;
        moveOffset = domIndex(prev);
        prev = prev.previousSibling;
      }
      if (!prev) {
        node = node.parentNode;
        if (node == view.dom)
          break;
        offset = 0;
      } else {
        node = prev;
        offset = nodeLen(node);
      }
    }
  }
  if (force)
    setSelFocus(view, node, offset);
  else if (moveNode)
    setSelFocus(view, moveNode, moveOffset);
}
function skipIgnoredNodesAfter(view) {
  let sel = view.domSelectionRange();
  let { focusNode: node, focusOffset: offset } = sel;
  if (!node)
    return;
  let len = nodeLen(node);
  let moveNode, moveOffset;
  for (;; ) {
    if (offset < len) {
      if (node.nodeType != 1)
        break;
      let after = node.childNodes[offset];
      if (isIgnorable(after, 1)) {
        moveNode = node;
        moveOffset = ++offset;
      } else
        break;
    } else if (isBlockNode(node)) {
      break;
    } else {
      let next = node.nextSibling;
      while (next && isIgnorable(next, 1)) {
        moveNode = next.parentNode;
        moveOffset = domIndex(next) + 1;
        next = next.nextSibling;
      }
      if (!next) {
        node = node.parentNode;
        if (node == view.dom)
          break;
        offset = len = 0;
      } else {
        node = next;
        offset = 0;
        len = nodeLen(node);
      }
    }
  }
  if (moveNode)
    setSelFocus(view, moveNode, moveOffset);
}
function isBlockNode(dom) {
  let desc = dom.pmViewDesc;
  return desc && desc.node && desc.node.isBlock;
}
function textNodeAfter(node, offset) {
  while (node && offset == node.childNodes.length && !hasBlockDesc(node)) {
    offset = domIndex(node) + 1;
    node = node.parentNode;
  }
  while (node && offset < node.childNodes.length) {
    let next = node.childNodes[offset];
    if (next.nodeType == 3)
      return next;
    if (next.nodeType == 1 && next.contentEditable == "false")
      break;
    node = next;
    offset = 0;
  }
}
function textNodeBefore(node, offset) {
  while (node && !offset && !hasBlockDesc(node)) {
    offset = domIndex(node);
    node = node.parentNode;
  }
  while (node && offset) {
    let next = node.childNodes[offset - 1];
    if (next.nodeType == 3)
      return next;
    if (next.nodeType == 1 && next.contentEditable == "false")
      break;
    node = next;
    offset = node.childNodes.length;
  }
}
function setSelFocus(view, node, offset) {
  if (node.nodeType != 3) {
    let before, after;
    if (after = textNodeAfter(node, offset)) {
      node = after;
      offset = 0;
    } else if (before = textNodeBefore(node, offset)) {
      node = before;
      offset = before.nodeValue.length;
    }
  }
  let sel = view.domSelection();
  if (!sel)
    return;
  if (selectionCollapsed(sel)) {
    let range = document.createRange();
    range.setEnd(node, offset);
    range.setStart(node, offset);
    sel.removeAllRanges();
    sel.addRange(range);
  } else if (sel.extend) {
    sel.extend(node, offset);
  }
  view.domObserver.setCurSelection();
  let { state } = view;
  setTimeout(() => {
    if (view.state == state)
      selectionToDOM(view);
  }, 50);
}
function findDirection(view, pos) {
  let $pos = view.state.doc.resolve(pos);
  if (!(chrome || windows) && $pos.parent.inlineContent) {
    let coords = view.coordsAtPos(pos);
    if (pos > $pos.start()) {
      let before = view.coordsAtPos(pos - 1);
      let mid = (before.top + before.bottom) / 2;
      if (mid > coords.top && mid < coords.bottom && Math.abs(before.left - coords.left) > 1)
        return before.left < coords.left ? "ltr" : "rtl";
    }
    if (pos < $pos.end()) {
      let after = view.coordsAtPos(pos + 1);
      let mid = (after.top + after.bottom) / 2;
      if (mid > coords.top && mid < coords.bottom && Math.abs(after.left - coords.left) > 1)
        return after.left > coords.left ? "ltr" : "rtl";
    }
  }
  let computed = getComputedStyle(view.dom).direction;
  return computed == "rtl" ? "rtl" : "ltr";
}
function selectVertically(view, dir, mods) {
  let sel = view.state.selection;
  if (sel instanceof TextSelection && !sel.empty || mods.indexOf("s") > -1)
    return false;
  if (mac && mods.indexOf("m") > -1)
    return false;
  let { $from, $to } = sel;
  if (!$from.parent.inlineContent || view.endOfTextblock(dir < 0 ? "up" : "down")) {
    let next = moveSelectionBlock(view.state, dir);
    if (next && next instanceof NodeSelection)
      return apply(view, next);
  }
  if (!$from.parent.inlineContent) {
    let side = dir < 0 ? $from : $to;
    let beyond = sel instanceof AllSelection ? Selection.near(side, dir) : Selection.findFrom(side, dir);
    return beyond ? apply(view, beyond) : false;
  }
  return false;
}
function stopNativeHorizontalDelete(view, dir) {
  if (!(view.state.selection instanceof TextSelection))
    return true;
  let { $head, $anchor, empty } = view.state.selection;
  if (!$head.sameParent($anchor))
    return true;
  if (!empty)
    return false;
  if (view.endOfTextblock(dir > 0 ? "forward" : "backward"))
    return true;
  let nextNode = !$head.textOffset && (dir < 0 ? $head.nodeBefore : $head.nodeAfter);
  if (nextNode && !nextNode.isText) {
    let tr = view.state.tr;
    if (dir < 0)
      tr.delete($head.pos - nextNode.nodeSize, $head.pos);
    else
      tr.delete($head.pos, $head.pos + nextNode.nodeSize);
    view.dispatch(tr);
    return true;
  }
  return false;
}
function switchEditable(view, node, state) {
  view.domObserver.stop();
  node.contentEditable = state;
  view.domObserver.start();
}
function safariDownArrowBug(view) {
  if (!safari2 || view.state.selection.$head.parentOffset > 0)
    return false;
  let { focusNode, focusOffset } = view.domSelectionRange();
  if (focusNode && focusNode.nodeType == 1 && focusOffset == 0 && focusNode.firstChild && focusNode.firstChild.contentEditable == "false") {
    let child = focusNode.firstChild;
    switchEditable(view, child, "true");
    setTimeout(() => switchEditable(view, child, "false"), 20);
  }
  return false;
}
function getMods(event) {
  let result = "";
  if (event.ctrlKey)
    result += "c";
  if (event.metaKey)
    result += "m";
  if (event.altKey)
    result += "a";
  if (event.shiftKey)
    result += "s";
  return result;
}
function captureKeyDown(view, event) {
  let code = event.keyCode, mods = getMods(event);
  if (code == 8 || mac && code == 72 && mods == "c") {
    return stopNativeHorizontalDelete(view, -1) || skipIgnoredNodes(view, -1);
  } else if (code == 46 && !event.shiftKey || mac && code == 68 && mods == "c") {
    return stopNativeHorizontalDelete(view, 1) || skipIgnoredNodes(view, 1);
  } else if (code == 13 || code == 27) {
    return true;
  } else if (code == 37 || mac && code == 66 && mods == "c") {
    let dir = code == 37 ? findDirection(view, view.state.selection.from) == "ltr" ? -1 : 1 : -1;
    return selectHorizontally(view, dir, mods) || skipIgnoredNodes(view, dir);
  } else if (code == 39 || mac && code == 70 && mods == "c") {
    let dir = code == 39 ? findDirection(view, view.state.selection.from) == "ltr" ? 1 : -1 : 1;
    return selectHorizontally(view, dir, mods) || skipIgnoredNodes(view, dir);
  } else if (code == 38 || mac && code == 80 && mods == "c") {
    return selectVertically(view, -1, mods) || skipIgnoredNodes(view, -1);
  } else if (code == 40 || mac && code == 78 && mods == "c") {
    return safariDownArrowBug(view) || selectVertically(view, 1, mods) || skipIgnoredNodes(view, 1);
  } else if (mods == (mac ? "m" : "c") && (code == 66 || code == 73 || code == 89 || code == 90)) {
    return true;
  }
  return false;
}
function serializeForClipboard(view, slice) {
  view.someProp("transformCopied", (f) => {
    slice = f(slice, view);
  });
  let context = [], { content, openStart, openEnd } = slice;
  while (openStart > 1 && openEnd > 1 && content.childCount == 1 && content.firstChild.childCount == 1) {
    openStart--;
    openEnd--;
    let node = content.firstChild;
    context.push(node.type.name, node.attrs != node.type.defaultAttrs ? node.attrs : null);
    content = node.content;
  }
  let serializer = view.someProp("clipboardSerializer") || DOMSerializer.fromSchema(view.state.schema);
  let doc3 = detachedDoc(), wrap2 = doc3.createElement("div");
  wrap2.appendChild(serializer.serializeFragment(content, { document: doc3 }));
  let firstChild = wrap2.firstChild, needsWrap, wrappers = 0;
  while (firstChild && firstChild.nodeType == 1 && (needsWrap = wrapMap[firstChild.nodeName.toLowerCase()])) {
    for (let i = needsWrap.length - 1;i >= 0; i--) {
      let wrapper = doc3.createElement(needsWrap[i]);
      while (wrap2.firstChild)
        wrapper.appendChild(wrap2.firstChild);
      wrap2.appendChild(wrapper);
      wrappers++;
    }
    firstChild = wrap2.firstChild;
  }
  if (firstChild && firstChild.nodeType == 1)
    firstChild.setAttribute("data-pm-slice", `${openStart} ${openEnd}${wrappers ? ` -${wrappers}` : ""} ${JSON.stringify(context)}`);
  let text = view.someProp("clipboardTextSerializer", (f) => f(slice, view)) || slice.content.textBetween(0, slice.content.size, `

`);
  return { dom: wrap2, text, slice };
}
function parseFromClipboard(view, text, html, plainText, $context) {
  let inCode = $context.parent.type.spec.code;
  let dom, slice;
  if (!html && !text)
    return null;
  let asText = !!text && (plainText || inCode || !html);
  if (asText) {
    view.someProp("transformPastedText", (f) => {
      text = f(text, inCode || plainText, view);
    });
    if (inCode) {
      slice = new Slice(Fragment.from(view.state.schema.text(text.replace(/\r\n?/g, `
`))), 0, 0);
      view.someProp("transformPasted", (f) => {
        slice = f(slice, view, true);
      });
      return slice;
    }
    let parsed = view.someProp("clipboardTextParser", (f) => f(text, $context, plainText, view));
    if (parsed) {
      slice = parsed;
    } else {
      let marks = $context.marks();
      let { schema } = view.state, serializer = DOMSerializer.fromSchema(schema);
      dom = document.createElement("div");
      text.split(/(?:\r\n?|\n)+/).forEach((block) => {
        let p = dom.appendChild(document.createElement("p"));
        if (block)
          p.appendChild(serializer.serializeNode(schema.text(block, marks)));
      });
    }
  } else {
    view.someProp("transformPastedHTML", (f) => {
      html = f(html, view);
    });
    dom = readHTML(html);
    if (webkit)
      restoreReplacedSpaces(dom);
  }
  let contextNode = dom && dom.querySelector("[data-pm-slice]");
  let sliceData = contextNode && /^(\d+) (\d+)(?: -(\d+))? (.*)/.exec(contextNode.getAttribute("data-pm-slice") || "");
  if (sliceData && sliceData[3])
    for (let i = +sliceData[3];i > 0; i--) {
      let child = dom.firstChild;
      while (child && child.nodeType != 1)
        child = child.nextSibling;
      if (!child)
        break;
      dom = child;
    }
  if (!slice) {
    let parser = view.someProp("clipboardParser") || view.someProp("domParser") || DOMParser2.fromSchema(view.state.schema);
    slice = parser.parseSlice(dom, {
      preserveWhitespace: !!(asText || sliceData),
      context: $context,
      ruleFromNode(dom2) {
        if (dom2.nodeName == "BR" && !dom2.nextSibling && dom2.parentNode && !inlineParents.test(dom2.parentNode.nodeName))
          return { ignore: true };
        return null;
      }
    });
  }
  if (sliceData) {
    slice = addContext(closeSlice(slice, +sliceData[1], +sliceData[2]), sliceData[4]);
  } else {
    slice = Slice.maxOpen(normalizeSiblings(slice.content, $context), true);
    if (slice.openStart || slice.openEnd) {
      let openStart = 0, openEnd = 0;
      for (let node = slice.content.firstChild;openStart < slice.openStart && !node.type.spec.isolating; openStart++, node = node.firstChild) {}
      for (let node = slice.content.lastChild;openEnd < slice.openEnd && !node.type.spec.isolating; openEnd++, node = node.lastChild) {}
      slice = closeSlice(slice, openStart, openEnd);
    }
  }
  view.someProp("transformPasted", (f) => {
    slice = f(slice, view, asText);
  });
  return slice;
}
var inlineParents = /^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var)$/i;
function normalizeSiblings(fragment, $context) {
  if (fragment.childCount < 2)
    return fragment;
  for (let d = $context.depth;d >= 0; d--) {
    let parent = $context.node(d);
    let match = parent.contentMatchAt($context.index(d));
    let lastWrap, result = [];
    fragment.forEach((node) => {
      if (!result)
        return;
      let wrap2 = match.findWrapping(node.type), inLast;
      if (!wrap2)
        return result = null;
      if (inLast = result.length && lastWrap.length && addToSibling(wrap2, lastWrap, node, result[result.length - 1], 0)) {
        result[result.length - 1] = inLast;
      } else {
        if (result.length)
          result[result.length - 1] = closeRight(result[result.length - 1], lastWrap.length);
        let wrapped = withWrappers(node, wrap2);
        result.push(wrapped);
        match = match.matchType(wrapped.type);
        lastWrap = wrap2;
      }
    });
    if (result)
      return Fragment.from(result);
  }
  return fragment;
}
function withWrappers(node, wrap2, from = 0) {
  for (let i = wrap2.length - 1;i >= from; i--)
    node = wrap2[i].create(null, Fragment.from(node));
  return node;
}
function addToSibling(wrap2, lastWrap, node, sibling, depth) {
  if (depth < wrap2.length && depth < lastWrap.length && wrap2[depth] == lastWrap[depth]) {
    let inner = addToSibling(wrap2, lastWrap, node, sibling.lastChild, depth + 1);
    if (inner)
      return sibling.copy(sibling.content.replaceChild(sibling.childCount - 1, inner));
    let match = sibling.contentMatchAt(sibling.childCount);
    if (match.matchType(depth == wrap2.length - 1 ? node.type : wrap2[depth + 1]))
      return sibling.copy(sibling.content.append(Fragment.from(withWrappers(node, wrap2, depth + 1))));
  }
}
function closeRight(node, depth) {
  if (depth == 0)
    return node;
  let fragment = node.content.replaceChild(node.childCount - 1, closeRight(node.lastChild, depth - 1));
  let fill = node.contentMatchAt(node.childCount).fillBefore(Fragment.empty, true);
  return node.copy(fragment.append(fill));
}
function closeRange(fragment, side, from, to, depth, openEnd) {
  let node = side < 0 ? fragment.firstChild : fragment.lastChild, inner = node.content;
  if (fragment.childCount > 1)
    openEnd = 0;
  if (depth < to - 1)
    inner = closeRange(inner, side, from, to, depth + 1, openEnd);
  if (depth >= from)
    inner = side < 0 ? node.contentMatchAt(0).fillBefore(inner, openEnd <= depth).append(inner) : inner.append(node.contentMatchAt(node.childCount).fillBefore(Fragment.empty, true));
  return fragment.replaceChild(side < 0 ? 0 : fragment.childCount - 1, node.copy(inner));
}
function closeSlice(slice, openStart, openEnd) {
  if (openStart < slice.openStart)
    slice = new Slice(closeRange(slice.content, -1, openStart, slice.openStart, 0, slice.openEnd), openStart, slice.openEnd);
  if (openEnd < slice.openEnd)
    slice = new Slice(closeRange(slice.content, 1, openEnd, slice.openEnd, 0, 0), slice.openStart, openEnd);
  return slice;
}
var wrapMap = {
  thead: ["table"],
  tbody: ["table"],
  tfoot: ["table"],
  caption: ["table"],
  colgroup: ["table"],
  col: ["table", "colgroup"],
  tr: ["table", "tbody"],
  td: ["table", "tbody", "tr"],
  th: ["table", "tbody", "tr"]
};
var _detachedDoc = null;
function detachedDoc() {
  return _detachedDoc || (_detachedDoc = document.implementation.createHTMLDocument("title"));
}
var _policy = null;
function maybeWrapTrusted(html) {
  let trustedTypes = window.trustedTypes;
  if (!trustedTypes)
    return html;
  if (!_policy)
    _policy = trustedTypes.defaultPolicy || trustedTypes.createPolicy("ProseMirrorClipboard", { createHTML: (s) => s });
  return _policy.createHTML(html);
}
function readHTML(html) {
  let metas = /^(\s*<meta [^>]*>)*/.exec(html);
  if (metas)
    html = html.slice(metas[0].length);
  let elt = detachedDoc().createElement("div");
  let firstTag = /<([a-z][^>\s]+)/i.exec(html), wrap2;
  if (wrap2 = firstTag && wrapMap[firstTag[1].toLowerCase()])
    html = wrap2.map((n) => "<" + n + ">").join("") + html + wrap2.map((n) => "</" + n + ">").reverse().join("");
  elt.innerHTML = maybeWrapTrusted(html);
  if (wrap2)
    for (let i = 0;i < wrap2.length; i++)
      elt = elt.querySelector(wrap2[i]) || elt;
  return elt;
}
function restoreReplacedSpaces(dom) {
  let nodes = dom.querySelectorAll(chrome ? "span:not([class]):not([style])" : "span.Apple-converted-space");
  for (let i = 0;i < nodes.length; i++) {
    let node = nodes[i];
    if (node.childNodes.length == 1 && node.textContent == "" && node.parentNode)
      node.parentNode.replaceChild(dom.ownerDocument.createTextNode(" "), node);
  }
}
function addContext(slice, context) {
  if (!slice.size)
    return slice;
  let schema = slice.content.firstChild.type.schema, array;
  try {
    array = JSON.parse(context);
  } catch (e) {
    return slice;
  }
  let { content, openStart, openEnd } = slice;
  for (let i = array.length - 2;i >= 0; i -= 2) {
    let type = schema.nodes[array[i]];
    if (!type || type.hasRequiredAttrs())
      break;
    content = Fragment.from(type.create(array[i + 1], content));
    openStart++;
    openEnd++;
  }
  return new Slice(content, openStart, openEnd);
}
var handlers = {};
var editHandlers = {};
var passiveHandlers = { touchstart: true, touchmove: true };

class InputState {
  constructor() {
    this.shiftKey = false;
    this.mouseDown = null;
    this.lastKeyCode = null;
    this.lastKeyCodeTime = 0;
    this.lastClick = { time: 0, x: 0, y: 0, type: "", button: 0 };
    this.lastSelectionOrigin = null;
    this.lastSelectionTime = 0;
    this.lastIOSEnter = 0;
    this.lastIOSEnterFallbackTimeout = -1;
    this.lastFocus = 0;
    this.lastTouch = 0;
    this.lastChromeDelete = 0;
    this.composing = false;
    this.compositionNode = null;
    this.composingTimeout = -1;
    this.compositionNodes = [];
    this.compositionEndedAt = -200000000;
    this.compositionID = 1;
    this.badSafariComposition = false;
    this.compositionPendingChanges = 0;
    this.domChangeCount = 0;
    this.eventHandlers = Object.create(null);
    this.hideSelectionGuard = null;
  }
}
function initInput(view) {
  for (let event in handlers) {
    let handler = handlers[event];
    view.dom.addEventListener(event, view.input.eventHandlers[event] = (event2) => {
      if (eventBelongsToView(view, event2) && !runCustomHandler(view, event2) && (view.editable || !(event2.type in editHandlers)))
        handler(view, event2);
    }, passiveHandlers[event] ? { passive: true } : undefined);
  }
  if (safari2)
    view.dom.addEventListener("input", () => null);
  ensureListeners(view);
}
function setSelectionOrigin(view, origin) {
  view.input.lastSelectionOrigin = origin;
  view.input.lastSelectionTime = Date.now();
}
function destroyInput(view) {
  view.domObserver.stop();
  for (let type in view.input.eventHandlers)
    view.dom.removeEventListener(type, view.input.eventHandlers[type]);
  clearTimeout(view.input.composingTimeout);
  clearTimeout(view.input.lastIOSEnterFallbackTimeout);
}
function ensureListeners(view) {
  view.someProp("handleDOMEvents", (currentHandlers) => {
    for (let type in currentHandlers)
      if (!view.input.eventHandlers[type])
        view.dom.addEventListener(type, view.input.eventHandlers[type] = (event) => runCustomHandler(view, event));
  });
}
function runCustomHandler(view, event) {
  return view.someProp("handleDOMEvents", (handlers2) => {
    let handler = handlers2[event.type];
    return handler ? handler(view, event) || event.defaultPrevented : false;
  });
}
function eventBelongsToView(view, event) {
  if (!event.bubbles)
    return true;
  if (event.defaultPrevented)
    return false;
  for (let node = event.target;node != view.dom; node = node.parentNode)
    if (!node || node.nodeType == 11 || node.pmViewDesc && node.pmViewDesc.stopEvent(event))
      return false;
  return true;
}
function dispatchEvent(view, event) {
  if (!runCustomHandler(view, event) && handlers[event.type] && (view.editable || !(event.type in editHandlers)))
    handlers[event.type](view, event);
}
editHandlers.keydown = (view, _event) => {
  let event = _event;
  view.input.shiftKey = event.keyCode == 16 || event.shiftKey;
  if (inOrNearComposition(view, event))
    return;
  view.input.lastKeyCode = event.keyCode;
  view.input.lastKeyCodeTime = Date.now();
  if (android && chrome && event.keyCode == 13)
    return;
  if (event.keyCode != 229)
    view.domObserver.forceFlush();
  if (ios && event.keyCode == 13 && !event.ctrlKey && !event.altKey && !event.metaKey) {
    let now = Date.now();
    view.input.lastIOSEnter = now;
    view.input.lastIOSEnterFallbackTimeout = setTimeout(() => {
      if (view.input.lastIOSEnter == now) {
        view.someProp("handleKeyDown", (f) => f(view, keyEvent(13, "Enter")));
        view.input.lastIOSEnter = 0;
      }
    }, 200);
  } else if (view.someProp("handleKeyDown", (f) => f(view, event)) || captureKeyDown(view, event)) {
    event.preventDefault();
  } else {
    setSelectionOrigin(view, "key");
  }
};
editHandlers.keyup = (view, event) => {
  if (event.keyCode == 16)
    view.input.shiftKey = false;
};
editHandlers.keypress = (view, _event) => {
  let event = _event;
  if (inOrNearComposition(view, event) || !event.charCode || event.ctrlKey && !event.altKey || mac && event.metaKey)
    return;
  if (view.someProp("handleKeyPress", (f) => f(view, event))) {
    event.preventDefault();
    return;
  }
  let sel = view.state.selection;
  if (!(sel instanceof TextSelection) || !sel.$from.sameParent(sel.$to)) {
    let text = String.fromCharCode(event.charCode);
    let deflt = () => view.state.tr.insertText(text).scrollIntoView();
    if (!/[\r\n]/.test(text) && !view.someProp("handleTextInput", (f) => f(view, sel.$from.pos, sel.$to.pos, text, deflt)))
      view.dispatch(deflt());
    event.preventDefault();
  }
};
function eventCoords(event) {
  return { left: event.clientX, top: event.clientY };
}
function isNear(event, click) {
  let dx = click.x - event.clientX, dy = click.y - event.clientY;
  return dx * dx + dy * dy < 100;
}
function runHandlerOnContext(view, propName, pos, inside, event) {
  if (inside == -1)
    return false;
  let $pos = view.state.doc.resolve(inside);
  for (let i = $pos.depth + 1;i > 0; i--) {
    if (view.someProp(propName, (f) => i > $pos.depth ? f(view, pos, $pos.nodeAfter, $pos.before(i), event, true) : f(view, pos, $pos.node(i), $pos.before(i), event, false)))
      return true;
  }
  return false;
}
function updateSelection(view, selection, origin) {
  if (!view.focused)
    view.focus();
  if (view.state.selection.eq(selection))
    return;
  let tr = view.state.tr.setSelection(selection);
  if (origin == "pointer")
    tr.setMeta("pointer", true);
  view.dispatch(tr);
}
function selectClickedLeaf(view, inside) {
  if (inside == -1)
    return false;
  let $pos = view.state.doc.resolve(inside), node = $pos.nodeAfter;
  if (node && node.isAtom && NodeSelection.isSelectable(node)) {
    updateSelection(view, new NodeSelection($pos), "pointer");
    return true;
  }
  return false;
}
function selectClickedNode(view, inside) {
  if (inside == -1)
    return false;
  let sel = view.state.selection, selectedNode, selectAt;
  if (sel instanceof NodeSelection)
    selectedNode = sel.node;
  let $pos = view.state.doc.resolve(inside);
  for (let i = $pos.depth + 1;i > 0; i--) {
    let node = i > $pos.depth ? $pos.nodeAfter : $pos.node(i);
    if (NodeSelection.isSelectable(node)) {
      if (selectedNode && sel.$from.depth > 0 && i >= sel.$from.depth && $pos.before(sel.$from.depth + 1) == sel.$from.pos)
        selectAt = $pos.before(sel.$from.depth);
      else
        selectAt = $pos.before(i);
      break;
    }
  }
  if (selectAt != null) {
    updateSelection(view, NodeSelection.create(view.state.doc, selectAt), "pointer");
    return true;
  } else {
    return false;
  }
}
function handleSingleClick(view, pos, inside, event, selectNode) {
  return runHandlerOnContext(view, "handleClickOn", pos, inside, event) || view.someProp("handleClick", (f) => f(view, pos, event)) || (selectNode ? selectClickedNode(view, inside) : selectClickedLeaf(view, inside));
}
function handleDoubleClick(view, pos, inside, event) {
  return runHandlerOnContext(view, "handleDoubleClickOn", pos, inside, event) || view.someProp("handleDoubleClick", (f) => f(view, pos, event));
}
function handleTripleClick(view, pos, inside, event) {
  return runHandlerOnContext(view, "handleTripleClickOn", pos, inside, event) || view.someProp("handleTripleClick", (f) => f(view, pos, event)) || defaultTripleClick(view, inside, event);
}
function defaultTripleClick(view, inside, event) {
  if (event.button != 0)
    return false;
  let doc3 = view.state.doc;
  if (inside == -1) {
    if (doc3.inlineContent) {
      updateSelection(view, TextSelection.create(doc3, 0, doc3.content.size), "pointer");
      return true;
    }
    return false;
  }
  let $pos = doc3.resolve(inside);
  for (let i = $pos.depth + 1;i > 0; i--) {
    let node = i > $pos.depth ? $pos.nodeAfter : $pos.node(i);
    let nodePos = $pos.before(i);
    if (node.inlineContent)
      updateSelection(view, TextSelection.create(doc3, nodePos + 1, nodePos + 1 + node.content.size), "pointer");
    else if (NodeSelection.isSelectable(node))
      updateSelection(view, NodeSelection.create(doc3, nodePos), "pointer");
    else
      continue;
    return true;
  }
}
function forceDOMFlush(view) {
  return endComposition(view);
}
var selectNodeModifier = mac ? "metaKey" : "ctrlKey";
handlers.mousedown = (view, _event) => {
  let event = _event;
  view.input.shiftKey = event.shiftKey;
  let flushed = forceDOMFlush(view);
  let now = Date.now(), type = "singleClick";
  if (now - view.input.lastClick.time < 500 && isNear(event, view.input.lastClick) && !event[selectNodeModifier] && view.input.lastClick.button == event.button) {
    if (view.input.lastClick.type == "singleClick")
      type = "doubleClick";
    else if (view.input.lastClick.type == "doubleClick")
      type = "tripleClick";
  }
  view.input.lastClick = { time: now, x: event.clientX, y: event.clientY, type, button: event.button };
  let pos = view.posAtCoords(eventCoords(event));
  if (!pos)
    return;
  if (type == "singleClick") {
    if (view.input.mouseDown)
      view.input.mouseDown.done();
    view.input.mouseDown = new MouseDown(view, pos, event, !!flushed);
  } else if ((type == "doubleClick" ? handleDoubleClick : handleTripleClick)(view, pos.pos, pos.inside, event)) {
    event.preventDefault();
  } else {
    setSelectionOrigin(view, "pointer");
  }
};

class MouseDown {
  constructor(view, pos, event, flushed) {
    this.view = view;
    this.pos = pos;
    this.event = event;
    this.flushed = flushed;
    this.delayedSelectionSync = false;
    this.mightDrag = null;
    this.startDoc = view.state.doc;
    this.selectNode = !!event[selectNodeModifier];
    this.allowDefault = event.shiftKey;
    let targetNode, targetPos;
    if (pos.inside > -1) {
      targetNode = view.state.doc.nodeAt(pos.inside);
      targetPos = pos.inside;
    } else {
      let $pos = view.state.doc.resolve(pos.pos);
      targetNode = $pos.parent;
      targetPos = $pos.depth ? $pos.before() : 0;
    }
    const target = flushed ? null : event.target;
    const targetDesc = target ? view.docView.nearestDesc(target, true) : null;
    this.target = targetDesc && targetDesc.nodeDOM.nodeType == 1 ? targetDesc.nodeDOM : null;
    let { selection } = view.state;
    if (event.button == 0 && targetNode.type.spec.draggable && targetNode.type.spec.selectable !== false || selection instanceof NodeSelection && selection.from <= targetPos && selection.to > targetPos)
      this.mightDrag = {
        node: targetNode,
        pos: targetPos,
        addAttr: !!(this.target && !this.target.draggable),
        setUneditable: !!(this.target && gecko && !this.target.hasAttribute("contentEditable"))
      };
    if (this.target && this.mightDrag && (this.mightDrag.addAttr || this.mightDrag.setUneditable)) {
      this.view.domObserver.stop();
      if (this.mightDrag.addAttr)
        this.target.draggable = true;
      if (this.mightDrag.setUneditable)
        setTimeout(() => {
          if (this.view.input.mouseDown == this)
            this.target.setAttribute("contentEditable", "false");
        }, 20);
      this.view.domObserver.start();
    }
    view.root.addEventListener("mouseup", this.up = this.up.bind(this));
    view.root.addEventListener("mousemove", this.move = this.move.bind(this));
    setSelectionOrigin(view, "pointer");
  }
  done() {
    this.view.root.removeEventListener("mouseup", this.up);
    this.view.root.removeEventListener("mousemove", this.move);
    if (this.mightDrag && this.target) {
      this.view.domObserver.stop();
      if (this.mightDrag.addAttr)
        this.target.removeAttribute("draggable");
      if (this.mightDrag.setUneditable)
        this.target.removeAttribute("contentEditable");
      this.view.domObserver.start();
    }
    if (this.delayedSelectionSync)
      setTimeout(() => selectionToDOM(this.view));
    this.view.input.mouseDown = null;
  }
  up(event) {
    this.done();
    if (!this.view.dom.contains(event.target))
      return;
    let pos = this.pos;
    if (this.view.state.doc != this.startDoc)
      pos = this.view.posAtCoords(eventCoords(event));
    this.updateAllowDefault(event);
    if (this.allowDefault || !pos) {
      setSelectionOrigin(this.view, "pointer");
    } else if (handleSingleClick(this.view, pos.pos, pos.inside, event, this.selectNode)) {
      event.preventDefault();
    } else if (event.button == 0 && (this.flushed || safari2 && this.mightDrag && !this.mightDrag.node.isAtom || chrome && !this.view.state.selection.visible && Math.min(Math.abs(pos.pos - this.view.state.selection.from), Math.abs(pos.pos - this.view.state.selection.to)) <= 2)) {
      updateSelection(this.view, Selection.near(this.view.state.doc.resolve(pos.pos)), "pointer");
      event.preventDefault();
    } else {
      setSelectionOrigin(this.view, "pointer");
    }
  }
  move(event) {
    this.updateAllowDefault(event);
    setSelectionOrigin(this.view, "pointer");
    if (event.buttons == 0)
      this.done();
  }
  updateAllowDefault(event) {
    if (!this.allowDefault && (Math.abs(this.event.x - event.clientX) > 4 || Math.abs(this.event.y - event.clientY) > 4))
      this.allowDefault = true;
  }
}
handlers.touchstart = (view) => {
  view.input.lastTouch = Date.now();
  forceDOMFlush(view);
  setSelectionOrigin(view, "pointer");
};
handlers.touchmove = (view) => {
  view.input.lastTouch = Date.now();
  setSelectionOrigin(view, "pointer");
};
handlers.contextmenu = (view) => forceDOMFlush(view);
function inOrNearComposition(view, event) {
  if (view.composing)
    return true;
  if (safari2 && Math.abs(event.timeStamp - view.input.compositionEndedAt) < 500) {
    view.input.compositionEndedAt = -200000000;
    return true;
  }
  return false;
}
var timeoutComposition = android ? 5000 : -1;
editHandlers.compositionstart = editHandlers.compositionupdate = (view) => {
  if (!view.composing) {
    view.domObserver.flush();
    let { state } = view, $pos = state.selection.$to;
    if (state.selection instanceof TextSelection && (state.storedMarks || !$pos.textOffset && $pos.parentOffset && $pos.nodeBefore.marks.some((m) => m.type.spec.inclusive === false) || chrome && windows && selectionBeforeUneditable(view))) {
      view.markCursor = view.state.storedMarks || $pos.marks();
      endComposition(view, true);
      view.markCursor = null;
    } else {
      endComposition(view, !state.selection.empty);
      if (gecko && state.selection.empty && $pos.parentOffset && !$pos.textOffset && $pos.nodeBefore.marks.length) {
        let sel = view.domSelectionRange();
        for (let { focusNode: node, focusOffset: offset } = sel;node && node.nodeType == 1 && offset != 0; ) {
          let before = offset < 0 ? node.lastChild : node.childNodes[offset - 1];
          if (!before)
            break;
          if (before.nodeType == 3) {
            let sel2 = view.domSelection();
            if (sel2)
              sel2.collapse(before, before.nodeValue.length);
            break;
          } else {
            node = before;
            offset = -1;
          }
        }
      }
    }
    view.input.composing = true;
  }
  scheduleComposeEnd(view, timeoutComposition);
};
function selectionBeforeUneditable(view) {
  let { focusNode, focusOffset } = view.domSelectionRange();
  if (!focusNode || focusNode.nodeType != 1 || focusOffset >= focusNode.childNodes.length)
    return false;
  let next = focusNode.childNodes[focusOffset];
  return next.nodeType == 1 && next.contentEditable == "false";
}
editHandlers.compositionend = (view, event) => {
  if (view.composing) {
    view.input.composing = false;
    view.input.compositionEndedAt = event.timeStamp;
    view.input.compositionPendingChanges = view.domObserver.pendingRecords().length ? view.input.compositionID : 0;
    view.input.compositionNode = null;
    if (view.input.badSafariComposition)
      view.domObserver.forceFlush();
    else if (view.input.compositionPendingChanges)
      Promise.resolve().then(() => view.domObserver.flush());
    view.input.compositionID++;
    scheduleComposeEnd(view, 20);
  }
};
function scheduleComposeEnd(view, delay) {
  clearTimeout(view.input.composingTimeout);
  if (delay > -1)
    view.input.composingTimeout = setTimeout(() => endComposition(view), delay);
}
function clearComposition(view) {
  if (view.composing) {
    view.input.composing = false;
    view.input.compositionEndedAt = timestampFromCustomEvent();
  }
  while (view.input.compositionNodes.length > 0)
    view.input.compositionNodes.pop().markParentsDirty();
}
function findCompositionNode(view) {
  let sel = view.domSelectionRange();
  if (!sel.focusNode)
    return null;
  let textBefore = textNodeBefore$1(sel.focusNode, sel.focusOffset);
  let textAfter = textNodeAfter$1(sel.focusNode, sel.focusOffset);
  if (textBefore && textAfter && textBefore != textAfter) {
    let descAfter = textAfter.pmViewDesc, lastChanged = view.domObserver.lastChangedTextNode;
    if (textBefore == lastChanged || textAfter == lastChanged)
      return lastChanged;
    if (!descAfter || !descAfter.isText(textAfter.nodeValue)) {
      return textAfter;
    } else if (view.input.compositionNode == textAfter) {
      let descBefore = textBefore.pmViewDesc;
      if (!(!descBefore || !descBefore.isText(textBefore.nodeValue)))
        return textAfter;
    }
  }
  return textBefore || textAfter;
}
function timestampFromCustomEvent() {
  let event = document.createEvent("Event");
  event.initEvent("event", true, true);
  return event.timeStamp;
}
function endComposition(view, restarting = false) {
  if (android && view.domObserver.flushingSoon >= 0)
    return;
  view.domObserver.forceFlush();
  clearComposition(view);
  if (restarting || view.docView && view.docView.dirty) {
    let sel = selectionFromDOM(view), cur = view.state.selection;
    if (sel && !sel.eq(cur))
      view.dispatch(view.state.tr.setSelection(sel));
    else if ((view.markCursor || restarting) && !cur.$from.node(cur.$from.sharedDepth(cur.to)).inlineContent)
      view.dispatch(view.state.tr.deleteSelection());
    else
      view.updateState(view.state);
    return true;
  }
  return false;
}
function captureCopy(view, dom) {
  if (!view.dom.parentNode)
    return;
  let wrap2 = view.dom.parentNode.appendChild(document.createElement("div"));
  wrap2.appendChild(dom);
  wrap2.style.cssText = "position: fixed; left: -10000px; top: 10px";
  let sel = getSelection(), range = document.createRange();
  range.selectNodeContents(dom);
  view.dom.blur();
  sel.removeAllRanges();
  sel.addRange(range);
  setTimeout(() => {
    if (wrap2.parentNode)
      wrap2.parentNode.removeChild(wrap2);
    view.focus();
  }, 50);
}
var brokenClipboardAPI = ie && ie_version < 15 || ios && webkit_version < 604;
handlers.copy = editHandlers.cut = (view, _event) => {
  let event = _event;
  let sel = view.state.selection, cut = event.type == "cut";
  if (sel.empty)
    return;
  let data = brokenClipboardAPI ? null : event.clipboardData;
  let slice = sel.content(), { dom, text } = serializeForClipboard(view, slice);
  if (data) {
    event.preventDefault();
    data.clearData();
    data.setData("text/html", dom.innerHTML);
    data.setData("text/plain", text);
  } else {
    captureCopy(view, dom);
  }
  if (cut)
    view.dispatch(view.state.tr.deleteSelection().scrollIntoView().setMeta("uiEvent", "cut"));
};
function sliceSingleNode(slice) {
  return slice.openStart == 0 && slice.openEnd == 0 && slice.content.childCount == 1 ? slice.content.firstChild : null;
}
function capturePaste(view, event) {
  if (!view.dom.parentNode)
    return;
  let plainText = view.input.shiftKey || view.state.selection.$from.parent.type.spec.code;
  let target = view.dom.parentNode.appendChild(document.createElement(plainText ? "textarea" : "div"));
  if (!plainText)
    target.contentEditable = "true";
  target.style.cssText = "position: fixed; left: -10000px; top: 10px";
  target.focus();
  let plain = view.input.shiftKey && view.input.lastKeyCode != 45;
  setTimeout(() => {
    view.focus();
    if (target.parentNode)
      target.parentNode.removeChild(target);
    if (plainText)
      doPaste(view, target.value, null, plain, event);
    else
      doPaste(view, target.textContent, target.innerHTML, plain, event);
  }, 50);
}
function doPaste(view, text, html, preferPlain, event) {
  let slice = parseFromClipboard(view, text, html, preferPlain, view.state.selection.$from);
  if (view.someProp("handlePaste", (f) => f(view, event, slice || Slice.empty)))
    return true;
  if (!slice)
    return false;
  let singleNode = sliceSingleNode(slice);
  let tr = singleNode ? view.state.tr.replaceSelectionWith(singleNode, preferPlain) : view.state.tr.replaceSelection(slice);
  view.dispatch(tr.scrollIntoView().setMeta("paste", true).setMeta("uiEvent", "paste"));
  return true;
}
function getText(clipboardData) {
  let text = clipboardData.getData("text/plain") || clipboardData.getData("Text");
  if (text)
    return text;
  let uris = clipboardData.getData("text/uri-list");
  return uris ? uris.replace(/\r?\n/g, " ") : "";
}
editHandlers.paste = (view, _event) => {
  let event = _event;
  if (view.composing && !android)
    return;
  let data = brokenClipboardAPI ? null : event.clipboardData;
  let plain = view.input.shiftKey && view.input.lastKeyCode != 45;
  if (data && doPaste(view, getText(data), data.getData("text/html"), plain, event))
    event.preventDefault();
  else
    capturePaste(view, event);
};

class Dragging {
  constructor(slice, move, node) {
    this.slice = slice;
    this.move = move;
    this.node = node;
  }
}
var dragCopyModifier = mac ? "altKey" : "ctrlKey";
function dragMoves(view, event) {
  let moves = view.someProp("dragCopies", (test) => !test(event));
  return moves != null ? moves : !event[dragCopyModifier];
}
handlers.dragstart = (view, _event) => {
  let event = _event;
  let mouseDown = view.input.mouseDown;
  if (mouseDown)
    mouseDown.done();
  if (!event.dataTransfer)
    return;
  let sel = view.state.selection;
  let pos = sel.empty ? null : view.posAtCoords(eventCoords(event));
  let node;
  if (pos && pos.pos >= sel.from && pos.pos <= (sel instanceof NodeSelection ? sel.to - 1 : sel.to))
    ;
  else if (mouseDown && mouseDown.mightDrag) {
    node = NodeSelection.create(view.state.doc, mouseDown.mightDrag.pos);
  } else if (event.target && event.target.nodeType == 1) {
    let desc = view.docView.nearestDesc(event.target, true);
    if (desc && desc.node.type.spec.draggable && desc != view.docView)
      node = NodeSelection.create(view.state.doc, desc.posBefore);
  }
  let draggedSlice = (node || view.state.selection).content();
  let { dom, text, slice } = serializeForClipboard(view, draggedSlice);
  if (!event.dataTransfer.files.length || !chrome || chrome_version > 120)
    event.dataTransfer.clearData();
  event.dataTransfer.setData(brokenClipboardAPI ? "Text" : "text/html", dom.innerHTML);
  event.dataTransfer.effectAllowed = "copyMove";
  if (!brokenClipboardAPI)
    event.dataTransfer.setData("text/plain", text);
  view.dragging = new Dragging(slice, dragMoves(view, event), node);
};
handlers.dragend = (view) => {
  let dragging = view.dragging;
  window.setTimeout(() => {
    if (view.dragging == dragging)
      view.dragging = null;
  }, 50);
};
editHandlers.dragover = editHandlers.dragenter = (_, e) => e.preventDefault();
editHandlers.drop = (view, event) => {
  try {
    handleDrop(view, event, view.dragging);
  } finally {
    view.dragging = null;
  }
};
function handleDrop(view, event, dragging) {
  if (!event.dataTransfer)
    return;
  let eventPos = view.posAtCoords(eventCoords(event));
  if (!eventPos)
    return;
  let $mouse = view.state.doc.resolve(eventPos.pos);
  let slice = dragging && dragging.slice;
  if (slice) {
    view.someProp("transformPasted", (f) => {
      slice = f(slice, view, false);
    });
  } else {
    slice = parseFromClipboard(view, getText(event.dataTransfer), brokenClipboardAPI ? null : event.dataTransfer.getData("text/html"), false, $mouse);
  }
  let move = !!(dragging && dragMoves(view, event));
  if (view.someProp("handleDrop", (f) => f(view, event, slice || Slice.empty, move))) {
    event.preventDefault();
    return;
  }
  if (!slice)
    return;
  event.preventDefault();
  let insertPos = slice ? dropPoint(view.state.doc, $mouse.pos, slice) : $mouse.pos;
  if (insertPos == null)
    insertPos = $mouse.pos;
  let tr = view.state.tr;
  if (move) {
    let { node } = dragging;
    if (node)
      node.replace(tr);
    else
      tr.deleteSelection();
  }
  let pos = tr.mapping.map(insertPos);
  let isNode = slice.openStart == 0 && slice.openEnd == 0 && slice.content.childCount == 1;
  let beforeInsert = tr.doc;
  if (isNode)
    tr.replaceRangeWith(pos, pos, slice.content.firstChild);
  else
    tr.replaceRange(pos, pos, slice);
  if (tr.doc.eq(beforeInsert))
    return;
  let $pos = tr.doc.resolve(pos);
  if (isNode && NodeSelection.isSelectable(slice.content.firstChild) && $pos.nodeAfter && $pos.nodeAfter.sameMarkup(slice.content.firstChild)) {
    tr.setSelection(new NodeSelection($pos));
  } else {
    let end = tr.mapping.map(insertPos);
    tr.mapping.maps[tr.mapping.maps.length - 1].forEach((_from, _to, _newFrom, newTo) => end = newTo);
    tr.setSelection(selectionBetween(view, $pos, tr.doc.resolve(end)));
  }
  view.focus();
  view.dispatch(tr.setMeta("uiEvent", "drop"));
}
handlers.focus = (view) => {
  view.input.lastFocus = Date.now();
  if (!view.focused) {
    view.domObserver.stop();
    view.dom.classList.add("ProseMirror-focused");
    view.domObserver.start();
    view.focused = true;
    setTimeout(() => {
      if (view.docView && view.hasFocus() && !view.domObserver.currentSelection.eq(view.domSelectionRange()))
        selectionToDOM(view);
    }, 20);
  }
};
handlers.blur = (view, _event) => {
  let event = _event;
  if (view.focused) {
    view.domObserver.stop();
    view.dom.classList.remove("ProseMirror-focused");
    view.domObserver.start();
    if (event.relatedTarget && view.dom.contains(event.relatedTarget))
      view.domObserver.currentSelection.clear();
    view.focused = false;
  }
};
handlers.beforeinput = (view, _event) => {
  let event = _event;
  if (chrome && android && event.inputType == "deleteContentBackward") {
    view.domObserver.flushSoon();
    let { domChangeCount } = view.input;
    setTimeout(() => {
      if (view.input.domChangeCount != domChangeCount)
        return;
      view.dom.blur();
      view.focus();
      if (view.someProp("handleKeyDown", (f) => f(view, keyEvent(8, "Backspace"))))
        return;
      let { $cursor } = view.state.selection;
      if ($cursor && $cursor.pos > 0)
        view.dispatch(view.state.tr.delete($cursor.pos - 1, $cursor.pos).scrollIntoView());
    }, 50);
  }
};
for (let prop in editHandlers)
  handlers[prop] = editHandlers[prop];
function compareObjs(a, b) {
  if (a == b)
    return true;
  for (let p in a)
    if (a[p] !== b[p])
      return false;
  for (let p in b)
    if (!(p in a))
      return false;
  return true;
}

class WidgetType {
  constructor(toDOM, spec) {
    this.toDOM = toDOM;
    this.spec = spec || noSpec;
    this.side = this.spec.side || 0;
  }
  map(mapping, span, offset, oldOffset) {
    let { pos, deleted } = mapping.mapResult(span.from + oldOffset, this.side < 0 ? -1 : 1);
    return deleted ? null : new Decoration(pos - offset, pos - offset, this);
  }
  valid() {
    return true;
  }
  eq(other) {
    return this == other || other instanceof WidgetType && (this.spec.key && this.spec.key == other.spec.key || this.toDOM == other.toDOM && compareObjs(this.spec, other.spec));
  }
  destroy(node) {
    if (this.spec.destroy)
      this.spec.destroy(node);
  }
}

class InlineType {
  constructor(attrs, spec) {
    this.attrs = attrs;
    this.spec = spec || noSpec;
  }
  map(mapping, span, offset, oldOffset) {
    let from = mapping.map(span.from + oldOffset, this.spec.inclusiveStart ? -1 : 1) - offset;
    let to = mapping.map(span.to + oldOffset, this.spec.inclusiveEnd ? 1 : -1) - offset;
    return from >= to ? null : new Decoration(from, to, this);
  }
  valid(_, span) {
    return span.from < span.to;
  }
  eq(other) {
    return this == other || other instanceof InlineType && compareObjs(this.attrs, other.attrs) && compareObjs(this.spec, other.spec);
  }
  static is(span) {
    return span.type instanceof InlineType;
  }
  destroy() {}
}

class NodeType2 {
  constructor(attrs, spec) {
    this.attrs = attrs;
    this.spec = spec || noSpec;
  }
  map(mapping, span, offset, oldOffset) {
    let from = mapping.mapResult(span.from + oldOffset, 1);
    if (from.deleted)
      return null;
    let to = mapping.mapResult(span.to + oldOffset, -1);
    if (to.deleted || to.pos <= from.pos)
      return null;
    return new Decoration(from.pos - offset, to.pos - offset, this);
  }
  valid(node, span) {
    let { index, offset } = node.content.findIndex(span.from), child;
    return offset == span.from && !(child = node.child(index)).isText && offset + child.nodeSize == span.to;
  }
  eq(other) {
    return this == other || other instanceof NodeType2 && compareObjs(this.attrs, other.attrs) && compareObjs(this.spec, other.spec);
  }
  destroy() {}
}

class Decoration {
  constructor(from, to, type) {
    this.from = from;
    this.to = to;
    this.type = type;
  }
  copy(from, to) {
    return new Decoration(from, to, this.type);
  }
  eq(other, offset = 0) {
    return this.type.eq(other.type) && this.from + offset == other.from && this.to + offset == other.to;
  }
  map(mapping, offset, oldOffset) {
    return this.type.map(mapping, this, offset, oldOffset);
  }
  static widget(pos, toDOM, spec) {
    return new Decoration(pos, pos, new WidgetType(toDOM, spec));
  }
  static inline(from, to, attrs, spec) {
    return new Decoration(from, to, new InlineType(attrs, spec));
  }
  static node(from, to, attrs, spec) {
    return new Decoration(from, to, new NodeType2(attrs, spec));
  }
  get spec() {
    return this.type.spec;
  }
  get inline() {
    return this.type instanceof InlineType;
  }
  get widget() {
    return this.type instanceof WidgetType;
  }
}
var none = [];
var noSpec = {};

class DecorationSet {
  constructor(local, children) {
    this.local = local.length ? local : none;
    this.children = children.length ? children : none;
  }
  static create(doc3, decorations) {
    return decorations.length ? buildTree(decorations, doc3, 0, noSpec) : empty;
  }
  find(start, end, predicate) {
    let result = [];
    this.findInner(start == null ? 0 : start, end == null ? 1e9 : end, result, 0, predicate);
    return result;
  }
  findInner(start, end, result, offset, predicate) {
    for (let i = 0;i < this.local.length; i++) {
      let span = this.local[i];
      if (span.from <= end && span.to >= start && (!predicate || predicate(span.spec)))
        result.push(span.copy(span.from + offset, span.to + offset));
    }
    for (let i = 0;i < this.children.length; i += 3) {
      if (this.children[i] < end && this.children[i + 1] > start) {
        let childOff = this.children[i] + 1;
        this.children[i + 2].findInner(start - childOff, end - childOff, result, offset + childOff, predicate);
      }
    }
  }
  map(mapping, doc3, options) {
    if (this == empty || mapping.maps.length == 0)
      return this;
    return this.mapInner(mapping, doc3, 0, 0, options || noSpec);
  }
  mapInner(mapping, node, offset, oldOffset, options) {
    let newLocal;
    for (let i = 0;i < this.local.length; i++) {
      let mapped = this.local[i].map(mapping, offset, oldOffset);
      if (mapped && mapped.type.valid(node, mapped))
        (newLocal || (newLocal = [])).push(mapped);
      else if (options.onRemove)
        options.onRemove(this.local[i].spec);
    }
    if (this.children.length)
      return mapChildren(this.children, newLocal || [], mapping, node, offset, oldOffset, options);
    else
      return newLocal ? new DecorationSet(newLocal.sort(byPos), none) : empty;
  }
  add(doc3, decorations) {
    if (!decorations.length)
      return this;
    if (this == empty)
      return DecorationSet.create(doc3, decorations);
    return this.addInner(doc3, decorations, 0);
  }
  addInner(doc3, decorations, offset) {
    let children, childIndex = 0;
    doc3.forEach((childNode, childOffset) => {
      let baseOffset = childOffset + offset, found2;
      if (!(found2 = takeSpansForNode(decorations, childNode, baseOffset)))
        return;
      if (!children)
        children = this.children.slice();
      while (childIndex < children.length && children[childIndex] < childOffset)
        childIndex += 3;
      if (children[childIndex] == childOffset)
        children[childIndex + 2] = children[childIndex + 2].addInner(childNode, found2, baseOffset + 1);
      else
        children.splice(childIndex, 0, childOffset, childOffset + childNode.nodeSize, buildTree(found2, childNode, baseOffset + 1, noSpec));
      childIndex += 3;
    });
    let local = moveSpans(childIndex ? withoutNulls(decorations) : decorations, -offset);
    for (let i = 0;i < local.length; i++)
      if (!local[i].type.valid(doc3, local[i]))
        local.splice(i--, 1);
    return new DecorationSet(local.length ? this.local.concat(local).sort(byPos) : this.local, children || this.children);
  }
  remove(decorations) {
    if (decorations.length == 0 || this == empty)
      return this;
    return this.removeInner(decorations, 0);
  }
  removeInner(decorations, offset) {
    let children = this.children, local = this.local;
    for (let i = 0;i < children.length; i += 3) {
      let found2;
      let from = children[i] + offset, to = children[i + 1] + offset;
      for (let j = 0, span;j < decorations.length; j++)
        if (span = decorations[j]) {
          if (span.from > from && span.to < to) {
            decorations[j] = null;
            (found2 || (found2 = [])).push(span);
          }
        }
      if (!found2)
        continue;
      if (children == this.children)
        children = this.children.slice();
      let removed = children[i + 2].removeInner(found2, from + 1);
      if (removed != empty) {
        children[i + 2] = removed;
      } else {
        children.splice(i, 3);
        i -= 3;
      }
    }
    if (local.length) {
      for (let i = 0, span;i < decorations.length; i++)
        if (span = decorations[i]) {
          for (let j = 0;j < local.length; j++)
            if (local[j].eq(span, offset)) {
              if (local == this.local)
                local = this.local.slice();
              local.splice(j--, 1);
            }
        }
    }
    if (children == this.children && local == this.local)
      return this;
    return local.length || children.length ? new DecorationSet(local, children) : empty;
  }
  forChild(offset, node) {
    if (this == empty)
      return this;
    if (node.isLeaf)
      return DecorationSet.empty;
    let child, local;
    for (let i = 0;i < this.children.length; i += 3)
      if (this.children[i] >= offset) {
        if (this.children[i] == offset)
          child = this.children[i + 2];
        break;
      }
    let start = offset + 1, end = start + node.content.size;
    for (let i = 0;i < this.local.length; i++) {
      let dec = this.local[i];
      if (dec.from < end && dec.to > start && dec.type instanceof InlineType) {
        let from = Math.max(start, dec.from) - start, to = Math.min(end, dec.to) - start;
        if (from < to)
          (local || (local = [])).push(dec.copy(from, to));
      }
    }
    if (local) {
      let localSet = new DecorationSet(local.sort(byPos), none);
      return child ? new DecorationGroup([localSet, child]) : localSet;
    }
    return child || empty;
  }
  eq(other) {
    if (this == other)
      return true;
    if (!(other instanceof DecorationSet) || this.local.length != other.local.length || this.children.length != other.children.length)
      return false;
    for (let i = 0;i < this.local.length; i++)
      if (!this.local[i].eq(other.local[i]))
        return false;
    for (let i = 0;i < this.children.length; i += 3)
      if (this.children[i] != other.children[i] || this.children[i + 1] != other.children[i + 1] || !this.children[i + 2].eq(other.children[i + 2]))
        return false;
    return true;
  }
  locals(node) {
    return removeOverlap(this.localsInner(node));
  }
  localsInner(node) {
    if (this == empty)
      return none;
    if (node.inlineContent || !this.local.some(InlineType.is))
      return this.local;
    let result = [];
    for (let i = 0;i < this.local.length; i++) {
      if (!(this.local[i].type instanceof InlineType))
        result.push(this.local[i]);
    }
    return result;
  }
  forEachSet(f) {
    f(this);
  }
}
DecorationSet.empty = new DecorationSet([], []);
DecorationSet.removeOverlap = removeOverlap;
var empty = DecorationSet.empty;

class DecorationGroup {
  constructor(members) {
    this.members = members;
  }
  map(mapping, doc3) {
    const mappedDecos = this.members.map((member) => member.map(mapping, doc3, noSpec));
    return DecorationGroup.from(mappedDecos);
  }
  forChild(offset, child) {
    if (child.isLeaf)
      return DecorationSet.empty;
    let found2 = [];
    for (let i = 0;i < this.members.length; i++) {
      let result = this.members[i].forChild(offset, child);
      if (result == empty)
        continue;
      if (result instanceof DecorationGroup)
        found2 = found2.concat(result.members);
      else
        found2.push(result);
    }
    return DecorationGroup.from(found2);
  }
  eq(other) {
    if (!(other instanceof DecorationGroup) || other.members.length != this.members.length)
      return false;
    for (let i = 0;i < this.members.length; i++)
      if (!this.members[i].eq(other.members[i]))
        return false;
    return true;
  }
  locals(node) {
    let result, sorted = true;
    for (let i = 0;i < this.members.length; i++) {
      let locals = this.members[i].localsInner(node);
      if (!locals.length)
        continue;
      if (!result) {
        result = locals;
      } else {
        if (sorted) {
          result = result.slice();
          sorted = false;
        }
        for (let j = 0;j < locals.length; j++)
          result.push(locals[j]);
      }
    }
    return result ? removeOverlap(sorted ? result : result.sort(byPos)) : none;
  }
  static from(members) {
    switch (members.length) {
      case 0:
        return empty;
      case 1:
        return members[0];
      default:
        return new DecorationGroup(members.every((m) => m instanceof DecorationSet) ? members : members.reduce((r, m) => r.concat(m instanceof DecorationSet ? m : m.members), []));
    }
  }
  forEachSet(f) {
    for (let i = 0;i < this.members.length; i++)
      this.members[i].forEachSet(f);
  }
}
function mapChildren(oldChildren, newLocal, mapping, node, offset, oldOffset, options) {
  let children = oldChildren.slice();
  for (let i = 0, baseOffset = oldOffset;i < mapping.maps.length; i++) {
    let moved = 0;
    mapping.maps[i].forEach((oldStart, oldEnd, newStart, newEnd) => {
      let dSize = newEnd - newStart - (oldEnd - oldStart);
      for (let i2 = 0;i2 < children.length; i2 += 3) {
        let end = children[i2 + 1];
        if (end < 0 || oldStart > end + baseOffset - moved)
          continue;
        let start = children[i2] + baseOffset - moved;
        if (oldEnd >= start) {
          children[i2 + 1] = oldStart <= start ? -2 : -1;
        } else if (oldStart >= baseOffset && dSize) {
          children[i2] += dSize;
          children[i2 + 1] += dSize;
        }
      }
      moved += dSize;
    });
    baseOffset = mapping.maps[i].map(baseOffset, -1);
  }
  let mustRebuild = false;
  for (let i = 0;i < children.length; i += 3)
    if (children[i + 1] < 0) {
      if (children[i + 1] == -2) {
        mustRebuild = true;
        children[i + 1] = -1;
        continue;
      }
      let from = mapping.map(oldChildren[i] + oldOffset), fromLocal = from - offset;
      if (fromLocal < 0 || fromLocal >= node.content.size) {
        mustRebuild = true;
        continue;
      }
      let to = mapping.map(oldChildren[i + 1] + oldOffset, -1), toLocal = to - offset;
      let { index, offset: childOffset } = node.content.findIndex(fromLocal);
      let childNode = node.maybeChild(index);
      if (childNode && childOffset == fromLocal && childOffset + childNode.nodeSize == toLocal) {
        let mapped = children[i + 2].mapInner(mapping, childNode, from + 1, oldChildren[i] + oldOffset + 1, options);
        if (mapped != empty) {
          children[i] = fromLocal;
          children[i + 1] = toLocal;
          children[i + 2] = mapped;
        } else {
          children[i + 1] = -2;
          mustRebuild = true;
        }
      } else {
        mustRebuild = true;
      }
    }
  if (mustRebuild) {
    let decorations = mapAndGatherRemainingDecorations(children, oldChildren, newLocal, mapping, offset, oldOffset, options);
    let built = buildTree(decorations, node, 0, options);
    newLocal = built.local;
    for (let i = 0;i < children.length; i += 3)
      if (children[i + 1] < 0) {
        children.splice(i, 3);
        i -= 3;
      }
    for (let i = 0, j = 0;i < built.children.length; i += 3) {
      let from = built.children[i];
      while (j < children.length && children[j] < from)
        j += 3;
      children.splice(j, 0, built.children[i], built.children[i + 1], built.children[i + 2]);
    }
  }
  return new DecorationSet(newLocal.sort(byPos), children);
}
function moveSpans(spans, offset) {
  if (!offset || !spans.length)
    return spans;
  let result = [];
  for (let i = 0;i < spans.length; i++) {
    let span = spans[i];
    result.push(new Decoration(span.from + offset, span.to + offset, span.type));
  }
  return result;
}
function mapAndGatherRemainingDecorations(children, oldChildren, decorations, mapping, offset, oldOffset, options) {
  function gather(set, oldOffset2) {
    for (let i = 0;i < set.local.length; i++) {
      let mapped = set.local[i].map(mapping, offset, oldOffset2);
      if (mapped)
        decorations.push(mapped);
      else if (options.onRemove)
        options.onRemove(set.local[i].spec);
    }
    for (let i = 0;i < set.children.length; i += 3)
      gather(set.children[i + 2], set.children[i] + oldOffset2 + 1);
  }
  for (let i = 0;i < children.length; i += 3)
    if (children[i + 1] == -1)
      gather(children[i + 2], oldChildren[i] + oldOffset + 1);
  return decorations;
}
function takeSpansForNode(spans, node, offset) {
  if (node.isLeaf)
    return null;
  let end = offset + node.nodeSize, found2 = null;
  for (let i = 0, span;i < spans.length; i++) {
    if ((span = spans[i]) && span.from > offset && span.to < end) {
      (found2 || (found2 = [])).push(span);
      spans[i] = null;
    }
  }
  return found2;
}
function withoutNulls(array) {
  let result = [];
  for (let i = 0;i < array.length; i++)
    if (array[i] != null)
      result.push(array[i]);
  return result;
}
function buildTree(spans, node, offset, options) {
  let children = [], hasNulls = false;
  node.forEach((childNode, localStart) => {
    let found2 = takeSpansForNode(spans, childNode, localStart + offset);
    if (found2) {
      hasNulls = true;
      let subtree = buildTree(found2, childNode, offset + localStart + 1, options);
      if (subtree != empty)
        children.push(localStart, localStart + childNode.nodeSize, subtree);
    }
  });
  let locals = moveSpans(hasNulls ? withoutNulls(spans) : spans, -offset).sort(byPos);
  for (let i = 0;i < locals.length; i++)
    if (!locals[i].type.valid(node, locals[i])) {
      if (options.onRemove)
        options.onRemove(locals[i].spec);
      locals.splice(i--, 1);
    }
  return locals.length || children.length ? new DecorationSet(locals, children) : empty;
}
function byPos(a, b) {
  return a.from - b.from || a.to - b.to;
}
function removeOverlap(spans) {
  let working = spans;
  for (let i = 0;i < working.length - 1; i++) {
    let span = working[i];
    if (span.from != span.to)
      for (let j = i + 1;j < working.length; j++) {
        let next = working[j];
        if (next.from == span.from) {
          if (next.to != span.to) {
            if (working == spans)
              working = spans.slice();
            working[j] = next.copy(next.from, span.to);
            insertAhead(working, j + 1, next.copy(span.to, next.to));
          }
          continue;
        } else {
          if (next.from < span.to) {
            if (working == spans)
              working = spans.slice();
            working[i] = span.copy(span.from, next.from);
            insertAhead(working, j, span.copy(next.from, span.to));
          }
          break;
        }
      }
  }
  return working;
}
function insertAhead(array, i, deco) {
  while (i < array.length && byPos(deco, array[i]) > 0)
    i++;
  array.splice(i, 0, deco);
}
function viewDecorations(view) {
  let found2 = [];
  view.someProp("decorations", (f) => {
    let result = f(view.state);
    if (result && result != empty)
      found2.push(result);
  });
  if (view.cursorWrapper)
    found2.push(DecorationSet.create(view.state.doc, [view.cursorWrapper.deco]));
  return DecorationGroup.from(found2);
}
var observeOptions = {
  childList: true,
  characterData: true,
  characterDataOldValue: true,
  attributes: true,
  attributeOldValue: true,
  subtree: true
};
var useCharData = ie && ie_version <= 11;

class SelectionState {
  constructor() {
    this.anchorNode = null;
    this.anchorOffset = 0;
    this.focusNode = null;
    this.focusOffset = 0;
  }
  set(sel) {
    this.anchorNode = sel.anchorNode;
    this.anchorOffset = sel.anchorOffset;
    this.focusNode = sel.focusNode;
    this.focusOffset = sel.focusOffset;
  }
  clear() {
    this.anchorNode = this.focusNode = null;
  }
  eq(sel) {
    return sel.anchorNode == this.anchorNode && sel.anchorOffset == this.anchorOffset && sel.focusNode == this.focusNode && sel.focusOffset == this.focusOffset;
  }
}

class DOMObserver {
  constructor(view, handleDOMChange) {
    this.view = view;
    this.handleDOMChange = handleDOMChange;
    this.queue = [];
    this.flushingSoon = -1;
    this.observer = null;
    this.currentSelection = new SelectionState;
    this.onCharData = null;
    this.suppressingSelectionUpdates = false;
    this.lastChangedTextNode = null;
    this.observer = window.MutationObserver && new window.MutationObserver((mutations) => {
      for (let i = 0;i < mutations.length; i++)
        this.queue.push(mutations[i]);
      if (ie && ie_version <= 11 && mutations.some((m) => m.type == "childList" && m.removedNodes.length || m.type == "characterData" && m.oldValue.length > m.target.nodeValue.length)) {
        this.flushSoon();
      } else if (safari2 && view.composing && mutations.some((m) => m.type == "childList" && m.target.nodeName == "TR")) {
        view.input.badSafariComposition = true;
        this.flushSoon();
      } else {
        this.flush();
      }
    });
    if (useCharData) {
      this.onCharData = (e) => {
        this.queue.push({ target: e.target, type: "characterData", oldValue: e.prevValue });
        this.flushSoon();
      };
    }
    this.onSelectionChange = this.onSelectionChange.bind(this);
  }
  flushSoon() {
    if (this.flushingSoon < 0)
      this.flushingSoon = window.setTimeout(() => {
        this.flushingSoon = -1;
        this.flush();
      }, 20);
  }
  forceFlush() {
    if (this.flushingSoon > -1) {
      window.clearTimeout(this.flushingSoon);
      this.flushingSoon = -1;
      this.flush();
    }
  }
  start() {
    if (this.observer) {
      this.observer.takeRecords();
      this.observer.observe(this.view.dom, observeOptions);
    }
    if (this.onCharData)
      this.view.dom.addEventListener("DOMCharacterDataModified", this.onCharData);
    this.connectSelection();
  }
  stop() {
    if (this.observer) {
      let take = this.observer.takeRecords();
      if (take.length) {
        for (let i = 0;i < take.length; i++)
          this.queue.push(take[i]);
        window.setTimeout(() => this.flush(), 20);
      }
      this.observer.disconnect();
    }
    if (this.onCharData)
      this.view.dom.removeEventListener("DOMCharacterDataModified", this.onCharData);
    this.disconnectSelection();
  }
  connectSelection() {
    this.view.dom.ownerDocument.addEventListener("selectionchange", this.onSelectionChange);
  }
  disconnectSelection() {
    this.view.dom.ownerDocument.removeEventListener("selectionchange", this.onSelectionChange);
  }
  suppressSelectionUpdates() {
    this.suppressingSelectionUpdates = true;
    setTimeout(() => this.suppressingSelectionUpdates = false, 50);
  }
  onSelectionChange() {
    if (!hasFocusAndSelection(this.view))
      return;
    if (this.suppressingSelectionUpdates)
      return selectionToDOM(this.view);
    if (ie && ie_version <= 11 && !this.view.state.selection.empty) {
      let sel = this.view.domSelectionRange();
      if (sel.focusNode && isEquivalentPosition(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset))
        return this.flushSoon();
    }
    this.flush();
  }
  setCurSelection() {
    this.currentSelection.set(this.view.domSelectionRange());
  }
  ignoreSelectionChange(sel) {
    if (!sel.focusNode)
      return true;
    let ancestors = new Set, container;
    for (let scan = sel.focusNode;scan; scan = parentNode(scan))
      ancestors.add(scan);
    for (let scan = sel.anchorNode;scan; scan = parentNode(scan))
      if (ancestors.has(scan)) {
        container = scan;
        break;
      }
    let desc = container && this.view.docView.nearestDesc(container);
    if (desc && desc.ignoreMutation({
      type: "selection",
      target: container.nodeType == 3 ? container.parentNode : container
    })) {
      this.setCurSelection();
      return true;
    }
  }
  pendingRecords() {
    if (this.observer)
      for (let mut of this.observer.takeRecords())
        this.queue.push(mut);
    return this.queue;
  }
  flush() {
    let { view } = this;
    if (!view.docView || this.flushingSoon > -1)
      return;
    let mutations = this.pendingRecords();
    if (mutations.length)
      this.queue = [];
    let sel = view.domSelectionRange();
    let newSel = !this.suppressingSelectionUpdates && !this.currentSelection.eq(sel) && hasFocusAndSelection(view) && !this.ignoreSelectionChange(sel);
    let from = -1, to = -1, typeOver = false, added = [];
    if (view.editable) {
      for (let i = 0;i < mutations.length; i++) {
        let result = this.registerMutation(mutations[i], added);
        if (result) {
          from = from < 0 ? result.from : Math.min(result.from, from);
          to = to < 0 ? result.to : Math.max(result.to, to);
          if (result.typeOver)
            typeOver = true;
        }
      }
    }
    if (gecko && added.length) {
      let brs = added.filter((n) => n.nodeName == "BR");
      if (brs.length == 2) {
        let [a, b] = brs;
        if (a.parentNode && a.parentNode.parentNode == b.parentNode)
          b.remove();
        else
          a.remove();
      } else {
        let { focusNode } = this.currentSelection;
        for (let br of brs) {
          let parent = br.parentNode;
          if (parent && parent.nodeName == "LI" && (!focusNode || blockParent(view, focusNode) != parent))
            br.remove();
        }
      }
    } else if ((chrome || safari2) && added.some((n) => n.nodeName == "BR") && (view.input.lastKeyCode == 8 || view.input.lastKeyCode == 46)) {
      for (let node of added)
        if (node.nodeName == "BR" && node.parentNode) {
          let after = node.nextSibling;
          if (after && after.nodeType == 1 && after.contentEditable == "false")
            node.parentNode.removeChild(node);
        }
    }
    let readSel = null;
    if (from < 0 && newSel && view.input.lastFocus > Date.now() - 200 && Math.max(view.input.lastTouch, view.input.lastClick.time) < Date.now() - 300 && selectionCollapsed(sel) && (readSel = selectionFromDOM(view)) && readSel.eq(Selection.near(view.state.doc.resolve(0), 1))) {
      view.input.lastFocus = 0;
      selectionToDOM(view);
      this.currentSelection.set(sel);
      view.scrollToSelection();
    } else if (from > -1 || newSel) {
      if (from > -1) {
        view.docView.markDirty(from, to);
        checkCSS(view);
      }
      if (view.input.badSafariComposition) {
        view.input.badSafariComposition = false;
        fixUpBadSafariComposition(view, added);
      }
      this.handleDOMChange(from, to, typeOver, added);
      if (view.docView && view.docView.dirty)
        view.updateState(view.state);
      else if (!this.currentSelection.eq(sel))
        selectionToDOM(view);
      this.currentSelection.set(sel);
    }
  }
  registerMutation(mut, added) {
    if (added.indexOf(mut.target) > -1)
      return null;
    let desc = this.view.docView.nearestDesc(mut.target);
    if (mut.type == "attributes" && (desc == this.view.docView || mut.attributeName == "contenteditable" || mut.attributeName == "style" && !mut.oldValue && !mut.target.getAttribute("style")))
      return null;
    if (!desc || desc.ignoreMutation(mut))
      return null;
    if (mut.type == "childList") {
      for (let i = 0;i < mut.addedNodes.length; i++) {
        let node = mut.addedNodes[i];
        added.push(node);
        if (node.nodeType == 3)
          this.lastChangedTextNode = node;
      }
      if (desc.contentDOM && desc.contentDOM != desc.dom && !desc.contentDOM.contains(mut.target))
        return { from: desc.posBefore, to: desc.posAfter };
      let { previousSibling: prev, nextSibling: next } = mut;
      if (ie && ie_version <= 11 && mut.addedNodes.length) {
        for (let i = 0;i < mut.addedNodes.length; i++) {
          let { previousSibling, nextSibling } = mut.addedNodes[i];
          if (!previousSibling || Array.prototype.indexOf.call(mut.addedNodes, previousSibling) < 0)
            prev = previousSibling;
          if (!nextSibling || Array.prototype.indexOf.call(mut.addedNodes, nextSibling) < 0)
            next = nextSibling;
        }
      }
      let fromOffset = prev && prev.parentNode == mut.target ? domIndex(prev) + 1 : 0;
      let from = desc.localPosFromDOM(mut.target, fromOffset, -1);
      let toOffset = next && next.parentNode == mut.target ? domIndex(next) : mut.target.childNodes.length;
      let to = desc.localPosFromDOM(mut.target, toOffset, 1);
      return { from, to };
    } else if (mut.type == "attributes") {
      return { from: desc.posAtStart - desc.border, to: desc.posAtEnd + desc.border };
    } else {
      this.lastChangedTextNode = mut.target;
      return {
        from: desc.posAtStart,
        to: desc.posAtEnd,
        typeOver: mut.target.nodeValue == mut.oldValue
      };
    }
  }
}
var cssChecked = new WeakMap;
var cssCheckWarned = false;
function checkCSS(view) {
  if (cssChecked.has(view))
    return;
  cssChecked.set(view, null);
  if (["normal", "nowrap", "pre-line"].indexOf(getComputedStyle(view.dom).whiteSpace) !== -1) {
    view.requiresGeckoHackNode = gecko;
    if (cssCheckWarned)
      return;
    console["warn"]("ProseMirror expects the CSS white-space property to be set, preferably to 'pre-wrap'. It is recommended to load style/prosemirror.css from the prosemirror-view package.");
    cssCheckWarned = true;
  }
}
function rangeToSelectionRange(view, range) {
  let { startContainer: anchorNode, startOffset: anchorOffset } = range;
  let { endContainer: focusNode, endOffset: focusOffset } = range;
  let currentAnchor = view.domAtPos(view.state.selection.anchor);
  if (isEquivalentPosition(currentAnchor.node, currentAnchor.offset, focusNode, focusOffset))
    [anchorNode, anchorOffset, focusNode, focusOffset] = [focusNode, focusOffset, anchorNode, anchorOffset];
  return { anchorNode, anchorOffset, focusNode, focusOffset };
}
function safariShadowSelectionRange(view, selection) {
  if (selection.getComposedRanges) {
    let range = selection.getComposedRanges(view.root)[0];
    if (range)
      return rangeToSelectionRange(view, range);
  }
  let found2;
  function read(event) {
    event.preventDefault();
    event.stopImmediatePropagation();
    found2 = event.getTargetRanges()[0];
  }
  view.dom.addEventListener("beforeinput", read, true);
  document.execCommand("indent");
  view.dom.removeEventListener("beforeinput", read, true);
  return found2 ? rangeToSelectionRange(view, found2) : null;
}
function blockParent(view, node) {
  for (let p = node.parentNode;p && p != view.dom; p = p.parentNode) {
    let desc = view.docView.nearestDesc(p, true);
    if (desc && desc.node.isBlock)
      return p;
  }
  return null;
}
function fixUpBadSafariComposition(view, addedNodes) {
  var _a;
  let { focusNode, focusOffset } = view.domSelectionRange();
  for (let node of addedNodes) {
    if (((_a = node.parentNode) === null || _a === undefined ? undefined : _a.nodeName) == "TR") {
      let nextCell = node.nextSibling;
      while (nextCell && (nextCell.nodeName != "TD" && nextCell.nodeName != "TH"))
        nextCell = nextCell.nextSibling;
      if (nextCell) {
        let parent = nextCell;
        for (;; ) {
          let first = parent.firstChild;
          if (!first || first.nodeType != 1 || first.contentEditable == "false" || /^(BR|IMG)$/.test(first.nodeName))
            break;
          parent = first;
        }
        parent.insertBefore(node, parent.firstChild);
        if (focusNode == node)
          view.domSelection().collapse(node, focusOffset);
      } else {
        node.parentNode.removeChild(node);
      }
    }
  }
}
function parseBetween(view, from_, to_) {
  let { node: parent, fromOffset, toOffset, from, to } = view.docView.parseRange(from_, to_);
  let domSel = view.domSelectionRange();
  let find;
  let anchor = domSel.anchorNode;
  if (anchor && view.dom.contains(anchor.nodeType == 1 ? anchor : anchor.parentNode)) {
    find = [{ node: anchor, offset: domSel.anchorOffset }];
    if (!selectionCollapsed(domSel))
      find.push({ node: domSel.focusNode, offset: domSel.focusOffset });
  }
  if (chrome && view.input.lastKeyCode === 8) {
    for (let off = toOffset;off > fromOffset; off--) {
      let node = parent.childNodes[off - 1], desc = node.pmViewDesc;
      if (node.nodeName == "BR" && !desc) {
        toOffset = off;
        break;
      }
      if (!desc || desc.size)
        break;
    }
  }
  let startDoc = view.state.doc;
  let parser = view.someProp("domParser") || DOMParser2.fromSchema(view.state.schema);
  let $from = startDoc.resolve(from);
  let sel = null, doc3 = parser.parse(parent, {
    topNode: $from.parent,
    topMatch: $from.parent.contentMatchAt($from.index()),
    topOpen: true,
    from: fromOffset,
    to: toOffset,
    preserveWhitespace: $from.parent.type.whitespace == "pre" ? "full" : true,
    findPositions: find,
    ruleFromNode,
    context: $from
  });
  if (find && find[0].pos != null) {
    let anchor2 = find[0].pos, head = find[1] && find[1].pos;
    if (head == null)
      head = anchor2;
    sel = { anchor: anchor2 + from, head: head + from };
  }
  return { doc: doc3, sel, from, to };
}
function ruleFromNode(dom) {
  let desc = dom.pmViewDesc;
  if (desc) {
    return desc.parseRule();
  } else if (dom.nodeName == "BR" && dom.parentNode) {
    if (safari2 && /^(ul|ol)$/i.test(dom.parentNode.nodeName)) {
      let skip = document.createElement("div");
      skip.appendChild(document.createElement("li"));
      return { skip };
    } else if (dom.parentNode.lastChild == dom || safari2 && /^(tr|table)$/i.test(dom.parentNode.nodeName)) {
      return { ignore: true };
    }
  } else if (dom.nodeName == "IMG" && dom.getAttribute("mark-placeholder")) {
    return { ignore: true };
  }
  return null;
}
var isInline = /^(a|abbr|acronym|b|bd[io]|big|br|button|cite|code|data(list)?|del|dfn|em|i|img|ins|kbd|label|map|mark|meter|output|q|ruby|s|samp|small|span|strong|su[bp]|time|u|tt|var)$/i;
function readDOMChange(view, from, to, typeOver, addedNodes) {
  let compositionID = view.input.compositionPendingChanges || (view.composing ? view.input.compositionID : 0);
  view.input.compositionPendingChanges = 0;
  if (from < 0) {
    let origin = view.input.lastSelectionTime > Date.now() - 50 ? view.input.lastSelectionOrigin : null;
    let newSel = selectionFromDOM(view, origin);
    if (newSel && !view.state.selection.eq(newSel)) {
      if (chrome && android && view.input.lastKeyCode === 13 && Date.now() - 100 < view.input.lastKeyCodeTime && view.someProp("handleKeyDown", (f) => f(view, keyEvent(13, "Enter"))))
        return;
      let tr = view.state.tr.setSelection(newSel);
      if (origin == "pointer")
        tr.setMeta("pointer", true);
      else if (origin == "key")
        tr.scrollIntoView();
      if (compositionID)
        tr.setMeta("composition", compositionID);
      view.dispatch(tr);
    }
    return;
  }
  let $before = view.state.doc.resolve(from);
  let shared = $before.sharedDepth(to);
  from = $before.before(shared + 1);
  to = view.state.doc.resolve(to).after(shared + 1);
  let sel = view.state.selection;
  let parse = parseBetween(view, from, to);
  let doc3 = view.state.doc, compare = doc3.slice(parse.from, parse.to);
  let preferredPos, preferredSide;
  if (view.input.lastKeyCode === 8 && Date.now() - 100 < view.input.lastKeyCodeTime) {
    preferredPos = view.state.selection.to;
    preferredSide = "end";
  } else {
    preferredPos = view.state.selection.from;
    preferredSide = "start";
  }
  view.input.lastKeyCode = null;
  let change = findDiff(compare.content, parse.doc.content, parse.from, preferredPos, preferredSide);
  if (change)
    view.input.domChangeCount++;
  if ((ios && view.input.lastIOSEnter > Date.now() - 225 || android) && addedNodes.some((n) => n.nodeType == 1 && !isInline.test(n.nodeName)) && (!change || change.endA >= change.endB) && view.someProp("handleKeyDown", (f) => f(view, keyEvent(13, "Enter")))) {
    view.input.lastIOSEnter = 0;
    return;
  }
  if (!change) {
    if (typeOver && sel instanceof TextSelection && !sel.empty && sel.$head.sameParent(sel.$anchor) && !view.composing && !(parse.sel && parse.sel.anchor != parse.sel.head)) {
      change = { start: sel.from, endA: sel.to, endB: sel.to };
    } else {
      if (parse.sel) {
        let sel2 = resolveSelection(view, view.state.doc, parse.sel);
        if (sel2 && !sel2.eq(view.state.selection)) {
          let tr = view.state.tr.setSelection(sel2);
          if (compositionID)
            tr.setMeta("composition", compositionID);
          view.dispatch(tr);
        }
      }
      return;
    }
  }
  if (view.state.selection.from < view.state.selection.to && change.start == change.endB && view.state.selection instanceof TextSelection) {
    if (change.start > view.state.selection.from && change.start <= view.state.selection.from + 2 && view.state.selection.from >= parse.from) {
      change.start = view.state.selection.from;
    } else if (change.endA < view.state.selection.to && change.endA >= view.state.selection.to - 2 && view.state.selection.to <= parse.to) {
      change.endB += view.state.selection.to - change.endA;
      change.endA = view.state.selection.to;
    }
  }
  if (ie && ie_version <= 11 && change.endB == change.start + 1 && change.endA == change.start && change.start > parse.from && parse.doc.textBetween(change.start - parse.from - 1, change.start - parse.from + 1) == " ") {
    change.start--;
    change.endA--;
    change.endB--;
  }
  let $from = parse.doc.resolveNoCache(change.start - parse.from);
  let $to = parse.doc.resolveNoCache(change.endB - parse.from);
  let $fromA = doc3.resolve(change.start);
  let inlineChange = $from.sameParent($to) && $from.parent.inlineContent && $fromA.end() >= change.endA;
  if ((ios && view.input.lastIOSEnter > Date.now() - 225 && (!inlineChange || addedNodes.some((n) => n.nodeName == "DIV" || n.nodeName == "P")) || !inlineChange && $from.pos < parse.doc.content.size && (!$from.sameParent($to) || !$from.parent.inlineContent) && $from.pos < $to.pos && !/\S/.test(parse.doc.textBetween($from.pos, $to.pos, "", ""))) && view.someProp("handleKeyDown", (f) => f(view, keyEvent(13, "Enter")))) {
    view.input.lastIOSEnter = 0;
    return;
  }
  if (view.state.selection.anchor > change.start && looksLikeBackspace(doc3, change.start, change.endA, $from, $to) && view.someProp("handleKeyDown", (f) => f(view, keyEvent(8, "Backspace")))) {
    if (android && chrome)
      view.domObserver.suppressSelectionUpdates();
    return;
  }
  if (chrome && change.endB == change.start)
    view.input.lastChromeDelete = Date.now();
  if (android && !inlineChange && $from.start() != $to.start() && $to.parentOffset == 0 && $from.depth == $to.depth && parse.sel && parse.sel.anchor == parse.sel.head && parse.sel.head == change.endA) {
    change.endB -= 2;
    $to = parse.doc.resolveNoCache(change.endB - parse.from);
    setTimeout(() => {
      view.someProp("handleKeyDown", function(f) {
        return f(view, keyEvent(13, "Enter"));
      });
    }, 20);
  }
  let { start: chFrom, endA: chTo } = change;
  let mkTr = (base) => {
    let tr = base || view.state.tr.replace(chFrom, chTo, parse.doc.slice(change.start - parse.from, change.endB - parse.from));
    if (parse.sel) {
      let sel2 = resolveSelection(view, tr.doc, parse.sel);
      if (sel2 && !(chrome && view.composing && sel2.empty && (change.start != change.endB || view.input.lastChromeDelete < Date.now() - 100) && (sel2.head == chFrom || sel2.head == tr.mapping.map(chTo) - 1) || ie && sel2.empty && sel2.head == chFrom))
        tr.setSelection(sel2);
    }
    if (compositionID)
      tr.setMeta("composition", compositionID);
    return tr.scrollIntoView();
  };
  let markChange;
  if (inlineChange) {
    if ($from.pos == $to.pos) {
      if (ie && ie_version <= 11 && $from.parentOffset == 0) {
        view.domObserver.suppressSelectionUpdates();
        setTimeout(() => selectionToDOM(view), 20);
      }
      let tr = mkTr(view.state.tr.delete(chFrom, chTo));
      let marks = doc3.resolve(change.start).marksAcross(doc3.resolve(change.endA));
      if (marks)
        tr.ensureMarks(marks);
      view.dispatch(tr);
    } else if (change.endA == change.endB && (markChange = isMarkChange($from.parent.content.cut($from.parentOffset, $to.parentOffset), $fromA.parent.content.cut($fromA.parentOffset, change.endA - $fromA.start())))) {
      let tr = mkTr(view.state.tr);
      if (markChange.type == "add")
        tr.addMark(chFrom, chTo, markChange.mark);
      else
        tr.removeMark(chFrom, chTo, markChange.mark);
      view.dispatch(tr);
    } else if ($from.parent.child($from.index()).isText && $from.index() == $to.index() - ($to.textOffset ? 0 : 1)) {
      let text = $from.parent.textBetween($from.parentOffset, $to.parentOffset);
      let deflt = () => mkTr(view.state.tr.insertText(text, chFrom, chTo));
      if (!view.someProp("handleTextInput", (f) => f(view, chFrom, chTo, text, deflt)))
        view.dispatch(deflt());
    } else {
      view.dispatch(mkTr());
    }
  } else {
    view.dispatch(mkTr());
  }
}
function resolveSelection(view, doc3, parsedSel) {
  if (Math.max(parsedSel.anchor, parsedSel.head) > doc3.content.size)
    return null;
  return selectionBetween(view, doc3.resolve(parsedSel.anchor), doc3.resolve(parsedSel.head));
}
function isMarkChange(cur, prev) {
  let curMarks = cur.firstChild.marks, prevMarks = prev.firstChild.marks;
  let added = curMarks, removed = prevMarks, type, mark, update;
  for (let i = 0;i < prevMarks.length; i++)
    added = prevMarks[i].removeFromSet(added);
  for (let i = 0;i < curMarks.length; i++)
    removed = curMarks[i].removeFromSet(removed);
  if (added.length == 1 && removed.length == 0) {
    mark = added[0];
    type = "add";
    update = (node) => node.mark(mark.addToSet(node.marks));
  } else if (added.length == 0 && removed.length == 1) {
    mark = removed[0];
    type = "remove";
    update = (node) => node.mark(mark.removeFromSet(node.marks));
  } else {
    return null;
  }
  let updated = [];
  for (let i = 0;i < prev.childCount; i++)
    updated.push(update(prev.child(i)));
  if (Fragment.from(updated).eq(cur))
    return { mark, type };
}
function looksLikeBackspace(old, start, end, $newStart, $newEnd) {
  if (end - start <= $newEnd.pos - $newStart.pos || skipClosingAndOpening($newStart, true, false) < $newEnd.pos)
    return false;
  let $start = old.resolve(start);
  if (!$newStart.parent.isTextblock) {
    let after = $start.nodeAfter;
    return after != null && end == start + after.nodeSize;
  }
  if ($start.parentOffset < $start.parent.content.size || !$start.parent.isTextblock)
    return false;
  let $next = old.resolve(skipClosingAndOpening($start, true, true));
  if (!$next.parent.isTextblock || $next.pos > end || skipClosingAndOpening($next, true, false) < end)
    return false;
  return $newStart.parent.content.cut($newStart.parentOffset).eq($next.parent.content);
}
function skipClosingAndOpening($pos, fromEnd, mayOpen) {
  let depth = $pos.depth, end = fromEnd ? $pos.end() : $pos.pos;
  while (depth > 0 && (fromEnd || $pos.indexAfter(depth) == $pos.node(depth).childCount)) {
    depth--;
    end++;
    fromEnd = false;
  }
  if (mayOpen) {
    let next = $pos.node(depth).maybeChild($pos.indexAfter(depth));
    while (next && !next.isLeaf) {
      next = next.firstChild;
      end++;
    }
  }
  return end;
}
function findDiff(a, b, pos, preferredPos, preferredSide) {
  let start = a.findDiffStart(b, pos);
  if (start == null)
    return null;
  let { a: endA, b: endB } = a.findDiffEnd(b, pos + a.size, pos + b.size);
  if (preferredSide == "end") {
    let adjust = Math.max(0, start - Math.min(endA, endB));
    preferredPos -= endA + adjust - start;
  }
  if (endA < start && a.size < b.size) {
    let move = preferredPos <= start && preferredPos >= endA ? start - preferredPos : 0;
    start -= move;
    if (start && start < b.size && isSurrogatePair(b.textBetween(start - 1, start + 1)))
      start += move ? 1 : -1;
    endB = start + (endB - endA);
    endA = start;
  } else if (endB < start) {
    let move = preferredPos <= start && preferredPos >= endB ? start - preferredPos : 0;
    start -= move;
    if (start && start < a.size && isSurrogatePair(a.textBetween(start - 1, start + 1)))
      start += move ? 1 : -1;
    endA = start + (endA - endB);
    endB = start;
  }
  return { start, endA, endB };
}
function isSurrogatePair(str) {
  if (str.length != 2)
    return false;
  let a = str.charCodeAt(0), b = str.charCodeAt(1);
  return a >= 56320 && a <= 57343 && b >= 55296 && b <= 56319;
}
class EditorView {
  constructor(place, props) {
    this._root = null;
    this.focused = false;
    this.trackWrites = null;
    this.mounted = false;
    this.markCursor = null;
    this.cursorWrapper = null;
    this.lastSelectedViewDesc = undefined;
    this.input = new InputState;
    this.prevDirectPlugins = [];
    this.pluginViews = [];
    this.requiresGeckoHackNode = false;
    this.dragging = null;
    this._props = props;
    this.state = props.state;
    this.directPlugins = props.plugins || [];
    this.directPlugins.forEach(checkStateComponent);
    this.dispatch = this.dispatch.bind(this);
    this.dom = place && place.mount || document.createElement("div");
    if (place) {
      if (place.appendChild)
        place.appendChild(this.dom);
      else if (typeof place == "function")
        place(this.dom);
      else if (place.mount)
        this.mounted = true;
    }
    this.editable = getEditable(this);
    updateCursorWrapper(this);
    this.nodeViews = buildNodeViews(this);
    this.docView = docViewDesc(this.state.doc, computeDocDeco(this), viewDecorations(this), this.dom, this);
    this.domObserver = new DOMObserver(this, (from, to, typeOver, added) => readDOMChange(this, from, to, typeOver, added));
    this.domObserver.start();
    initInput(this);
    this.updatePluginViews();
  }
  get composing() {
    return this.input.composing;
  }
  get props() {
    if (this._props.state != this.state) {
      let prev = this._props;
      this._props = {};
      for (let name in prev)
        this._props[name] = prev[name];
      this._props.state = this.state;
    }
    return this._props;
  }
  update(props) {
    if (props.handleDOMEvents != this._props.handleDOMEvents)
      ensureListeners(this);
    let prevProps = this._props;
    this._props = props;
    if (props.plugins) {
      props.plugins.forEach(checkStateComponent);
      this.directPlugins = props.plugins;
    }
    this.updateStateInner(props.state, prevProps);
  }
  setProps(props) {
    let updated = {};
    for (let name in this._props)
      updated[name] = this._props[name];
    updated.state = this.state;
    for (let name in props)
      updated[name] = props[name];
    this.update(updated);
  }
  updateState(state) {
    this.updateStateInner(state, this._props);
  }
  updateStateInner(state, prevProps) {
    var _a;
    let prev = this.state, redraw = false, updateSel = false;
    if (state.storedMarks && this.composing) {
      clearComposition(this);
      updateSel = true;
    }
    this.state = state;
    let pluginsChanged = prev.plugins != state.plugins || this._props.plugins != prevProps.plugins;
    if (pluginsChanged || this._props.plugins != prevProps.plugins || this._props.nodeViews != prevProps.nodeViews) {
      let nodeViews = buildNodeViews(this);
      if (changedNodeViews(nodeViews, this.nodeViews)) {
        this.nodeViews = nodeViews;
        redraw = true;
      }
    }
    if (pluginsChanged || prevProps.handleDOMEvents != this._props.handleDOMEvents) {
      ensureListeners(this);
    }
    this.editable = getEditable(this);
    updateCursorWrapper(this);
    let innerDeco = viewDecorations(this), outerDeco = computeDocDeco(this);
    let scroll = prev.plugins != state.plugins && !prev.doc.eq(state.doc) ? "reset" : state.scrollToSelection > prev.scrollToSelection ? "to selection" : "preserve";
    let updateDoc = redraw || !this.docView.matchesNode(state.doc, outerDeco, innerDeco);
    if (updateDoc || !state.selection.eq(prev.selection))
      updateSel = true;
    let oldScrollPos = scroll == "preserve" && updateSel && this.dom.style.overflowAnchor == null && storeScrollPos(this);
    if (updateSel) {
      this.domObserver.stop();
      let forceSelUpdate = updateDoc && (ie || chrome) && !this.composing && !prev.selection.empty && !state.selection.empty && selectionContextChanged(prev.selection, state.selection);
      if (updateDoc) {
        let chromeKludge = chrome ? this.trackWrites = this.domSelectionRange().focusNode : null;
        if (this.composing)
          this.input.compositionNode = findCompositionNode(this);
        if (redraw || !this.docView.update(state.doc, outerDeco, innerDeco, this)) {
          this.docView.updateOuterDeco(outerDeco);
          this.docView.destroy();
          this.docView = docViewDesc(state.doc, outerDeco, innerDeco, this.dom, this);
        }
        if (chromeKludge && (!this.trackWrites || !this.dom.contains(this.trackWrites)))
          forceSelUpdate = true;
      }
      if (forceSelUpdate || !(this.input.mouseDown && this.domObserver.currentSelection.eq(this.domSelectionRange()) && anchorInRightPlace(this))) {
        selectionToDOM(this, forceSelUpdate);
      } else {
        syncNodeSelection(this, state.selection);
        this.domObserver.setCurSelection();
      }
      this.domObserver.start();
    }
    this.updatePluginViews(prev);
    if (((_a = this.dragging) === null || _a === undefined ? undefined : _a.node) && !prev.doc.eq(state.doc))
      this.updateDraggedNode(this.dragging, prev);
    if (scroll == "reset") {
      this.dom.scrollTop = 0;
    } else if (scroll == "to selection") {
      this.scrollToSelection();
    } else if (oldScrollPos) {
      resetScrollPos(oldScrollPos);
    }
  }
  scrollToSelection() {
    let startDOM = this.domSelectionRange().focusNode;
    if (!startDOM || !this.dom.contains(startDOM.nodeType == 1 ? startDOM : startDOM.parentNode))
      ;
    else if (this.someProp("handleScrollToSelection", (f) => f(this)))
      ;
    else if (this.state.selection instanceof NodeSelection) {
      let target = this.docView.domAfterPos(this.state.selection.from);
      if (target.nodeType == 1)
        scrollRectIntoView(this, target.getBoundingClientRect(), startDOM);
    } else {
      scrollRectIntoView(this, this.coordsAtPos(this.state.selection.head, 1), startDOM);
    }
  }
  destroyPluginViews() {
    let view;
    while (view = this.pluginViews.pop())
      if (view.destroy)
        view.destroy();
  }
  updatePluginViews(prevState) {
    if (!prevState || prevState.plugins != this.state.plugins || this.directPlugins != this.prevDirectPlugins) {
      this.prevDirectPlugins = this.directPlugins;
      this.destroyPluginViews();
      for (let i = 0;i < this.directPlugins.length; i++) {
        let plugin = this.directPlugins[i];
        if (plugin.spec.view)
          this.pluginViews.push(plugin.spec.view(this));
      }
      for (let i = 0;i < this.state.plugins.length; i++) {
        let plugin = this.state.plugins[i];
        if (plugin.spec.view)
          this.pluginViews.push(plugin.spec.view(this));
      }
    } else {
      for (let i = 0;i < this.pluginViews.length; i++) {
        let pluginView = this.pluginViews[i];
        if (pluginView.update)
          pluginView.update(this, prevState);
      }
    }
  }
  updateDraggedNode(dragging, prev) {
    let sel = dragging.node, found2 = -1;
    if (this.state.doc.nodeAt(sel.from) == sel.node) {
      found2 = sel.from;
    } else {
      let movedPos = sel.from + (this.state.doc.content.size - prev.doc.content.size);
      let moved = movedPos > 0 && this.state.doc.nodeAt(movedPos);
      if (moved == sel.node)
        found2 = movedPos;
    }
    this.dragging = new Dragging(dragging.slice, dragging.move, found2 < 0 ? undefined : NodeSelection.create(this.state.doc, found2));
  }
  someProp(propName, f) {
    let prop = this._props && this._props[propName], value;
    if (prop != null && (value = f ? f(prop) : prop))
      return value;
    for (let i = 0;i < this.directPlugins.length; i++) {
      let prop2 = this.directPlugins[i].props[propName];
      if (prop2 != null && (value = f ? f(prop2) : prop2))
        return value;
    }
    let plugins = this.state.plugins;
    if (plugins)
      for (let i = 0;i < plugins.length; i++) {
        let prop2 = plugins[i].props[propName];
        if (prop2 != null && (value = f ? f(prop2) : prop2))
          return value;
      }
  }
  hasFocus() {
    if (ie) {
      let node = this.root.activeElement;
      if (node == this.dom)
        return true;
      if (!node || !this.dom.contains(node))
        return false;
      while (node && this.dom != node && this.dom.contains(node)) {
        if (node.contentEditable == "false")
          return false;
        node = node.parentElement;
      }
      return true;
    }
    return this.root.activeElement == this.dom;
  }
  focus() {
    this.domObserver.stop();
    if (this.editable)
      focusPreventScroll(this.dom);
    selectionToDOM(this);
    this.domObserver.start();
  }
  get root() {
    let cached = this._root;
    if (cached == null)
      for (let search = this.dom.parentNode;search; search = search.parentNode) {
        if (search.nodeType == 9 || search.nodeType == 11 && search.host) {
          if (!search.getSelection)
            Object.getPrototypeOf(search).getSelection = () => search.ownerDocument.getSelection();
          return this._root = search;
        }
      }
    return cached || document;
  }
  updateRoot() {
    this._root = null;
  }
  posAtCoords(coords) {
    return posAtCoords(this, coords);
  }
  coordsAtPos(pos, side = 1) {
    return coordsAtPos(this, pos, side);
  }
  domAtPos(pos, side = 0) {
    return this.docView.domFromPos(pos, side);
  }
  nodeDOM(pos) {
    let desc = this.docView.descAt(pos);
    return desc ? desc.nodeDOM : null;
  }
  posAtDOM(node, offset, bias = -1) {
    let pos = this.docView.posFromDOM(node, offset, bias);
    if (pos == null)
      throw new RangeError("DOM position not inside the editor");
    return pos;
  }
  endOfTextblock(dir, state) {
    return endOfTextblock(this, state || this.state, dir);
  }
  pasteHTML(html, event) {
    return doPaste(this, "", html, false, event || new ClipboardEvent("paste"));
  }
  pasteText(text, event) {
    return doPaste(this, text, null, true, event || new ClipboardEvent("paste"));
  }
  serializeForClipboard(slice) {
    return serializeForClipboard(this, slice);
  }
  destroy() {
    if (!this.docView)
      return;
    destroyInput(this);
    this.destroyPluginViews();
    if (this.mounted) {
      this.docView.update(this.state.doc, [], viewDecorations(this), this);
      this.dom.textContent = "";
    } else if (this.dom.parentNode) {
      this.dom.parentNode.removeChild(this.dom);
    }
    this.docView.destroy();
    this.docView = null;
    clearReusedRange();
  }
  get isDestroyed() {
    return this.docView == null;
  }
  dispatchEvent(event) {
    return dispatchEvent(this, event);
  }
  domSelectionRange() {
    let sel = this.domSelection();
    if (!sel)
      return { focusNode: null, focusOffset: 0, anchorNode: null, anchorOffset: 0 };
    return safari2 && this.root.nodeType === 11 && deepActiveElement(this.dom.ownerDocument) == this.dom && safariShadowSelectionRange(this, sel) || sel;
  }
  domSelection() {
    return this.root.getSelection();
  }
}
EditorView.prototype.dispatch = function(tr) {
  let dispatchTransaction = this._props.dispatchTransaction;
  if (dispatchTransaction)
    dispatchTransaction.call(this, tr);
  else
    this.updateState(this.state.apply(tr));
};
function computeDocDeco(view) {
  let attrs = Object.create(null);
  attrs.class = "ProseMirror";
  attrs.contenteditable = String(view.editable);
  view.someProp("attributes", (value) => {
    if (typeof value == "function")
      value = value(view.state);
    if (value)
      for (let attr in value) {
        if (attr == "class")
          attrs.class += " " + value[attr];
        else if (attr == "style")
          attrs.style = (attrs.style ? attrs.style + ";" : "") + value[attr];
        else if (!attrs[attr] && attr != "contenteditable" && attr != "nodeName")
          attrs[attr] = String(value[attr]);
      }
  });
  if (!attrs.translate)
    attrs.translate = "no";
  return [Decoration.node(0, view.state.doc.content.size, attrs)];
}
function updateCursorWrapper(view) {
  if (view.markCursor) {
    let dom = document.createElement("img");
    dom.className = "ProseMirror-separator";
    dom.setAttribute("mark-placeholder", "true");
    dom.setAttribute("alt", "");
    view.cursorWrapper = { dom, deco: Decoration.widget(view.state.selection.from, dom, { raw: true, marks: view.markCursor }) };
  } else {
    view.cursorWrapper = null;
  }
}
function getEditable(view) {
  return !view.someProp("editable", (value) => value(view.state) === false);
}
function selectionContextChanged(sel1, sel2) {
  let depth = Math.min(sel1.$anchor.sharedDepth(sel1.head), sel2.$anchor.sharedDepth(sel2.head));
  return sel1.$anchor.start(depth) != sel2.$anchor.start(depth);
}
function buildNodeViews(view) {
  let result = Object.create(null);
  function add(obj) {
    for (let prop in obj)
      if (!Object.prototype.hasOwnProperty.call(result, prop))
        result[prop] = obj[prop];
  }
  view.someProp("nodeViews", add);
  view.someProp("markViews", add);
  return result;
}
function changedNodeViews(a, b) {
  let nA = 0, nB = 0;
  for (let prop in a) {
    if (a[prop] != b[prop])
      return true;
    nA++;
  }
  for (let _ in b)
    nB++;
  return nA != nB;
}
function checkStateComponent(plugin) {
  if (plugin.spec.state || plugin.spec.filterTransaction || plugin.spec.appendTransaction)
    throw new RangeError("Plugins passed directly to the view must not have a state component");
}
// node_modules/w3c-keyname/index.js
var base = {
  8: "Backspace",
  9: "Tab",
  10: "Enter",
  12: "NumLock",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  44: "PrintScreen",
  45: "Insert",
  46: "Delete",
  59: ";",
  61: "=",
  91: "Meta",
  92: "Meta",
  106: "*",
  107: "+",
  108: ",",
  109: "-",
  110: ".",
  111: "/",
  144: "NumLock",
  145: "ScrollLock",
  160: "Shift",
  161: "Shift",
  162: "Control",
  163: "Control",
  164: "Alt",
  165: "Alt",
  173: "-",
  186: ";",
  187: "=",
  188: ",",
  189: "-",
  190: ".",
  191: "/",
  192: "`",
  219: "[",
  220: "\\",
  221: "]",
  222: "'"
};
var shift = {
  48: ")",
  49: "!",
  50: "@",
  51: "#",
  52: "$",
  53: "%",
  54: "^",
  55: "&",
  56: "*",
  57: "(",
  59: ":",
  61: "+",
  173: "_",
  186: ":",
  187: "+",
  188: "<",
  189: "_",
  190: ">",
  191: "?",
  192: "~",
  219: "{",
  220: "|",
  221: "}",
  222: '"'
};
var mac2 = typeof navigator != "undefined" && /Mac/.test(navigator.platform);
var ie2 = typeof navigator != "undefined" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
for (i = 0;i < 10; i++)
  base[48 + i] = base[96 + i] = String(i);
var i;
for (i = 1;i <= 24; i++)
  base[i + 111] = "F" + i;
var i;
for (i = 65;i <= 90; i++) {
  base[i] = String.fromCharCode(i + 32);
  shift[i] = String.fromCharCode(i);
}
var i;
for (code in base)
  if (!shift.hasOwnProperty(code))
    shift[code] = base[code];
var code;
function keyName(event) {
  var ignoreKey = mac2 && event.metaKey && event.shiftKey && !event.ctrlKey && !event.altKey || ie2 && event.shiftKey && event.key && event.key.length == 1 || event.key == "Unidentified";
  var name = !ignoreKey && event.key || (event.shiftKey ? shift : base)[event.keyCode] || event.key || "Unidentified";
  if (name == "Esc")
    name = "Escape";
  if (name == "Del")
    name = "Delete";
  if (name == "Left")
    name = "ArrowLeft";
  if (name == "Up")
    name = "ArrowUp";
  if (name == "Right")
    name = "ArrowRight";
  if (name == "Down")
    name = "ArrowDown";
  return name;
}

// node_modules/prosemirror-keymap/dist/index.js
var mac3 = typeof navigator != "undefined" && /Mac|iP(hone|[oa]d)/.test(navigator.platform);
var windows2 = typeof navigator != "undefined" && /Win/.test(navigator.platform);
function normalizeKeyName(name) {
  let parts = name.split(/-(?!$)/), result = parts[parts.length - 1];
  if (result == "Space")
    result = " ";
  let alt, ctrl, shift2, meta;
  for (let i2 = 0;i2 < parts.length - 1; i2++) {
    let mod = parts[i2];
    if (/^(cmd|meta|m)$/i.test(mod))
      meta = true;
    else if (/^a(lt)?$/i.test(mod))
      alt = true;
    else if (/^(c|ctrl|control)$/i.test(mod))
      ctrl = true;
    else if (/^s(hift)?$/i.test(mod))
      shift2 = true;
    else if (/^mod$/i.test(mod)) {
      if (mac3)
        meta = true;
      else
        ctrl = true;
    } else
      throw new Error("Unrecognized modifier name: " + mod);
  }
  if (alt)
    result = "Alt-" + result;
  if (ctrl)
    result = "Ctrl-" + result;
  if (meta)
    result = "Meta-" + result;
  if (shift2)
    result = "Shift-" + result;
  return result;
}
function normalize(map) {
  let copy2 = Object.create(null);
  for (let prop in map)
    copy2[normalizeKeyName(prop)] = map[prop];
  return copy2;
}
function modifiers(name, event, shift2 = true) {
  if (event.altKey)
    name = "Alt-" + name;
  if (event.ctrlKey)
    name = "Ctrl-" + name;
  if (event.metaKey)
    name = "Meta-" + name;
  if (shift2 && event.shiftKey)
    name = "Shift-" + name;
  return name;
}
function keymap(bindings) {
  return new Plugin({ props: { handleKeyDown: keydownHandler(bindings) } });
}
function keydownHandler(bindings) {
  let map = normalize(bindings);
  return function(view, event) {
    let name = keyName(event), baseName, direct = map[modifiers(name, event)];
    if (direct && direct(view.state, view.dispatch, view))
      return true;
    if (name.length == 1 && name != " ") {
      if (event.shiftKey) {
        let noShift = map[modifiers(name, event, false)];
        if (noShift && noShift(view.state, view.dispatch, view))
          return true;
      }
      if ((event.altKey || event.metaKey || event.ctrlKey) && !(windows2 && event.ctrlKey && event.altKey) && (baseName = base[event.keyCode]) && baseName != name) {
        let fromCode = map[modifiers(baseName, event)];
        if (fromCode && fromCode(view.state, view.dispatch, view))
          return true;
      }
    }
    return false;
  };
}
// node_modules/prosemirror-commands/dist/index.js
var deleteSelection = (state, dispatch) => {
  if (state.selection.empty)
    return false;
  if (dispatch)
    dispatch(state.tr.deleteSelection().scrollIntoView());
  return true;
};
function atBlockStart(state, view) {
  let { $cursor } = state.selection;
  if (!$cursor || (view ? !view.endOfTextblock("backward", state) : $cursor.parentOffset > 0))
    return null;
  return $cursor;
}
var joinBackward = (state, dispatch, view) => {
  let $cursor = atBlockStart(state, view);
  if (!$cursor)
    return false;
  let $cut = findCutBefore($cursor);
  if (!$cut) {
    let range = $cursor.blockRange(), target = range && liftTarget(range);
    if (target == null)
      return false;
    if (dispatch)
      dispatch(state.tr.lift(range, target).scrollIntoView());
    return true;
  }
  let before = $cut.nodeBefore;
  if (deleteBarrier(state, $cut, dispatch, -1))
    return true;
  if ($cursor.parent.content.size == 0 && (textblockAt(before, "end") || NodeSelection.isSelectable(before))) {
    for (let depth = $cursor.depth;; depth--) {
      let delStep = replaceStep(state.doc, $cursor.before(depth), $cursor.after(depth), Slice.empty);
      if (delStep && delStep.slice.size < delStep.to - delStep.from) {
        if (dispatch) {
          let tr = state.tr.step(delStep);
          tr.setSelection(textblockAt(before, "end") ? Selection.findFrom(tr.doc.resolve(tr.mapping.map($cut.pos, -1)), -1) : NodeSelection.create(tr.doc, $cut.pos - before.nodeSize));
          dispatch(tr.scrollIntoView());
        }
        return true;
      }
      if (depth == 1 || $cursor.node(depth - 1).childCount > 1)
        break;
    }
  }
  if (before.isAtom && $cut.depth == $cursor.depth - 1) {
    if (dispatch)
      dispatch(state.tr.delete($cut.pos - before.nodeSize, $cut.pos).scrollIntoView());
    return true;
  }
  return false;
};
var joinTextblockBackward = (state, dispatch, view) => {
  let $cursor = atBlockStart(state, view);
  if (!$cursor)
    return false;
  let $cut = findCutBefore($cursor);
  return $cut ? joinTextblocksAround(state, $cut, dispatch) : false;
};
var joinTextblockForward = (state, dispatch, view) => {
  let $cursor = atBlockEnd(state, view);
  if (!$cursor)
    return false;
  let $cut = findCutAfter($cursor);
  return $cut ? joinTextblocksAround(state, $cut, dispatch) : false;
};
function joinTextblocksAround(state, $cut, dispatch) {
  let before = $cut.nodeBefore, beforeText = before, beforePos = $cut.pos - 1;
  for (;!beforeText.isTextblock; beforePos--) {
    if (beforeText.type.spec.isolating)
      return false;
    let child = beforeText.lastChild;
    if (!child)
      return false;
    beforeText = child;
  }
  let after = $cut.nodeAfter, afterText = after, afterPos = $cut.pos + 1;
  for (;!afterText.isTextblock; afterPos++) {
    if (afterText.type.spec.isolating)
      return false;
    let child = afterText.firstChild;
    if (!child)
      return false;
    afterText = child;
  }
  let step = replaceStep(state.doc, beforePos, afterPos, Slice.empty);
  if (!step || step.from != beforePos || step instanceof ReplaceStep && step.slice.size >= afterPos - beforePos)
    return false;
  if (dispatch) {
    let tr = state.tr.step(step);
    tr.setSelection(TextSelection.create(tr.doc, beforePos));
    dispatch(tr.scrollIntoView());
  }
  return true;
}
function textblockAt(node, side, only = false) {
  for (let scan = node;scan; scan = side == "start" ? scan.firstChild : scan.lastChild) {
    if (scan.isTextblock)
      return true;
    if (only && scan.childCount != 1)
      return false;
  }
  return false;
}
var selectNodeBackward = (state, dispatch, view) => {
  let { $head, empty: empty2 } = state.selection, $cut = $head;
  if (!empty2)
    return false;
  if ($head.parent.isTextblock) {
    if (view ? !view.endOfTextblock("backward", state) : $head.parentOffset > 0)
      return false;
    $cut = findCutBefore($head);
  }
  let node = $cut && $cut.nodeBefore;
  if (!node || !NodeSelection.isSelectable(node))
    return false;
  if (dispatch)
    dispatch(state.tr.setSelection(NodeSelection.create(state.doc, $cut.pos - node.nodeSize)).scrollIntoView());
  return true;
};
function findCutBefore($pos) {
  if (!$pos.parent.type.spec.isolating)
    for (let i2 = $pos.depth - 1;i2 >= 0; i2--) {
      if ($pos.index(i2) > 0)
        return $pos.doc.resolve($pos.before(i2 + 1));
      if ($pos.node(i2).type.spec.isolating)
        break;
    }
  return null;
}
function atBlockEnd(state, view) {
  let { $cursor } = state.selection;
  if (!$cursor || (view ? !view.endOfTextblock("forward", state) : $cursor.parentOffset < $cursor.parent.content.size))
    return null;
  return $cursor;
}
var joinForward = (state, dispatch, view) => {
  let $cursor = atBlockEnd(state, view);
  if (!$cursor)
    return false;
  let $cut = findCutAfter($cursor);
  if (!$cut)
    return false;
  let after = $cut.nodeAfter;
  if (deleteBarrier(state, $cut, dispatch, 1))
    return true;
  if ($cursor.parent.content.size == 0 && (textblockAt(after, "start") || NodeSelection.isSelectable(after))) {
    let delStep = replaceStep(state.doc, $cursor.before(), $cursor.after(), Slice.empty);
    if (delStep && delStep.slice.size < delStep.to - delStep.from) {
      if (dispatch) {
        let tr = state.tr.step(delStep);
        tr.setSelection(textblockAt(after, "start") ? Selection.findFrom(tr.doc.resolve(tr.mapping.map($cut.pos)), 1) : NodeSelection.create(tr.doc, tr.mapping.map($cut.pos)));
        dispatch(tr.scrollIntoView());
      }
      return true;
    }
  }
  if (after.isAtom && $cut.depth == $cursor.depth - 1) {
    if (dispatch)
      dispatch(state.tr.delete($cut.pos, $cut.pos + after.nodeSize).scrollIntoView());
    return true;
  }
  return false;
};
var selectNodeForward = (state, dispatch, view) => {
  let { $head, empty: empty2 } = state.selection, $cut = $head;
  if (!empty2)
    return false;
  if ($head.parent.isTextblock) {
    if (view ? !view.endOfTextblock("forward", state) : $head.parentOffset < $head.parent.content.size)
      return false;
    $cut = findCutAfter($head);
  }
  let node = $cut && $cut.nodeAfter;
  if (!node || !NodeSelection.isSelectable(node))
    return false;
  if (dispatch)
    dispatch(state.tr.setSelection(NodeSelection.create(state.doc, $cut.pos)).scrollIntoView());
  return true;
};
function findCutAfter($pos) {
  if (!$pos.parent.type.spec.isolating)
    for (let i2 = $pos.depth - 1;i2 >= 0; i2--) {
      let parent = $pos.node(i2);
      if ($pos.index(i2) + 1 < parent.childCount)
        return $pos.doc.resolve($pos.after(i2 + 1));
      if (parent.type.spec.isolating)
        break;
    }
  return null;
}
var joinUp = (state, dispatch) => {
  let sel = state.selection, nodeSel = sel instanceof NodeSelection, point;
  if (nodeSel) {
    if (sel.node.isTextblock || !canJoin(state.doc, sel.from))
      return false;
    point = sel.from;
  } else {
    point = joinPoint(state.doc, sel.from, -1);
    if (point == null)
      return false;
  }
  if (dispatch) {
    let tr = state.tr.join(point);
    if (nodeSel)
      tr.setSelection(NodeSelection.create(tr.doc, point - state.doc.resolve(point).nodeBefore.nodeSize));
    dispatch(tr.scrollIntoView());
  }
  return true;
};
var joinDown = (state, dispatch) => {
  let sel = state.selection, point;
  if (sel instanceof NodeSelection) {
    if (sel.node.isTextblock || !canJoin(state.doc, sel.to))
      return false;
    point = sel.to;
  } else {
    point = joinPoint(state.doc, sel.to, 1);
    if (point == null)
      return false;
  }
  if (dispatch)
    dispatch(state.tr.join(point).scrollIntoView());
  return true;
};
var lift2 = (state, dispatch) => {
  let { $from, $to } = state.selection;
  let range = $from.blockRange($to), target = range && liftTarget(range);
  if (target == null)
    return false;
  if (dispatch)
    dispatch(state.tr.lift(range, target).scrollIntoView());
  return true;
};
var newlineInCode = (state, dispatch) => {
  let { $head, $anchor } = state.selection;
  if (!$head.parent.type.spec.code || !$head.sameParent($anchor))
    return false;
  if (dispatch)
    dispatch(state.tr.insertText(`
`).scrollIntoView());
  return true;
};
function defaultBlockAt(match) {
  for (let i2 = 0;i2 < match.edgeCount; i2++) {
    let { type } = match.edge(i2);
    if (type.isTextblock && !type.hasRequiredAttrs())
      return type;
  }
  return null;
}
var exitCode = (state, dispatch) => {
  let { $head, $anchor } = state.selection;
  if (!$head.parent.type.spec.code || !$head.sameParent($anchor))
    return false;
  let above = $head.node(-1), after = $head.indexAfter(-1), type = defaultBlockAt(above.contentMatchAt(after));
  if (!type || !above.canReplaceWith(after, after, type))
    return false;
  if (dispatch) {
    let pos = $head.after(), tr = state.tr.replaceWith(pos, pos, type.createAndFill());
    tr.setSelection(Selection.near(tr.doc.resolve(pos), 1));
    dispatch(tr.scrollIntoView());
  }
  return true;
};
var createParagraphNear = (state, dispatch) => {
  let sel = state.selection, { $from, $to } = sel;
  if (sel instanceof AllSelection || $from.parent.inlineContent || $to.parent.inlineContent)
    return false;
  let type = defaultBlockAt($to.parent.contentMatchAt($to.indexAfter()));
  if (!type || !type.isTextblock)
    return false;
  if (dispatch) {
    let side = (!$from.parentOffset && $to.index() < $to.parent.childCount ? $from : $to).pos;
    let tr = state.tr.insert(side, type.createAndFill());
    tr.setSelection(TextSelection.create(tr.doc, side + 1));
    dispatch(tr.scrollIntoView());
  }
  return true;
};
var liftEmptyBlock = (state, dispatch) => {
  let { $cursor } = state.selection;
  if (!$cursor || $cursor.parent.content.size)
    return false;
  if ($cursor.depth > 1 && $cursor.after() != $cursor.end(-1)) {
    let before = $cursor.before();
    if (canSplit(state.doc, before)) {
      if (dispatch)
        dispatch(state.tr.split(before).scrollIntoView());
      return true;
    }
  }
  let range = $cursor.blockRange(), target = range && liftTarget(range);
  if (target == null)
    return false;
  if (dispatch)
    dispatch(state.tr.lift(range, target).scrollIntoView());
  return true;
};
function splitBlockAs(splitNode) {
  return (state, dispatch) => {
    let { $from, $to } = state.selection;
    if (state.selection instanceof NodeSelection && state.selection.node.isBlock) {
      if (!$from.parentOffset || !canSplit(state.doc, $from.pos))
        return false;
      if (dispatch)
        dispatch(state.tr.split($from.pos).scrollIntoView());
      return true;
    }
    if (!$from.depth)
      return false;
    let types = [];
    let splitDepth, deflt, atEnd = false, atStart = false;
    for (let d = $from.depth;; d--) {
      let node = $from.node(d);
      if (node.isBlock) {
        atEnd = $from.end(d) == $from.pos + ($from.depth - d);
        atStart = $from.start(d) == $from.pos - ($from.depth - d);
        deflt = defaultBlockAt($from.node(d - 1).contentMatchAt($from.indexAfter(d - 1)));
        let splitType = splitNode && splitNode($to.parent, atEnd, $from);
        types.unshift(splitType || (atEnd && deflt ? { type: deflt } : null));
        splitDepth = d;
        break;
      } else {
        if (d == 1)
          return false;
        types.unshift(null);
      }
    }
    let tr = state.tr;
    if (state.selection instanceof TextSelection || state.selection instanceof AllSelection)
      tr.deleteSelection();
    let splitPos = tr.mapping.map($from.pos);
    let can = canSplit(tr.doc, splitPos, types.length, types);
    if (!can) {
      types[0] = deflt ? { type: deflt } : null;
      can = canSplit(tr.doc, splitPos, types.length, types);
    }
    if (!can)
      return false;
    tr.split(splitPos, types.length, types);
    if (!atEnd && atStart && $from.node(splitDepth).type != deflt) {
      let first = tr.mapping.map($from.before(splitDepth)), $first = tr.doc.resolve(first);
      if (deflt && $from.node(splitDepth - 1).canReplaceWith($first.index(), $first.index() + 1, deflt))
        tr.setNodeMarkup(tr.mapping.map($from.before(splitDepth)), deflt);
    }
    if (dispatch)
      dispatch(tr.scrollIntoView());
    return true;
  };
}
var splitBlock = splitBlockAs();
var selectParentNode = (state, dispatch) => {
  let { $from, to } = state.selection, pos;
  let same = $from.sharedDepth(to);
  if (same == 0)
    return false;
  pos = $from.before(same);
  if (dispatch)
    dispatch(state.tr.setSelection(NodeSelection.create(state.doc, pos)));
  return true;
};
var selectAll = (state, dispatch) => {
  if (dispatch)
    dispatch(state.tr.setSelection(new AllSelection(state.doc)));
  return true;
};
function joinMaybeClear(state, $pos, dispatch) {
  let { nodeBefore: before, nodeAfter: after } = $pos, index = $pos.index();
  if (!before || !after || !before.type.compatibleContent(after.type))
    return false;
  if (!before.content.size && $pos.parent.canReplace(index - 1, index)) {
    if (dispatch)
      dispatch(state.tr.delete($pos.pos - before.nodeSize, $pos.pos).scrollIntoView());
    return true;
  }
  if (!$pos.parent.canReplace(index, index + 1) || !(after.isTextblock || canJoin(state.doc, $pos.pos)))
    return false;
  if (dispatch)
    dispatch(state.tr.join($pos.pos).scrollIntoView());
  return true;
}
function deleteBarrier(state, $cut, dispatch, dir) {
  let { nodeBefore: before, nodeAfter: after } = $cut, conn, match;
  let isolated = before.type.spec.isolating || after.type.spec.isolating;
  if (!isolated && joinMaybeClear(state, $cut, dispatch))
    return true;
  let canDelAfter = !isolated && $cut.parent.canReplace($cut.index(), $cut.index() + 1);
  if (canDelAfter && (conn = (match = before.contentMatchAt(before.childCount)).findWrapping(after.type)) && match.matchType(conn[0] || after.type).validEnd) {
    if (dispatch) {
      let end = $cut.pos + after.nodeSize, wrap2 = Fragment.empty;
      for (let i2 = conn.length - 1;i2 >= 0; i2--)
        wrap2 = Fragment.from(conn[i2].create(null, wrap2));
      wrap2 = Fragment.from(before.copy(wrap2));
      let tr = state.tr.step(new ReplaceAroundStep($cut.pos - 1, end, $cut.pos, end, new Slice(wrap2, 1, 0), conn.length, true));
      let $joinAt = tr.doc.resolve(end + 2 * conn.length);
      if ($joinAt.nodeAfter && $joinAt.nodeAfter.type == before.type && canJoin(tr.doc, $joinAt.pos))
        tr.join($joinAt.pos);
      dispatch(tr.scrollIntoView());
    }
    return true;
  }
  let selAfter = after.type.spec.isolating || dir > 0 && isolated ? null : Selection.findFrom($cut, 1);
  let range = selAfter && selAfter.$from.blockRange(selAfter.$to), target = range && liftTarget(range);
  if (target != null && target >= $cut.depth) {
    if (dispatch)
      dispatch(state.tr.lift(range, target).scrollIntoView());
    return true;
  }
  if (canDelAfter && textblockAt(after, "start", true) && textblockAt(before, "end")) {
    let at = before, wrap2 = [];
    for (;; ) {
      wrap2.push(at);
      if (at.isTextblock)
        break;
      at = at.lastChild;
    }
    let afterText = after, afterDepth = 1;
    for (;!afterText.isTextblock; afterText = afterText.firstChild)
      afterDepth++;
    if (at.canReplace(at.childCount, at.childCount, afterText.content)) {
      if (dispatch) {
        let end = Fragment.empty;
        for (let i2 = wrap2.length - 1;i2 >= 0; i2--)
          end = Fragment.from(wrap2[i2].copy(end));
        let tr = state.tr.step(new ReplaceAroundStep($cut.pos - wrap2.length, $cut.pos + after.nodeSize, $cut.pos + afterDepth, $cut.pos + after.nodeSize - afterDepth, new Slice(end, wrap2.length, 0), 0, true));
        dispatch(tr.scrollIntoView());
      }
      return true;
    }
  }
  return false;
}
function selectTextblockSide(side) {
  return function(state, dispatch) {
    let sel = state.selection, $pos = side < 0 ? sel.$from : sel.$to;
    let depth = $pos.depth;
    while ($pos.node(depth).isInline) {
      if (!depth)
        return false;
      depth--;
    }
    if (!$pos.node(depth).isTextblock)
      return false;
    if (dispatch)
      dispatch(state.tr.setSelection(TextSelection.create(state.doc, side < 0 ? $pos.start(depth) : $pos.end(depth))));
    return true;
  };
}
var selectTextblockStart = selectTextblockSide(-1);
var selectTextblockEnd = selectTextblockSide(1);
function wrapIn(nodeType, attrs = null) {
  return function(state, dispatch) {
    let { $from, $to } = state.selection;
    let range = $from.blockRange($to), wrapping = range && findWrapping(range, nodeType, attrs);
    if (!wrapping)
      return false;
    if (dispatch)
      dispatch(state.tr.wrap(range, wrapping).scrollIntoView());
    return true;
  };
}
function setBlockType2(nodeType, attrs = null) {
  return function(state, dispatch) {
    let applicable = false;
    for (let i2 = 0;i2 < state.selection.ranges.length && !applicable; i2++) {
      let { $from: { pos: from }, $to: { pos: to } } = state.selection.ranges[i2];
      state.doc.nodesBetween(from, to, (node, pos) => {
        if (applicable)
          return false;
        if (!node.isTextblock || node.hasMarkup(nodeType, attrs))
          return;
        if (node.type == nodeType) {
          applicable = true;
        } else {
          let $pos = state.doc.resolve(pos), index = $pos.index();
          applicable = $pos.parent.canReplaceWith(index, index + 1, nodeType);
        }
      });
    }
    if (!applicable)
      return false;
    if (dispatch) {
      let tr = state.tr;
      for (let i2 = 0;i2 < state.selection.ranges.length; i2++) {
        let { $from: { pos: from }, $to: { pos: to } } = state.selection.ranges[i2];
        tr.setBlockType(from, to, nodeType, attrs);
      }
      dispatch(tr.scrollIntoView());
    }
    return true;
  };
}
function chainCommands(...commands) {
  return function(state, dispatch, view) {
    for (let i2 = 0;i2 < commands.length; i2++)
      if (commands[i2](state, dispatch, view))
        return true;
    return false;
  };
}
var backspace = chainCommands(deleteSelection, joinBackward, selectNodeBackward);
var del = chainCommands(deleteSelection, joinForward, selectNodeForward);
var pcBaseKeymap = {
  Enter: chainCommands(newlineInCode, createParagraphNear, liftEmptyBlock, splitBlock),
  "Mod-Enter": exitCode,
  Backspace: backspace,
  "Mod-Backspace": backspace,
  "Shift-Backspace": backspace,
  Delete: del,
  "Mod-Delete": del,
  "Mod-a": selectAll
};
var macBaseKeymap = {
  "Ctrl-h": pcBaseKeymap["Backspace"],
  "Alt-Backspace": pcBaseKeymap["Mod-Backspace"],
  "Ctrl-d": pcBaseKeymap["Delete"],
  "Ctrl-Alt-Backspace": pcBaseKeymap["Mod-Delete"],
  "Alt-Delete": pcBaseKeymap["Mod-Delete"],
  "Alt-d": pcBaseKeymap["Mod-Delete"],
  "Ctrl-a": selectTextblockStart,
  "Ctrl-e": selectTextblockEnd
};
for (let key in pcBaseKeymap)
  macBaseKeymap[key] = pcBaseKeymap[key];
var mac4 = typeof navigator != "undefined" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : typeof os != "undefined" && os.platform ? os.platform() == "darwin" : false;
// node_modules/prosemirror-schema-list/dist/index.js
function wrapInList(listType, attrs = null) {
  return function(state, dispatch) {
    let { $from, $to } = state.selection;
    let range = $from.blockRange($to);
    if (!range)
      return false;
    let tr = dispatch ? state.tr : null;
    if (!wrapRangeInList(tr, range, listType, attrs))
      return false;
    if (dispatch)
      dispatch(tr.scrollIntoView());
    return true;
  };
}
function wrapRangeInList(tr, range, listType, attrs = null) {
  let doJoin = false, outerRange = range, doc3 = range.$from.doc;
  if (range.depth >= 2 && range.$from.node(range.depth - 1).type.compatibleContent(listType) && range.startIndex == 0) {
    if (range.$from.index(range.depth - 1) == 0)
      return false;
    let $insert = doc3.resolve(range.start - 2);
    outerRange = new NodeRange($insert, $insert, range.depth);
    if (range.endIndex < range.parent.childCount)
      range = new NodeRange(range.$from, doc3.resolve(range.$to.end(range.depth)), range.depth);
    doJoin = true;
  }
  let wrap2 = findWrapping(outerRange, listType, attrs, range);
  if (!wrap2)
    return false;
  if (tr)
    doWrapInList(tr, range, wrap2, doJoin, listType);
  return true;
}
function doWrapInList(tr, range, wrappers, joinBefore, listType) {
  let content = Fragment.empty;
  for (let i2 = wrappers.length - 1;i2 >= 0; i2--)
    content = Fragment.from(wrappers[i2].type.create(wrappers[i2].attrs, content));
  tr.step(new ReplaceAroundStep(range.start - (joinBefore ? 2 : 0), range.end, range.start, range.end, new Slice(content, 0, 0), wrappers.length, true));
  let found2 = 0;
  for (let i2 = 0;i2 < wrappers.length; i2++)
    if (wrappers[i2].type == listType)
      found2 = i2 + 1;
  let splitDepth = wrappers.length - found2;
  let splitPos = range.start + wrappers.length - (joinBefore ? 2 : 0), parent = range.parent;
  for (let { startIndex: i2, endIndex: e } = range, first = true;i2 < e; i2++, first = false) {
    if (!first && canSplit(tr.doc, splitPos, splitDepth)) {
      tr.split(splitPos, splitDepth);
      splitPos += 2 * splitDepth;
    }
    splitPos += parent.child(i2).nodeSize;
  }
  return tr;
}
function liftListItem(itemType) {
  return function(state, dispatch) {
    let { $from, $to } = state.selection;
    let range = $from.blockRange($to, (node) => node.childCount > 0 && node.firstChild.type == itemType);
    if (!range)
      return false;
    if (!dispatch)
      return true;
    if ($from.node(range.depth - 1).type == itemType)
      return liftToOuterList(state, dispatch, itemType, range);
    else
      return liftOutOfList(state, dispatch, range);
  };
}
function liftToOuterList(state, dispatch, itemType, range) {
  let tr = state.tr, end = range.end, endOfList = range.$to.end(range.depth);
  if (end < endOfList) {
    tr.step(new ReplaceAroundStep(end - 1, endOfList, end, endOfList, new Slice(Fragment.from(itemType.create(null, range.parent.copy())), 1, 0), 1, true));
    range = new NodeRange(tr.doc.resolve(range.$from.pos), tr.doc.resolve(endOfList), range.depth);
  }
  const target = liftTarget(range);
  if (target == null)
    return false;
  tr.lift(range, target);
  let $after = tr.doc.resolve(tr.mapping.map(end, -1) - 1);
  if (canJoin(tr.doc, $after.pos) && $after.nodeBefore.type == $after.nodeAfter.type)
    tr.join($after.pos);
  dispatch(tr.scrollIntoView());
  return true;
}
function liftOutOfList(state, dispatch, range) {
  let tr = state.tr, list = range.parent;
  for (let pos = range.end, i2 = range.endIndex - 1, e = range.startIndex;i2 > e; i2--) {
    pos -= list.child(i2).nodeSize;
    tr.delete(pos - 1, pos + 1);
  }
  let $start = tr.doc.resolve(range.start), item = $start.nodeAfter;
  if (tr.mapping.map(range.end) != range.start + $start.nodeAfter.nodeSize)
    return false;
  let atStart = range.startIndex == 0, atEnd = range.endIndex == list.childCount;
  let parent = $start.node(-1), indexBefore = $start.index(-1);
  if (!parent.canReplace(indexBefore + (atStart ? 0 : 1), indexBefore + 1, item.content.append(atEnd ? Fragment.empty : Fragment.from(list))))
    return false;
  let start = $start.pos, end = start + item.nodeSize;
  tr.step(new ReplaceAroundStep(start - (atStart ? 1 : 0), end + (atEnd ? 1 : 0), start + 1, end - 1, new Slice((atStart ? Fragment.empty : Fragment.from(list.copy(Fragment.empty))).append(atEnd ? Fragment.empty : Fragment.from(list.copy(Fragment.empty))), atStart ? 0 : 1, atEnd ? 0 : 1), atStart ? 0 : 1));
  dispatch(tr.scrollIntoView());
  return true;
}
function sinkListItem(itemType) {
  return function(state, dispatch) {
    let { $from, $to } = state.selection;
    let range = $from.blockRange($to, (node) => node.childCount > 0 && node.firstChild.type == itemType);
    if (!range)
      return false;
    let startIndex = range.startIndex;
    if (startIndex == 0)
      return false;
    let parent = range.parent, nodeBefore = parent.child(startIndex - 1);
    if (nodeBefore.type != itemType)
      return false;
    if (dispatch) {
      let nestedBefore = nodeBefore.lastChild && nodeBefore.lastChild.type == parent.type;
      let inner = Fragment.from(nestedBefore ? itemType.create() : null);
      let slice = new Slice(Fragment.from(itemType.create(null, Fragment.from(parent.type.create(null, inner)))), nestedBefore ? 3 : 1, 0);
      let { start: before, end: after } = range;
      dispatch(state.tr.step(new ReplaceAroundStep(before - (nestedBefore ? 3 : 1), after, before, after, slice, 1, true)).scrollIntoView());
    }
    return true;
  };
}
// node_modules/@tiptap/core/dist/index.js
function createChainableState(config) {
  const { state, transaction } = config;
  let { selection } = transaction;
  let { doc: doc3 } = transaction;
  let { storedMarks } = transaction;
  return {
    ...state,
    apply: state.apply.bind(state),
    applyTransaction: state.applyTransaction.bind(state),
    plugins: state.plugins,
    schema: state.schema,
    reconfigure: state.reconfigure.bind(state),
    toJSON: state.toJSON.bind(state),
    get storedMarks() {
      return storedMarks;
    },
    get selection() {
      return selection;
    },
    get doc() {
      return doc3;
    },
    get tr() {
      selection = transaction.selection;
      doc3 = transaction.doc;
      storedMarks = transaction.storedMarks;
      return transaction;
    }
  };
}

class CommandManager {
  constructor(props) {
    this.editor = props.editor;
    this.rawCommands = this.editor.extensionManager.commands;
    this.customState = props.state;
  }
  get hasCustomState() {
    return !!this.customState;
  }
  get state() {
    return this.customState || this.editor.state;
  }
  get commands() {
    const { rawCommands, editor, state } = this;
    const { view } = editor;
    const { tr } = state;
    const props = this.buildProps(tr);
    return Object.fromEntries(Object.entries(rawCommands).map(([name, command]) => {
      const method = (...args) => {
        const callback = command(...args)(props);
        if (!tr.getMeta("preventDispatch") && !this.hasCustomState) {
          view.dispatch(tr);
        }
        return callback;
      };
      return [name, method];
    }));
  }
  get chain() {
    return () => this.createChain();
  }
  get can() {
    return () => this.createCan();
  }
  createChain(startTr, shouldDispatch = true) {
    const { rawCommands, editor, state } = this;
    const { view } = editor;
    const callbacks = [];
    const hasStartTransaction = !!startTr;
    const tr = startTr || state.tr;
    const run = () => {
      if (!hasStartTransaction && shouldDispatch && !tr.getMeta("preventDispatch") && !this.hasCustomState) {
        view.dispatch(tr);
      }
      return callbacks.every((callback) => callback === true);
    };
    const chain = {
      ...Object.fromEntries(Object.entries(rawCommands).map(([name, command]) => {
        const chainedCommand = (...args) => {
          const props = this.buildProps(tr, shouldDispatch);
          const callback = command(...args)(props);
          callbacks.push(callback);
          return chain;
        };
        return [name, chainedCommand];
      })),
      run
    };
    return chain;
  }
  createCan(startTr) {
    const { rawCommands, state } = this;
    const dispatch = false;
    const tr = startTr || state.tr;
    const props = this.buildProps(tr, dispatch);
    const formattedCommands = Object.fromEntries(Object.entries(rawCommands).map(([name, command]) => {
      return [name, (...args) => command(...args)({ ...props, dispatch: undefined })];
    }));
    return {
      ...formattedCommands,
      chain: () => this.createChain(tr, dispatch)
    };
  }
  buildProps(tr, shouldDispatch = true) {
    const { rawCommands, editor, state } = this;
    const { view } = editor;
    const props = {
      tr,
      editor,
      view,
      state: createChainableState({
        state,
        transaction: tr
      }),
      dispatch: shouldDispatch ? () => {
        return;
      } : undefined,
      chain: () => this.createChain(tr, shouldDispatch),
      can: () => this.createCan(tr),
      get commands() {
        return Object.fromEntries(Object.entries(rawCommands).map(([name, command]) => {
          return [name, (...args) => command(...args)(props)];
        }));
      }
    };
    return props;
  }
}

class EventEmitter {
  constructor() {
    this.callbacks = {};
  }
  on(event, fn) {
    if (!this.callbacks[event]) {
      this.callbacks[event] = [];
    }
    this.callbacks[event].push(fn);
    return this;
  }
  emit(event, ...args) {
    const callbacks = this.callbacks[event];
    if (callbacks) {
      callbacks.forEach((callback) => callback.apply(this, args));
    }
    return this;
  }
  off(event, fn) {
    const callbacks = this.callbacks[event];
    if (callbacks) {
      if (fn) {
        this.callbacks[event] = callbacks.filter((callback) => callback !== fn);
      } else {
        delete this.callbacks[event];
      }
    }
    return this;
  }
  once(event, fn) {
    const onceFn = (...args) => {
      this.off(event, onceFn);
      fn.apply(this, args);
    };
    return this.on(event, onceFn);
  }
  removeAllListeners() {
    this.callbacks = {};
  }
}
function getExtensionField(extension, field, context) {
  if (extension.config[field] === undefined && extension.parent) {
    return getExtensionField(extension.parent, field, context);
  }
  if (typeof extension.config[field] === "function") {
    const value = extension.config[field].bind({
      ...context,
      parent: extension.parent ? getExtensionField(extension.parent, field, context) : null
    });
    return value;
  }
  return extension.config[field];
}
function splitExtensions(extensions) {
  const baseExtensions = extensions.filter((extension) => extension.type === "extension");
  const nodeExtensions = extensions.filter((extension) => extension.type === "node");
  const markExtensions = extensions.filter((extension) => extension.type === "mark");
  return {
    baseExtensions,
    nodeExtensions,
    markExtensions
  };
}
function getAttributesFromExtensions(extensions) {
  const extensionAttributes = [];
  const { nodeExtensions, markExtensions } = splitExtensions(extensions);
  const nodeAndMarkExtensions = [...nodeExtensions, ...markExtensions];
  const defaultAttribute = {
    default: null,
    rendered: true,
    renderHTML: null,
    parseHTML: null,
    keepOnSplit: true,
    isRequired: false
  };
  extensions.forEach((extension) => {
    const context = {
      name: extension.name,
      options: extension.options,
      storage: extension.storage,
      extensions: nodeAndMarkExtensions
    };
    const addGlobalAttributes = getExtensionField(extension, "addGlobalAttributes", context);
    if (!addGlobalAttributes) {
      return;
    }
    const globalAttributes = addGlobalAttributes();
    globalAttributes.forEach((globalAttribute) => {
      globalAttribute.types.forEach((type) => {
        Object.entries(globalAttribute.attributes).forEach(([name, attribute]) => {
          extensionAttributes.push({
            type,
            name,
            attribute: {
              ...defaultAttribute,
              ...attribute
            }
          });
        });
      });
    });
  });
  nodeAndMarkExtensions.forEach((extension) => {
    const context = {
      name: extension.name,
      options: extension.options,
      storage: extension.storage
    };
    const addAttributes = getExtensionField(extension, "addAttributes", context);
    if (!addAttributes) {
      return;
    }
    const attributes = addAttributes();
    Object.entries(attributes).forEach(([name, attribute]) => {
      const mergedAttr = {
        ...defaultAttribute,
        ...attribute
      };
      if (typeof (mergedAttr === null || mergedAttr === undefined ? undefined : mergedAttr.default) === "function") {
        mergedAttr.default = mergedAttr.default();
      }
      if ((mergedAttr === null || mergedAttr === undefined ? undefined : mergedAttr.isRequired) && (mergedAttr === null || mergedAttr === undefined ? undefined : mergedAttr.default) === undefined) {
        delete mergedAttr.default;
      }
      extensionAttributes.push({
        type: extension.name,
        name,
        attribute: mergedAttr
      });
    });
  });
  return extensionAttributes;
}
function getNodeType(nameOrType, schema) {
  if (typeof nameOrType === "string") {
    if (!schema.nodes[nameOrType]) {
      throw Error(`There is no node type named '${nameOrType}'. Maybe you forgot to add the extension?`);
    }
    return schema.nodes[nameOrType];
  }
  return nameOrType;
}
function mergeAttributes(...objects) {
  return objects.filter((item) => !!item).reduce((items, item) => {
    const mergedAttributes = { ...items };
    Object.entries(item).forEach(([key, value]) => {
      const exists = mergedAttributes[key];
      if (!exists) {
        mergedAttributes[key] = value;
        return;
      }
      if (key === "class") {
        const valueClasses = value ? String(value).split(" ") : [];
        const existingClasses = mergedAttributes[key] ? mergedAttributes[key].split(" ") : [];
        const insertClasses = valueClasses.filter((valueClass) => !existingClasses.includes(valueClass));
        mergedAttributes[key] = [...existingClasses, ...insertClasses].join(" ");
      } else if (key === "style") {
        const newStyles = value ? value.split(";").map((style) => style.trim()).filter(Boolean) : [];
        const existingStyles = mergedAttributes[key] ? mergedAttributes[key].split(";").map((style) => style.trim()).filter(Boolean) : [];
        const styleMap = new Map;
        existingStyles.forEach((style) => {
          const [property, val] = style.split(":").map((part) => part.trim());
          styleMap.set(property, val);
        });
        newStyles.forEach((style) => {
          const [property, val] = style.split(":").map((part) => part.trim());
          styleMap.set(property, val);
        });
        mergedAttributes[key] = Array.from(styleMap.entries()).map(([property, val]) => `${property}: ${val}`).join("; ");
      } else {
        mergedAttributes[key] = value;
      }
    });
    return mergedAttributes;
  }, {});
}
function getRenderedAttributes(nodeOrMark, extensionAttributes) {
  return extensionAttributes.filter((attribute) => attribute.type === nodeOrMark.type.name).filter((item) => item.attribute.rendered).map((item) => {
    if (!item.attribute.renderHTML) {
      return {
        [item.name]: nodeOrMark.attrs[item.name]
      };
    }
    return item.attribute.renderHTML(nodeOrMark.attrs) || {};
  }).reduce((attributes, attribute) => mergeAttributes(attributes, attribute), {});
}
function isFunction(value) {
  return typeof value === "function";
}
function callOrReturn(value, context = undefined, ...props) {
  if (isFunction(value)) {
    if (context) {
      return value.bind(context)(...props);
    }
    return value(...props);
  }
  return value;
}
function isEmptyObject(value = {}) {
  return Object.keys(value).length === 0 && value.constructor === Object;
}
function fromString(value) {
  if (typeof value !== "string") {
    return value;
  }
  if (value.match(/^[+-]?(?:\d*\.)?\d+$/)) {
    return Number(value);
  }
  if (value === "true") {
    return true;
  }
  if (value === "false") {
    return false;
  }
  return value;
}
function injectExtensionAttributesToParseRule(parseRule, extensionAttributes) {
  if ("style" in parseRule) {
    return parseRule;
  }
  return {
    ...parseRule,
    getAttrs: (node) => {
      const oldAttributes = parseRule.getAttrs ? parseRule.getAttrs(node) : parseRule.attrs;
      if (oldAttributes === false) {
        return false;
      }
      const newAttributes = extensionAttributes.reduce((items, item) => {
        const value = item.attribute.parseHTML ? item.attribute.parseHTML(node) : fromString(node.getAttribute(item.name));
        if (value === null || value === undefined) {
          return items;
        }
        return {
          ...items,
          [item.name]: value
        };
      }, {});
      return { ...oldAttributes, ...newAttributes };
    }
  };
}
function cleanUpSchemaItem(data) {
  return Object.fromEntries(Object.entries(data).filter(([key, value]) => {
    if (key === "attrs" && isEmptyObject(value)) {
      return false;
    }
    return value !== null && value !== undefined;
  }));
}
function getSchemaByResolvedExtensions(extensions, editor) {
  var _a;
  const allAttributes = getAttributesFromExtensions(extensions);
  const { nodeExtensions, markExtensions } = splitExtensions(extensions);
  const topNode = (_a = nodeExtensions.find((extension) => getExtensionField(extension, "topNode"))) === null || _a === undefined ? undefined : _a.name;
  const nodes = Object.fromEntries(nodeExtensions.map((extension) => {
    const extensionAttributes = allAttributes.filter((attribute) => attribute.type === extension.name);
    const context = {
      name: extension.name,
      options: extension.options,
      storage: extension.storage,
      editor
    };
    const extraNodeFields = extensions.reduce((fields, e) => {
      const extendNodeSchema = getExtensionField(e, "extendNodeSchema", context);
      return {
        ...fields,
        ...extendNodeSchema ? extendNodeSchema(extension) : {}
      };
    }, {});
    const schema = cleanUpSchemaItem({
      ...extraNodeFields,
      content: callOrReturn(getExtensionField(extension, "content", context)),
      marks: callOrReturn(getExtensionField(extension, "marks", context)),
      group: callOrReturn(getExtensionField(extension, "group", context)),
      inline: callOrReturn(getExtensionField(extension, "inline", context)),
      atom: callOrReturn(getExtensionField(extension, "atom", context)),
      selectable: callOrReturn(getExtensionField(extension, "selectable", context)),
      draggable: callOrReturn(getExtensionField(extension, "draggable", context)),
      code: callOrReturn(getExtensionField(extension, "code", context)),
      whitespace: callOrReturn(getExtensionField(extension, "whitespace", context)),
      linebreakReplacement: callOrReturn(getExtensionField(extension, "linebreakReplacement", context)),
      defining: callOrReturn(getExtensionField(extension, "defining", context)),
      isolating: callOrReturn(getExtensionField(extension, "isolating", context)),
      attrs: Object.fromEntries(extensionAttributes.map((extensionAttribute) => {
        var _a2;
        return [extensionAttribute.name, { default: (_a2 = extensionAttribute === null || extensionAttribute === undefined ? undefined : extensionAttribute.attribute) === null || _a2 === undefined ? undefined : _a2.default }];
      }))
    });
    const parseHTML = callOrReturn(getExtensionField(extension, "parseHTML", context));
    if (parseHTML) {
      schema.parseDOM = parseHTML.map((parseRule) => injectExtensionAttributesToParseRule(parseRule, extensionAttributes));
    }
    const renderHTML = getExtensionField(extension, "renderHTML", context);
    if (renderHTML) {
      schema.toDOM = (node) => renderHTML({
        node,
        HTMLAttributes: getRenderedAttributes(node, extensionAttributes)
      });
    }
    const renderText = getExtensionField(extension, "renderText", context);
    if (renderText) {
      schema.toText = renderText;
    }
    return [extension.name, schema];
  }));
  const marks = Object.fromEntries(markExtensions.map((extension) => {
    const extensionAttributes = allAttributes.filter((attribute) => attribute.type === extension.name);
    const context = {
      name: extension.name,
      options: extension.options,
      storage: extension.storage,
      editor
    };
    const extraMarkFields = extensions.reduce((fields, e) => {
      const extendMarkSchema = getExtensionField(e, "extendMarkSchema", context);
      return {
        ...fields,
        ...extendMarkSchema ? extendMarkSchema(extension) : {}
      };
    }, {});
    const schema = cleanUpSchemaItem({
      ...extraMarkFields,
      inclusive: callOrReturn(getExtensionField(extension, "inclusive", context)),
      excludes: callOrReturn(getExtensionField(extension, "excludes", context)),
      group: callOrReturn(getExtensionField(extension, "group", context)),
      spanning: callOrReturn(getExtensionField(extension, "spanning", context)),
      code: callOrReturn(getExtensionField(extension, "code", context)),
      attrs: Object.fromEntries(extensionAttributes.map((extensionAttribute) => {
        var _a2;
        return [extensionAttribute.name, { default: (_a2 = extensionAttribute === null || extensionAttribute === undefined ? undefined : extensionAttribute.attribute) === null || _a2 === undefined ? undefined : _a2.default }];
      }))
    });
    const parseHTML = callOrReturn(getExtensionField(extension, "parseHTML", context));
    if (parseHTML) {
      schema.parseDOM = parseHTML.map((parseRule) => injectExtensionAttributesToParseRule(parseRule, extensionAttributes));
    }
    const renderHTML = getExtensionField(extension, "renderHTML", context);
    if (renderHTML) {
      schema.toDOM = (mark) => renderHTML({
        mark,
        HTMLAttributes: getRenderedAttributes(mark, extensionAttributes)
      });
    }
    return [extension.name, schema];
  }));
  return new Schema({
    topNode,
    nodes,
    marks
  });
}
function getSchemaTypeByName(name, schema) {
  return schema.nodes[name] || schema.marks[name] || null;
}
function isExtensionRulesEnabled(extension, enabled) {
  if (Array.isArray(enabled)) {
    return enabled.some((enabledExtension) => {
      const name = typeof enabledExtension === "string" ? enabledExtension : enabledExtension.name;
      return name === extension.name;
    });
  }
  return enabled;
}
function getHTMLFromFragment(fragment, schema) {
  const documentFragment = DOMSerializer.fromSchema(schema).serializeFragment(fragment);
  const temporaryDocument = document.implementation.createHTMLDocument();
  const container = temporaryDocument.createElement("div");
  container.appendChild(documentFragment);
  return container.innerHTML;
}
var getTextContentFromNodes = ($from, maxMatch = 500) => {
  let textBefore = "";
  const sliceEndPos = $from.parentOffset;
  $from.parent.nodesBetween(Math.max(0, sliceEndPos - maxMatch), sliceEndPos, (node, pos, parent, index) => {
    var _a, _b;
    const chunk = ((_b = (_a = node.type.spec).toText) === null || _b === undefined ? undefined : _b.call(_a, {
      node,
      pos,
      parent,
      index
    })) || node.textContent || "%leaf%";
    textBefore += node.isAtom && !node.isText ? chunk : chunk.slice(0, Math.max(0, sliceEndPos - pos));
  });
  return textBefore;
};
function isRegExp(value) {
  return Object.prototype.toString.call(value) === "[object RegExp]";
}

class InputRule {
  constructor(config) {
    this.find = config.find;
    this.handler = config.handler;
  }
}
var inputRuleMatcherHandler = (text, find) => {
  if (isRegExp(find)) {
    return find.exec(text);
  }
  const inputRuleMatch = find(text);
  if (!inputRuleMatch) {
    return null;
  }
  const result = [inputRuleMatch.text];
  result.index = inputRuleMatch.index;
  result.input = text;
  result.data = inputRuleMatch.data;
  if (inputRuleMatch.replaceWith) {
    if (!inputRuleMatch.text.includes(inputRuleMatch.replaceWith)) {
      console.warn('[tiptap warn]: "inputRuleMatch.replaceWith" must be part of "inputRuleMatch.text".');
    }
    result.push(inputRuleMatch.replaceWith);
  }
  return result;
};
function run$1(config) {
  var _a;
  const { editor, from, to, text, rules, plugin } = config;
  const { view } = editor;
  if (view.composing) {
    return false;
  }
  const $from = view.state.doc.resolve(from);
  if ($from.parent.type.spec.code || !!((_a = $from.nodeBefore || $from.nodeAfter) === null || _a === undefined ? undefined : _a.marks.find((mark) => mark.type.spec.code))) {
    return false;
  }
  let matched = false;
  const textBefore = getTextContentFromNodes($from) + text;
  rules.forEach((rule) => {
    if (matched) {
      return;
    }
    const match = inputRuleMatcherHandler(textBefore, rule.find);
    if (!match) {
      return;
    }
    const tr = view.state.tr;
    const state = createChainableState({
      state: view.state,
      transaction: tr
    });
    const range = {
      from: from - (match[0].length - text.length),
      to
    };
    const { commands, chain, can } = new CommandManager({
      editor,
      state
    });
    const handler = rule.handler({
      state,
      range,
      match,
      commands,
      chain,
      can
    });
    if (handler === null || !tr.steps.length) {
      return;
    }
    tr.setMeta(plugin, {
      transform: tr,
      from,
      to,
      text
    });
    view.dispatch(tr);
    matched = true;
  });
  return matched;
}
function inputRulesPlugin(props) {
  const { editor, rules } = props;
  const plugin = new Plugin({
    state: {
      init() {
        return null;
      },
      apply(tr, prev, state) {
        const stored = tr.getMeta(plugin);
        if (stored) {
          return stored;
        }
        const simulatedInputMeta = tr.getMeta("applyInputRules");
        const isSimulatedInput = !!simulatedInputMeta;
        if (isSimulatedInput) {
          setTimeout(() => {
            let { text } = simulatedInputMeta;
            if (typeof text === "string") {
              text = text;
            } else {
              text = getHTMLFromFragment(Fragment.from(text), state.schema);
            }
            const { from } = simulatedInputMeta;
            const to = from + text.length;
            run$1({
              editor,
              from,
              to,
              text,
              rules,
              plugin
            });
          });
        }
        return tr.selectionSet || tr.docChanged ? null : prev;
      }
    },
    props: {
      handleTextInput(view, from, to, text) {
        return run$1({
          editor,
          from,
          to,
          text,
          rules,
          plugin
        });
      },
      handleDOMEvents: {
        compositionend: (view) => {
          setTimeout(() => {
            const { $cursor } = view.state.selection;
            if ($cursor) {
              run$1({
                editor,
                from: $cursor.pos,
                to: $cursor.pos,
                text: "",
                rules,
                plugin
              });
            }
          });
          return false;
        }
      },
      handleKeyDown(view, event) {
        if (event.key !== "Enter") {
          return false;
        }
        const { $cursor } = view.state.selection;
        if ($cursor) {
          return run$1({
            editor,
            from: $cursor.pos,
            to: $cursor.pos,
            text: `
`,
            rules,
            plugin
          });
        }
        return false;
      }
    },
    isInputRules: true
  });
  return plugin;
}
function getType(value) {
  return Object.prototype.toString.call(value).slice(8, -1);
}
function isPlainObject(value) {
  if (getType(value) !== "Object") {
    return false;
  }
  return value.constructor === Object && Object.getPrototypeOf(value) === Object.prototype;
}
function mergeDeep(target, source) {
  const output = { ...target };
  if (isPlainObject(target) && isPlainObject(source)) {
    Object.keys(source).forEach((key) => {
      if (isPlainObject(source[key]) && isPlainObject(target[key])) {
        output[key] = mergeDeep(target[key], source[key]);
      } else {
        output[key] = source[key];
      }
    });
  }
  return output;
}

class Mark2 {
  constructor(config = {}) {
    this.type = "mark";
    this.name = "mark";
    this.parent = null;
    this.child = null;
    this.config = {
      name: this.name,
      defaultOptions: {}
    };
    this.config = {
      ...this.config,
      ...config
    };
    this.name = this.config.name;
    if (config.defaultOptions && Object.keys(config.defaultOptions).length > 0) {
      console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`);
    }
    this.options = this.config.defaultOptions;
    if (this.config.addOptions) {
      this.options = callOrReturn(getExtensionField(this, "addOptions", {
        name: this.name
      }));
    }
    this.storage = callOrReturn(getExtensionField(this, "addStorage", {
      name: this.name,
      options: this.options
    })) || {};
  }
  static create(config = {}) {
    return new Mark2(config);
  }
  configure(options = {}) {
    const extension = this.extend({
      ...this.config,
      addOptions: () => {
        return mergeDeep(this.options, options);
      }
    });
    extension.name = this.name;
    extension.parent = this.parent;
    return extension;
  }
  extend(extendedConfig = {}) {
    const extension = new Mark2(extendedConfig);
    extension.parent = this;
    this.child = extension;
    extension.name = extendedConfig.name ? extendedConfig.name : extension.parent.name;
    if (extendedConfig.defaultOptions && Object.keys(extendedConfig.defaultOptions).length > 0) {
      console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${extension.name}".`);
    }
    extension.options = callOrReturn(getExtensionField(extension, "addOptions", {
      name: extension.name
    }));
    extension.storage = callOrReturn(getExtensionField(extension, "addStorage", {
      name: extension.name,
      options: extension.options
    }));
    return extension;
  }
  static handleExit({ editor, mark }) {
    const { tr } = editor.state;
    const currentPos = editor.state.selection.$from;
    const isAtEnd = currentPos.pos === currentPos.end();
    if (isAtEnd) {
      const currentMarks = currentPos.marks();
      const isInMark = !!currentMarks.find((m) => (m === null || m === undefined ? undefined : m.type.name) === mark.name);
      if (!isInMark) {
        return false;
      }
      const removeMark2 = currentMarks.find((m) => (m === null || m === undefined ? undefined : m.type.name) === mark.name);
      if (removeMark2) {
        tr.removeStoredMark(removeMark2);
      }
      tr.insertText(" ", currentPos.pos);
      editor.view.dispatch(tr);
      return true;
    }
    return false;
  }
}
function isNumber(value) {
  return typeof value === "number";
}

class PasteRule {
  constructor(config) {
    this.find = config.find;
    this.handler = config.handler;
  }
}
var pasteRuleMatcherHandler = (text, find, event) => {
  if (isRegExp(find)) {
    return [...text.matchAll(find)];
  }
  const matches2 = find(text, event);
  if (!matches2) {
    return [];
  }
  return matches2.map((pasteRuleMatch) => {
    const result = [pasteRuleMatch.text];
    result.index = pasteRuleMatch.index;
    result.input = text;
    result.data = pasteRuleMatch.data;
    if (pasteRuleMatch.replaceWith) {
      if (!pasteRuleMatch.text.includes(pasteRuleMatch.replaceWith)) {
        console.warn('[tiptap warn]: "pasteRuleMatch.replaceWith" must be part of "pasteRuleMatch.text".');
      }
      result.push(pasteRuleMatch.replaceWith);
    }
    return result;
  });
};
function run(config) {
  const { editor, state, from, to, rule, pasteEvent, dropEvent } = config;
  const { commands, chain, can } = new CommandManager({
    editor,
    state
  });
  const handlers2 = [];
  state.doc.nodesBetween(from, to, (node, pos) => {
    if (!node.isTextblock || node.type.spec.code) {
      return;
    }
    const resolvedFrom = Math.max(from, pos);
    const resolvedTo = Math.min(to, pos + node.content.size);
    const textToMatch = node.textBetween(resolvedFrom - pos, resolvedTo - pos, undefined, "");
    const matches2 = pasteRuleMatcherHandler(textToMatch, rule.find, pasteEvent);
    matches2.forEach((match) => {
      if (match.index === undefined) {
        return;
      }
      const start = resolvedFrom + match.index + 1;
      const end = start + match[0].length;
      const range = {
        from: state.tr.mapping.map(start),
        to: state.tr.mapping.map(end)
      };
      const handler = rule.handler({
        state,
        range,
        match,
        commands,
        chain,
        can,
        pasteEvent,
        dropEvent
      });
      handlers2.push(handler);
    });
  });
  const success = handlers2.every((handler) => handler !== null);
  return success;
}
var tiptapDragFromOtherEditor = null;
var createClipboardPasteEvent = (text) => {
  var _a;
  const event = new ClipboardEvent("paste", {
    clipboardData: new DataTransfer
  });
  (_a = event.clipboardData) === null || _a === undefined || _a.setData("text/html", text);
  return event;
};
function pasteRulesPlugin(props) {
  const { editor, rules } = props;
  let dragSourceElement = null;
  let isPastedFromProseMirror = false;
  let isDroppedFromProseMirror = false;
  let pasteEvent = typeof ClipboardEvent !== "undefined" ? new ClipboardEvent("paste") : null;
  let dropEvent;
  try {
    dropEvent = typeof DragEvent !== "undefined" ? new DragEvent("drop") : null;
  } catch {
    dropEvent = null;
  }
  const processEvent = ({ state, from, to, rule, pasteEvt }) => {
    const tr = state.tr;
    const chainableState = createChainableState({
      state,
      transaction: tr
    });
    const handler = run({
      editor,
      state: chainableState,
      from: Math.max(from - 1, 0),
      to: to.b - 1,
      rule,
      pasteEvent: pasteEvt,
      dropEvent
    });
    if (!handler || !tr.steps.length) {
      return;
    }
    try {
      dropEvent = typeof DragEvent !== "undefined" ? new DragEvent("drop") : null;
    } catch {
      dropEvent = null;
    }
    pasteEvent = typeof ClipboardEvent !== "undefined" ? new ClipboardEvent("paste") : null;
    return tr;
  };
  const plugins = rules.map((rule) => {
    return new Plugin({
      view(view) {
        const handleDragstart = (event) => {
          var _a;
          dragSourceElement = ((_a = view.dom.parentElement) === null || _a === undefined ? undefined : _a.contains(event.target)) ? view.dom.parentElement : null;
          if (dragSourceElement) {
            tiptapDragFromOtherEditor = editor;
          }
        };
        const handleDragend = () => {
          if (tiptapDragFromOtherEditor) {
            tiptapDragFromOtherEditor = null;
          }
        };
        window.addEventListener("dragstart", handleDragstart);
        window.addEventListener("dragend", handleDragend);
        return {
          destroy() {
            window.removeEventListener("dragstart", handleDragstart);
            window.removeEventListener("dragend", handleDragend);
          }
        };
      },
      props: {
        handleDOMEvents: {
          drop: (view, event) => {
            isDroppedFromProseMirror = dragSourceElement === view.dom.parentElement;
            dropEvent = event;
            if (!isDroppedFromProseMirror) {
              const dragFromOtherEditor = tiptapDragFromOtherEditor;
              if (dragFromOtherEditor === null || dragFromOtherEditor === undefined ? undefined : dragFromOtherEditor.isEditable) {
                setTimeout(() => {
                  const selection = dragFromOtherEditor.state.selection;
                  if (selection) {
                    dragFromOtherEditor.commands.deleteRange({ from: selection.from, to: selection.to });
                  }
                }, 10);
              }
            }
            return false;
          },
          paste: (_view, event) => {
            var _a;
            const html = (_a = event.clipboardData) === null || _a === undefined ? undefined : _a.getData("text/html");
            pasteEvent = event;
            isPastedFromProseMirror = !!(html === null || html === undefined ? undefined : html.includes("data-pm-slice"));
            return false;
          }
        }
      },
      appendTransaction: (transactions, oldState, state) => {
        const transaction = transactions[0];
        const isPaste = transaction.getMeta("uiEvent") === "paste" && !isPastedFromProseMirror;
        const isDrop = transaction.getMeta("uiEvent") === "drop" && !isDroppedFromProseMirror;
        const simulatedPasteMeta = transaction.getMeta("applyPasteRules");
        const isSimulatedPaste = !!simulatedPasteMeta;
        if (!isPaste && !isDrop && !isSimulatedPaste) {
          return;
        }
        if (isSimulatedPaste) {
          let { text } = simulatedPasteMeta;
          if (typeof text === "string") {
            text = text;
          } else {
            text = getHTMLFromFragment(Fragment.from(text), state.schema);
          }
          const { from: from2 } = simulatedPasteMeta;
          const to2 = from2 + text.length;
          const pasteEvt = createClipboardPasteEvent(text);
          return processEvent({
            rule,
            state,
            from: from2,
            to: { b: to2 },
            pasteEvt
          });
        }
        const from = oldState.doc.content.findDiffStart(state.doc.content);
        const to = oldState.doc.content.findDiffEnd(state.doc.content);
        if (!isNumber(from) || !to || from === to.b) {
          return;
        }
        return processEvent({
          rule,
          state,
          from,
          to,
          pasteEvt: pasteEvent
        });
      }
    });
  });
  return plugins;
}
function findDuplicates(items) {
  const filtered = items.filter((el, index) => items.indexOf(el) !== index);
  return Array.from(new Set(filtered));
}

class ExtensionManager {
  constructor(extensions, editor) {
    this.splittableMarks = [];
    this.editor = editor;
    this.extensions = ExtensionManager.resolve(extensions);
    this.schema = getSchemaByResolvedExtensions(this.extensions, editor);
    this.setupExtensions();
  }
  static resolve(extensions) {
    const resolvedExtensions = ExtensionManager.sort(ExtensionManager.flatten(extensions));
    const duplicatedNames = findDuplicates(resolvedExtensions.map((extension) => extension.name));
    if (duplicatedNames.length) {
      console.warn(`[tiptap warn]: Duplicate extension names found: [${duplicatedNames.map((item) => `'${item}'`).join(", ")}]. This can lead to issues.`);
    }
    return resolvedExtensions;
  }
  static flatten(extensions) {
    return extensions.map((extension) => {
      const context = {
        name: extension.name,
        options: extension.options,
        storage: extension.storage
      };
      const addExtensions = getExtensionField(extension, "addExtensions", context);
      if (addExtensions) {
        return [extension, ...this.flatten(addExtensions())];
      }
      return extension;
    }).flat(10);
  }
  static sort(extensions) {
    const defaultPriority = 100;
    return extensions.sort((a, b) => {
      const priorityA = getExtensionField(a, "priority") || defaultPriority;
      const priorityB = getExtensionField(b, "priority") || defaultPriority;
      if (priorityA > priorityB) {
        return -1;
      }
      if (priorityA < priorityB) {
        return 1;
      }
      return 0;
    });
  }
  get commands() {
    return this.extensions.reduce((commands, extension) => {
      const context = {
        name: extension.name,
        options: extension.options,
        storage: extension.storage,
        editor: this.editor,
        type: getSchemaTypeByName(extension.name, this.schema)
      };
      const addCommands = getExtensionField(extension, "addCommands", context);
      if (!addCommands) {
        return commands;
      }
      return {
        ...commands,
        ...addCommands()
      };
    }, {});
  }
  get plugins() {
    const { editor } = this;
    const extensions = ExtensionManager.sort([...this.extensions].reverse());
    const inputRules = [];
    const pasteRules = [];
    const allPlugins = extensions.map((extension) => {
      const context = {
        name: extension.name,
        options: extension.options,
        storage: extension.storage,
        editor,
        type: getSchemaTypeByName(extension.name, this.schema)
      };
      const plugins = [];
      const addKeyboardShortcuts = getExtensionField(extension, "addKeyboardShortcuts", context);
      let defaultBindings = {};
      if (extension.type === "mark" && getExtensionField(extension, "exitable", context)) {
        defaultBindings.ArrowRight = () => Mark2.handleExit({ editor, mark: extension });
      }
      if (addKeyboardShortcuts) {
        const bindings = Object.fromEntries(Object.entries(addKeyboardShortcuts()).map(([shortcut, method]) => {
          return [shortcut, () => method({ editor })];
        }));
        defaultBindings = { ...defaultBindings, ...bindings };
      }
      const keyMapPlugin = keymap(defaultBindings);
      plugins.push(keyMapPlugin);
      const addInputRules = getExtensionField(extension, "addInputRules", context);
      if (isExtensionRulesEnabled(extension, editor.options.enableInputRules) && addInputRules) {
        inputRules.push(...addInputRules());
      }
      const addPasteRules = getExtensionField(extension, "addPasteRules", context);
      if (isExtensionRulesEnabled(extension, editor.options.enablePasteRules) && addPasteRules) {
        pasteRules.push(...addPasteRules());
      }
      const addProseMirrorPlugins = getExtensionField(extension, "addProseMirrorPlugins", context);
      if (addProseMirrorPlugins) {
        const proseMirrorPlugins = addProseMirrorPlugins();
        plugins.push(...proseMirrorPlugins);
      }
      return plugins;
    }).flat();
    return [
      inputRulesPlugin({
        editor,
        rules: inputRules
      }),
      ...pasteRulesPlugin({
        editor,
        rules: pasteRules
      }),
      ...allPlugins
    ];
  }
  get attributes() {
    return getAttributesFromExtensions(this.extensions);
  }
  get nodeViews() {
    const { editor } = this;
    const { nodeExtensions } = splitExtensions(this.extensions);
    return Object.fromEntries(nodeExtensions.filter((extension) => !!getExtensionField(extension, "addNodeView")).map((extension) => {
      const extensionAttributes = this.attributes.filter((attribute) => attribute.type === extension.name);
      const context = {
        name: extension.name,
        options: extension.options,
        storage: extension.storage,
        editor,
        type: getNodeType(extension.name, this.schema)
      };
      const addNodeView = getExtensionField(extension, "addNodeView", context);
      if (!addNodeView) {
        return [];
      }
      const nodeview = (node, view, getPos, decorations, innerDecorations) => {
        const HTMLAttributes = getRenderedAttributes(node, extensionAttributes);
        return addNodeView()({
          node,
          view,
          getPos,
          decorations,
          innerDecorations,
          editor,
          extension,
          HTMLAttributes
        });
      };
      return [extension.name, nodeview];
    }));
  }
  setupExtensions() {
    this.extensions.forEach((extension) => {
      var _a;
      this.editor.extensionStorage[extension.name] = extension.storage;
      const context = {
        name: extension.name,
        options: extension.options,
        storage: extension.storage,
        editor: this.editor,
        type: getSchemaTypeByName(extension.name, this.schema)
      };
      if (extension.type === "mark") {
        const keepOnSplit = (_a = callOrReturn(getExtensionField(extension, "keepOnSplit", context))) !== null && _a !== undefined ? _a : true;
        if (keepOnSplit) {
          this.splittableMarks.push(extension.name);
        }
      }
      const onBeforeCreate = getExtensionField(extension, "onBeforeCreate", context);
      const onCreate = getExtensionField(extension, "onCreate", context);
      const onUpdate = getExtensionField(extension, "onUpdate", context);
      const onSelectionUpdate = getExtensionField(extension, "onSelectionUpdate", context);
      const onTransaction = getExtensionField(extension, "onTransaction", context);
      const onFocus = getExtensionField(extension, "onFocus", context);
      const onBlur = getExtensionField(extension, "onBlur", context);
      const onDestroy = getExtensionField(extension, "onDestroy", context);
      if (onBeforeCreate) {
        this.editor.on("beforeCreate", onBeforeCreate);
      }
      if (onCreate) {
        this.editor.on("create", onCreate);
      }
      if (onUpdate) {
        this.editor.on("update", onUpdate);
      }
      if (onSelectionUpdate) {
        this.editor.on("selectionUpdate", onSelectionUpdate);
      }
      if (onTransaction) {
        this.editor.on("transaction", onTransaction);
      }
      if (onFocus) {
        this.editor.on("focus", onFocus);
      }
      if (onBlur) {
        this.editor.on("blur", onBlur);
      }
      if (onDestroy) {
        this.editor.on("destroy", onDestroy);
      }
    });
  }
}

class Extension {
  constructor(config = {}) {
    this.type = "extension";
    this.name = "extension";
    this.parent = null;
    this.child = null;
    this.config = {
      name: this.name,
      defaultOptions: {}
    };
    this.config = {
      ...this.config,
      ...config
    };
    this.name = this.config.name;
    if (config.defaultOptions && Object.keys(config.defaultOptions).length > 0) {
      console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`);
    }
    this.options = this.config.defaultOptions;
    if (this.config.addOptions) {
      this.options = callOrReturn(getExtensionField(this, "addOptions", {
        name: this.name
      }));
    }
    this.storage = callOrReturn(getExtensionField(this, "addStorage", {
      name: this.name,
      options: this.options
    })) || {};
  }
  static create(config = {}) {
    return new Extension(config);
  }
  configure(options = {}) {
    const extension = this.extend({
      ...this.config,
      addOptions: () => {
        return mergeDeep(this.options, options);
      }
    });
    extension.name = this.name;
    extension.parent = this.parent;
    return extension;
  }
  extend(extendedConfig = {}) {
    const extension = new Extension({ ...this.config, ...extendedConfig });
    extension.parent = this;
    this.child = extension;
    extension.name = extendedConfig.name ? extendedConfig.name : extension.parent.name;
    if (extendedConfig.defaultOptions && Object.keys(extendedConfig.defaultOptions).length > 0) {
      console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${extension.name}".`);
    }
    extension.options = callOrReturn(getExtensionField(extension, "addOptions", {
      name: extension.name
    }));
    extension.storage = callOrReturn(getExtensionField(extension, "addStorage", {
      name: extension.name,
      options: extension.options
    }));
    return extension;
  }
}
function getTextBetween(startNode, range, options) {
  const { from, to } = range;
  const { blockSeparator = `

`, textSerializers = {} } = options || {};
  let text = "";
  startNode.nodesBetween(from, to, (node, pos, parent, index) => {
    var _a;
    if (node.isBlock && pos > from) {
      text += blockSeparator;
    }
    const textSerializer = textSerializers === null || textSerializers === undefined ? undefined : textSerializers[node.type.name];
    if (textSerializer) {
      if (parent) {
        text += textSerializer({
          node,
          pos,
          parent,
          index,
          range
        });
      }
      return false;
    }
    if (node.isText) {
      text += (_a = node === null || node === undefined ? undefined : node.text) === null || _a === undefined ? undefined : _a.slice(Math.max(from, pos) - pos, to - pos);
    }
  });
  return text;
}
function getTextSerializersFromSchema(schema) {
  return Object.fromEntries(Object.entries(schema.nodes).filter(([, node]) => node.spec.toText).map(([name, node]) => [name, node.spec.toText]));
}
var ClipboardTextSerializer = Extension.create({
  name: "clipboardTextSerializer",
  addOptions() {
    return {
      blockSeparator: undefined
    };
  },
  addProseMirrorPlugins() {
    return [
      new Plugin({
        key: new PluginKey("clipboardTextSerializer"),
        props: {
          clipboardTextSerializer: () => {
            const { editor } = this;
            const { state, schema } = editor;
            const { doc: doc3, selection } = state;
            const { ranges } = selection;
            const from = Math.min(...ranges.map((range2) => range2.$from.pos));
            const to = Math.max(...ranges.map((range2) => range2.$to.pos));
            const textSerializers = getTextSerializersFromSchema(schema);
            const range = { from, to };
            return getTextBetween(doc3, range, {
              ...this.options.blockSeparator !== undefined ? { blockSeparator: this.options.blockSeparator } : {},
              textSerializers
            });
          }
        }
      })
    ];
  }
});
var blur = () => ({ editor, view }) => {
  requestAnimationFrame(() => {
    var _a;
    if (!editor.isDestroyed) {
      view.dom.blur();
      (_a = window === null || window === undefined ? undefined : window.getSelection()) === null || _a === undefined || _a.removeAllRanges();
    }
  });
  return true;
};
var clearContent = (emitUpdate = false) => ({ commands }) => {
  return commands.setContent("", emitUpdate);
};
var clearNodes = () => ({ state, tr, dispatch }) => {
  const { selection } = tr;
  const { ranges } = selection;
  if (!dispatch) {
    return true;
  }
  ranges.forEach(({ $from, $to }) => {
    state.doc.nodesBetween($from.pos, $to.pos, (node, pos) => {
      if (node.type.isText) {
        return;
      }
      const { doc: doc3, mapping } = tr;
      const $mappedFrom = doc3.resolve(mapping.map(pos));
      const $mappedTo = doc3.resolve(mapping.map(pos + node.nodeSize));
      const nodeRange = $mappedFrom.blockRange($mappedTo);
      if (!nodeRange) {
        return;
      }
      const targetLiftDepth = liftTarget(nodeRange);
      if (node.type.isTextblock) {
        const { defaultType } = $mappedFrom.parent.contentMatchAt($mappedFrom.index());
        tr.setNodeMarkup(nodeRange.start, defaultType);
      }
      if (targetLiftDepth || targetLiftDepth === 0) {
        tr.lift(nodeRange, targetLiftDepth);
      }
    });
  });
  return true;
};
var command = (fn) => (props) => {
  return fn(props);
};
var createParagraphNear2 = () => ({ state, dispatch }) => {
  return createParagraphNear(state, dispatch);
};
var cut = (originRange, targetPos) => ({ editor, tr }) => {
  const { state } = editor;
  const contentSlice = state.doc.slice(originRange.from, originRange.to);
  tr.deleteRange(originRange.from, originRange.to);
  const newPos = tr.mapping.map(targetPos);
  tr.insert(newPos, contentSlice.content);
  tr.setSelection(new TextSelection(tr.doc.resolve(Math.max(newPos - 1, 0))));
  return true;
};
var deleteCurrentNode = () => ({ tr, dispatch }) => {
  const { selection } = tr;
  const currentNode = selection.$anchor.node();
  if (currentNode.content.size > 0) {
    return false;
  }
  const $pos = tr.selection.$anchor;
  for (let depth = $pos.depth;depth > 0; depth -= 1) {
    const node = $pos.node(depth);
    if (node.type === currentNode.type) {
      if (dispatch) {
        const from = $pos.before(depth);
        const to = $pos.after(depth);
        tr.delete(from, to).scrollIntoView();
      }
      return true;
    }
  }
  return false;
};
var deleteNode = (typeOrName) => ({ tr, state, dispatch }) => {
  const type = getNodeType(typeOrName, state.schema);
  const $pos = tr.selection.$anchor;
  for (let depth = $pos.depth;depth > 0; depth -= 1) {
    const node = $pos.node(depth);
    if (node.type === type) {
      if (dispatch) {
        const from = $pos.before(depth);
        const to = $pos.after(depth);
        tr.delete(from, to).scrollIntoView();
      }
      return true;
    }
  }
  return false;
};
var deleteRange2 = (range) => ({ tr, dispatch }) => {
  const { from, to } = range;
  if (dispatch) {
    tr.delete(from, to);
  }
  return true;
};
var deleteSelection2 = () => ({ state, dispatch }) => {
  return deleteSelection(state, dispatch);
};
var enter = () => ({ commands }) => {
  return commands.keyboardShortcut("Enter");
};
var exitCode2 = () => ({ state, dispatch }) => {
  return exitCode(state, dispatch);
};
function objectIncludes(object1, object2, options = { strict: true }) {
  const keys2 = Object.keys(object2);
  if (!keys2.length) {
    return true;
  }
  return keys2.every((key) => {
    if (options.strict) {
      return object2[key] === object1[key];
    }
    if (isRegExp(object2[key])) {
      return object2[key].test(object1[key]);
    }
    return object2[key] === object1[key];
  });
}
function findMarkInSet(marks, type, attributes = {}) {
  return marks.find((item) => {
    return item.type === type && objectIncludes(Object.fromEntries(Object.keys(attributes).map((k) => [k, item.attrs[k]])), attributes);
  });
}
function isMarkInSet(marks, type, attributes = {}) {
  return !!findMarkInSet(marks, type, attributes);
}
function getMarkRange($pos, type, attributes) {
  var _a;
  if (!$pos || !type) {
    return;
  }
  let start = $pos.parent.childAfter($pos.parentOffset);
  if (!start.node || !start.node.marks.some((mark2) => mark2.type === type)) {
    start = $pos.parent.childBefore($pos.parentOffset);
  }
  if (!start.node || !start.node.marks.some((mark2) => mark2.type === type)) {
    return;
  }
  attributes = attributes || ((_a = start.node.marks[0]) === null || _a === undefined ? undefined : _a.attrs);
  const mark = findMarkInSet([...start.node.marks], type, attributes);
  if (!mark) {
    return;
  }
  let startIndex = start.index;
  let startPos = $pos.start() + start.offset;
  let endIndex = startIndex + 1;
  let endPos = startPos + start.node.nodeSize;
  while (startIndex > 0 && isMarkInSet([...$pos.parent.child(startIndex - 1).marks], type, attributes)) {
    startIndex -= 1;
    startPos -= $pos.parent.child(startIndex).nodeSize;
  }
  while (endIndex < $pos.parent.childCount && isMarkInSet([...$pos.parent.child(endIndex).marks], type, attributes)) {
    endPos += $pos.parent.child(endIndex).nodeSize;
    endIndex += 1;
  }
  return {
    from: startPos,
    to: endPos
  };
}
function getMarkType(nameOrType, schema) {
  if (typeof nameOrType === "string") {
    if (!schema.marks[nameOrType]) {
      throw Error(`There is no mark type named '${nameOrType}'. Maybe you forgot to add the extension?`);
    }
    return schema.marks[nameOrType];
  }
  return nameOrType;
}
var extendMarkRange = (typeOrName, attributes = {}) => ({ tr, state, dispatch }) => {
  const type = getMarkType(typeOrName, state.schema);
  const { doc: doc3, selection } = tr;
  const { $from, from, to } = selection;
  if (dispatch) {
    const range = getMarkRange($from, type, attributes);
    if (range && range.from <= from && range.to >= to) {
      const newSelection = TextSelection.create(doc3, range.from, range.to);
      tr.setSelection(newSelection);
    }
  }
  return true;
};
var first = (commands) => (props) => {
  const items = typeof commands === "function" ? commands(props) : commands;
  for (let i2 = 0;i2 < items.length; i2 += 1) {
    if (items[i2](props)) {
      return true;
    }
  }
  return false;
};
function isTextSelection(value) {
  return value instanceof TextSelection;
}
function minMax(value = 0, min = 0, max = 0) {
  return Math.min(Math.max(value, min), max);
}
function resolveFocusPosition(doc3, position = null) {
  if (!position) {
    return null;
  }
  const selectionAtStart = Selection.atStart(doc3);
  const selectionAtEnd = Selection.atEnd(doc3);
  if (position === "start" || position === true) {
    return selectionAtStart;
  }
  if (position === "end") {
    return selectionAtEnd;
  }
  const minPos = selectionAtStart.from;
  const maxPos = selectionAtEnd.to;
  if (position === "all") {
    return TextSelection.create(doc3, minMax(0, minPos, maxPos), minMax(doc3.content.size, minPos, maxPos));
  }
  return TextSelection.create(doc3, minMax(position, minPos, maxPos), minMax(position, minPos, maxPos));
}
function isAndroid() {
  return navigator.platform === "Android" || /android/i.test(navigator.userAgent);
}
function isiOS() {
  return [
    "iPad Simulator",
    "iPhone Simulator",
    "iPod Simulator",
    "iPad",
    "iPhone",
    "iPod"
  ].includes(navigator.platform) || navigator.userAgent.includes("Mac") && "ontouchend" in document;
}
function isSafari() {
  return typeof navigator !== "undefined" ? /^((?!chrome|android).)*safari/i.test(navigator.userAgent) : false;
}
var focus = (position = null, options = {}) => ({ editor, view, tr, dispatch }) => {
  options = {
    scrollIntoView: true,
    ...options
  };
  const delayedFocus = () => {
    if (isiOS() || isAndroid()) {
      view.dom.focus();
    }
    requestAnimationFrame(() => {
      if (!editor.isDestroyed) {
        view.focus();
        if (isSafari() && !isiOS() && !isAndroid()) {
          view.dom.focus({ preventScroll: true });
        }
      }
    });
  };
  if (view.hasFocus() && position === null || position === false) {
    return true;
  }
  if (dispatch && position === null && !isTextSelection(editor.state.selection)) {
    delayedFocus();
    return true;
  }
  const selection = resolveFocusPosition(tr.doc, position) || editor.state.selection;
  const isSameSelection = editor.state.selection.eq(selection);
  if (dispatch) {
    if (!isSameSelection) {
      tr.setSelection(selection);
    }
    if (isSameSelection && tr.storedMarks) {
      tr.setStoredMarks(tr.storedMarks);
    }
    delayedFocus();
  }
  return true;
};
var forEach = (items, fn) => (props) => {
  return items.every((item, index) => fn(item, { ...props, index }));
};
var insertContent = (value, options) => ({ tr, commands }) => {
  return commands.insertContentAt({ from: tr.selection.from, to: tr.selection.to }, value, options);
};
var removeWhitespaces = (node) => {
  const children = node.childNodes;
  for (let i2 = children.length - 1;i2 >= 0; i2 -= 1) {
    const child = children[i2];
    if (child.nodeType === 3 && child.nodeValue && /^(\n\s\s|\n)$/.test(child.nodeValue)) {
      node.removeChild(child);
    } else if (child.nodeType === 1) {
      removeWhitespaces(child);
    }
  }
  return node;
};
function elementFromString(value) {
  const wrappedValue = `<body>${value}</body>`;
  const html = new window.DOMParser().parseFromString(wrappedValue, "text/html").body;
  return removeWhitespaces(html);
}
function createNodeFromContent(content, schema, options) {
  if (content instanceof Node2 || content instanceof Fragment) {
    return content;
  }
  options = {
    slice: true,
    parseOptions: {},
    ...options
  };
  const isJSONContent = typeof content === "object" && content !== null;
  const isTextContent = typeof content === "string";
  if (isJSONContent) {
    try {
      const isArrayContent = Array.isArray(content) && content.length > 0;
      if (isArrayContent) {
        return Fragment.fromArray(content.map((item) => schema.nodeFromJSON(item)));
      }
      const node = schema.nodeFromJSON(content);
      if (options.errorOnInvalidContent) {
        node.check();
      }
      return node;
    } catch (error) {
      if (options.errorOnInvalidContent) {
        throw new Error("[tiptap error]: Invalid JSON content", { cause: error });
      }
      console.warn("[tiptap warn]: Invalid content.", "Passed value:", content, "Error:", error);
      return createNodeFromContent("", schema, options);
    }
  }
  if (isTextContent) {
    if (options.errorOnInvalidContent) {
      let hasInvalidContent = false;
      let invalidContent = "";
      const contentCheckSchema = new Schema({
        topNode: schema.spec.topNode,
        marks: schema.spec.marks,
        nodes: schema.spec.nodes.append({
          __tiptap__private__unknown__catch__all__node: {
            content: "inline*",
            group: "block",
            parseDOM: [
              {
                tag: "*",
                getAttrs: (e) => {
                  hasInvalidContent = true;
                  invalidContent = typeof e === "string" ? e : e.outerHTML;
                  return null;
                }
              }
            ]
          }
        })
      });
      if (options.slice) {
        DOMParser2.fromSchema(contentCheckSchema).parseSlice(elementFromString(content), options.parseOptions);
      } else {
        DOMParser2.fromSchema(contentCheckSchema).parse(elementFromString(content), options.parseOptions);
      }
      if (options.errorOnInvalidContent && hasInvalidContent) {
        throw new Error("[tiptap error]: Invalid HTML content", { cause: new Error(`Invalid element found: ${invalidContent}`) });
      }
    }
    const parser = DOMParser2.fromSchema(schema);
    if (options.slice) {
      return parser.parseSlice(elementFromString(content), options.parseOptions).content;
    }
    return parser.parse(elementFromString(content), options.parseOptions);
  }
  return createNodeFromContent("", schema, options);
}
function selectionToInsertionEnd2(tr, startLen, bias) {
  const last = tr.steps.length - 1;
  if (last < startLen) {
    return;
  }
  const step = tr.steps[last];
  if (!(step instanceof ReplaceStep || step instanceof ReplaceAroundStep)) {
    return;
  }
  const map = tr.mapping.maps[last];
  let end = 0;
  map.forEach((_from, _to, _newFrom, newTo) => {
    if (end === 0) {
      end = newTo;
    }
  });
  tr.setSelection(Selection.near(tr.doc.resolve(end), bias));
}
var isFragment = (nodeOrFragment) => {
  return !("type" in nodeOrFragment);
};
var insertContentAt = (position, value, options) => ({ tr, dispatch, editor }) => {
  var _a;
  if (dispatch) {
    options = {
      parseOptions: editor.options.parseOptions,
      updateSelection: true,
      applyInputRules: false,
      applyPasteRules: false,
      ...options
    };
    let content;
    const emitContentError = (error) => {
      editor.emit("contentError", {
        editor,
        error,
        disableCollaboration: () => {
          if (editor.storage.collaboration) {
            editor.storage.collaboration.isDisabled = true;
          }
        }
      });
    };
    const parseOptions = {
      preserveWhitespace: "full",
      ...options.parseOptions
    };
    if (!options.errorOnInvalidContent && !editor.options.enableContentCheck && editor.options.emitContentError) {
      try {
        createNodeFromContent(value, editor.schema, {
          parseOptions,
          errorOnInvalidContent: true
        });
      } catch (e) {
        emitContentError(e);
      }
    }
    try {
      content = createNodeFromContent(value, editor.schema, {
        parseOptions,
        errorOnInvalidContent: (_a = options.errorOnInvalidContent) !== null && _a !== undefined ? _a : editor.options.enableContentCheck
      });
    } catch (e) {
      emitContentError(e);
      return false;
    }
    let { from, to } = typeof position === "number" ? { from: position, to: position } : { from: position.from, to: position.to };
    let isOnlyTextContent = true;
    let isOnlyBlockContent = true;
    const nodes = isFragment(content) ? content : [content];
    nodes.forEach((node) => {
      node.check();
      isOnlyTextContent = isOnlyTextContent ? node.isText && node.marks.length === 0 : false;
      isOnlyBlockContent = isOnlyBlockContent ? node.isBlock : false;
    });
    if (from === to && isOnlyBlockContent) {
      const { parent } = tr.doc.resolve(from);
      const isEmptyTextBlock = parent.isTextblock && !parent.type.spec.code && !parent.childCount;
      if (isEmptyTextBlock) {
        from -= 1;
        to += 1;
      }
    }
    let newContent;
    if (isOnlyTextContent) {
      if (Array.isArray(value)) {
        newContent = value.map((v) => v.text || "").join("");
      } else if (value instanceof Fragment) {
        let text = "";
        value.forEach((node) => {
          if (node.text) {
            text += node.text;
          }
        });
        newContent = text;
      } else if (typeof value === "object" && !!value && !!value.text) {
        newContent = value.text;
      } else {
        newContent = value;
      }
      tr.insertText(newContent, from, to);
    } else {
      newContent = content;
      tr.replaceWith(from, to, newContent);
    }
    if (options.updateSelection) {
      selectionToInsertionEnd2(tr, tr.steps.length - 1, -1);
    }
    if (options.applyInputRules) {
      tr.setMeta("applyInputRules", { from, text: newContent });
    }
    if (options.applyPasteRules) {
      tr.setMeta("applyPasteRules", { from, text: newContent });
    }
  }
  return true;
};
var joinUp2 = () => ({ state, dispatch }) => {
  return joinUp(state, dispatch);
};
var joinDown2 = () => ({ state, dispatch }) => {
  return joinDown(state, dispatch);
};
var joinBackward2 = () => ({ state, dispatch }) => {
  return joinBackward(state, dispatch);
};
var joinForward2 = () => ({ state, dispatch }) => {
  return joinForward(state, dispatch);
};
var joinItemBackward = () => ({ state, dispatch, tr }) => {
  try {
    const point = joinPoint(state.doc, state.selection.$from.pos, -1);
    if (point === null || point === undefined) {
      return false;
    }
    tr.join(point, 2);
    if (dispatch) {
      dispatch(tr);
    }
    return true;
  } catch {
    return false;
  }
};
var joinItemForward = () => ({ state, dispatch, tr }) => {
  try {
    const point = joinPoint(state.doc, state.selection.$from.pos, 1);
    if (point === null || point === undefined) {
      return false;
    }
    tr.join(point, 2);
    if (dispatch) {
      dispatch(tr);
    }
    return true;
  } catch {
    return false;
  }
};
var joinTextblockBackward2 = () => ({ state, dispatch }) => {
  return joinTextblockBackward(state, dispatch);
};
var joinTextblockForward2 = () => ({ state, dispatch }) => {
  return joinTextblockForward(state, dispatch);
};
function isMacOS() {
  return typeof navigator !== "undefined" ? /Mac/.test(navigator.platform) : false;
}
function normalizeKeyName2(name) {
  const parts = name.split(/-(?!$)/);
  let result = parts[parts.length - 1];
  if (result === "Space") {
    result = " ";
  }
  let alt;
  let ctrl;
  let shift2;
  let meta;
  for (let i2 = 0;i2 < parts.length - 1; i2 += 1) {
    const mod = parts[i2];
    if (/^(cmd|meta|m)$/i.test(mod)) {
      meta = true;
    } else if (/^a(lt)?$/i.test(mod)) {
      alt = true;
    } else if (/^(c|ctrl|control)$/i.test(mod)) {
      ctrl = true;
    } else if (/^s(hift)?$/i.test(mod)) {
      shift2 = true;
    } else if (/^mod$/i.test(mod)) {
      if (isiOS() || isMacOS()) {
        meta = true;
      } else {
        ctrl = true;
      }
    } else {
      throw new Error(`Unrecognized modifier name: ${mod}`);
    }
  }
  if (alt) {
    result = `Alt-${result}`;
  }
  if (ctrl) {
    result = `Ctrl-${result}`;
  }
  if (meta) {
    result = `Meta-${result}`;
  }
  if (shift2) {
    result = `Shift-${result}`;
  }
  return result;
}
var keyboardShortcut = (name) => ({ editor, view, tr, dispatch }) => {
  const keys2 = normalizeKeyName2(name).split(/-(?!$)/);
  const key = keys2.find((item) => !["Alt", "Ctrl", "Meta", "Shift"].includes(item));
  const event = new KeyboardEvent("keydown", {
    key: key === "Space" ? " " : key,
    altKey: keys2.includes("Alt"),
    ctrlKey: keys2.includes("Ctrl"),
    metaKey: keys2.includes("Meta"),
    shiftKey: keys2.includes("Shift"),
    bubbles: true,
    cancelable: true
  });
  const capturedTransaction = editor.captureTransaction(() => {
    view.someProp("handleKeyDown", (f) => f(view, event));
  });
  capturedTransaction === null || capturedTransaction === undefined || capturedTransaction.steps.forEach((step) => {
    const newStep = step.map(tr.mapping);
    if (newStep && dispatch) {
      tr.maybeStep(newStep);
    }
  });
  return true;
};
function isNodeActive(state, typeOrName, attributes = {}) {
  const { from, to, empty: empty2 } = state.selection;
  const type = typeOrName ? getNodeType(typeOrName, state.schema) : null;
  const nodeRanges = [];
  state.doc.nodesBetween(from, to, (node, pos) => {
    if (node.isText) {
      return;
    }
    const relativeFrom = Math.max(from, pos);
    const relativeTo = Math.min(to, pos + node.nodeSize);
    nodeRanges.push({
      node,
      from: relativeFrom,
      to: relativeTo
    });
  });
  const selectionRange = to - from;
  const matchedNodeRanges = nodeRanges.filter((nodeRange) => {
    if (!type) {
      return true;
    }
    return type.name === nodeRange.node.type.name;
  }).filter((nodeRange) => objectIncludes(nodeRange.node.attrs, attributes, { strict: false }));
  if (empty2) {
    return !!matchedNodeRanges.length;
  }
  const range = matchedNodeRanges.reduce((sum, nodeRange) => sum + nodeRange.to - nodeRange.from, 0);
  return range >= selectionRange;
}
var lift3 = (typeOrName, attributes = {}) => ({ state, dispatch }) => {
  const type = getNodeType(typeOrName, state.schema);
  const isActive = isNodeActive(state, type, attributes);
  if (!isActive) {
    return false;
  }
  return lift2(state, dispatch);
};
var liftEmptyBlock2 = () => ({ state, dispatch }) => {
  return liftEmptyBlock(state, dispatch);
};
var liftListItem2 = (typeOrName) => ({ state, dispatch }) => {
  const type = getNodeType(typeOrName, state.schema);
  return liftListItem(type)(state, dispatch);
};
var newlineInCode2 = () => ({ state, dispatch }) => {
  return newlineInCode(state, dispatch);
};
function getSchemaTypeNameByName(name, schema) {
  if (schema.nodes[name]) {
    return "node";
  }
  if (schema.marks[name]) {
    return "mark";
  }
  return null;
}
function deleteProps(obj, propOrProps) {
  const props = typeof propOrProps === "string" ? [propOrProps] : propOrProps;
  return Object.keys(obj).reduce((newObj, prop) => {
    if (!props.includes(prop)) {
      newObj[prop] = obj[prop];
    }
    return newObj;
  }, {});
}
var resetAttributes = (typeOrName, attributes) => ({ tr, state, dispatch }) => {
  let nodeType = null;
  let markType = null;
  const schemaType = getSchemaTypeNameByName(typeof typeOrName === "string" ? typeOrName : typeOrName.name, state.schema);
  if (!schemaType) {
    return false;
  }
  if (schemaType === "node") {
    nodeType = getNodeType(typeOrName, state.schema);
  }
  if (schemaType === "mark") {
    markType = getMarkType(typeOrName, state.schema);
  }
  if (dispatch) {
    tr.selection.ranges.forEach((range) => {
      state.doc.nodesBetween(range.$from.pos, range.$to.pos, (node, pos) => {
        if (nodeType && nodeType === node.type) {
          tr.setNodeMarkup(pos, undefined, deleteProps(node.attrs, attributes));
        }
        if (markType && node.marks.length) {
          node.marks.forEach((mark) => {
            if (markType === mark.type) {
              tr.addMark(pos, pos + node.nodeSize, markType.create(deleteProps(mark.attrs, attributes)));
            }
          });
        }
      });
    });
  }
  return true;
};
var scrollIntoView = () => ({ tr, dispatch }) => {
  if (dispatch) {
    tr.scrollIntoView();
  }
  return true;
};
var selectAll2 = () => ({ tr, dispatch }) => {
  if (dispatch) {
    const selection = new AllSelection(tr.doc);
    tr.setSelection(selection);
  }
  return true;
};
var selectNodeBackward2 = () => ({ state, dispatch }) => {
  return selectNodeBackward(state, dispatch);
};
var selectNodeForward2 = () => ({ state, dispatch }) => {
  return selectNodeForward(state, dispatch);
};
var selectParentNode2 = () => ({ state, dispatch }) => {
  return selectParentNode(state, dispatch);
};
var selectTextblockEnd2 = () => ({ state, dispatch }) => {
  return selectTextblockEnd(state, dispatch);
};
var selectTextblockStart2 = () => ({ state, dispatch }) => {
  return selectTextblockStart(state, dispatch);
};
function createDocument(content, schema, parseOptions = {}, options = {}) {
  return createNodeFromContent(content, schema, {
    slice: false,
    parseOptions,
    errorOnInvalidContent: options.errorOnInvalidContent
  });
}
var setContent = (content, emitUpdate = false, parseOptions = {}, options = {}) => ({ editor, tr, dispatch, commands }) => {
  var _a, _b;
  const { doc: doc3 } = tr;
  if (parseOptions.preserveWhitespace !== "full") {
    const document2 = createDocument(content, editor.schema, parseOptions, {
      errorOnInvalidContent: (_a = options.errorOnInvalidContent) !== null && _a !== undefined ? _a : editor.options.enableContentCheck
    });
    if (dispatch) {
      tr.replaceWith(0, doc3.content.size, document2).setMeta("preventUpdate", !emitUpdate);
    }
    return true;
  }
  if (dispatch) {
    tr.setMeta("preventUpdate", !emitUpdate);
  }
  return commands.insertContentAt({ from: 0, to: doc3.content.size }, content, {
    parseOptions,
    errorOnInvalidContent: (_b = options.errorOnInvalidContent) !== null && _b !== undefined ? _b : editor.options.enableContentCheck
  });
};
function getMarkAttributes(state, typeOrName) {
  const type = getMarkType(typeOrName, state.schema);
  const { from, to, empty: empty2 } = state.selection;
  const marks = [];
  if (empty2) {
    if (state.storedMarks) {
      marks.push(...state.storedMarks);
    }
    marks.push(...state.selection.$head.marks());
  } else {
    state.doc.nodesBetween(from, to, (node) => {
      marks.push(...node.marks);
    });
  }
  const mark = marks.find((markItem) => markItem.type.name === type.name);
  if (!mark) {
    return {};
  }
  return { ...mark.attrs };
}
function defaultBlockAt2(match) {
  for (let i2 = 0;i2 < match.edgeCount; i2 += 1) {
    const { type } = match.edge(i2);
    if (type.isTextblock && !type.hasRequiredAttrs()) {
      return type;
    }
  }
  return null;
}
function findParentNodeClosestToPos($pos, predicate) {
  for (let i2 = $pos.depth;i2 > 0; i2 -= 1) {
    const node = $pos.node(i2);
    if (predicate(node)) {
      return {
        pos: i2 > 0 ? $pos.before(i2) : 0,
        start: $pos.start(i2),
        depth: i2,
        node
      };
    }
  }
}
function findParentNode(predicate) {
  return (selection) => findParentNodeClosestToPos(selection.$from, predicate);
}
function getText2(node, options) {
  const range = {
    from: 0,
    to: node.content.size
  };
  return getTextBetween(node, range, options);
}
function getNodeAttributes(state, typeOrName) {
  const type = getNodeType(typeOrName, state.schema);
  const { from, to } = state.selection;
  const nodes = [];
  state.doc.nodesBetween(from, to, (node2) => {
    nodes.push(node2);
  });
  const node = nodes.reverse().find((nodeItem) => nodeItem.type.name === type.name);
  if (!node) {
    return {};
  }
  return { ...node.attrs };
}
function getAttributes(state, typeOrName) {
  const schemaType = getSchemaTypeNameByName(typeof typeOrName === "string" ? typeOrName : typeOrName.name, state.schema);
  if (schemaType === "node") {
    return getNodeAttributes(state, typeOrName);
  }
  if (schemaType === "mark") {
    return getMarkAttributes(state, typeOrName);
  }
  return {};
}
function getMarksBetween(from, to, doc3) {
  const marks = [];
  if (from === to) {
    doc3.resolve(from).marks().forEach((mark) => {
      const $pos = doc3.resolve(from);
      const range = getMarkRange($pos, mark.type);
      if (!range) {
        return;
      }
      marks.push({
        mark,
        ...range
      });
    });
  } else {
    doc3.nodesBetween(from, to, (node, pos) => {
      if (!node || (node === null || node === undefined ? undefined : node.nodeSize) === undefined) {
        return;
      }
      marks.push(...node.marks.map((mark) => ({
        from: pos,
        to: pos + node.nodeSize,
        mark
      })));
    });
  }
  return marks;
}
function getSplittedAttributes(extensionAttributes, typeName, attributes) {
  return Object.fromEntries(Object.entries(attributes).filter(([name]) => {
    const extensionAttribute = extensionAttributes.find((item) => {
      return item.type === typeName && item.name === name;
    });
    if (!extensionAttribute) {
      return false;
    }
    return extensionAttribute.attribute.keepOnSplit;
  }));
}
function isMarkActive(state, typeOrName, attributes = {}) {
  const { empty: empty2, ranges } = state.selection;
  const type = typeOrName ? getMarkType(typeOrName, state.schema) : null;
  if (empty2) {
    return !!(state.storedMarks || state.selection.$from.marks()).filter((mark) => {
      if (!type) {
        return true;
      }
      return type.name === mark.type.name;
    }).find((mark) => objectIncludes(mark.attrs, attributes, { strict: false }));
  }
  let selectionRange = 0;
  const markRanges = [];
  ranges.forEach(({ $from, $to }) => {
    const from = $from.pos;
    const to = $to.pos;
    state.doc.nodesBetween(from, to, (node, pos) => {
      if (!node.isText && !node.marks.length) {
        return;
      }
      const relativeFrom = Math.max(from, pos);
      const relativeTo = Math.min(to, pos + node.nodeSize);
      const range2 = relativeTo - relativeFrom;
      selectionRange += range2;
      markRanges.push(...node.marks.map((mark) => ({
        mark,
        from: relativeFrom,
        to: relativeTo
      })));
    });
  });
  if (selectionRange === 0) {
    return false;
  }
  const matchedRange = markRanges.filter((markRange) => {
    if (!type) {
      return true;
    }
    return type.name === markRange.mark.type.name;
  }).filter((markRange) => objectIncludes(markRange.mark.attrs, attributes, { strict: false })).reduce((sum, markRange) => sum + markRange.to - markRange.from, 0);
  const excludedRange = markRanges.filter((markRange) => {
    if (!type) {
      return true;
    }
    return markRange.mark.type !== type && markRange.mark.type.excludes(type);
  }).reduce((sum, markRange) => sum + markRange.to - markRange.from, 0);
  const range = matchedRange > 0 ? matchedRange + excludedRange : matchedRange;
  return range >= selectionRange;
}
function isActive(state, name, attributes = {}) {
  if (!name) {
    return isNodeActive(state, null, attributes) || isMarkActive(state, null, attributes);
  }
  const schemaType = getSchemaTypeNameByName(name, state.schema);
  if (schemaType === "node") {
    return isNodeActive(state, name, attributes);
  }
  if (schemaType === "mark") {
    return isMarkActive(state, name, attributes);
  }
  return false;
}
function isList(name, extensions) {
  const { nodeExtensions } = splitExtensions(extensions);
  const extension = nodeExtensions.find((item) => item.name === name);
  if (!extension) {
    return false;
  }
  const context = {
    name: extension.name,
    options: extension.options,
    storage: extension.storage
  };
  const group = callOrReturn(getExtensionField(extension, "group", context));
  if (typeof group !== "string") {
    return false;
  }
  return group.split(" ").includes("list");
}
function isNodeEmpty(node, { checkChildren = true, ignoreWhitespace = false } = {}) {
  var _a;
  if (ignoreWhitespace) {
    if (node.type.name === "hardBreak") {
      return true;
    }
    if (node.isText) {
      return /^\s*$/m.test((_a = node.text) !== null && _a !== undefined ? _a : "");
    }
  }
  if (node.isText) {
    return !node.text;
  }
  if (node.isAtom || node.isLeaf) {
    return false;
  }
  if (node.content.childCount === 0) {
    return true;
  }
  if (checkChildren) {
    let isContentEmpty = true;
    node.content.forEach((childNode) => {
      if (isContentEmpty === false) {
        return;
      }
      if (!isNodeEmpty(childNode, { ignoreWhitespace, checkChildren })) {
        isContentEmpty = false;
      }
    });
    return isContentEmpty;
  }
  return false;
}
function isNodeSelection(value) {
  return value instanceof NodeSelection;
}
function canSetMark(state, tr, newMarkType) {
  var _a;
  const { selection } = tr;
  let cursor = null;
  if (isTextSelection(selection)) {
    cursor = selection.$cursor;
  }
  if (cursor) {
    const currentMarks = (_a = state.storedMarks) !== null && _a !== undefined ? _a : cursor.marks();
    return !!newMarkType.isInSet(currentMarks) || !currentMarks.some((mark) => mark.type.excludes(newMarkType));
  }
  const { ranges } = selection;
  return ranges.some(({ $from, $to }) => {
    let someNodeSupportsMark = $from.depth === 0 ? state.doc.inlineContent && state.doc.type.allowsMarkType(newMarkType) : false;
    state.doc.nodesBetween($from.pos, $to.pos, (node, _pos, parent) => {
      if (someNodeSupportsMark) {
        return false;
      }
      if (node.isInline) {
        const parentAllowsMarkType = !parent || parent.type.allowsMarkType(newMarkType);
        const currentMarksAllowMarkType = !!newMarkType.isInSet(node.marks) || !node.marks.some((otherMark) => otherMark.type.excludes(newMarkType));
        someNodeSupportsMark = parentAllowsMarkType && currentMarksAllowMarkType;
      }
      return !someNodeSupportsMark;
    });
    return someNodeSupportsMark;
  });
}
var setMark = (typeOrName, attributes = {}) => ({ tr, state, dispatch }) => {
  const { selection } = tr;
  const { empty: empty2, ranges } = selection;
  const type = getMarkType(typeOrName, state.schema);
  if (dispatch) {
    if (empty2) {
      const oldAttributes = getMarkAttributes(state, type);
      tr.addStoredMark(type.create({
        ...oldAttributes,
        ...attributes
      }));
    } else {
      ranges.forEach((range) => {
        const from = range.$from.pos;
        const to = range.$to.pos;
        state.doc.nodesBetween(from, to, (node, pos) => {
          const trimmedFrom = Math.max(pos, from);
          const trimmedTo = Math.min(pos + node.nodeSize, to);
          const someHasMark = node.marks.find((mark) => mark.type === type);
          if (someHasMark) {
            node.marks.forEach((mark) => {
              if (type === mark.type) {
                tr.addMark(trimmedFrom, trimmedTo, type.create({
                  ...mark.attrs,
                  ...attributes
                }));
              }
            });
          } else {
            tr.addMark(trimmedFrom, trimmedTo, type.create(attributes));
          }
        });
      });
    }
  }
  return canSetMark(state, tr, type);
};
var setMeta = (key, value) => ({ tr }) => {
  tr.setMeta(key, value);
  return true;
};
var setNode = (typeOrName, attributes = {}) => ({ state, dispatch, chain }) => {
  const type = getNodeType(typeOrName, state.schema);
  let attributesToCopy;
  if (state.selection.$anchor.sameParent(state.selection.$head)) {
    attributesToCopy = state.selection.$anchor.parent.attrs;
  }
  if (!type.isTextblock) {
    console.warn('[tiptap warn]: Currently "setNode()" only supports text block nodes.');
    return false;
  }
  return chain().command(({ commands }) => {
    const canSetBlock = setBlockType2(type, { ...attributesToCopy, ...attributes })(state);
    if (canSetBlock) {
      return true;
    }
    return commands.clearNodes();
  }).command(({ state: updatedState }) => {
    return setBlockType2(type, { ...attributesToCopy, ...attributes })(updatedState, dispatch);
  }).run();
};
var setNodeSelection = (position) => ({ tr, dispatch }) => {
  if (dispatch) {
    const { doc: doc3 } = tr;
    const from = minMax(position, 0, doc3.content.size);
    const selection = NodeSelection.create(doc3, from);
    tr.setSelection(selection);
  }
  return true;
};
var setTextSelection = (position) => ({ tr, dispatch }) => {
  if (dispatch) {
    const { doc: doc3 } = tr;
    const { from, to } = typeof position === "number" ? { from: position, to: position } : position;
    const minPos = TextSelection.atStart(doc3).from;
    const maxPos = TextSelection.atEnd(doc3).to;
    const resolvedFrom = minMax(from, minPos, maxPos);
    const resolvedEnd = minMax(to, minPos, maxPos);
    const selection = TextSelection.create(doc3, resolvedFrom, resolvedEnd);
    tr.setSelection(selection);
  }
  return true;
};
var sinkListItem2 = (typeOrName) => ({ state, dispatch }) => {
  const type = getNodeType(typeOrName, state.schema);
  return sinkListItem(type)(state, dispatch);
};
function ensureMarks(state, splittableMarks) {
  const marks = state.storedMarks || state.selection.$to.parentOffset && state.selection.$from.marks();
  if (marks) {
    const filteredMarks = marks.filter((mark) => splittableMarks === null || splittableMarks === undefined ? undefined : splittableMarks.includes(mark.type.name));
    state.tr.ensureMarks(filteredMarks);
  }
}
var splitBlock2 = ({ keepMarks = true } = {}) => ({ tr, state, dispatch, editor }) => {
  const { selection, doc: doc3 } = tr;
  const { $from, $to } = selection;
  const extensionAttributes = editor.extensionManager.attributes;
  const newAttributes = getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs);
  if (selection instanceof NodeSelection && selection.node.isBlock) {
    if (!$from.parentOffset || !canSplit(doc3, $from.pos)) {
      return false;
    }
    if (dispatch) {
      if (keepMarks) {
        ensureMarks(state, editor.extensionManager.splittableMarks);
      }
      tr.split($from.pos).scrollIntoView();
    }
    return true;
  }
  if (!$from.parent.isBlock) {
    return false;
  }
  const atEnd = $to.parentOffset === $to.parent.content.size;
  const deflt = $from.depth === 0 ? undefined : defaultBlockAt2($from.node(-1).contentMatchAt($from.indexAfter(-1)));
  let types = atEnd && deflt ? [
    {
      type: deflt,
      attrs: newAttributes
    }
  ] : undefined;
  let can = canSplit(tr.doc, tr.mapping.map($from.pos), 1, types);
  if (!types && !can && canSplit(tr.doc, tr.mapping.map($from.pos), 1, deflt ? [{ type: deflt }] : undefined)) {
    can = true;
    types = deflt ? [
      {
        type: deflt,
        attrs: newAttributes
      }
    ] : undefined;
  }
  if (dispatch) {
    if (can) {
      if (selection instanceof TextSelection) {
        tr.deleteSelection();
      }
      tr.split(tr.mapping.map($from.pos), 1, types);
      if (deflt && !atEnd && !$from.parentOffset && $from.parent.type !== deflt) {
        const first2 = tr.mapping.map($from.before());
        const $first = tr.doc.resolve(first2);
        if ($from.node(-1).canReplaceWith($first.index(), $first.index() + 1, deflt)) {
          tr.setNodeMarkup(tr.mapping.map($from.before()), deflt);
        }
      }
    }
    if (keepMarks) {
      ensureMarks(state, editor.extensionManager.splittableMarks);
    }
    tr.scrollIntoView();
  }
  return can;
};
var splitListItem = (typeOrName, overrideAttrs = {}) => ({ tr, state, dispatch, editor }) => {
  var _a;
  const type = getNodeType(typeOrName, state.schema);
  const { $from, $to } = state.selection;
  const node = state.selection.node;
  if (node && node.isBlock || $from.depth < 2 || !$from.sameParent($to)) {
    return false;
  }
  const grandParent = $from.node(-1);
  if (grandParent.type !== type) {
    return false;
  }
  const extensionAttributes = editor.extensionManager.attributes;
  if ($from.parent.content.size === 0 && $from.node(-1).childCount === $from.indexAfter(-1)) {
    if ($from.depth === 2 || $from.node(-3).type !== type || $from.index(-2) !== $from.node(-2).childCount - 1) {
      return false;
    }
    if (dispatch) {
      let wrap2 = Fragment.empty;
      const depthBefore = $from.index(-1) ? 1 : $from.index(-2) ? 2 : 3;
      for (let d = $from.depth - depthBefore;d >= $from.depth - 3; d -= 1) {
        wrap2 = Fragment.from($from.node(d).copy(wrap2));
      }
      const depthAfter = $from.indexAfter(-1) < $from.node(-2).childCount ? 1 : $from.indexAfter(-2) < $from.node(-3).childCount ? 2 : 3;
      const newNextTypeAttributes2 = {
        ...getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs),
        ...overrideAttrs
      };
      const nextType2 = ((_a = type.contentMatch.defaultType) === null || _a === undefined ? undefined : _a.createAndFill(newNextTypeAttributes2)) || undefined;
      wrap2 = wrap2.append(Fragment.from(type.createAndFill(null, nextType2) || undefined));
      const start = $from.before($from.depth - (depthBefore - 1));
      tr.replace(start, $from.after(-depthAfter), new Slice(wrap2, 4 - depthBefore, 0));
      let sel = -1;
      tr.doc.nodesBetween(start, tr.doc.content.size, (n, pos) => {
        if (sel > -1) {
          return false;
        }
        if (n.isTextblock && n.content.size === 0) {
          sel = pos + 1;
        }
      });
      if (sel > -1) {
        tr.setSelection(TextSelection.near(tr.doc.resolve(sel)));
      }
      tr.scrollIntoView();
    }
    return true;
  }
  const nextType = $to.pos === $from.end() ? grandParent.contentMatchAt(0).defaultType : null;
  const newTypeAttributes = {
    ...getSplittedAttributes(extensionAttributes, grandParent.type.name, grandParent.attrs),
    ...overrideAttrs
  };
  const newNextTypeAttributes = {
    ...getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs),
    ...overrideAttrs
  };
  tr.delete($from.pos, $to.pos);
  const types = nextType ? [
    { type, attrs: newTypeAttributes },
    { type: nextType, attrs: newNextTypeAttributes }
  ] : [{ type, attrs: newTypeAttributes }];
  if (!canSplit(tr.doc, $from.pos, 2)) {
    return false;
  }
  if (dispatch) {
    const { selection, storedMarks } = state;
    const { splittableMarks } = editor.extensionManager;
    const marks = storedMarks || selection.$to.parentOffset && selection.$from.marks();
    tr.split($from.pos, 2, types).scrollIntoView();
    if (!marks || !dispatch) {
      return true;
    }
    const filteredMarks = marks.filter((mark) => splittableMarks.includes(mark.type.name));
    tr.ensureMarks(filteredMarks);
  }
  return true;
};
var joinListBackwards = (tr, listType) => {
  const list = findParentNode((node) => node.type === listType)(tr.selection);
  if (!list) {
    return true;
  }
  const before = tr.doc.resolve(Math.max(0, list.pos - 1)).before(list.depth);
  if (before === undefined) {
    return true;
  }
  const nodeBefore = tr.doc.nodeAt(before);
  const canJoinBackwards = list.node.type === (nodeBefore === null || nodeBefore === undefined ? undefined : nodeBefore.type) && canJoin(tr.doc, list.pos);
  if (!canJoinBackwards) {
    return true;
  }
  tr.join(list.pos);
  return true;
};
var joinListForwards = (tr, listType) => {
  const list = findParentNode((node) => node.type === listType)(tr.selection);
  if (!list) {
    return true;
  }
  const after = tr.doc.resolve(list.start).after(list.depth);
  if (after === undefined) {
    return true;
  }
  const nodeAfter = tr.doc.nodeAt(after);
  const canJoinForwards = list.node.type === (nodeAfter === null || nodeAfter === undefined ? undefined : nodeAfter.type) && canJoin(tr.doc, after);
  if (!canJoinForwards) {
    return true;
  }
  tr.join(after);
  return true;
};
var toggleList = (listTypeOrName, itemTypeOrName, keepMarks, attributes = {}) => ({ editor, tr, state, dispatch, chain, commands, can }) => {
  const { extensions, splittableMarks } = editor.extensionManager;
  const listType = getNodeType(listTypeOrName, state.schema);
  const itemType = getNodeType(itemTypeOrName, state.schema);
  const { selection, storedMarks } = state;
  const { $from, $to } = selection;
  const range = $from.blockRange($to);
  const marks = storedMarks || selection.$to.parentOffset && selection.$from.marks();
  if (!range) {
    return false;
  }
  const parentList = findParentNode((node) => isList(node.type.name, extensions))(selection);
  if (range.depth >= 1 && parentList && range.depth - parentList.depth <= 1) {
    if (parentList.node.type === listType) {
      return commands.liftListItem(itemType);
    }
    if (isList(parentList.node.type.name, extensions) && listType.validContent(parentList.node.content) && dispatch) {
      return chain().command(() => {
        tr.setNodeMarkup(parentList.pos, listType);
        return true;
      }).command(() => joinListBackwards(tr, listType)).command(() => joinListForwards(tr, listType)).run();
    }
  }
  if (!keepMarks || !marks || !dispatch) {
    return chain().command(() => {
      const canWrapInList = can().wrapInList(listType, attributes);
      if (canWrapInList) {
        return true;
      }
      return commands.clearNodes();
    }).wrapInList(listType, attributes).command(() => joinListBackwards(tr, listType)).command(() => joinListForwards(tr, listType)).run();
  }
  return chain().command(() => {
    const canWrapInList = can().wrapInList(listType, attributes);
    const filteredMarks = marks.filter((mark) => splittableMarks.includes(mark.type.name));
    tr.ensureMarks(filteredMarks);
    if (canWrapInList) {
      return true;
    }
    return commands.clearNodes();
  }).wrapInList(listType, attributes).command(() => joinListBackwards(tr, listType)).command(() => joinListForwards(tr, listType)).run();
};
var toggleMark = (typeOrName, attributes = {}, options = {}) => ({ state, commands }) => {
  const { extendEmptyMarkRange = false } = options;
  const type = getMarkType(typeOrName, state.schema);
  const isActive2 = isMarkActive(state, type, attributes);
  if (isActive2) {
    return commands.unsetMark(type, { extendEmptyMarkRange });
  }
  return commands.setMark(type, attributes);
};
var toggleNode = (typeOrName, toggleTypeOrName, attributes = {}) => ({ state, commands }) => {
  const type = getNodeType(typeOrName, state.schema);
  const toggleType = getNodeType(toggleTypeOrName, state.schema);
  const isActive2 = isNodeActive(state, type, attributes);
  let attributesToCopy;
  if (state.selection.$anchor.sameParent(state.selection.$head)) {
    attributesToCopy = state.selection.$anchor.parent.attrs;
  }
  if (isActive2) {
    return commands.setNode(toggleType, attributesToCopy);
  }
  return commands.setNode(type, { ...attributesToCopy, ...attributes });
};
var toggleWrap = (typeOrName, attributes = {}) => ({ state, commands }) => {
  const type = getNodeType(typeOrName, state.schema);
  const isActive2 = isNodeActive(state, type, attributes);
  if (isActive2) {
    return commands.lift(type);
  }
  return commands.wrapIn(type, attributes);
};
var undoInputRule = () => ({ state, dispatch }) => {
  const plugins = state.plugins;
  for (let i2 = 0;i2 < plugins.length; i2 += 1) {
    const plugin = plugins[i2];
    let undoable;
    if (plugin.spec.isInputRules && (undoable = plugin.getState(state))) {
      if (dispatch) {
        const tr = state.tr;
        const toUndo = undoable.transform;
        for (let j = toUndo.steps.length - 1;j >= 0; j -= 1) {
          tr.step(toUndo.steps[j].invert(toUndo.docs[j]));
        }
        if (undoable.text) {
          const marks = tr.doc.resolve(undoable.from).marks();
          tr.replaceWith(undoable.from, undoable.to, state.schema.text(undoable.text, marks));
        } else {
          tr.delete(undoable.from, undoable.to);
        }
      }
      return true;
    }
  }
  return false;
};
var unsetAllMarks = () => ({ tr, dispatch }) => {
  const { selection } = tr;
  const { empty: empty2, ranges } = selection;
  if (empty2) {
    return true;
  }
  if (dispatch) {
    ranges.forEach((range) => {
      tr.removeMark(range.$from.pos, range.$to.pos);
    });
  }
  return true;
};
var unsetMark = (typeOrName, options = {}) => ({ tr, state, dispatch }) => {
  var _a;
  const { extendEmptyMarkRange = false } = options;
  const { selection } = tr;
  const type = getMarkType(typeOrName, state.schema);
  const { $from, empty: empty2, ranges } = selection;
  if (!dispatch) {
    return true;
  }
  if (empty2 && extendEmptyMarkRange) {
    let { from, to } = selection;
    const attrs = (_a = $from.marks().find((mark) => mark.type === type)) === null || _a === undefined ? undefined : _a.attrs;
    const range = getMarkRange($from, type, attrs);
    if (range) {
      from = range.from;
      to = range.to;
    }
    tr.removeMark(from, to, type);
  } else {
    ranges.forEach((range) => {
      tr.removeMark(range.$from.pos, range.$to.pos, type);
    });
  }
  tr.removeStoredMark(type);
  return true;
};
var updateAttributes = (typeOrName, attributes = {}) => ({ tr, state, dispatch }) => {
  let nodeType = null;
  let markType = null;
  const schemaType = getSchemaTypeNameByName(typeof typeOrName === "string" ? typeOrName : typeOrName.name, state.schema);
  if (!schemaType) {
    return false;
  }
  if (schemaType === "node") {
    nodeType = getNodeType(typeOrName, state.schema);
  }
  if (schemaType === "mark") {
    markType = getMarkType(typeOrName, state.schema);
  }
  if (dispatch) {
    tr.selection.ranges.forEach((range) => {
      const from = range.$from.pos;
      const to = range.$to.pos;
      let lastPos;
      let lastNode;
      let trimmedFrom;
      let trimmedTo;
      if (tr.selection.empty) {
        state.doc.nodesBetween(from, to, (node, pos) => {
          if (nodeType && nodeType === node.type) {
            trimmedFrom = Math.max(pos, from);
            trimmedTo = Math.min(pos + node.nodeSize, to);
            lastPos = pos;
            lastNode = node;
          }
        });
      } else {
        state.doc.nodesBetween(from, to, (node, pos) => {
          if (pos < from && nodeType && nodeType === node.type) {
            trimmedFrom = Math.max(pos, from);
            trimmedTo = Math.min(pos + node.nodeSize, to);
            lastPos = pos;
            lastNode = node;
          }
          if (pos >= from && pos <= to) {
            if (nodeType && nodeType === node.type) {
              tr.setNodeMarkup(pos, undefined, {
                ...node.attrs,
                ...attributes
              });
            }
            if (markType && node.marks.length) {
              node.marks.forEach((mark) => {
                if (markType === mark.type) {
                  const trimmedFrom2 = Math.max(pos, from);
                  const trimmedTo2 = Math.min(pos + node.nodeSize, to);
                  tr.addMark(trimmedFrom2, trimmedTo2, markType.create({
                    ...mark.attrs,
                    ...attributes
                  }));
                }
              });
            }
          }
        });
      }
      if (lastNode) {
        if (lastPos !== undefined) {
          tr.setNodeMarkup(lastPos, undefined, {
            ...lastNode.attrs,
            ...attributes
          });
        }
        if (markType && lastNode.marks.length) {
          lastNode.marks.forEach((mark) => {
            if (markType === mark.type) {
              tr.addMark(trimmedFrom, trimmedTo, markType.create({
                ...mark.attrs,
                ...attributes
              }));
            }
          });
        }
      }
    });
  }
  return true;
};
var wrapIn2 = (typeOrName, attributes = {}) => ({ state, dispatch }) => {
  const type = getNodeType(typeOrName, state.schema);
  return wrapIn(type, attributes)(state, dispatch);
};
var wrapInList2 = (typeOrName, attributes = {}) => ({ state, dispatch }) => {
  const type = getNodeType(typeOrName, state.schema);
  return wrapInList(type, attributes)(state, dispatch);
};
var commands = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  blur,
  clearContent,
  clearNodes,
  command,
  createParagraphNear: createParagraphNear2,
  cut,
  deleteCurrentNode,
  deleteNode,
  deleteRange: deleteRange2,
  deleteSelection: deleteSelection2,
  enter,
  exitCode: exitCode2,
  extendMarkRange,
  first,
  focus,
  forEach,
  insertContent,
  insertContentAt,
  joinBackward: joinBackward2,
  joinDown: joinDown2,
  joinForward: joinForward2,
  joinItemBackward,
  joinItemForward,
  joinTextblockBackward: joinTextblockBackward2,
  joinTextblockForward: joinTextblockForward2,
  joinUp: joinUp2,
  keyboardShortcut,
  lift: lift3,
  liftEmptyBlock: liftEmptyBlock2,
  liftListItem: liftListItem2,
  newlineInCode: newlineInCode2,
  resetAttributes,
  scrollIntoView,
  selectAll: selectAll2,
  selectNodeBackward: selectNodeBackward2,
  selectNodeForward: selectNodeForward2,
  selectParentNode: selectParentNode2,
  selectTextblockEnd: selectTextblockEnd2,
  selectTextblockStart: selectTextblockStart2,
  setContent,
  setMark,
  setMeta,
  setNode,
  setNodeSelection,
  setTextSelection,
  sinkListItem: sinkListItem2,
  splitBlock: splitBlock2,
  splitListItem,
  toggleList,
  toggleMark,
  toggleNode,
  toggleWrap,
  undoInputRule,
  unsetAllMarks,
  unsetMark,
  updateAttributes,
  wrapIn: wrapIn2,
  wrapInList: wrapInList2
});
var Commands = Extension.create({
  name: "commands",
  addCommands() {
    return {
      ...commands
    };
  }
});
var Drop = Extension.create({
  name: "drop",
  addProseMirrorPlugins() {
    return [
      new Plugin({
        key: new PluginKey("tiptapDrop"),
        props: {
          handleDrop: (_, e, slice, moved) => {
            this.editor.emit("drop", {
              editor: this.editor,
              event: e,
              slice,
              moved
            });
          }
        }
      })
    ];
  }
});
var Editable = Extension.create({
  name: "editable",
  addProseMirrorPlugins() {
    return [
      new Plugin({
        key: new PluginKey("editable"),
        props: {
          editable: () => this.editor.options.editable
        }
      })
    ];
  }
});
var focusEventsPluginKey = new PluginKey("focusEvents");
var FocusEvents = Extension.create({
  name: "focusEvents",
  addProseMirrorPlugins() {
    const { editor } = this;
    return [
      new Plugin({
        key: focusEventsPluginKey,
        props: {
          handleDOMEvents: {
            focus: (view, event) => {
              editor.isFocused = true;
              const transaction = editor.state.tr.setMeta("focus", { event }).setMeta("addToHistory", false);
              view.dispatch(transaction);
              return false;
            },
            blur: (view, event) => {
              editor.isFocused = false;
              const transaction = editor.state.tr.setMeta("blur", { event }).setMeta("addToHistory", false);
              view.dispatch(transaction);
              return false;
            }
          }
        }
      })
    ];
  }
});
var Keymap = Extension.create({
  name: "keymap",
  addKeyboardShortcuts() {
    const handleBackspace = () => this.editor.commands.first(({ commands: commands2 }) => [
      () => commands2.undoInputRule(),
      () => commands2.command(({ tr }) => {
        const { selection, doc: doc3 } = tr;
        const { empty: empty2, $anchor } = selection;
        const { pos, parent } = $anchor;
        const $parentPos = $anchor.parent.isTextblock && pos > 0 ? tr.doc.resolve(pos - 1) : $anchor;
        const parentIsIsolating = $parentPos.parent.type.spec.isolating;
        const parentPos = $anchor.pos - $anchor.parentOffset;
        const isAtStart = parentIsIsolating && $parentPos.parent.childCount === 1 ? parentPos === $anchor.pos : Selection.atStart(doc3).from === pos;
        if (!empty2 || !parent.type.isTextblock || parent.textContent.length || !isAtStart || isAtStart && $anchor.parent.type.name === "paragraph") {
          return false;
        }
        return commands2.clearNodes();
      }),
      () => commands2.deleteSelection(),
      () => commands2.joinBackward(),
      () => commands2.selectNodeBackward()
    ]);
    const handleDelete = () => this.editor.commands.first(({ commands: commands2 }) => [
      () => commands2.deleteSelection(),
      () => commands2.deleteCurrentNode(),
      () => commands2.joinForward(),
      () => commands2.selectNodeForward()
    ]);
    const handleEnter = () => this.editor.commands.first(({ commands: commands2 }) => [
      () => commands2.newlineInCode(),
      () => commands2.createParagraphNear(),
      () => commands2.liftEmptyBlock(),
      () => commands2.splitBlock()
    ]);
    const baseKeymap = {
      Enter: handleEnter,
      "Mod-Enter": () => this.editor.commands.exitCode(),
      Backspace: handleBackspace,
      "Mod-Backspace": handleBackspace,
      "Shift-Backspace": handleBackspace,
      Delete: handleDelete,
      "Mod-Delete": handleDelete,
      "Mod-a": () => this.editor.commands.selectAll()
    };
    const pcKeymap = {
      ...baseKeymap
    };
    const macKeymap = {
      ...baseKeymap,
      "Ctrl-h": handleBackspace,
      "Alt-Backspace": handleBackspace,
      "Ctrl-d": handleDelete,
      "Ctrl-Alt-Backspace": handleDelete,
      "Alt-Delete": handleDelete,
      "Alt-d": handleDelete,
      "Ctrl-a": () => this.editor.commands.selectTextblockStart(),
      "Ctrl-e": () => this.editor.commands.selectTextblockEnd()
    };
    if (isiOS() || isMacOS()) {
      return macKeymap;
    }
    return pcKeymap;
  },
  addProseMirrorPlugins() {
    return [
      new Plugin({
        key: new PluginKey("clearDocument"),
        appendTransaction: (transactions, oldState, newState) => {
          if (transactions.some((tr2) => tr2.getMeta("composition"))) {
            return;
          }
          const docChanges = transactions.some((transaction) => transaction.docChanged) && !oldState.doc.eq(newState.doc);
          const ignoreTr = transactions.some((transaction) => transaction.getMeta("preventClearDocument"));
          if (!docChanges || ignoreTr) {
            return;
          }
          const { empty: empty2, from, to } = oldState.selection;
          const allFrom = Selection.atStart(oldState.doc).from;
          const allEnd = Selection.atEnd(oldState.doc).to;
          const allWasSelected = from === allFrom && to === allEnd;
          if (empty2 || !allWasSelected) {
            return;
          }
          const isEmpty = isNodeEmpty(newState.doc);
          if (!isEmpty) {
            return;
          }
          const tr = newState.tr;
          const state = createChainableState({
            state: newState,
            transaction: tr
          });
          const { commands: commands2 } = new CommandManager({
            editor: this.editor,
            state
          });
          commands2.clearNodes();
          if (!tr.steps.length) {
            return;
          }
          return tr;
        }
      })
    ];
  }
});
var Paste = Extension.create({
  name: "paste",
  addProseMirrorPlugins() {
    return [
      new Plugin({
        key: new PluginKey("tiptapPaste"),
        props: {
          handlePaste: (_view, e, slice) => {
            this.editor.emit("paste", {
              editor: this.editor,
              event: e,
              slice
            });
          }
        }
      })
    ];
  }
});
var Tabindex = Extension.create({
  name: "tabindex",
  addProseMirrorPlugins() {
    return [
      new Plugin({
        key: new PluginKey("tabindex"),
        props: {
          attributes: () => this.editor.isEditable ? { tabindex: "0" } : {}
        }
      })
    ];
  }
});
class NodePos {
  get name() {
    return this.node.type.name;
  }
  constructor(pos, editor, isBlock = false, node = null) {
    this.currentNode = null;
    this.actualDepth = null;
    this.isBlock = isBlock;
    this.resolvedPos = pos;
    this.editor = editor;
    this.currentNode = node;
  }
  get node() {
    return this.currentNode || this.resolvedPos.node();
  }
  get element() {
    return this.editor.view.domAtPos(this.pos).node;
  }
  get depth() {
    var _a;
    return (_a = this.actualDepth) !== null && _a !== undefined ? _a : this.resolvedPos.depth;
  }
  get pos() {
    return this.resolvedPos.pos;
  }
  get content() {
    return this.node.content;
  }
  set content(content) {
    let from = this.from;
    let to = this.to;
    if (this.isBlock) {
      if (this.content.size === 0) {
        console.error(`You cant set content on a block node. Tried to set content on ${this.name} at ${this.pos}`);
        return;
      }
      from = this.from + 1;
      to = this.to - 1;
    }
    this.editor.commands.insertContentAt({ from, to }, content);
  }
  get attributes() {
    return this.node.attrs;
  }
  get textContent() {
    return this.node.textContent;
  }
  get size() {
    return this.node.nodeSize;
  }
  get from() {
    if (this.isBlock) {
      return this.pos;
    }
    return this.resolvedPos.start(this.resolvedPos.depth);
  }
  get range() {
    return {
      from: this.from,
      to: this.to
    };
  }
  get to() {
    if (this.isBlock) {
      return this.pos + this.size;
    }
    return this.resolvedPos.end(this.resolvedPos.depth) + (this.node.isText ? 0 : 1);
  }
  get parent() {
    if (this.depth === 0) {
      return null;
    }
    const parentPos = this.resolvedPos.start(this.resolvedPos.depth - 1);
    const $pos = this.resolvedPos.doc.resolve(parentPos);
    return new NodePos($pos, this.editor);
  }
  get before() {
    let $pos = this.resolvedPos.doc.resolve(this.from - (this.isBlock ? 1 : 2));
    if ($pos.depth !== this.depth) {
      $pos = this.resolvedPos.doc.resolve(this.from - 3);
    }
    return new NodePos($pos, this.editor);
  }
  get after() {
    let $pos = this.resolvedPos.doc.resolve(this.to + (this.isBlock ? 2 : 1));
    if ($pos.depth !== this.depth) {
      $pos = this.resolvedPos.doc.resolve(this.to + 3);
    }
    return new NodePos($pos, this.editor);
  }
  get children() {
    const children = [];
    this.node.content.forEach((node, offset) => {
      const isBlock = node.isBlock && !node.isTextblock;
      const isNonTextAtom = node.isAtom && !node.isText;
      const targetPos = this.pos + offset + (isNonTextAtom ? 0 : 1);
      if (targetPos < 0 || targetPos > this.resolvedPos.doc.nodeSize - 2) {
        return;
      }
      const $pos = this.resolvedPos.doc.resolve(targetPos);
      if (!isBlock && $pos.depth <= this.depth) {
        return;
      }
      const childNodePos = new NodePos($pos, this.editor, isBlock, isBlock ? node : null);
      if (isBlock) {
        childNodePos.actualDepth = this.depth + 1;
      }
      children.push(new NodePos($pos, this.editor, isBlock, isBlock ? node : null));
    });
    return children;
  }
  get firstChild() {
    return this.children[0] || null;
  }
  get lastChild() {
    const children = this.children;
    return children[children.length - 1] || null;
  }
  closest(selector, attributes = {}) {
    let node = null;
    let currentNode = this.parent;
    while (currentNode && !node) {
      if (currentNode.node.type.name === selector) {
        if (Object.keys(attributes).length > 0) {
          const nodeAttributes = currentNode.node.attrs;
          const attrKeys = Object.keys(attributes);
          for (let index = 0;index < attrKeys.length; index += 1) {
            const key = attrKeys[index];
            if (nodeAttributes[key] !== attributes[key]) {
              break;
            }
          }
        } else {
          node = currentNode;
        }
      }
      currentNode = currentNode.parent;
    }
    return node;
  }
  querySelector(selector, attributes = {}) {
    return this.querySelectorAll(selector, attributes, true)[0] || null;
  }
  querySelectorAll(selector, attributes = {}, firstItemOnly = false) {
    let nodes = [];
    if (!this.children || this.children.length === 0) {
      return nodes;
    }
    const attrKeys = Object.keys(attributes);
    this.children.forEach((childPos) => {
      if (firstItemOnly && nodes.length > 0) {
        return;
      }
      if (childPos.node.type.name === selector) {
        const doesAllAttributesMatch = attrKeys.every((key) => attributes[key] === childPos.node.attrs[key]);
        if (doesAllAttributesMatch) {
          nodes.push(childPos);
        }
      }
      if (firstItemOnly && nodes.length > 0) {
        return;
      }
      nodes = nodes.concat(childPos.querySelectorAll(selector, attributes, firstItemOnly));
    });
    return nodes;
  }
  setAttribute(attributes) {
    const { tr } = this.editor.state;
    tr.setNodeMarkup(this.from, undefined, {
      ...this.node.attrs,
      ...attributes
    });
    this.editor.view.dispatch(tr);
  }
}
var style = `.ProseMirror {
  position: relative;
}

.ProseMirror {
  word-wrap: break-word;
  white-space: pre-wrap;
  white-space: break-spaces;
  -webkit-font-variant-ligatures: none;
  font-variant-ligatures: none;
  font-feature-settings: "liga" 0; /* the above doesn't seem to work in Edge */
}

.ProseMirror [contenteditable="false"] {
  white-space: normal;
}

.ProseMirror [contenteditable="false"] [contenteditable="true"] {
  white-space: pre-wrap;
}

.ProseMirror pre {
  white-space: pre-wrap;
}

img.ProseMirror-separator {
  display: inline !important;
  border: none !important;
  margin: 0 !important;
  width: 0 !important;
  height: 0 !important;
}

.ProseMirror-gapcursor {
  display: none;
  pointer-events: none;
  position: absolute;
  margin: 0;
}

.ProseMirror-gapcursor:after {
  content: "";
  display: block;
  position: absolute;
  top: -2px;
  width: 20px;
  border-top: 1px solid black;
  animation: ProseMirror-cursor-blink 1.1s steps(2, start) infinite;
}

@keyframes ProseMirror-cursor-blink {
  to {
    visibility: hidden;
  }
}

.ProseMirror-hideselection *::selection {
  background: transparent;
}

.ProseMirror-hideselection *::-moz-selection {
  background: transparent;
}

.ProseMirror-hideselection * {
  caret-color: transparent;
}

.ProseMirror-focused .ProseMirror-gapcursor {
  display: block;
}

.tippy-box[data-animation=fade][data-state=hidden] {
  opacity: 0
}`;
function createStyleTag(style2, nonce, suffix) {
  const tiptapStyleTag = document.querySelector(`style[data-tiptap-style${suffix ? `-${suffix}` : ""}]`);
  if (tiptapStyleTag !== null) {
    return tiptapStyleTag;
  }
  const styleNode = document.createElement("style");
  if (nonce) {
    styleNode.setAttribute("nonce", nonce);
  }
  styleNode.setAttribute(`data-tiptap-style${suffix ? `-${suffix}` : ""}`, "");
  styleNode.innerHTML = style2;
  document.getElementsByTagName("head")[0].appendChild(styleNode);
  return styleNode;
}

class Editor extends EventEmitter {
  constructor(options = {}) {
    super();
    this.isFocused = false;
    this.isInitialized = false;
    this.extensionStorage = {};
    this.options = {
      element: document.createElement("div"),
      content: "",
      injectCSS: true,
      injectNonce: undefined,
      extensions: [],
      autofocus: false,
      editable: true,
      editorProps: {},
      parseOptions: {},
      coreExtensionOptions: {},
      enableInputRules: true,
      enablePasteRules: true,
      enableCoreExtensions: true,
      enableContentCheck: false,
      emitContentError: false,
      onBeforeCreate: () => null,
      onCreate: () => null,
      onUpdate: () => null,
      onSelectionUpdate: () => null,
      onTransaction: () => null,
      onFocus: () => null,
      onBlur: () => null,
      onDestroy: () => null,
      onContentError: ({ error }) => {
        throw error;
      },
      onPaste: () => null,
      onDrop: () => null
    };
    this.isCapturingTransaction = false;
    this.capturedTransaction = null;
    this.setOptions(options);
    this.createExtensionManager();
    this.createCommandManager();
    this.createSchema();
    this.on("beforeCreate", this.options.onBeforeCreate);
    this.emit("beforeCreate", { editor: this });
    this.on("contentError", this.options.onContentError);
    this.createView();
    this.injectCSS();
    this.on("create", this.options.onCreate);
    this.on("update", this.options.onUpdate);
    this.on("selectionUpdate", this.options.onSelectionUpdate);
    this.on("transaction", this.options.onTransaction);
    this.on("focus", this.options.onFocus);
    this.on("blur", this.options.onBlur);
    this.on("destroy", this.options.onDestroy);
    this.on("drop", ({ event, slice, moved }) => this.options.onDrop(event, slice, moved));
    this.on("paste", ({ event, slice }) => this.options.onPaste(event, slice));
    window.setTimeout(() => {
      if (this.isDestroyed) {
        return;
      }
      this.commands.focus(this.options.autofocus);
      this.emit("create", { editor: this });
      this.isInitialized = true;
    }, 0);
  }
  get storage() {
    return this.extensionStorage;
  }
  get commands() {
    return this.commandManager.commands;
  }
  chain() {
    return this.commandManager.chain();
  }
  can() {
    return this.commandManager.can();
  }
  injectCSS() {
    if (this.options.injectCSS && document) {
      this.css = createStyleTag(style, this.options.injectNonce);
    }
  }
  setOptions(options = {}) {
    this.options = {
      ...this.options,
      ...options
    };
    if (!this.view || !this.state || this.isDestroyed) {
      return;
    }
    if (this.options.editorProps) {
      this.view.setProps(this.options.editorProps);
    }
    this.view.updateState(this.state);
  }
  setEditable(editable, emitUpdate = true) {
    this.setOptions({ editable });
    if (emitUpdate) {
      this.emit("update", { editor: this, transaction: this.state.tr });
    }
  }
  get isEditable() {
    return this.options.editable && this.view && this.view.editable;
  }
  get state() {
    return this.view.state;
  }
  registerPlugin(plugin, handlePlugins) {
    const plugins = isFunction(handlePlugins) ? handlePlugins(plugin, [...this.state.plugins]) : [...this.state.plugins, plugin];
    const state = this.state.reconfigure({ plugins });
    this.view.updateState(state);
    return state;
  }
  unregisterPlugin(nameOrPluginKeyToRemove) {
    if (this.isDestroyed) {
      return;
    }
    const prevPlugins = this.state.plugins;
    let plugins = prevPlugins;
    [].concat(nameOrPluginKeyToRemove).forEach((nameOrPluginKey) => {
      const name = typeof nameOrPluginKey === "string" ? `${nameOrPluginKey}$` : nameOrPluginKey.key;
      plugins = plugins.filter((plugin) => !plugin.key.startsWith(name));
    });
    if (prevPlugins.length === plugins.length) {
      return;
    }
    const state = this.state.reconfigure({
      plugins
    });
    this.view.updateState(state);
    return state;
  }
  createExtensionManager() {
    var _a, _b;
    const coreExtensions = this.options.enableCoreExtensions ? [
      Editable,
      ClipboardTextSerializer.configure({
        blockSeparator: (_b = (_a = this.options.coreExtensionOptions) === null || _a === undefined ? undefined : _a.clipboardTextSerializer) === null || _b === undefined ? undefined : _b.blockSeparator
      }),
      Commands,
      FocusEvents,
      Keymap,
      Tabindex,
      Drop,
      Paste
    ].filter((ext) => {
      if (typeof this.options.enableCoreExtensions === "object") {
        return this.options.enableCoreExtensions[ext.name] !== false;
      }
      return true;
    }) : [];
    const allExtensions = [...coreExtensions, ...this.options.extensions].filter((extension) => {
      return ["extension", "node", "mark"].includes(extension === null || extension === undefined ? undefined : extension.type);
    });
    this.extensionManager = new ExtensionManager(allExtensions, this);
  }
  createCommandManager() {
    this.commandManager = new CommandManager({
      editor: this
    });
  }
  createSchema() {
    this.schema = this.extensionManager.schema;
  }
  createView() {
    var _a;
    let doc3;
    try {
      doc3 = createDocument(this.options.content, this.schema, this.options.parseOptions, { errorOnInvalidContent: this.options.enableContentCheck });
    } catch (e) {
      if (!(e instanceof Error) || !["[tiptap error]: Invalid JSON content", "[tiptap error]: Invalid HTML content"].includes(e.message)) {
        throw e;
      }
      this.emit("contentError", {
        editor: this,
        error: e,
        disableCollaboration: () => {
          if (this.storage.collaboration) {
            this.storage.collaboration.isDisabled = true;
          }
          this.options.extensions = this.options.extensions.filter((extension) => extension.name !== "collaboration");
          this.createExtensionManager();
        }
      });
      doc3 = createDocument(this.options.content, this.schema, this.options.parseOptions, { errorOnInvalidContent: false });
    }
    const selection = resolveFocusPosition(doc3, this.options.autofocus);
    this.view = new EditorView(this.options.element, {
      ...this.options.editorProps,
      attributes: {
        role: "textbox",
        ...(_a = this.options.editorProps) === null || _a === undefined ? undefined : _a.attributes
      },
      dispatchTransaction: this.dispatchTransaction.bind(this),
      state: EditorState.create({
        doc: doc3,
        selection: selection || undefined
      })
    });
    const newState = this.state.reconfigure({
      plugins: this.extensionManager.plugins
    });
    this.view.updateState(newState);
    this.createNodeViews();
    this.prependClass();
    const dom = this.view.dom;
    dom.editor = this;
  }
  createNodeViews() {
    if (this.view.isDestroyed) {
      return;
    }
    this.view.setProps({
      nodeViews: this.extensionManager.nodeViews
    });
  }
  prependClass() {
    this.view.dom.className = `tiptap ${this.view.dom.className}`;
  }
  captureTransaction(fn) {
    this.isCapturingTransaction = true;
    fn();
    this.isCapturingTransaction = false;
    const tr = this.capturedTransaction;
    this.capturedTransaction = null;
    return tr;
  }
  dispatchTransaction(transaction) {
    if (this.view.isDestroyed) {
      return;
    }
    if (this.isCapturingTransaction) {
      if (!this.capturedTransaction) {
        this.capturedTransaction = transaction;
        return;
      }
      transaction.steps.forEach((step) => {
        var _a;
        return (_a = this.capturedTransaction) === null || _a === undefined ? undefined : _a.step(step);
      });
      return;
    }
    const state = this.state.apply(transaction);
    const selectionHasChanged = !this.state.selection.eq(state.selection);
    this.emit("beforeTransaction", {
      editor: this,
      transaction,
      nextState: state
    });
    this.view.updateState(state);
    this.emit("transaction", {
      editor: this,
      transaction
    });
    if (selectionHasChanged) {
      this.emit("selectionUpdate", {
        editor: this,
        transaction
      });
    }
    const focus2 = transaction.getMeta("focus");
    const blur2 = transaction.getMeta("blur");
    if (focus2) {
      this.emit("focus", {
        editor: this,
        event: focus2.event,
        transaction
      });
    }
    if (blur2) {
      this.emit("blur", {
        editor: this,
        event: blur2.event,
        transaction
      });
    }
    if (!transaction.docChanged || transaction.getMeta("preventUpdate")) {
      return;
    }
    this.emit("update", {
      editor: this,
      transaction
    });
  }
  getAttributes(nameOrType) {
    return getAttributes(this.state, nameOrType);
  }
  isActive(nameOrAttributes, attributesOrUndefined) {
    const name = typeof nameOrAttributes === "string" ? nameOrAttributes : null;
    const attributes = typeof nameOrAttributes === "string" ? attributesOrUndefined : nameOrAttributes;
    return isActive(this.state, name, attributes);
  }
  getJSON() {
    return this.state.doc.toJSON();
  }
  getHTML() {
    return getHTMLFromFragment(this.state.doc.content, this.schema);
  }
  getText(options) {
    const { blockSeparator = `

`, textSerializers = {} } = options || {};
    return getText2(this.state.doc, {
      blockSeparator,
      textSerializers: {
        ...getTextSerializersFromSchema(this.schema),
        ...textSerializers
      }
    });
  }
  get isEmpty() {
    return isNodeEmpty(this.state.doc);
  }
  getCharacterCount() {
    console.warn('[tiptap warn]: "editor.getCharacterCount()" is deprecated. Please use "editor.storage.characterCount.characters()" instead.');
    return this.state.doc.content.size - 2;
  }
  destroy() {
    this.emit("destroy");
    if (this.view) {
      const dom = this.view.dom;
      if (dom && dom.editor) {
        delete dom.editor;
      }
      this.view.destroy();
    }
    this.removeAllListeners();
  }
  get isDestroyed() {
    var _a;
    return !((_a = this.view) === null || _a === undefined ? undefined : _a.docView);
  }
  $node(selector, attributes) {
    var _a;
    return ((_a = this.$doc) === null || _a === undefined ? undefined : _a.querySelector(selector, attributes)) || null;
  }
  $nodes(selector, attributes) {
    var _a;
    return ((_a = this.$doc) === null || _a === undefined ? undefined : _a.querySelectorAll(selector, attributes)) || null;
  }
  $pos(pos) {
    const $pos = this.state.doc.resolve(pos);
    return new NodePos($pos, this);
  }
  get $doc() {
    return this.$pos(0);
  }
}
function markInputRule(config) {
  return new InputRule({
    find: config.find,
    handler: ({ state, range, match }) => {
      const attributes = callOrReturn(config.getAttributes, undefined, match);
      if (attributes === false || attributes === null) {
        return null;
      }
      const { tr } = state;
      const captureGroup = match[match.length - 1];
      const fullMatch = match[0];
      if (captureGroup) {
        const startSpaces = fullMatch.search(/\S/);
        const textStart = range.from + fullMatch.indexOf(captureGroup);
        const textEnd = textStart + captureGroup.length;
        const excludedMarks = getMarksBetween(range.from, range.to, state.doc).filter((item) => {
          const excluded = item.mark.type.excluded;
          return excluded.find((type) => type === config.type && type !== item.mark.type);
        }).filter((item) => item.to > textStart);
        if (excludedMarks.length) {
          return null;
        }
        if (textEnd < range.to) {
          tr.delete(textEnd, range.to);
        }
        if (textStart > range.from) {
          tr.delete(range.from + startSpaces, textStart);
        }
        const markEnd = range.from + startSpaces + captureGroup.length;
        tr.addMark(range.from + startSpaces, markEnd, config.type.create(attributes || {}));
        tr.removeStoredMark(config.type);
      }
    }
  });
}
function nodeInputRule(config) {
  return new InputRule({
    find: config.find,
    handler: ({ state, range, match }) => {
      const attributes = callOrReturn(config.getAttributes, undefined, match) || {};
      const { tr } = state;
      const start = range.from;
      let end = range.to;
      const newNode = config.type.create(attributes);
      if (match[1]) {
        const offset = match[0].lastIndexOf(match[1]);
        let matchStart = start + offset;
        if (matchStart > end) {
          matchStart = end;
        } else {
          end = matchStart + match[1].length;
        }
        const lastChar = match[0][match[0].length - 1];
        tr.insertText(lastChar, start + match[0].length - 1);
        tr.replaceWith(matchStart, end, newNode);
      } else if (match[0]) {
        const insertionStart = config.type.isInline ? start : start - 1;
        tr.insert(insertionStart, config.type.create(attributes)).delete(tr.mapping.map(start), tr.mapping.map(end));
      }
      tr.scrollIntoView();
    }
  });
}
function textblockTypeInputRule(config) {
  return new InputRule({
    find: config.find,
    handler: ({ state, range, match }) => {
      const $start = state.doc.resolve(range.from);
      const attributes = callOrReturn(config.getAttributes, undefined, match) || {};
      if (!$start.node(-1).canReplaceWith($start.index(-1), $start.indexAfter(-1), config.type)) {
        return null;
      }
      state.tr.delete(range.from, range.to).setBlockType(range.from, range.from, config.type, attributes);
    }
  });
}
function wrappingInputRule(config) {
  return new InputRule({
    find: config.find,
    handler: ({ state, range, match, chain }) => {
      const attributes = callOrReturn(config.getAttributes, undefined, match) || {};
      const tr = state.tr.delete(range.from, range.to);
      const $start = tr.doc.resolve(range.from);
      const blockRange = $start.blockRange();
      const wrapping = blockRange && findWrapping(blockRange, config.type, attributes);
      if (!wrapping) {
        return null;
      }
      tr.wrap(blockRange, wrapping);
      if (config.keepMarks && config.editor) {
        const { selection, storedMarks } = state;
        const { splittableMarks } = config.editor.extensionManager;
        const marks = storedMarks || selection.$to.parentOffset && selection.$from.marks();
        if (marks) {
          const filteredMarks = marks.filter((mark) => splittableMarks.includes(mark.type.name));
          tr.ensureMarks(filteredMarks);
        }
      }
      if (config.keepAttributes) {
        const nodeType = config.type.name === "bulletList" || config.type.name === "orderedList" ? "listItem" : "taskList";
        chain().updateAttributes(nodeType, attributes).run();
      }
      const before = tr.doc.resolve(range.from - 1).nodeBefore;
      if (before && before.type === config.type && canJoin(tr.doc, range.from - 1) && (!config.joinPredicate || config.joinPredicate(match, before))) {
        tr.join(range.from - 1);
      }
    }
  });
}

class Node3 {
  constructor(config = {}) {
    this.type = "node";
    this.name = "node";
    this.parent = null;
    this.child = null;
    this.config = {
      name: this.name,
      defaultOptions: {}
    };
    this.config = {
      ...this.config,
      ...config
    };
    this.name = this.config.name;
    if (config.defaultOptions && Object.keys(config.defaultOptions).length > 0) {
      console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`);
    }
    this.options = this.config.defaultOptions;
    if (this.config.addOptions) {
      this.options = callOrReturn(getExtensionField(this, "addOptions", {
        name: this.name
      }));
    }
    this.storage = callOrReturn(getExtensionField(this, "addStorage", {
      name: this.name,
      options: this.options
    })) || {};
  }
  static create(config = {}) {
    return new Node3(config);
  }
  configure(options = {}) {
    const extension = this.extend({
      ...this.config,
      addOptions: () => {
        return mergeDeep(this.options, options);
      }
    });
    extension.name = this.name;
    extension.parent = this.parent;
    return extension;
  }
  extend(extendedConfig = {}) {
    const extension = new Node3(extendedConfig);
    extension.parent = this;
    this.child = extension;
    extension.name = extendedConfig.name ? extendedConfig.name : extension.parent.name;
    if (extendedConfig.defaultOptions && Object.keys(extendedConfig.defaultOptions).length > 0) {
      console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${extension.name}".`);
    }
    extension.options = callOrReturn(getExtensionField(extension, "addOptions", {
      name: extension.name
    }));
    extension.storage = callOrReturn(getExtensionField(extension, "addStorage", {
      name: extension.name,
      options: extension.options
    }));
    return extension;
  }
}
function markPasteRule(config) {
  return new PasteRule({
    find: config.find,
    handler: ({ state, range, match, pasteEvent }) => {
      const attributes = callOrReturn(config.getAttributes, undefined, match, pasteEvent);
      if (attributes === false || attributes === null) {
        return null;
      }
      const { tr } = state;
      const captureGroup = match[match.length - 1];
      const fullMatch = match[0];
      let markEnd = range.to;
      if (captureGroup) {
        const startSpaces = fullMatch.search(/\S/);
        const textStart = range.from + fullMatch.indexOf(captureGroup);
        const textEnd = textStart + captureGroup.length;
        const excludedMarks = getMarksBetween(range.from, range.to, state.doc).filter((item) => {
          const excluded = item.mark.type.excluded;
          return excluded.find((type) => type === config.type && type !== item.mark.type);
        }).filter((item) => item.to > textStart);
        if (excludedMarks.length) {
          return null;
        }
        if (textEnd < range.to) {
          tr.delete(textEnd, range.to);
        }
        if (textStart > range.from) {
          tr.delete(range.from + startSpaces, textStart);
        }
        markEnd = range.from + startSpaces + captureGroup.length;
        tr.addMark(range.from + startSpaces, markEnd, config.type.create(attributes || {}));
        tr.removeStoredMark(config.type);
      }
    }
  });
}
function canInsertNode(state, nodeType) {
  const { selection } = state;
  const { $from } = selection;
  if (selection instanceof NodeSelection) {
    const index = $from.index();
    const parent = $from.parent;
    return parent.canReplaceWith(index, index + 1, nodeType);
  }
  let depth = $from.depth;
  while (depth >= 0) {
    const index = $from.index(depth);
    const parent = $from.node(depth);
    const match = parent.contentMatchAt(index);
    if (match.matchType(nodeType)) {
      return true;
    }
    depth -= 1;
  }
  return false;
}

// node_modules/@tiptap/extension-blockquote/dist/index.js
var inputRegex = /^\s*>\s$/;
var Blockquote = Node3.create({
  name: "blockquote",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  content: "block+",
  group: "block",
  defining: true,
  parseHTML() {
    return [
      { tag: "blockquote" }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["blockquote", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      setBlockquote: () => ({ commands: commands2 }) => {
        return commands2.wrapIn(this.name);
      },
      toggleBlockquote: () => ({ commands: commands2 }) => {
        return commands2.toggleWrap(this.name);
      },
      unsetBlockquote: () => ({ commands: commands2 }) => {
        return commands2.lift(this.name);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-b": () => this.editor.commands.toggleBlockquote()
    };
  },
  addInputRules() {
    return [
      wrappingInputRule({
        find: inputRegex,
        type: this.type
      })
    ];
  }
});

// node_modules/@tiptap/extension-bold/dist/index.js
var starInputRegex = /(?:^|\s)(\*\*(?!\s+\*\*)((?:[^*]+))\*\*(?!\s+\*\*))$/;
var starPasteRegex = /(?:^|\s)(\*\*(?!\s+\*\*)((?:[^*]+))\*\*(?!\s+\*\*))/g;
var underscoreInputRegex = /(?:^|\s)(__(?!\s+__)((?:[^_]+))__(?!\s+__))$/;
var underscorePasteRegex = /(?:^|\s)(__(?!\s+__)((?:[^_]+))__(?!\s+__))/g;
var Bold = Mark2.create({
  name: "bold",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "strong"
      },
      {
        tag: "b",
        getAttrs: (node) => node.style.fontWeight !== "normal" && null
      },
      {
        style: "font-weight=400",
        clearMark: (mark) => mark.type.name === this.name
      },
      {
        style: "font-weight",
        getAttrs: (value) => /^(bold(er)?|[5-9]\d{2,})$/.test(value) && null
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["strong", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      setBold: () => ({ commands: commands2 }) => {
        return commands2.setMark(this.name);
      },
      toggleBold: () => ({ commands: commands2 }) => {
        return commands2.toggleMark(this.name);
      },
      unsetBold: () => ({ commands: commands2 }) => {
        return commands2.unsetMark(this.name);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-b": () => this.editor.commands.toggleBold(),
      "Mod-B": () => this.editor.commands.toggleBold()
    };
  },
  addInputRules() {
    return [
      markInputRule({
        find: starInputRegex,
        type: this.type
      }),
      markInputRule({
        find: underscoreInputRegex,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      markPasteRule({
        find: starPasteRegex,
        type: this.type
      }),
      markPasteRule({
        find: underscorePasteRegex,
        type: this.type
      })
    ];
  }
});

// node_modules/@tiptap/extension-bullet-list/dist/index.js
var ListItemName = "listItem";
var TextStyleName = "textStyle";
var inputRegex2 = /^\s*([-+*])\s$/;
var BulletList = Node3.create({
  name: "bulletList",
  addOptions() {
    return {
      itemTypeName: "listItem",
      HTMLAttributes: {},
      keepMarks: false,
      keepAttributes: false
    };
  },
  group: "block list",
  content() {
    return `${this.options.itemTypeName}+`;
  },
  parseHTML() {
    return [
      { tag: "ul" }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["ul", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      toggleBulletList: () => ({ commands: commands2, chain }) => {
        if (this.options.keepAttributes) {
          return chain().toggleList(this.name, this.options.itemTypeName, this.options.keepMarks).updateAttributes(ListItemName, this.editor.getAttributes(TextStyleName)).run();
        }
        return commands2.toggleList(this.name, this.options.itemTypeName, this.options.keepMarks);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-8": () => this.editor.commands.toggleBulletList()
    };
  },
  addInputRules() {
    let inputRule = wrappingInputRule({
      find: inputRegex2,
      type: this.type
    });
    if (this.options.keepMarks || this.options.keepAttributes) {
      inputRule = wrappingInputRule({
        find: inputRegex2,
        type: this.type,
        keepMarks: this.options.keepMarks,
        keepAttributes: this.options.keepAttributes,
        getAttributes: () => {
          return this.editor.getAttributes(TextStyleName);
        },
        editor: this.editor
      });
    }
    return [
      inputRule
    ];
  }
});

// node_modules/@tiptap/extension-code/dist/index.js
var inputRegex3 = /(^|[^`])`([^`]+)`(?!`)/;
var pasteRegex = /(^|[^`])`([^`]+)`(?!`)/g;
var Code = Mark2.create({
  name: "code",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  excludes: "_",
  code: true,
  exitable: true,
  parseHTML() {
    return [
      { tag: "code" }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["code", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      setCode: () => ({ commands: commands2 }) => {
        return commands2.setMark(this.name);
      },
      toggleCode: () => ({ commands: commands2 }) => {
        return commands2.toggleMark(this.name);
      },
      unsetCode: () => ({ commands: commands2 }) => {
        return commands2.unsetMark(this.name);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-e": () => this.editor.commands.toggleCode()
    };
  },
  addInputRules() {
    return [
      markInputRule({
        find: inputRegex3,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      markPasteRule({
        find: pasteRegex,
        type: this.type
      })
    ];
  }
});

// node_modules/@tiptap/extension-code-block/dist/index.js
var backtickInputRegex = /^```([a-z]+)?[\s\n]$/;
var tildeInputRegex = /^~~~([a-z]+)?[\s\n]$/;
var CodeBlock = Node3.create({
  name: "codeBlock",
  addOptions() {
    return {
      languageClassPrefix: "language-",
      exitOnTripleEnter: true,
      exitOnArrowDown: true,
      defaultLanguage: null,
      HTMLAttributes: {}
    };
  },
  content: "text*",
  marks: "",
  group: "block",
  code: true,
  defining: true,
  addAttributes() {
    return {
      language: {
        default: this.options.defaultLanguage,
        parseHTML: (element) => {
          var _a;
          const { languageClassPrefix } = this.options;
          const classNames = [...((_a = element.firstElementChild) === null || _a === undefined ? undefined : _a.classList) || []];
          const languages = classNames.filter((className) => className.startsWith(languageClassPrefix)).map((className) => className.replace(languageClassPrefix, ""));
          const language = languages[0];
          if (!language) {
            return null;
          }
          return language;
        },
        rendered: false
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: "pre",
        preserveWhitespace: "full"
      }
    ];
  },
  renderHTML({ node, HTMLAttributes }) {
    return [
      "pre",
      mergeAttributes(this.options.HTMLAttributes, HTMLAttributes),
      [
        "code",
        {
          class: node.attrs.language ? this.options.languageClassPrefix + node.attrs.language : null
        },
        0
      ]
    ];
  },
  addCommands() {
    return {
      setCodeBlock: (attributes) => ({ commands: commands2 }) => {
        return commands2.setNode(this.name, attributes);
      },
      toggleCodeBlock: (attributes) => ({ commands: commands2 }) => {
        return commands2.toggleNode(this.name, "paragraph", attributes);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Alt-c": () => this.editor.commands.toggleCodeBlock(),
      Backspace: () => {
        const { empty: empty2, $anchor } = this.editor.state.selection;
        const isAtStart = $anchor.pos === 1;
        if (!empty2 || $anchor.parent.type.name !== this.name) {
          return false;
        }
        if (isAtStart || !$anchor.parent.textContent.length) {
          return this.editor.commands.clearNodes();
        }
        return false;
      },
      Enter: ({ editor }) => {
        if (!this.options.exitOnTripleEnter) {
          return false;
        }
        const { state } = editor;
        const { selection } = state;
        const { $from, empty: empty2 } = selection;
        if (!empty2 || $from.parent.type !== this.type) {
          return false;
        }
        const isAtEnd = $from.parentOffset === $from.parent.nodeSize - 2;
        const endsWithDoubleNewline = $from.parent.textContent.endsWith(`

`);
        if (!isAtEnd || !endsWithDoubleNewline) {
          return false;
        }
        return editor.chain().command(({ tr }) => {
          tr.delete($from.pos - 2, $from.pos);
          return true;
        }).exitCode().run();
      },
      ArrowDown: ({ editor }) => {
        if (!this.options.exitOnArrowDown) {
          return false;
        }
        const { state } = editor;
        const { selection, doc: doc3 } = state;
        const { $from, empty: empty2 } = selection;
        if (!empty2 || $from.parent.type !== this.type) {
          return false;
        }
        const isAtEnd = $from.parentOffset === $from.parent.nodeSize - 2;
        if (!isAtEnd) {
          return false;
        }
        const after = $from.after();
        if (after === undefined) {
          return false;
        }
        const nodeAfter = doc3.nodeAt(after);
        if (nodeAfter) {
          return editor.commands.command(({ tr }) => {
            tr.setSelection(Selection.near(doc3.resolve(after)));
            return true;
          });
        }
        return editor.commands.exitCode();
      }
    };
  },
  addInputRules() {
    return [
      textblockTypeInputRule({
        find: backtickInputRegex,
        type: this.type,
        getAttributes: (match) => ({
          language: match[1]
        })
      }),
      textblockTypeInputRule({
        find: tildeInputRegex,
        type: this.type,
        getAttributes: (match) => ({
          language: match[1]
        })
      })
    ];
  },
  addProseMirrorPlugins() {
    return [
      new Plugin({
        key: new PluginKey("codeBlockVSCodeHandler"),
        props: {
          handlePaste: (view, event) => {
            if (!event.clipboardData) {
              return false;
            }
            if (this.editor.isActive(this.type.name)) {
              return false;
            }
            const text = event.clipboardData.getData("text/plain");
            const vscode = event.clipboardData.getData("vscode-editor-data");
            const vscodeData = vscode ? JSON.parse(vscode) : undefined;
            const language = vscodeData === null || vscodeData === undefined ? undefined : vscodeData.mode;
            if (!text || !language) {
              return false;
            }
            const { tr, schema } = view.state;
            const textNode = schema.text(text.replace(/\r\n?/g, `
`));
            tr.replaceSelectionWith(this.type.create({ language }, textNode));
            if (tr.selection.$from.parent.type !== this.type) {
              tr.setSelection(TextSelection.near(tr.doc.resolve(Math.max(0, tr.selection.from - 2))));
            }
            tr.setMeta("paste", true);
            view.dispatch(tr);
            return true;
          }
        }
      })
    ];
  }
});

// node_modules/@tiptap/extension-document/dist/index.js
var Document = Node3.create({
  name: "doc",
  topNode: true,
  content: "block+"
});

// node_modules/prosemirror-dropcursor/dist/index.js
function dropCursor(options = {}) {
  return new Plugin({
    view(editorView) {
      return new DropCursorView(editorView, options);
    }
  });
}

class DropCursorView {
  constructor(editorView, options) {
    var _a;
    this.editorView = editorView;
    this.cursorPos = null;
    this.element = null;
    this.timeout = -1;
    this.width = (_a = options.width) !== null && _a !== undefined ? _a : 1;
    this.color = options.color === false ? undefined : options.color || "black";
    this.class = options.class;
    this.handlers = ["dragover", "dragend", "drop", "dragleave"].map((name) => {
      let handler = (e) => {
        this[name](e);
      };
      editorView.dom.addEventListener(name, handler);
      return { name, handler };
    });
  }
  destroy() {
    this.handlers.forEach(({ name, handler }) => this.editorView.dom.removeEventListener(name, handler));
  }
  update(editorView, prevState) {
    if (this.cursorPos != null && prevState.doc != editorView.state.doc) {
      if (this.cursorPos > editorView.state.doc.content.size)
        this.setCursor(null);
      else
        this.updateOverlay();
    }
  }
  setCursor(pos) {
    if (pos == this.cursorPos)
      return;
    this.cursorPos = pos;
    if (pos == null) {
      this.element.parentNode.removeChild(this.element);
      this.element = null;
    } else {
      this.updateOverlay();
    }
  }
  updateOverlay() {
    let $pos = this.editorView.state.doc.resolve(this.cursorPos);
    let isBlock = !$pos.parent.inlineContent, rect;
    let editorDOM = this.editorView.dom, editorRect = editorDOM.getBoundingClientRect();
    let scaleX = editorRect.width / editorDOM.offsetWidth, scaleY = editorRect.height / editorDOM.offsetHeight;
    if (isBlock) {
      let { nodeBefore: before, nodeAfter: after } = $pos;
      if (before || after) {
        let node = this.editorView.nodeDOM(this.cursorPos - (before ? before.nodeSize : 0));
        if (node) {
          let nodeRect = node.getBoundingClientRect();
          let top = before ? nodeRect.bottom : nodeRect.top;
          if (before && after)
            top = (top + this.editorView.nodeDOM(this.cursorPos).getBoundingClientRect().top) / 2;
          let halfWidth = this.width / 2 * scaleY;
          rect = { left: nodeRect.left, right: nodeRect.right, top: top - halfWidth, bottom: top + halfWidth };
        }
      }
    }
    if (!rect) {
      let coords = this.editorView.coordsAtPos(this.cursorPos);
      let halfWidth = this.width / 2 * scaleX;
      rect = { left: coords.left - halfWidth, right: coords.left + halfWidth, top: coords.top, bottom: coords.bottom };
    }
    let parent = this.editorView.dom.offsetParent;
    if (!this.element) {
      this.element = parent.appendChild(document.createElement("div"));
      if (this.class)
        this.element.className = this.class;
      this.element.style.cssText = "position: absolute; z-index: 50; pointer-events: none;";
      if (this.color) {
        this.element.style.backgroundColor = this.color;
      }
    }
    this.element.classList.toggle("prosemirror-dropcursor-block", isBlock);
    this.element.classList.toggle("prosemirror-dropcursor-inline", !isBlock);
    let parentLeft, parentTop;
    if (!parent || parent == document.body && getComputedStyle(parent).position == "static") {
      parentLeft = -pageXOffset;
      parentTop = -pageYOffset;
    } else {
      let rect2 = parent.getBoundingClientRect();
      let parentScaleX = rect2.width / parent.offsetWidth, parentScaleY = rect2.height / parent.offsetHeight;
      parentLeft = rect2.left - parent.scrollLeft * parentScaleX;
      parentTop = rect2.top - parent.scrollTop * parentScaleY;
    }
    this.element.style.left = (rect.left - parentLeft) / scaleX + "px";
    this.element.style.top = (rect.top - parentTop) / scaleY + "px";
    this.element.style.width = (rect.right - rect.left) / scaleX + "px";
    this.element.style.height = (rect.bottom - rect.top) / scaleY + "px";
  }
  scheduleRemoval(timeout) {
    clearTimeout(this.timeout);
    this.timeout = setTimeout(() => this.setCursor(null), timeout);
  }
  dragover(event) {
    if (!this.editorView.editable)
      return;
    let pos = this.editorView.posAtCoords({ left: event.clientX, top: event.clientY });
    let node = pos && pos.inside >= 0 && this.editorView.state.doc.nodeAt(pos.inside);
    let disableDropCursor = node && node.type.spec.disableDropCursor;
    let disabled = typeof disableDropCursor == "function" ? disableDropCursor(this.editorView, pos, event) : disableDropCursor;
    if (pos && !disabled) {
      let target = pos.pos;
      if (this.editorView.dragging && this.editorView.dragging.slice) {
        let point = dropPoint(this.editorView.state.doc, target, this.editorView.dragging.slice);
        if (point != null)
          target = point;
      }
      this.setCursor(target);
      this.scheduleRemoval(5000);
    }
  }
  dragend() {
    this.scheduleRemoval(20);
  }
  drop() {
    this.scheduleRemoval(20);
  }
  dragleave(event) {
    if (!this.editorView.dom.contains(event.relatedTarget))
      this.setCursor(null);
  }
}
// node_modules/@tiptap/extension-dropcursor/dist/index.js
var Dropcursor = Extension.create({
  name: "dropCursor",
  addOptions() {
    return {
      color: "currentColor",
      width: 1,
      class: undefined
    };
  },
  addProseMirrorPlugins() {
    return [
      dropCursor(this.options)
    ];
  }
});

// node_modules/prosemirror-gapcursor/dist/index.js
class GapCursor extends Selection {
  constructor($pos) {
    super($pos, $pos);
  }
  map(doc3, mapping) {
    let $pos = doc3.resolve(mapping.map(this.head));
    return GapCursor.valid($pos) ? new GapCursor($pos) : Selection.near($pos);
  }
  content() {
    return Slice.empty;
  }
  eq(other) {
    return other instanceof GapCursor && other.head == this.head;
  }
  toJSON() {
    return { type: "gapcursor", pos: this.head };
  }
  static fromJSON(doc3, json) {
    if (typeof json.pos != "number")
      throw new RangeError("Invalid input for GapCursor.fromJSON");
    return new GapCursor(doc3.resolve(json.pos));
  }
  getBookmark() {
    return new GapBookmark(this.anchor);
  }
  static valid($pos) {
    let parent = $pos.parent;
    if (parent.isTextblock || !closedBefore($pos) || !closedAfter($pos))
      return false;
    let override = parent.type.spec.allowGapCursor;
    if (override != null)
      return override;
    let deflt = parent.contentMatchAt($pos.index()).defaultType;
    return deflt && deflt.isTextblock;
  }
  static findGapCursorFrom($pos, dir, mustMove = false) {
    search:
      for (;; ) {
        if (!mustMove && GapCursor.valid($pos))
          return $pos;
        let pos = $pos.pos, next = null;
        for (let d = $pos.depth;; d--) {
          let parent = $pos.node(d);
          if (dir > 0 ? $pos.indexAfter(d) < parent.childCount : $pos.index(d) > 0) {
            next = parent.child(dir > 0 ? $pos.indexAfter(d) : $pos.index(d) - 1);
            break;
          } else if (d == 0) {
            return null;
          }
          pos += dir;
          let $cur = $pos.doc.resolve(pos);
          if (GapCursor.valid($cur))
            return $cur;
        }
        for (;; ) {
          let inside = dir > 0 ? next.firstChild : next.lastChild;
          if (!inside) {
            if (next.isAtom && !next.isText && !NodeSelection.isSelectable(next)) {
              $pos = $pos.doc.resolve(pos + next.nodeSize * dir);
              mustMove = false;
              continue search;
            }
            break;
          }
          next = inside;
          pos += dir;
          let $cur = $pos.doc.resolve(pos);
          if (GapCursor.valid($cur))
            return $cur;
        }
        return null;
      }
  }
}
GapCursor.prototype.visible = false;
GapCursor.findFrom = GapCursor.findGapCursorFrom;
Selection.jsonID("gapcursor", GapCursor);

class GapBookmark {
  constructor(pos) {
    this.pos = pos;
  }
  map(mapping) {
    return new GapBookmark(mapping.map(this.pos));
  }
  resolve(doc3) {
    let $pos = doc3.resolve(this.pos);
    return GapCursor.valid($pos) ? new GapCursor($pos) : Selection.near($pos);
  }
}
function needsGap(type) {
  return type.isAtom || type.spec.isolating || type.spec.createGapCursor;
}
function closedBefore($pos) {
  for (let d = $pos.depth;d >= 0; d--) {
    let index = $pos.index(d), parent = $pos.node(d);
    if (index == 0) {
      if (parent.type.spec.isolating)
        return true;
      continue;
    }
    for (let before = parent.child(index - 1);; before = before.lastChild) {
      if (before.childCount == 0 && !before.inlineContent || needsGap(before.type))
        return true;
      if (before.inlineContent)
        return false;
    }
  }
  return true;
}
function closedAfter($pos) {
  for (let d = $pos.depth;d >= 0; d--) {
    let index = $pos.indexAfter(d), parent = $pos.node(d);
    if (index == parent.childCount) {
      if (parent.type.spec.isolating)
        return true;
      continue;
    }
    for (let after = parent.child(index);; after = after.firstChild) {
      if (after.childCount == 0 && !after.inlineContent || needsGap(after.type))
        return true;
      if (after.inlineContent)
        return false;
    }
  }
  return true;
}
function gapCursor() {
  return new Plugin({
    props: {
      decorations: drawGapCursor,
      createSelectionBetween(_view, $anchor, $head) {
        return $anchor.pos == $head.pos && GapCursor.valid($head) ? new GapCursor($head) : null;
      },
      handleClick,
      handleKeyDown,
      handleDOMEvents: { beforeinput }
    }
  });
}
var handleKeyDown = keydownHandler({
  ArrowLeft: arrow("horiz", -1),
  ArrowRight: arrow("horiz", 1),
  ArrowUp: arrow("vert", -1),
  ArrowDown: arrow("vert", 1)
});
function arrow(axis, dir) {
  const dirStr = axis == "vert" ? dir > 0 ? "down" : "up" : dir > 0 ? "right" : "left";
  return function(state, dispatch, view) {
    let sel = state.selection;
    let $start = dir > 0 ? sel.$to : sel.$from, mustMove = sel.empty;
    if (sel instanceof TextSelection) {
      if (!view.endOfTextblock(dirStr) || $start.depth == 0)
        return false;
      mustMove = false;
      $start = state.doc.resolve(dir > 0 ? $start.after() : $start.before());
    }
    let $found = GapCursor.findGapCursorFrom($start, dir, mustMove);
    if (!$found)
      return false;
    if (dispatch)
      dispatch(state.tr.setSelection(new GapCursor($found)));
    return true;
  };
}
function handleClick(view, pos, event) {
  if (!view || !view.editable)
    return false;
  let $pos = view.state.doc.resolve(pos);
  if (!GapCursor.valid($pos))
    return false;
  let clickPos = view.posAtCoords({ left: event.clientX, top: event.clientY });
  if (clickPos && clickPos.inside > -1 && NodeSelection.isSelectable(view.state.doc.nodeAt(clickPos.inside)))
    return false;
  view.dispatch(view.state.tr.setSelection(new GapCursor($pos)));
  return true;
}
function beforeinput(view, event) {
  if (event.inputType != "insertCompositionText" || !(view.state.selection instanceof GapCursor))
    return false;
  let { $from } = view.state.selection;
  let insert = $from.parent.contentMatchAt($from.index()).findWrapping(view.state.schema.nodes.text);
  if (!insert)
    return false;
  let frag = Fragment.empty;
  for (let i2 = insert.length - 1;i2 >= 0; i2--)
    frag = Fragment.from(insert[i2].createAndFill(null, frag));
  let tr = view.state.tr.replace($from.pos, $from.pos, new Slice(frag, 0, 0));
  tr.setSelection(TextSelection.near(tr.doc.resolve($from.pos + 1)));
  view.dispatch(tr);
  return false;
}
function drawGapCursor(state) {
  if (!(state.selection instanceof GapCursor))
    return null;
  let node = document.createElement("div");
  node.className = "ProseMirror-gapcursor";
  return DecorationSet.create(state.doc, [Decoration.widget(state.selection.head, node, { key: "gapcursor" })]);
}
// node_modules/@tiptap/extension-gapcursor/dist/index.js
var Gapcursor = Extension.create({
  name: "gapCursor",
  addProseMirrorPlugins() {
    return [
      gapCursor()
    ];
  },
  extendNodeSchema(extension) {
    var _a;
    const context = {
      name: extension.name,
      options: extension.options,
      storage: extension.storage
    };
    return {
      allowGapCursor: (_a = callOrReturn(getExtensionField(extension, "allowGapCursor", context))) !== null && _a !== undefined ? _a : null
    };
  }
});

// node_modules/@tiptap/extension-hard-break/dist/index.js
var HardBreak = Node3.create({
  name: "hardBreak",
  addOptions() {
    return {
      keepMarks: true,
      HTMLAttributes: {}
    };
  },
  inline: true,
  group: "inline",
  selectable: false,
  linebreakReplacement: true,
  parseHTML() {
    return [
      { tag: "br" }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["br", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes)];
  },
  renderText() {
    return `
`;
  },
  addCommands() {
    return {
      setHardBreak: () => ({ commands: commands2, chain, state, editor }) => {
        return commands2.first([
          () => commands2.exitCode(),
          () => commands2.command(() => {
            const { selection, storedMarks } = state;
            if (selection.$from.parent.type.spec.isolating) {
              return false;
            }
            const { keepMarks } = this.options;
            const { splittableMarks } = editor.extensionManager;
            const marks = storedMarks || selection.$to.parentOffset && selection.$from.marks();
            return chain().insertContent({ type: this.name }).command(({ tr, dispatch }) => {
              if (dispatch && marks && keepMarks) {
                const filteredMarks = marks.filter((mark) => splittableMarks.includes(mark.type.name));
                tr.ensureMarks(filteredMarks);
              }
              return true;
            }).run();
          })
        ]);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Enter": () => this.editor.commands.setHardBreak(),
      "Shift-Enter": () => this.editor.commands.setHardBreak()
    };
  }
});

// node_modules/@tiptap/extension-heading/dist/index.js
var Heading = Node3.create({
  name: "heading",
  addOptions() {
    return {
      levels: [1, 2, 3, 4, 5, 6],
      HTMLAttributes: {}
    };
  },
  content: "inline*",
  group: "block",
  defining: true,
  addAttributes() {
    return {
      level: {
        default: 1,
        rendered: false
      }
    };
  },
  parseHTML() {
    return this.options.levels.map((level) => ({
      tag: `h${level}`,
      attrs: { level }
    }));
  },
  renderHTML({ node, HTMLAttributes }) {
    const hasLevel = this.options.levels.includes(node.attrs.level);
    const level = hasLevel ? node.attrs.level : this.options.levels[0];
    return [`h${level}`, mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      setHeading: (attributes) => ({ commands: commands2 }) => {
        if (!this.options.levels.includes(attributes.level)) {
          return false;
        }
        return commands2.setNode(this.name, attributes);
      },
      toggleHeading: (attributes) => ({ commands: commands2 }) => {
        if (!this.options.levels.includes(attributes.level)) {
          return false;
        }
        return commands2.toggleNode(this.name, "paragraph", attributes);
      }
    };
  },
  addKeyboardShortcuts() {
    return this.options.levels.reduce((items, level) => ({
      ...items,
      ...{
        [`Mod-Alt-${level}`]: () => this.editor.commands.toggleHeading({ level })
      }
    }), {});
  },
  addInputRules() {
    return this.options.levels.map((level) => {
      return textblockTypeInputRule({
        find: new RegExp(`^(#{${Math.min(...this.options.levels)},${level}})\\s$`),
        type: this.type,
        getAttributes: {
          level
        }
      });
    });
  }
});

// node_modules/rope-sequence/dist/index.js
var GOOD_LEAF_SIZE = 200;
var RopeSequence = function RopeSequence2() {};
RopeSequence.prototype.append = function append(other) {
  if (!other.length) {
    return this;
  }
  other = RopeSequence.from(other);
  return !this.length && other || other.length < GOOD_LEAF_SIZE && this.leafAppend(other) || this.length < GOOD_LEAF_SIZE && other.leafPrepend(this) || this.appendInner(other);
};
RopeSequence.prototype.prepend = function prepend(other) {
  if (!other.length) {
    return this;
  }
  return RopeSequence.from(other).append(this);
};
RopeSequence.prototype.appendInner = function appendInner(other) {
  return new Append(this, other);
};
RopeSequence.prototype.slice = function slice(from, to) {
  if (from === undefined)
    from = 0;
  if (to === undefined)
    to = this.length;
  if (from >= to) {
    return RopeSequence.empty;
  }
  return this.sliceInner(Math.max(0, from), Math.min(this.length, to));
};
RopeSequence.prototype.get = function get(i2) {
  if (i2 < 0 || i2 >= this.length) {
    return;
  }
  return this.getInner(i2);
};
RopeSequence.prototype.forEach = function forEach2(f, from, to) {
  if (from === undefined)
    from = 0;
  if (to === undefined)
    to = this.length;
  if (from <= to) {
    this.forEachInner(f, from, to, 0);
  } else {
    this.forEachInvertedInner(f, from, to, 0);
  }
};
RopeSequence.prototype.map = function map(f, from, to) {
  if (from === undefined)
    from = 0;
  if (to === undefined)
    to = this.length;
  var result = [];
  this.forEach(function(elt, i2) {
    return result.push(f(elt, i2));
  }, from, to);
  return result;
};
RopeSequence.from = function from(values) {
  if (values instanceof RopeSequence) {
    return values;
  }
  return values && values.length ? new Leaf(values) : RopeSequence.empty;
};
var Leaf = /* @__PURE__ */ function(RopeSequence3) {
  function Leaf2(values) {
    RopeSequence3.call(this);
    this.values = values;
  }
  if (RopeSequence3)
    Leaf2.__proto__ = RopeSequence3;
  Leaf2.prototype = Object.create(RopeSequence3 && RopeSequence3.prototype);
  Leaf2.prototype.constructor = Leaf2;
  var prototypeAccessors = { length: { configurable: true }, depth: { configurable: true } };
  Leaf2.prototype.flatten = function flatten() {
    return this.values;
  };
  Leaf2.prototype.sliceInner = function sliceInner(from2, to) {
    if (from2 == 0 && to == this.length) {
      return this;
    }
    return new Leaf2(this.values.slice(from2, to));
  };
  Leaf2.prototype.getInner = function getInner(i2) {
    return this.values[i2];
  };
  Leaf2.prototype.forEachInner = function forEachInner(f, from2, to, start) {
    for (var i2 = from2;i2 < to; i2++) {
      if (f(this.values[i2], start + i2) === false) {
        return false;
      }
    }
  };
  Leaf2.prototype.forEachInvertedInner = function forEachInvertedInner(f, from2, to, start) {
    for (var i2 = from2 - 1;i2 >= to; i2--) {
      if (f(this.values[i2], start + i2) === false) {
        return false;
      }
    }
  };
  Leaf2.prototype.leafAppend = function leafAppend(other) {
    if (this.length + other.length <= GOOD_LEAF_SIZE) {
      return new Leaf2(this.values.concat(other.flatten()));
    }
  };
  Leaf2.prototype.leafPrepend = function leafPrepend(other) {
    if (this.length + other.length <= GOOD_LEAF_SIZE) {
      return new Leaf2(other.flatten().concat(this.values));
    }
  };
  prototypeAccessors.length.get = function() {
    return this.values.length;
  };
  prototypeAccessors.depth.get = function() {
    return 0;
  };
  Object.defineProperties(Leaf2.prototype, prototypeAccessors);
  return Leaf2;
}(RopeSequence);
RopeSequence.empty = new Leaf([]);
var Append = /* @__PURE__ */ function(RopeSequence3) {
  function Append2(left, right) {
    RopeSequence3.call(this);
    this.left = left;
    this.right = right;
    this.length = left.length + right.length;
    this.depth = Math.max(left.depth, right.depth) + 1;
  }
  if (RopeSequence3)
    Append2.__proto__ = RopeSequence3;
  Append2.prototype = Object.create(RopeSequence3 && RopeSequence3.prototype);
  Append2.prototype.constructor = Append2;
  Append2.prototype.flatten = function flatten() {
    return this.left.flatten().concat(this.right.flatten());
  };
  Append2.prototype.getInner = function getInner(i2) {
    return i2 < this.left.length ? this.left.get(i2) : this.right.get(i2 - this.left.length);
  };
  Append2.prototype.forEachInner = function forEachInner(f, from2, to, start) {
    var leftLen = this.left.length;
    if (from2 < leftLen && this.left.forEachInner(f, from2, Math.min(to, leftLen), start) === false) {
      return false;
    }
    if (to > leftLen && this.right.forEachInner(f, Math.max(from2 - leftLen, 0), Math.min(this.length, to) - leftLen, start + leftLen) === false) {
      return false;
    }
  };
  Append2.prototype.forEachInvertedInner = function forEachInvertedInner(f, from2, to, start) {
    var leftLen = this.left.length;
    if (from2 > leftLen && this.right.forEachInvertedInner(f, from2 - leftLen, Math.max(to, leftLen) - leftLen, start + leftLen) === false) {
      return false;
    }
    if (to < leftLen && this.left.forEachInvertedInner(f, Math.min(from2, leftLen), to, start) === false) {
      return false;
    }
  };
  Append2.prototype.sliceInner = function sliceInner(from2, to) {
    if (from2 == 0 && to == this.length) {
      return this;
    }
    var leftLen = this.left.length;
    if (to <= leftLen) {
      return this.left.slice(from2, to);
    }
    if (from2 >= leftLen) {
      return this.right.slice(from2 - leftLen, to - leftLen);
    }
    return this.left.slice(from2, leftLen).append(this.right.slice(0, to - leftLen));
  };
  Append2.prototype.leafAppend = function leafAppend(other) {
    var inner = this.right.leafAppend(other);
    if (inner) {
      return new Append2(this.left, inner);
    }
  };
  Append2.prototype.leafPrepend = function leafPrepend(other) {
    var inner = this.left.leafPrepend(other);
    if (inner) {
      return new Append2(inner, this.right);
    }
  };
  Append2.prototype.appendInner = function appendInner(other) {
    if (this.left.depth >= Math.max(this.right.depth, other.depth) + 1) {
      return new Append2(this.left, new Append2(this.right, other));
    }
    return new Append2(this, other);
  };
  return Append2;
}(RopeSequence);
var dist_default2 = RopeSequence;

// node_modules/prosemirror-history/dist/index.js
var max_empty_items = 500;

class Branch {
  constructor(items, eventCount) {
    this.items = items;
    this.eventCount = eventCount;
  }
  popEvent(state, preserveItems) {
    if (this.eventCount == 0)
      return null;
    let end = this.items.length;
    for (;; end--) {
      let next = this.items.get(end - 1);
      if (next.selection) {
        --end;
        break;
      }
    }
    let remap, mapFrom;
    if (preserveItems) {
      remap = this.remapping(end, this.items.length);
      mapFrom = remap.maps.length;
    }
    let transform = state.tr;
    let selection, remaining;
    let addAfter = [], addBefore = [];
    this.items.forEach((item, i2) => {
      if (!item.step) {
        if (!remap) {
          remap = this.remapping(end, i2 + 1);
          mapFrom = remap.maps.length;
        }
        mapFrom--;
        addBefore.push(item);
        return;
      }
      if (remap) {
        addBefore.push(new Item(item.map));
        let step = item.step.map(remap.slice(mapFrom)), map2;
        if (step && transform.maybeStep(step).doc) {
          map2 = transform.mapping.maps[transform.mapping.maps.length - 1];
          addAfter.push(new Item(map2, undefined, undefined, addAfter.length + addBefore.length));
        }
        mapFrom--;
        if (map2)
          remap.appendMap(map2, mapFrom);
      } else {
        transform.maybeStep(item.step);
      }
      if (item.selection) {
        selection = remap ? item.selection.map(remap.slice(mapFrom)) : item.selection;
        remaining = new Branch(this.items.slice(0, end).append(addBefore.reverse().concat(addAfter)), this.eventCount - 1);
        return false;
      }
    }, this.items.length, 0);
    return { remaining, transform, selection };
  }
  addTransform(transform, selection, histOptions, preserveItems) {
    let newItems = [], eventCount = this.eventCount;
    let oldItems = this.items, lastItem = !preserveItems && oldItems.length ? oldItems.get(oldItems.length - 1) : null;
    for (let i2 = 0;i2 < transform.steps.length; i2++) {
      let step = transform.steps[i2].invert(transform.docs[i2]);
      let item = new Item(transform.mapping.maps[i2], step, selection), merged;
      if (merged = lastItem && lastItem.merge(item)) {
        item = merged;
        if (i2)
          newItems.pop();
        else
          oldItems = oldItems.slice(0, oldItems.length - 1);
      }
      newItems.push(item);
      if (selection) {
        eventCount++;
        selection = undefined;
      }
      if (!preserveItems)
        lastItem = item;
    }
    let overflow = eventCount - histOptions.depth;
    if (overflow > DEPTH_OVERFLOW) {
      oldItems = cutOffEvents(oldItems, overflow);
      eventCount -= overflow;
    }
    return new Branch(oldItems.append(newItems), eventCount);
  }
  remapping(from2, to) {
    let maps = new Mapping;
    this.items.forEach((item, i2) => {
      let mirrorPos = item.mirrorOffset != null && i2 - item.mirrorOffset >= from2 ? maps.maps.length - item.mirrorOffset : undefined;
      maps.appendMap(item.map, mirrorPos);
    }, from2, to);
    return maps;
  }
  addMaps(array) {
    if (this.eventCount == 0)
      return this;
    return new Branch(this.items.append(array.map((map2) => new Item(map2))), this.eventCount);
  }
  rebased(rebasedTransform, rebasedCount) {
    if (!this.eventCount)
      return this;
    let rebasedItems = [], start = Math.max(0, this.items.length - rebasedCount);
    let mapping = rebasedTransform.mapping;
    let newUntil = rebasedTransform.steps.length;
    let eventCount = this.eventCount;
    this.items.forEach((item) => {
      if (item.selection)
        eventCount--;
    }, start);
    let iRebased = rebasedCount;
    this.items.forEach((item) => {
      let pos = mapping.getMirror(--iRebased);
      if (pos == null)
        return;
      newUntil = Math.min(newUntil, pos);
      let map2 = mapping.maps[pos];
      if (item.step) {
        let step = rebasedTransform.steps[pos].invert(rebasedTransform.docs[pos]);
        let selection = item.selection && item.selection.map(mapping.slice(iRebased + 1, pos));
        if (selection)
          eventCount++;
        rebasedItems.push(new Item(map2, step, selection));
      } else {
        rebasedItems.push(new Item(map2));
      }
    }, start);
    let newMaps = [];
    for (let i2 = rebasedCount;i2 < newUntil; i2++)
      newMaps.push(new Item(mapping.maps[i2]));
    let items = this.items.slice(0, start).append(newMaps).append(rebasedItems);
    let branch = new Branch(items, eventCount);
    if (branch.emptyItemCount() > max_empty_items)
      branch = branch.compress(this.items.length - rebasedItems.length);
    return branch;
  }
  emptyItemCount() {
    let count = 0;
    this.items.forEach((item) => {
      if (!item.step)
        count++;
    });
    return count;
  }
  compress(upto = this.items.length) {
    let remap = this.remapping(0, upto), mapFrom = remap.maps.length;
    let items = [], events = 0;
    this.items.forEach((item, i2) => {
      if (i2 >= upto) {
        items.push(item);
        if (item.selection)
          events++;
      } else if (item.step) {
        let step = item.step.map(remap.slice(mapFrom)), map2 = step && step.getMap();
        mapFrom--;
        if (map2)
          remap.appendMap(map2, mapFrom);
        if (step) {
          let selection = item.selection && item.selection.map(remap.slice(mapFrom));
          if (selection)
            events++;
          let newItem = new Item(map2.invert(), step, selection), merged, last = items.length - 1;
          if (merged = items.length && items[last].merge(newItem))
            items[last] = merged;
          else
            items.push(newItem);
        }
      } else if (item.map) {
        mapFrom--;
      }
    }, this.items.length, 0);
    return new Branch(dist_default2.from(items.reverse()), events);
  }
}
Branch.empty = new Branch(dist_default2.empty, 0);
function cutOffEvents(items, n) {
  let cutPoint;
  items.forEach((item, i2) => {
    if (item.selection && n-- == 0) {
      cutPoint = i2;
      return false;
    }
  });
  return items.slice(cutPoint);
}

class Item {
  constructor(map2, step, selection, mirrorOffset) {
    this.map = map2;
    this.step = step;
    this.selection = selection;
    this.mirrorOffset = mirrorOffset;
  }
  merge(other) {
    if (this.step && other.step && !other.selection) {
      let step = other.step.merge(this.step);
      if (step)
        return new Item(step.getMap().invert(), step, this.selection);
    }
  }
}

class HistoryState {
  constructor(done, undone, prevRanges, prevTime, prevComposition) {
    this.done = done;
    this.undone = undone;
    this.prevRanges = prevRanges;
    this.prevTime = prevTime;
    this.prevComposition = prevComposition;
  }
}
var DEPTH_OVERFLOW = 20;
function applyTransaction(history, state, tr, options) {
  let historyTr = tr.getMeta(historyKey), rebased;
  if (historyTr)
    return historyTr.historyState;
  if (tr.getMeta(closeHistoryKey))
    history = new HistoryState(history.done, history.undone, null, 0, -1);
  let appended = tr.getMeta("appendedTransaction");
  if (tr.steps.length == 0) {
    return history;
  } else if (appended && appended.getMeta(historyKey)) {
    if (appended.getMeta(historyKey).redo)
      return new HistoryState(history.done.addTransform(tr, undefined, options, mustPreserveItems(state)), history.undone, rangesFor(tr.mapping.maps), history.prevTime, history.prevComposition);
    else
      return new HistoryState(history.done, history.undone.addTransform(tr, undefined, options, mustPreserveItems(state)), null, history.prevTime, history.prevComposition);
  } else if (tr.getMeta("addToHistory") !== false && !(appended && appended.getMeta("addToHistory") === false)) {
    let composition = tr.getMeta("composition");
    let newGroup = history.prevTime == 0 || !appended && history.prevComposition != composition && (history.prevTime < (tr.time || 0) - options.newGroupDelay || !isAdjacentTo(tr, history.prevRanges));
    let prevRanges = appended ? mapRanges(history.prevRanges, tr.mapping) : rangesFor(tr.mapping.maps);
    return new HistoryState(history.done.addTransform(tr, newGroup ? state.selection.getBookmark() : undefined, options, mustPreserveItems(state)), Branch.empty, prevRanges, tr.time, composition == null ? history.prevComposition : composition);
  } else if (rebased = tr.getMeta("rebased")) {
    return new HistoryState(history.done.rebased(tr, rebased), history.undone.rebased(tr, rebased), mapRanges(history.prevRanges, tr.mapping), history.prevTime, history.prevComposition);
  } else {
    return new HistoryState(history.done.addMaps(tr.mapping.maps), history.undone.addMaps(tr.mapping.maps), mapRanges(history.prevRanges, tr.mapping), history.prevTime, history.prevComposition);
  }
}
function isAdjacentTo(transform, prevRanges) {
  if (!prevRanges)
    return false;
  if (!transform.docChanged)
    return true;
  let adjacent = false;
  transform.mapping.maps[0].forEach((start, end) => {
    for (let i2 = 0;i2 < prevRanges.length; i2 += 2)
      if (start <= prevRanges[i2 + 1] && end >= prevRanges[i2])
        adjacent = true;
  });
  return adjacent;
}
function rangesFor(maps) {
  let result = [];
  for (let i2 = maps.length - 1;i2 >= 0 && result.length == 0; i2--)
    maps[i2].forEach((_from, _to, from2, to) => result.push(from2, to));
  return result;
}
function mapRanges(ranges, mapping) {
  if (!ranges)
    return null;
  let result = [];
  for (let i2 = 0;i2 < ranges.length; i2 += 2) {
    let from2 = mapping.map(ranges[i2], 1), to = mapping.map(ranges[i2 + 1], -1);
    if (from2 <= to)
      result.push(from2, to);
  }
  return result;
}
function histTransaction(history, state, redo) {
  let preserveItems = mustPreserveItems(state);
  let histOptions = historyKey.get(state).spec.config;
  let pop = (redo ? history.undone : history.done).popEvent(state, preserveItems);
  if (!pop)
    return null;
  let selection = pop.selection.resolve(pop.transform.doc);
  let added = (redo ? history.done : history.undone).addTransform(pop.transform, state.selection.getBookmark(), histOptions, preserveItems);
  let newHist = new HistoryState(redo ? added : pop.remaining, redo ? pop.remaining : added, null, 0, -1);
  return pop.transform.setSelection(selection).setMeta(historyKey, { redo, historyState: newHist });
}
var cachedPreserveItems = false;
var cachedPreserveItemsPlugins = null;
function mustPreserveItems(state) {
  let plugins = state.plugins;
  if (cachedPreserveItemsPlugins != plugins) {
    cachedPreserveItems = false;
    cachedPreserveItemsPlugins = plugins;
    for (let i2 = 0;i2 < plugins.length; i2++)
      if (plugins[i2].spec.historyPreserveItems) {
        cachedPreserveItems = true;
        break;
      }
  }
  return cachedPreserveItems;
}
var historyKey = new PluginKey("history");
var closeHistoryKey = new PluginKey("closeHistory");
function history(config = {}) {
  config = {
    depth: config.depth || 100,
    newGroupDelay: config.newGroupDelay || 500
  };
  return new Plugin({
    key: historyKey,
    state: {
      init() {
        return new HistoryState(Branch.empty, Branch.empty, null, 0, -1);
      },
      apply(tr, hist, state) {
        return applyTransaction(hist, state, tr, config);
      }
    },
    config,
    props: {
      handleDOMEvents: {
        beforeinput(view, e) {
          let inputType = e.inputType;
          let command2 = inputType == "historyUndo" ? undo : inputType == "historyRedo" ? redo : null;
          if (!command2 || !view.editable)
            return false;
          e.preventDefault();
          return command2(view.state, view.dispatch);
        }
      }
    }
  });
}
function buildCommand(redo, scroll) {
  return (state, dispatch) => {
    let hist = historyKey.getState(state);
    if (!hist || (redo ? hist.undone : hist.done).eventCount == 0)
      return false;
    if (dispatch) {
      let tr = histTransaction(hist, state, redo);
      if (tr)
        dispatch(scroll ? tr.scrollIntoView() : tr);
    }
    return true;
  };
}
var undo = buildCommand(false, true);
var redo = buildCommand(true, true);
var undoNoScroll = buildCommand(false, false);
var redoNoScroll = buildCommand(true, false);
// node_modules/@tiptap/extension-history/dist/index.js
var History = Extension.create({
  name: "history",
  addOptions() {
    return {
      depth: 100,
      newGroupDelay: 500
    };
  },
  addCommands() {
    return {
      undo: () => ({ state, dispatch }) => {
        return undo(state, dispatch);
      },
      redo: () => ({ state, dispatch }) => {
        return redo(state, dispatch);
      }
    };
  },
  addProseMirrorPlugins() {
    return [
      history(this.options)
    ];
  },
  addKeyboardShortcuts() {
    return {
      "Mod-z": () => this.editor.commands.undo(),
      "Shift-Mod-z": () => this.editor.commands.redo(),
      "Mod-y": () => this.editor.commands.redo(),
      "Mod-": () => this.editor.commands.undo(),
      "Shift-Mod-": () => this.editor.commands.redo()
    };
  }
});

// node_modules/@tiptap/extension-horizontal-rule/dist/index.js
var HorizontalRule = Node3.create({
  name: "horizontalRule",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  group: "block",
  parseHTML() {
    return [{ tag: "hr" }];
  },
  renderHTML({ HTMLAttributes }) {
    return ["hr", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes)];
  },
  addCommands() {
    return {
      setHorizontalRule: () => ({ chain, state }) => {
        if (!canInsertNode(state, state.schema.nodes[this.name])) {
          return false;
        }
        const { selection } = state;
        const { $from: $originFrom, $to: $originTo } = selection;
        const currentChain = chain();
        if ($originFrom.parentOffset === 0) {
          currentChain.insertContentAt({
            from: Math.max($originFrom.pos - 1, 0),
            to: $originTo.pos
          }, {
            type: this.name
          });
        } else if (isNodeSelection(selection)) {
          currentChain.insertContentAt($originTo.pos, {
            type: this.name
          });
        } else {
          currentChain.insertContent({ type: this.name });
        }
        return currentChain.command(({ tr, dispatch }) => {
          var _a;
          if (dispatch) {
            const { $to } = tr.selection;
            const posAfter = $to.end();
            if ($to.nodeAfter) {
              if ($to.nodeAfter.isTextblock) {
                tr.setSelection(TextSelection.create(tr.doc, $to.pos + 1));
              } else if ($to.nodeAfter.isBlock) {
                tr.setSelection(NodeSelection.create(tr.doc, $to.pos));
              } else {
                tr.setSelection(TextSelection.create(tr.doc, $to.pos));
              }
            } else {
              const node = (_a = $to.parent.type.contentMatch.defaultType) === null || _a === undefined ? undefined : _a.create();
              if (node) {
                tr.insert(posAfter, node);
                tr.setSelection(TextSelection.create(tr.doc, posAfter + 1));
              }
            }
            tr.scrollIntoView();
          }
          return true;
        }).run();
      }
    };
  },
  addInputRules() {
    return [
      nodeInputRule({
        find: /^(?:---|-|___\s|\*\*\*\s)$/,
        type: this.type
      })
    ];
  }
});

// node_modules/@tiptap/extension-italic/dist/index.js
var starInputRegex2 = /(?:^|\s)(\*(?!\s+\*)((?:[^*]+))\*(?!\s+\*))$/;
var starPasteRegex2 = /(?:^|\s)(\*(?!\s+\*)((?:[^*]+))\*(?!\s+\*))/g;
var underscoreInputRegex2 = /(?:^|\s)(_(?!\s+_)((?:[^_]+))_(?!\s+_))$/;
var underscorePasteRegex2 = /(?:^|\s)(_(?!\s+_)((?:[^_]+))_(?!\s+_))/g;
var Italic = Mark2.create({
  name: "italic",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "em"
      },
      {
        tag: "i",
        getAttrs: (node) => node.style.fontStyle !== "normal" && null
      },
      {
        style: "font-style=normal",
        clearMark: (mark) => mark.type.name === this.name
      },
      {
        style: "font-style=italic"
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["em", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      setItalic: () => ({ commands: commands2 }) => {
        return commands2.setMark(this.name);
      },
      toggleItalic: () => ({ commands: commands2 }) => {
        return commands2.toggleMark(this.name);
      },
      unsetItalic: () => ({ commands: commands2 }) => {
        return commands2.unsetMark(this.name);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-i": () => this.editor.commands.toggleItalic(),
      "Mod-I": () => this.editor.commands.toggleItalic()
    };
  },
  addInputRules() {
    return [
      markInputRule({
        find: starInputRegex2,
        type: this.type
      }),
      markInputRule({
        find: underscoreInputRegex2,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      markPasteRule({
        find: starPasteRegex2,
        type: this.type
      }),
      markPasteRule({
        find: underscorePasteRegex2,
        type: this.type
      })
    ];
  }
});

// node_modules/@tiptap/extension-list-item/dist/index.js
var ListItem = Node3.create({
  name: "listItem",
  addOptions() {
    return {
      HTMLAttributes: {},
      bulletListTypeName: "bulletList",
      orderedListTypeName: "orderedList"
    };
  },
  content: "paragraph block*",
  defining: true,
  parseHTML() {
    return [
      {
        tag: "li"
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["li", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addKeyboardShortcuts() {
    return {
      Enter: () => this.editor.commands.splitListItem(this.name),
      Tab: () => this.editor.commands.sinkListItem(this.name),
      "Shift-Tab": () => this.editor.commands.liftListItem(this.name)
    };
  }
});

// node_modules/@tiptap/extension-ordered-list/dist/index.js
var ListItemName2 = "listItem";
var TextStyleName2 = "textStyle";
var inputRegex4 = /^(\d+)\.\s$/;
var OrderedList = Node3.create({
  name: "orderedList",
  addOptions() {
    return {
      itemTypeName: "listItem",
      HTMLAttributes: {},
      keepMarks: false,
      keepAttributes: false
    };
  },
  group: "block list",
  content() {
    return `${this.options.itemTypeName}+`;
  },
  addAttributes() {
    return {
      start: {
        default: 1,
        parseHTML: (element) => {
          return element.hasAttribute("start") ? parseInt(element.getAttribute("start") || "", 10) : 1;
        }
      },
      type: {
        default: null,
        parseHTML: (element) => element.getAttribute("type")
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: "ol"
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    const { start, ...attributesWithoutStart } = HTMLAttributes;
    return start === 1 ? ["ol", mergeAttributes(this.options.HTMLAttributes, attributesWithoutStart), 0] : ["ol", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      toggleOrderedList: () => ({ commands: commands2, chain }) => {
        if (this.options.keepAttributes) {
          return chain().toggleList(this.name, this.options.itemTypeName, this.options.keepMarks).updateAttributes(ListItemName2, this.editor.getAttributes(TextStyleName2)).run();
        }
        return commands2.toggleList(this.name, this.options.itemTypeName, this.options.keepMarks);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-7": () => this.editor.commands.toggleOrderedList()
    };
  },
  addInputRules() {
    let inputRule = wrappingInputRule({
      find: inputRegex4,
      type: this.type,
      getAttributes: (match) => ({ start: +match[1] }),
      joinPredicate: (match, node) => node.childCount + node.attrs.start === +match[1]
    });
    if (this.options.keepMarks || this.options.keepAttributes) {
      inputRule = wrappingInputRule({
        find: inputRegex4,
        type: this.type,
        keepMarks: this.options.keepMarks,
        keepAttributes: this.options.keepAttributes,
        getAttributes: (match) => ({ start: +match[1], ...this.editor.getAttributes(TextStyleName2) }),
        joinPredicate: (match, node) => node.childCount + node.attrs.start === +match[1],
        editor: this.editor
      });
    }
    return [
      inputRule
    ];
  }
});

// node_modules/@tiptap/extension-paragraph/dist/index.js
var Paragraph = Node3.create({
  name: "paragraph",
  priority: 1000,
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  group: "block",
  content: "inline*",
  parseHTML() {
    return [
      { tag: "p" }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["p", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      setParagraph: () => ({ commands: commands2 }) => {
        return commands2.setNode(this.name);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Alt-0": () => this.editor.commands.setParagraph()
    };
  }
});

// node_modules/@tiptap/extension-strike/dist/index.js
var inputRegex5 = /(?:^|\s)(~~(?!\s+~~)((?:[^~]+))~~(?!\s+~~))$/;
var pasteRegex2 = /(?:^|\s)(~~(?!\s+~~)((?:[^~]+))~~(?!\s+~~))/g;
var Strike = Mark2.create({
  name: "strike",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "s"
      },
      {
        tag: "del"
      },
      {
        tag: "strike"
      },
      {
        style: "text-decoration",
        consuming: false,
        getAttrs: (style2) => style2.includes("line-through") ? {} : false
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["s", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      setStrike: () => ({ commands: commands2 }) => {
        return commands2.setMark(this.name);
      },
      toggleStrike: () => ({ commands: commands2 }) => {
        return commands2.toggleMark(this.name);
      },
      unsetStrike: () => ({ commands: commands2 }) => {
        return commands2.unsetMark(this.name);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-s": () => this.editor.commands.toggleStrike()
    };
  },
  addInputRules() {
    return [
      markInputRule({
        find: inputRegex5,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      markPasteRule({
        find: pasteRegex2,
        type: this.type
      })
    ];
  }
});

// node_modules/@tiptap/extension-text/dist/index.js
var Text = Node3.create({
  name: "text",
  group: "inline"
});

// node_modules/@tiptap/starter-kit/dist/index.js
var StarterKit = Extension.create({
  name: "starterKit",
  addExtensions() {
    const extensions = [];
    if (this.options.bold !== false) {
      extensions.push(Bold.configure(this.options.bold));
    }
    if (this.options.blockquote !== false) {
      extensions.push(Blockquote.configure(this.options.blockquote));
    }
    if (this.options.bulletList !== false) {
      extensions.push(BulletList.configure(this.options.bulletList));
    }
    if (this.options.code !== false) {
      extensions.push(Code.configure(this.options.code));
    }
    if (this.options.codeBlock !== false) {
      extensions.push(CodeBlock.configure(this.options.codeBlock));
    }
    if (this.options.document !== false) {
      extensions.push(Document.configure(this.options.document));
    }
    if (this.options.dropcursor !== false) {
      extensions.push(Dropcursor.configure(this.options.dropcursor));
    }
    if (this.options.gapcursor !== false) {
      extensions.push(Gapcursor.configure(this.options.gapcursor));
    }
    if (this.options.hardBreak !== false) {
      extensions.push(HardBreak.configure(this.options.hardBreak));
    }
    if (this.options.heading !== false) {
      extensions.push(Heading.configure(this.options.heading));
    }
    if (this.options.history !== false) {
      extensions.push(History.configure(this.options.history));
    }
    if (this.options.horizontalRule !== false) {
      extensions.push(HorizontalRule.configure(this.options.horizontalRule));
    }
    if (this.options.italic !== false) {
      extensions.push(Italic.configure(this.options.italic));
    }
    if (this.options.listItem !== false) {
      extensions.push(ListItem.configure(this.options.listItem));
    }
    if (this.options.orderedList !== false) {
      extensions.push(OrderedList.configure(this.options.orderedList));
    }
    if (this.options.paragraph !== false) {
      extensions.push(Paragraph.configure(this.options.paragraph));
    }
    if (this.options.strike !== false) {
      extensions.push(Strike.configure(this.options.strike));
    }
    if (this.options.text !== false) {
      extensions.push(Text.configure(this.options.text));
    }
    return extensions;
  }
});

// node_modules/@tiptap/extension-placeholder/dist/index.js
var Placeholder = Extension.create({
  name: "placeholder",
  addOptions() {
    return {
      emptyEditorClass: "is-editor-empty",
      emptyNodeClass: "is-empty",
      placeholder: "Write something ",
      showOnlyWhenEditable: true,
      showOnlyCurrent: true,
      includeChildren: false
    };
  },
  addProseMirrorPlugins() {
    return [
      new Plugin({
        key: new PluginKey("placeholder"),
        props: {
          decorations: ({ doc: doc3, selection }) => {
            const active = this.editor.isEditable || !this.options.showOnlyWhenEditable;
            const { anchor } = selection;
            const decorations = [];
            if (!active) {
              return null;
            }
            const isEmptyDoc = this.editor.isEmpty;
            doc3.descendants((node, pos) => {
              const hasAnchor = anchor >= pos && anchor <= pos + node.nodeSize;
              const isEmpty = !node.isLeaf && isNodeEmpty(node);
              if ((hasAnchor || !this.options.showOnlyCurrent) && isEmpty) {
                const classes = [this.options.emptyNodeClass];
                if (isEmptyDoc) {
                  classes.push(this.options.emptyEditorClass);
                }
                const decoration = Decoration.node(pos, pos + node.nodeSize, {
                  class: classes.join(" "),
                  "data-placeholder": typeof this.options.placeholder === "function" ? this.options.placeholder({
                    editor: this.editor,
                    node,
                    pos,
                    hasAnchor
                  }) : this.options.placeholder
                });
                decorations.push(decoration);
              }
              return this.options.includeChildren;
            });
            return DecorationSet.create(doc3, decorations);
          }
        }
      })
    ];
  }
});

// node_modules/@tiptap/extension-text-align/dist/index.js
var TextAlign = Extension.create({
  name: "textAlign",
  addOptions() {
    return {
      types: [],
      alignments: ["left", "center", "right", "justify"],
      defaultAlignment: null
    };
  },
  addGlobalAttributes() {
    return [
      {
        types: this.options.types,
        attributes: {
          textAlign: {
            default: this.options.defaultAlignment,
            parseHTML: (element) => {
              const alignment = element.style.textAlign;
              return this.options.alignments.includes(alignment) ? alignment : this.options.defaultAlignment;
            },
            renderHTML: (attributes) => {
              if (!attributes.textAlign) {
                return {};
              }
              return { style: `text-align: ${attributes.textAlign}` };
            }
          }
        }
      }
    ];
  },
  addCommands() {
    return {
      setTextAlign: (alignment) => ({ commands: commands2 }) => {
        if (!this.options.alignments.includes(alignment)) {
          return false;
        }
        return this.options.types.map((type) => commands2.updateAttributes(type, { textAlign: alignment })).some((response) => response);
      },
      unsetTextAlign: () => ({ commands: commands2 }) => {
        return this.options.types.map((type) => commands2.resetAttributes(type, "textAlign")).some((response) => response);
      },
      toggleTextAlign: (alignment) => ({ editor, commands: commands2 }) => {
        if (!this.options.alignments.includes(alignment)) {
          return false;
        }
        if (editor.isActive({ textAlign: alignment })) {
          return commands2.unsetTextAlign();
        }
        return commands2.setTextAlign(alignment);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-l": () => this.editor.commands.setTextAlign("left"),
      "Mod-Shift-e": () => this.editor.commands.setTextAlign("center"),
      "Mod-Shift-r": () => this.editor.commands.setTextAlign("right"),
      "Mod-Shift-j": () => this.editor.commands.setTextAlign("justify")
    };
  }
});
var index_default = TextAlign;

// node_modules/@tiptap/extension-underline/dist/index.js
var Underline = Mark2.create({
  name: "underline",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "u"
      },
      {
        style: "text-decoration",
        consuming: false,
        getAttrs: (style2) => style2.includes("underline") ? {} : false
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["u", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  parseMarkdown(token, helpers) {
    return helpers.applyMark(this.name || "underline", helpers.parseInline(token.tokens || []));
  },
  renderMarkdown(node, helpers) {
    return `++${helpers.renderChildren(node)}++`;
  },
  markdownTokenizer: {
    name: "underline",
    level: "inline",
    start(src) {
      return src.indexOf("++");
    },
    tokenize(src, _tokens, lexer) {
      const rule = /^(\+\+)([\s\S]+?)(\+\+)/;
      const match = rule.exec(src);
      if (!match) {
        return;
      }
      const innerContent = match[2].trim();
      return {
        type: "underline",
        raw: match[0],
        text: innerContent,
        tokens: lexer.inlineTokens(innerContent)
      };
    }
  },
  addCommands() {
    return {
      setUnderline: () => ({ commands: commands2 }) => {
        return commands2.setMark(this.name);
      },
      toggleUnderline: () => ({ commands: commands2 }) => {
        return commands2.toggleMark(this.name);
      },
      unsetUnderline: () => ({ commands: commands2 }) => {
        return commands2.unsetMark(this.name);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-u": () => this.editor.commands.toggleUnderline(),
      "Mod-U": () => this.editor.commands.toggleUnderline()
    };
  }
});
var index_default2 = Underline;

// node_modules/@tiptap/extension-text-style/dist/index.js
var MAX_FIND_CHILD_SPAN_DEPTH = 20;
var findChildSpans = (element, depth = 0) => {
  const childSpans = [];
  if (!element.children.length || depth > MAX_FIND_CHILD_SPAN_DEPTH) {
    return childSpans;
  }
  Array.from(element.children).forEach((child) => {
    if (child.tagName === "SPAN") {
      childSpans.push(child);
    } else if (child.children.length) {
      childSpans.push(...findChildSpans(child, depth + 1));
    }
  });
  return childSpans;
};
var mergeNestedSpanStyles = (element) => {
  if (!element.children.length) {
    return;
  }
  const childSpans = findChildSpans(element);
  if (!childSpans) {
    return;
  }
  childSpans.forEach((childSpan) => {
    var _a, _b;
    const childStyle = childSpan.getAttribute("style");
    const closestParentSpanStyleOfChild = (_b = (_a = childSpan.parentElement) == null ? undefined : _a.closest("span")) == null ? undefined : _b.getAttribute("style");
    childSpan.setAttribute("style", `${closestParentSpanStyleOfChild};${childStyle}`);
  });
};
var TextStyle = Mark2.create({
  name: "textStyle",
  priority: 101,
  addOptions() {
    return {
      HTMLAttributes: {},
      mergeNestedSpanStyles: true
    };
  },
  parseHTML() {
    return [
      {
        tag: "span",
        consuming: false,
        getAttrs: (element) => {
          const hasStyles = element.hasAttribute("style");
          if (!hasStyles) {
            return false;
          }
          if (this.options.mergeNestedSpanStyles) {
            mergeNestedSpanStyles(element);
          }
          return {};
        }
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["span", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      toggleTextStyle: (attributes) => ({ commands: commands2 }) => {
        return commands2.toggleMark(this.name, attributes);
      },
      removeEmptyTextStyle: () => ({ tr }) => {
        const { selection } = tr;
        tr.doc.nodesBetween(selection.from, selection.to, (node, pos) => {
          if (node.isTextblock) {
            return true;
          }
          if (!node.marks.filter((mark) => mark.type === this.type).some((mark) => Object.values(mark.attrs).some((value) => !!value))) {
            tr.removeMark(pos, pos + node.nodeSize, this.type);
          }
        });
        return true;
      }
    };
  }
});
var BackgroundColor = Extension.create({
  name: "backgroundColor",
  addOptions() {
    return {
      types: ["textStyle"]
    };
  },
  addGlobalAttributes() {
    return [
      {
        types: this.options.types,
        attributes: {
          backgroundColor: {
            default: null,
            parseHTML: (element) => {
              var _a;
              const styleAttr = element.getAttribute("style");
              if (styleAttr) {
                const decls = styleAttr.split(";").map((s) => s.trim()).filter(Boolean);
                for (let i2 = decls.length - 1;i2 >= 0; i2 -= 1) {
                  const parts = decls[i2].split(":");
                  if (parts.length >= 2) {
                    const prop = parts[0].trim().toLowerCase();
                    const val = parts.slice(1).join(":").trim();
                    if (prop === "background-color") {
                      return val.replace(/['"]+/g, "");
                    }
                  }
                }
              }
              return (_a = element.style.backgroundColor) == null ? undefined : _a.replace(/['"]+/g, "");
            },
            renderHTML: (attributes) => {
              if (!attributes.backgroundColor) {
                return {};
              }
              return {
                style: `background-color: ${attributes.backgroundColor}`
              };
            }
          }
        }
      }
    ];
  },
  addCommands() {
    return {
      setBackgroundColor: (backgroundColor) => ({ chain }) => {
        return chain().setMark("textStyle", { backgroundColor }).run();
      },
      unsetBackgroundColor: () => ({ chain }) => {
        return chain().setMark("textStyle", { backgroundColor: null }).removeEmptyTextStyle().run();
      }
    };
  }
});
var Color = Extension.create({
  name: "color",
  addOptions() {
    return {
      types: ["textStyle"]
    };
  },
  addGlobalAttributes() {
    return [
      {
        types: this.options.types,
        attributes: {
          color: {
            default: null,
            parseHTML: (element) => {
              var _a;
              const styleAttr = element.getAttribute("style");
              if (styleAttr) {
                const decls = styleAttr.split(";").map((s) => s.trim()).filter(Boolean);
                for (let i2 = decls.length - 1;i2 >= 0; i2 -= 1) {
                  const parts = decls[i2].split(":");
                  if (parts.length >= 2) {
                    const prop = parts[0].trim().toLowerCase();
                    const val = parts.slice(1).join(":").trim();
                    if (prop === "color") {
                      return val.replace(/['"]+/g, "");
                    }
                  }
                }
              }
              return (_a = element.style.color) == null ? undefined : _a.replace(/['"]+/g, "");
            },
            renderHTML: (attributes) => {
              if (!attributes.color) {
                return {};
              }
              return {
                style: `color: ${attributes.color}`
              };
            }
          }
        }
      }
    ];
  },
  addCommands() {
    return {
      setColor: (color) => ({ chain }) => {
        return chain().setMark("textStyle", { color }).run();
      },
      unsetColor: () => ({ chain }) => {
        return chain().setMark("textStyle", { color: null }).removeEmptyTextStyle().run();
      }
    };
  }
});
var FontFamily = Extension.create({
  name: "fontFamily",
  addOptions() {
    return {
      types: ["textStyle"]
    };
  },
  addGlobalAttributes() {
    return [
      {
        types: this.options.types,
        attributes: {
          fontFamily: {
            default: null,
            parseHTML: (element) => element.style.fontFamily,
            renderHTML: (attributes) => {
              if (!attributes.fontFamily) {
                return {};
              }
              return {
                style: `font-family: ${attributes.fontFamily}`
              };
            }
          }
        }
      }
    ];
  },
  addCommands() {
    return {
      setFontFamily: (fontFamily) => ({ chain }) => {
        return chain().setMark("textStyle", { fontFamily }).run();
      },
      unsetFontFamily: () => ({ chain }) => {
        return chain().setMark("textStyle", { fontFamily: null }).removeEmptyTextStyle().run();
      }
    };
  }
});
var FontSize = Extension.create({
  name: "fontSize",
  addOptions() {
    return {
      types: ["textStyle"]
    };
  },
  addGlobalAttributes() {
    return [
      {
        types: this.options.types,
        attributes: {
          fontSize: {
            default: null,
            parseHTML: (element) => element.style.fontSize,
            renderHTML: (attributes) => {
              if (!attributes.fontSize) {
                return {};
              }
              return {
                style: `font-size: ${attributes.fontSize}`
              };
            }
          }
        }
      }
    ];
  },
  addCommands() {
    return {
      setFontSize: (fontSize) => ({ chain }) => {
        return chain().setMark("textStyle", { fontSize }).run();
      },
      unsetFontSize: () => ({ chain }) => {
        return chain().setMark("textStyle", { fontSize: null }).removeEmptyTextStyle().run();
      }
    };
  }
});
var LineHeight = Extension.create({
  name: "lineHeight",
  addOptions() {
    return {
      types: ["textStyle"]
    };
  },
  addGlobalAttributes() {
    return [
      {
        types: this.options.types,
        attributes: {
          lineHeight: {
            default: null,
            parseHTML: (element) => element.style.lineHeight,
            renderHTML: (attributes) => {
              if (!attributes.lineHeight) {
                return {};
              }
              return {
                style: `line-height: ${attributes.lineHeight}`
              };
            }
          }
        }
      }
    ];
  },
  addCommands() {
    return {
      setLineHeight: (lineHeight) => ({ chain }) => {
        return chain().setMark("textStyle", { lineHeight }).run();
      },
      unsetLineHeight: () => ({ chain }) => {
        return chain().setMark("textStyle", { lineHeight: null }).removeEmptyTextStyle().run();
      }
    };
  }
});
var TextStyleKit = Extension.create({
  name: "textStyleKit",
  addExtensions() {
    const extensions = [];
    if (this.options.backgroundColor !== false) {
      extensions.push(BackgroundColor.configure(this.options.backgroundColor));
    }
    if (this.options.color !== false) {
      extensions.push(Color.configure(this.options.color));
    }
    if (this.options.fontFamily !== false) {
      extensions.push(FontFamily.configure(this.options.fontFamily));
    }
    if (this.options.fontSize !== false) {
      extensions.push(FontSize.configure(this.options.fontSize));
    }
    if (this.options.lineHeight !== false) {
      extensions.push(LineHeight.configure(this.options.lineHeight));
    }
    if (this.options.textStyle !== false) {
      extensions.push(TextStyle.configure(this.options.textStyle));
    }
    return extensions;
  }
});

// node_modules/@tiptap/extension-font-family/dist/index.js
var index_default3 = FontFamily;

// node_modules/@tiptap/extension-highlight/dist/index.js
var inputRegex6 = /(?:^|\s)(==(?!\s+==)((?:[^=]+))==(?!\s+==))$/;
var pasteRegex3 = /(?:^|\s)(==(?!\s+==)((?:[^=]+))==(?!\s+==))/g;
var Highlight = Mark2.create({
  name: "highlight",
  addOptions() {
    return {
      multicolor: false,
      HTMLAttributes: {}
    };
  },
  addAttributes() {
    if (!this.options.multicolor) {
      return {};
    }
    return {
      color: {
        default: null,
        parseHTML: (element) => element.getAttribute("data-color") || element.style.backgroundColor,
        renderHTML: (attributes) => {
          if (!attributes.color) {
            return {};
          }
          return {
            "data-color": attributes.color,
            style: `background-color: ${attributes.color}; color: inherit`
          };
        }
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: "mark"
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["mark", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  renderMarkdown: (node, h) => {
    return `==${h.renderChildren(node)}==`;
  },
  parseMarkdown: (token, h) => {
    return h.applyMark("highlight", h.parseInline(token.tokens || []));
  },
  markdownTokenizer: {
    name: "highlight",
    level: "inline",
    start: (src) => src.indexOf("=="),
    tokenize(src, _, h) {
      const rule = /^(==)([^=]+)(==)/;
      const match = rule.exec(src);
      if (match) {
        const innerContent = match[2].trim();
        const children = h.inlineTokens(innerContent);
        return {
          type: "highlight",
          raw: match[0],
          text: innerContent,
          tokens: children
        };
      }
    }
  },
  addCommands() {
    return {
      setHighlight: (attributes) => ({ commands: commands2 }) => {
        return commands2.setMark(this.name, attributes);
      },
      toggleHighlight: (attributes) => ({ commands: commands2 }) => {
        return commands2.toggleMark(this.name, attributes);
      },
      unsetHighlight: () => ({ commands: commands2 }) => {
        return commands2.unsetMark(this.name);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-h": () => this.editor.commands.toggleHighlight()
    };
  },
  addInputRules() {
    return [
      markInputRule({
        find: inputRegex6,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      markPasteRule({
        find: pasteRegex3,
        type: this.type
      })
    ];
  }
});
var index_default4 = Highlight;

// node_modules/@tiptap/extension-subscript/dist/index.js
var Subscript = Mark2.create({
  name: "subscript",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "sub"
      },
      {
        style: "vertical-align",
        getAttrs(value) {
          if (value !== "sub") {
            return false;
          }
          return null;
        }
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["sub", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      setSubscript: () => ({ commands: commands2 }) => {
        return commands2.setMark(this.name);
      },
      toggleSubscript: () => ({ commands: commands2 }) => {
        return commands2.toggleMark(this.name);
      },
      unsetSubscript: () => ({ commands: commands2 }) => {
        return commands2.unsetMark(this.name);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-,": () => this.editor.commands.toggleSubscript()
    };
  }
});
var index_default5 = Subscript;

// node_modules/@tiptap/extension-superscript/dist/index.js
var Superscript = Mark2.create({
  name: "superscript",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "sup"
      },
      {
        style: "vertical-align",
        getAttrs(value) {
          if (value !== "super") {
            return false;
          }
          return null;
        }
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["sup", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      setSuperscript: () => ({ commands: commands2 }) => {
        return commands2.setMark(this.name);
      },
      toggleSuperscript: () => ({ commands: commands2 }) => {
        return commands2.toggleMark(this.name);
      },
      unsetSuperscript: () => ({ commands: commands2 }) => {
        return commands2.unsetMark(this.name);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-.": () => this.editor.commands.toggleSuperscript()
    };
  }
});
var index_default6 = Superscript;

// node_modules/@tiptap/extension-font-size/dist/index.js
var FontSize2 = Extension.create({
  name: "fontSize",
  addOptions() {
    return {
      types: ["textStyle"]
    };
  },
  addGlobalAttributes() {
    return [
      {
        types: this.options.types,
        attributes: {
          fontSize: {
            default: null,
            parseHTML: (element) => element.style.fontSize,
            renderHTML: (attributes) => {
              if (!attributes.fontSize) {
                return {};
              }
              return {
                style: `font-size: ${attributes.fontSize}`
              };
            }
          }
        }
      }
    ];
  },
  addCommands() {
    return {
      setFontSize: (fontSize) => ({ chain }) => {
        return chain().setMark("textStyle", { fontSize }).run();
      },
      unsetFontSize: () => ({ chain }) => {
        return chain().setMark("textStyle", { fontSize: null }).removeEmptyTextStyle().run();
      }
    };
  }
});
var src_default = FontSize2;

// src/client/js/editor.ts
class DocumentEditor {
  editor;
  onUpdateCallback;
  constructor(options) {
    this.onUpdateCallback = options.onUpdate;
    this.editor = new Editor({
      element: options.element,
      extensions: [
        StarterKit.configure({
          heading: {
            levels: [1, 2, 3]
          }
        }),
        Placeholder.configure({
          placeholder: options.placeholder || "Start typing or use voice input..."
        }),
        index_default.configure({
          types: ["heading", "paragraph"]
        }),
        index_default2,
        TextStyle,
        index_default3,
        src_default,
        index_default4.configure({
          multicolor: true
        }),
        index_default5,
        index_default6
      ],
      content: options.initialContent || "",
      onUpdate: ({ editor }) => {
        if (this.onUpdateCallback) {
          this.onUpdateCallback(editor.getJSON());
        }
      }
    });
  }
  getJSON() {
    return this.editor.getJSON();
  }
  getHTML() {
    return this.editor.getHTML();
  }
  getText() {
    return this.editor.getText();
  }
  setContent(content) {
    this.editor.commands.setContent(content);
  }
  clear() {
    this.editor.commands.clearContent();
  }
  focus() {
    this.editor.commands.focus();
  }
  isEmpty() {
    return this.editor.isEmpty;
  }
  getWordCount() {
    const text = this.getText();
    if (!text.trim())
      return 0;
    return text.trim().split(/\s+/).length;
  }
  getCharacterCount() {
    return this.getText().length;
  }
  toggleBold() {
    this.editor.chain().focus().toggleBold().run();
  }
  toggleItalic() {
    this.editor.chain().focus().toggleItalic().run();
  }
  toggleStrike() {
    this.editor.chain().focus().toggleStrike().run();
  }
  toggleUnderline() {
    this.editor.chain().focus().toggleUnderline().run();
  }
  setTextAlign(align) {
    this.editor.chain().focus().setTextAlign(align).run();
  }
  toggleHeading(level) {
    this.editor.chain().focus().toggleHeading({ level }).run();
  }
  toggleBulletList() {
    this.editor.chain().focus().toggleBulletList().run();
  }
  toggleOrderedList() {
    this.editor.chain().focus().toggleOrderedList().run();
  }
  toggleBlockquote() {
    this.editor.chain().focus().toggleBlockquote().run();
  }
  setHorizontalRule() {
    this.editor.chain().focus().setHorizontalRule().run();
  }
  undo() {
    this.editor.chain().focus().undo().run();
  }
  redo() {
    this.editor.chain().focus().redo().run();
  }
  setFontFamily(font) {
    this.editor.chain().focus().setFontFamily(font).run();
  }
  setFontSize(size) {
    this.editor.chain().focus().setFontSize(size).run();
  }
  toggleHighlight(color) {
    if (color) {
      this.editor.chain().focus().toggleHighlight({ color }).run();
    } else {
      this.editor.chain().focus().toggleHighlight().run();
    }
  }
  toggleSuperscript() {
    this.editor.chain().focus().toggleSuperscript().run();
  }
  toggleSubscript() {
    this.editor.chain().focus().toggleSubscript().run();
  }
  clearFormatting() {
    this.editor.chain().focus().unsetAllMarks().clearNodes().run();
  }
  isActive(nameOrAttrs, attrs) {
    return this.editor.isActive(nameOrAttrs, attrs);
  }
  isBoldActive() {
    return this.editor.isActive("bold");
  }
  isItalicActive() {
    return this.editor.isActive("italic");
  }
  isStrikeActive() {
    return this.editor.isActive("strike");
  }
  isUnderlineActive() {
    return this.editor.isActive("underline");
  }
  isHighlightActive() {
    return this.editor.isActive("highlight");
  }
  isSuperscriptActive() {
    return this.editor.isActive("superscript");
  }
  isSubscriptActive() {
    return this.editor.isActive("subscript");
  }
  isHeadingActive(level) {
    return this.editor.isActive("heading", { level });
  }
  isBulletListActive() {
    return this.editor.isActive("bulletList");
  }
  isOrderedListActive() {
    return this.editor.isActive("orderedList");
  }
  insertText(text) {
    this.editor.chain().focus().insertContent(text).run();
  }
  destroy() {
    this.editor.destroy();
  }
  getEditor() {
    return this.editor;
  }
}

// src/client/js/api.ts
var API_BASE = "/api";
function getUserIdentity() {
  let userId = localStorage.getItem("x_user_id");
  if (!userId) {
    userId = crypto.randomUUID();
    localStorage.setItem("x_user_id", userId);
  }
  return userId;
}

class ApiError extends Error {
  code;
  constructor(code2, message) {
    super(message);
    this.name = "ApiError";
    this.code = code2;
  }
}
async function request(path, options = {}) {
  const response = await fetch(`${API_BASE}${path}`, {
    headers: {
      "Content-Type": "application/json",
      "X-User-ID": getUserIdentity(),
      ...options.headers
    },
    ...options
  });
  const result = await response.json();
  if (!result.success) {
    throw new ApiError(result.error?.code || "UNKNOWN_ERROR", result.error?.message || "Unknown error occurred");
  }
  return result.data;
}
var documentApi = {
  async list() {
    const data = await request("/documents");
    return data || [];
  },
  async get(id) {
    return request(`/documents/${id}`);
  },
  async create(data) {
    return request("/documents", {
      method: "POST",
      body: JSON.stringify(data)
    });
  },
  async update(id, data) {
    return request(`/documents/${id}`, {
      method: "PUT",
      body: JSON.stringify(data)
    });
  },
  async delete(id) {
    const result = await request(`/documents/${id}`, {
      method: "DELETE"
    });
    return result?.deleted ?? false;
  },
  async heartbeat(id) {
    const result = await request(`/documents/${id}/heartbeat`, {
      method: "POST"
    });
    return result?.locked ?? false;
  }
};
var templateApi = {
  async list() {
    const data = await request("/templates");
    return data || [];
  },
  async get(id) {
    return request(`/templates/${id}`);
  }
};

// src/client/js/voice.ts
class VoiceInput {
  recognition = null;
  isListening = false;
  options;
  constructor(options) {
    this.options = options;
    this.initialize();
  }
  initialize() {
    const SpeechRecognitionAPI = window.SpeechRecognition || window.webkitSpeechRecognition;
    if (!SpeechRecognitionAPI) {
      console.warn("Speech recognition not supported in this browser");
      return;
    }
    this.recognition = new SpeechRecognitionAPI;
    this.recognition.continuous = this.options.continuous ?? true;
    this.recognition.interimResults = true;
    this.recognition.lang = this.options.language || "en-US";
    this.recognition.onstart = () => {
      this.isListening = true;
      this.options.onStart?.();
    };
    this.recognition.onend = () => {
      this.isListening = false;
      this.options.onEnd?.();
    };
    this.recognition.onresult = (event) => {
      const result = event.results[event.results.length - 1];
      const transcript = result[0].transcript;
      const isFinal = result.isFinal;
      this.options.onResult(transcript, isFinal);
    };
    this.recognition.onerror = (event) => {
      console.error("Speech recognition error:", event.error);
      this.isListening = false;
      this.options.onError?.(event.error);
    };
  }
  isSupported() {
    return this.recognition !== null;
  }
  isActive() {
    return this.isListening;
  }
  start() {
    if (!this.recognition) {
      this.options.onError?.("Speech recognition not supported");
      return false;
    }
    if (this.isListening) {
      return true;
    }
    try {
      this.recognition.start();
      return true;
    } catch (error) {
      console.error("Failed to start speech recognition:", error);
      return false;
    }
  }
  stop() {
    if (this.recognition && this.isListening) {
      this.recognition.stop();
    }
  }
  toggle() {
    if (this.isListening) {
      this.stop();
      return false;
    } else {
      return this.start();
    }
  }
  setLanguage(lang) {
    if (this.recognition) {
      this.recognition.lang = lang;
    }
  }
}

// src/client/js/main.ts
var state = {
  currentDocId: null,
  isDirty: false,
  isSaving: false,
  isLoading: false,
  editor: null,
  voiceInput: null,
  autoSaveTimer: null,
  heartbeatTimer: null
};
var elements2 = {
  docTitle: document.getElementById("doc-title"),
  saveStatus: document.getElementById("save-status"),
  btnSave: document.getElementById("btn-save"),
  btnNew: document.getElementById("btn-new"),
  btnExport: document.getElementById("btn-export"),
  btnVoice: document.getElementById("btn-voice"),
  btnDelete: document.getElementById("btn-delete"),
  documentList: document.getElementById("document-list"),
  templateList: document.getElementById("template-list"),
  editorEl: document.getElementById("editor"),
  statusText: document.getElementById("status-text"),
  wordCount: document.getElementById("word-count"),
  toolbar: document.getElementById("toolbar"),
  pageSize: document.getElementById("page-size"),
  lineSpacing: document.getElementById("line-spacing"),
  fontFamily: document.getElementById("font-family"),
  fontSize: document.getElementById("font-size"),
  btnMenu: document.getElementById("btn-menu"),
  sidebar: document.getElementById("sidebar"),
  sidebarOverlay: document.getElementById("sidebar-overlay")
};
function updateStatus(text, type = "default") {
  elements2.statusText.textContent = text;
  elements2.saveStatus.textContent = text;
  elements2.saveStatus.className = "save-status " + type;
}
function updateWordCount() {
  if (state.editor) {
    const count = state.editor.getWordCount();
    elements2.wordCount.textContent = `${count} word${count !== 1 ? "s" : ""}`;
  }
}
function formatDate(isoString) {
  const date = new Date(isoString);
  const now = new Date;
  const diffMs = now.getTime() - date.getTime();
  const diffMins = Math.floor(diffMs / 60000);
  const diffHours = Math.floor(diffMs / 3600000);
  const diffDays = Math.floor(diffMs / 86400000);
  if (diffMins < 1)
    return "Just now";
  if (diffMins < 60)
    return `${diffMins}m ago`;
  if (diffHours < 24)
    return `${diffHours}h ago`;
  if (diffDays < 7)
    return `${diffDays}d ago`;
  return date.toLocaleDateString("en-US", {
    month: "short",
    day: "numeric"
  });
}
function markDirty() {
  if (!state.isDirty) {
    state.isDirty = true;
    updateStatus("Unsaved changes");
    updateDeleteButton();
  }
  if (state.autoSaveTimer)
    clearTimeout(state.autoSaveTimer);
  if (state.currentDocId) {
    state.autoSaveTimer = setTimeout(() => {
      saveDocument(true);
    }, 2000);
  } else {
    state.autoSaveTimer = setTimeout(() => {
      saveDraft();
      updateStatus("Draft saved locally");
    }, 2000);
  }
}
function updateDeleteButton() {
  if (elements2.btnDelete) {
    elements2.btnDelete.style.display = state.currentDocId ? "inline-flex" : "none";
  }
}
function stopHeartbeat() {
  if (state.heartbeatTimer) {
    clearInterval(state.heartbeatTimer);
    state.heartbeatTimer = null;
  }
}
function startHeartbeat(docId) {
  stopHeartbeat();
  state.heartbeatTimer = setInterval(async () => {
    try {
      const locked = await documentApi.heartbeat(docId);
      if (!locked) {
        updateStatus(" Lock lost! Copy your work.", "error");
        stopHeartbeat();
      }
    } catch (e2) {
      console.warn("Heartbeat failed:", e2);
    }
  }, 1e4);
}
function clearAutoSaveTimer() {
  if (state.autoSaveTimer) {
    clearTimeout(state.autoSaveTimer);
    state.autoSaveTimer = null;
  }
}
function toggleSidebar(forceState) {
  const isOpen = forceState !== undefined ? forceState : elements2.sidebar.classList.contains("open");
  if (isOpen) {
    elements2.sidebar.classList.remove("open");
    elements2.sidebarOverlay.classList.remove("active");
  } else {
    elements2.sidebar.classList.add("open");
    elements2.sidebarOverlay.classList.add("active");
  }
}
var DRAFT_KEY = "smart-office-draft";
function saveDraft() {
  if (!state.currentDocId && state.editor) {
    const title = elements2.docTitle.value || "Untitled Document";
    const content = state.editor.getJSON();
    const charCount = state.editor.getCharacterCount();
    if (charCount > 0 || title !== "Untitled Document" && title !== "") {
      const draft = {
        title,
        content,
        timestamp: Date.now()
      };
      try {
        localStorage.setItem(DRAFT_KEY, JSON.stringify(draft));
        console.log("[Smart Office] Draft saved to localStorage");
      } catch (e2) {
        console.warn("[Smart Office] Failed to save draft:", e2);
      }
    }
  }
}
function loadDraft() {
  try {
    const data = localStorage.getItem(DRAFT_KEY);
    if (data) {
      return JSON.parse(data);
    }
  } catch (e2) {
    console.warn("[Smart Office] Failed to load draft:", e2);
  }
  return null;
}
function clearDraft() {
  try {
    localStorage.removeItem(DRAFT_KEY);
  } catch (e2) {}
}
function isValidTipTapContent(content) {
  if (!content || typeof content !== "object")
    return false;
  if (content.type !== "doc")
    return false;
  if (content.content !== undefined && !Array.isArray(content.content))
    return false;
  return true;
}
async function handleUnsavedChanges() {
  if (!state.isDirty)
    return "proceed";
  const wantToSave = window.confirm(`You have unsaved changes.

` + "Click OK to save before continuing, or Cancel to choose another option.");
  if (wantToSave) {
    await saveDocument(false);
    if (!state.isDirty) {
      return "proceed";
    }
    const discardAnyway = window.confirm("Save failed. Discard your changes and continue anyway?");
    return discardAnyway ? "proceed" : "cancel";
  }
  const discardChanges = window.confirm("Discard your unsaved changes?");
  return discardChanges ? "proceed" : "cancel";
}
function setLoading(loading) {
  state.isLoading = loading;
  elements2.btnSave.disabled = loading;
  elements2.btnNew.disabled = loading;
  elements2.btnExport.disabled = loading;
  if (elements2.btnDelete) {
    elements2.btnDelete.disabled = loading;
  }
}
function renderDocumentList(documents) {
  if (!documents || documents.length === 0) {
    elements2.documentList.innerHTML = `
      <div class="empty-state">
        <p>No documents yet.</p>
        <p class="text-muted">Create your first document!</p>
      </div>
    `;
    return;
  }
  elements2.documentList.innerHTML = documents.map((doc3) => `
    <div class="doc-item-wrapper">
      <button 
        class="doc-item ${doc3.id === state.currentDocId ? "active" : ""}" 
        data-id="${doc3.id}"
        title="${escapeHtml(doc3.title)}"
      >
        <span class="doc-item-title">${escapeHtml(doc3.title)}</span>
        <span class="doc-item-date">${formatDate(doc3.updatedAt)}</span>
      </button>
      <button 
        class="doc-item-delete" 
        data-id="${doc3.id}"
        title="Delete document"
      >
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="14" height="14">
          <polyline points="3 6 5 6 21 6"></polyline>
          <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
        </svg>
      </button>
    </div>
  `).join("");
  elements2.documentList.querySelectorAll(".doc-item").forEach((btn) => {
    btn.addEventListener("click", (e2) => {
      e2.stopPropagation();
      const id = btn.dataset.id;
      if (id) {
        loadDocument(id);
        if (window.innerWidth <= 768) {
          toggleSidebar(false);
        }
      }
    });
  });
  elements2.documentList.querySelectorAll(".doc-item-delete").forEach((btn) => {
    btn.addEventListener("click", (e2) => {
      e2.stopPropagation();
      const id = btn.dataset.id;
      if (id)
        deleteDocument(id);
    });
  });
}
function renderTemplateList(templates) {
  if (!templates || templates.length === 0) {
    elements2.templateList.innerHTML = '<p class="text-muted">No templates available.</p>';
    return;
  }
  elements2.templateList.innerHTML = templates.map((tmpl) => `
    <button 
      class="template-item" 
      data-id="${tmpl.id}"
      title="${escapeHtml(tmpl.description)}"
    >
      <svg class="template-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
        <polyline points="14 2 14 8 20 8"></polyline>
        <line x1="16" y1="13" x2="8" y2="13"></line>
        <line x1="16" y1="17" x2="8" y2="17"></line>
        <polyline points="10 9 9 9 8 9"></polyline>
      </svg>
      <span class="template-name">${escapeHtml(tmpl.name)}</span>
    </button>
  `).join("");
  elements2.templateList.querySelectorAll(".template-item").forEach((btn) => {
    btn.addEventListener("click", () => {
      const id = btn.dataset.id;
      if (id) {
        loadTemplate(id);
        if (window.innerWidth <= 768) {
          toggleSidebar(false);
        }
      }
    });
  });
}
function escapeHtml(text) {
  const div = document.createElement("div");
  div.textContent = text;
  return div.innerHTML;
}
function applyPageSize(size) {
  elements2.editorEl.classList.remove("page-a4", "page-letter", "page-legal", "page-a5");
  elements2.editorEl.classList.add(`page-${size}`);
}
function applyLineSpacing(spacing) {
  const proseMirror = elements2.editorEl.querySelector(".ProseMirror");
  if (proseMirror) {
    proseMirror.style.lineHeight = spacing.toString();
  }
}
function getCurrentSettings() {
  return {
    pageSize: elements2.pageSize?.value || "a4",
    lineSpacing: parseFloat(elements2.lineSpacing?.value || "1.15")
  };
}
async function loadDocuments() {
  const docs = await documentApi.list();
  renderDocumentList(docs);
}
async function loadTemplates() {
  const templates = await templateApi.list();
  renderTemplateList(templates);
}
async function loadDocument(id) {
  clearAutoSaveTimer();
  const action = await handleUnsavedChanges();
  if (action === "cancel")
    return;
  setLoading(true);
  updateStatus("Loading...", "saving");
  try {
    const doc3 = await documentApi.get(id);
    if (doc3) {
      state.currentDocId = doc3.id;
      elements2.docTitle.value = doc3.title;
      if (state.editor && doc3.content) {
        if (isValidTipTapContent(doc3.content)) {
          try {
            state.editor.setContent(doc3.content);
          } catch (e2) {
            console.error("Failed to set document content:", e2);
            updateStatus("Content error, using empty document", "error");
            state.editor.clear();
          }
        } else {
          console.warn("Invalid document content structure, using empty document");
          state.editor.clear();
        }
      } else if (state.editor) {
        state.editor.clear();
      }
      if (doc3.settings) {
        if (doc3.settings.pageSize && elements2.pageSize) {
          elements2.pageSize.value = doc3.settings.pageSize;
          applyPageSize(doc3.settings.pageSize);
        }
        if (doc3.settings.lineSpacing && elements2.lineSpacing) {
          elements2.lineSpacing.value = doc3.settings.lineSpacing.toString();
          applyLineSpacing(doc3.settings.lineSpacing);
        }
      }
      state.isDirty = false;
      clearDraft();
      updateStatus("Loaded", "saved");
      updateWordCount();
      updateDeleteButton();
      await loadDocuments();
    } else {
      updateStatus("Failed to load", "error");
    }
  } catch (error) {
    console.error("Load error:", error);
    updateStatus("Failed to load", "error");
  } finally {
    setLoading(false);
    if (state.currentDocId) {
      startHeartbeat(state.currentDocId);
    }
  }
}
async function loadTemplate(templateId) {
  clearAutoSaveTimer();
  const action = await handleUnsavedChanges();
  if (action === "cancel")
    return;
  setLoading(true);
  updateStatus("Loading template...", "saving");
  try {
    const template = await templateApi.get(templateId);
    if (template && template.content) {
      state.currentDocId = null;
      elements2.docTitle.value = template.name;
      if (state.editor) {
        state.editor.setContent(template.content);
      }
      state.isDirty = true;
      clearDraft();
      updateStatus("Template loaded - click Save to create document");
      updateWordCount();
      updateDeleteButton();
      elements2.documentList.querySelectorAll(".doc-item").forEach((item) => {
        item.classList.remove("active");
      });
      elements2.docTitle.focus();
      elements2.docTitle.select();
    } else {
      updateStatus("Failed to load template", "error");
    }
  } catch (error) {
    console.error("Template load error:", error);
    updateStatus("Failed to load template", "error");
  } finally {
    setLoading(false);
  }
}
async function saveDocument(isAutoSave = false, retryCount = 0) {
  clearAutoSaveTimer();
  if (state.isSaving || state.isLoading)
    return;
  state.isSaving = true;
  if (!isAutoSave)
    setLoading(true);
  updateStatus(isAutoSave ? "Auto-saving..." : "Saving...", "saving");
  const title = elements2.docTitle.value.trim();
  const content = state.editor?.getJSON() || { type: "doc", content: [] };
  const isContentEmpty = state.editor?.getCharacterCount() === 0;
  if (!state.currentDocId && (!title || title === "Untitled Document") && isContentEmpty) {
    updateStatus("Add title or content to save", "error");
    state.isSaving = false;
    if (!isAutoSave)
      setLoading(false);
    return;
  }
  if (!isAutoSave && state.currentDocId && isContentEmpty) {
    const confirmSave = window.confirm("This document is empty. Are you sure you want to save it?");
    if (!confirmSave) {
      state.isSaving = false;
      setLoading(false);
      return;
    }
  }
  const finalTitle = title || "Untitled Document";
  const settings = getCurrentSettings();
  try {
    let doc3;
    if (state.currentDocId) {
      doc3 = await documentApi.update(state.currentDocId, {
        title: finalTitle,
        content,
        settings
      });
    } else {
      doc3 = await documentApi.create({ title: finalTitle, content, settings });
    }
    if (doc3) {
      state.currentDocId = doc3.id;
      state.isDirty = false;
      clearDraft();
      updateStatus("Saved", "saved");
      updateDeleteButton();
      await loadDocuments();
      startHeartbeat(doc3.id);
    }
  } catch (error) {
    console.error("Save error:", error);
    if (error instanceof ApiError && error.code === "LOCKED") {
      updateStatus(`\uD83D\uDD12 ${error.message}`, "error");
      alert(`Cannot save: ${error.message}`);
      return;
    }
    if (isAutoSave && retryCount < 2) {
      const nextDelay = 1000 * (retryCount + 1);
      console.warn(`Auto-save failed, retrying in ${nextDelay}ms...`);
      state.isSaving = false;
      setTimeout(() => {
        saveDocument(true, retryCount + 1);
      }, nextDelay);
      return;
    }
    updateStatus("Save failed", "error");
  } finally {
    if (!isAutoSave || retryCount >= 2) {
      state.isSaving = false;
      if (!isAutoSave)
        setLoading(false);
    }
  }
}
async function createNewDocument() {
  clearAutoSaveTimer();
  stopHeartbeat();
  const action = await handleUnsavedChanges();
  if (action === "cancel")
    return;
  state.currentDocId = null;
  elements2.docTitle.value = "";
  state.editor?.clear();
  state.isDirty = false;
  clearDraft();
  updateStatus("New document");
  updateWordCount();
  updateDeleteButton();
  elements2.documentList.querySelectorAll(".doc-item").forEach((item) => {
    item.classList.remove("active");
  });
  state.editor?.focus();
}
async function deleteDocument(id) {
  const confirmDelete = window.confirm("Are you sure you want to delete this document?");
  if (!confirmDelete)
    return;
  setLoading(true);
  updateStatus("Deleting...", "saving");
  try {
    const success = await documentApi.delete(id);
    if (success) {
      if (id === state.currentDocId) {
        state.currentDocId = null;
        elements2.docTitle.value = "";
        state.editor?.clear();
        state.isDirty = false;
        updateDeleteButton();
      }
      await loadDocuments();
      updateStatus("Document deleted", "saved");
    } else {
      updateStatus("Delete failed", "error");
    }
  } catch (error) {
    console.error("Delete error:", error);
    updateStatus("Delete failed", "error");
  } finally {
    setLoading(false);
  }
}
async function deleteCurrentDocument() {
  if (!state.currentDocId)
    return;
  await deleteDocument(state.currentDocId);
}
var PAGE_SIZES = {
  a4: { width: 210, height: 297 },
  a5: { width: 148, height: 210 },
  letter: { width: 215.9, height: 279.4 },
  legal: { width: 215.9, height: 355.6 }
};
var PDF_MARGIN = 25.4;
function mapFontFamily(fontFamily) {
  if (!fontFamily)
    return "helvetica";
  const lower = fontFamily.toLowerCase();
  if (lower.includes("times") || lower.includes("serif"))
    return "times";
  if (lower.includes("courier") || lower.includes("mono"))
    return "courier";
  return "helvetica";
}
function parseColor(color) {
  if (!color)
    return null;
  const hex = color.replace("#", "");
  if (hex.length === 6) {
    return {
      r: parseInt(hex.substring(0, 2), 16),
      g: parseInt(hex.substring(2, 4), 16),
      b: parseInt(hex.substring(4, 6), 16)
    };
  }
  const rgbMatch = color.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
  if (rgbMatch) {
    return {
      r: parseInt(rgbMatch[1]),
      g: parseInt(rgbMatch[2]),
      b: parseInt(rgbMatch[3])
    };
  }
  return null;
}
function parseFontSize(size) {
  if (!size)
    return null;
  const match = size.match(/(\d+(?:\.\d+)?)(pt|px)?/);
  if (match) {
    const value = parseFloat(match[1]);
    const unit = match[2] || "pt";
    return unit === "px" ? value * 0.75 : value;
  }
  return null;
}
async function exportPdf() {
  if (!state.editor)
    return;
  if (state.editor.getCharacterCount() === 0) {
    alert("Cannot export an empty document. Please add some text first.");
    return;
  }
  if (state.isDirty) {
    const confirmSave = window.confirm("You have unsaved changes. Save before exporting to ensure latest version?");
    if (confirmSave) {
      await saveDocument();
    }
  }
  setLoading(true);
  updateStatus("Generating PDF...", "saving");
  try {
    const { jsPDF } = await Promise.resolve().then(() => (init_jspdf_es_min(), exports_jspdf_es_min));
    const title = elements2.docTitle.value || "Untitled Document";
    const content = state.editor.getJSON();
    const pageSizeKey = elements2.pageSize?.value || "a4";
    const pageSize = PAGE_SIZES[pageSizeKey] || PAGE_SIZES.a4;
    const lineSpacing = parseFloat(elements2.lineSpacing?.value || "1.15");
    const pdf = new jsPDF({
      orientation: "portrait",
      unit: "mm",
      format: [pageSize.width, pageSize.height]
    });
    const pageWidth = pageSize.width;
    const pageHeight = pageSize.height;
    const margin = PDF_MARGIN;
    const maxWidth = pageWidth - margin * 2;
    const baseFontSize = 11;
    const baseLineHeight = baseFontSize * 0.38 * lineSpacing;
    let y3 = margin;
    let currentPage = 1;
    const checkPageBreak = (heightNeeded) => {
      if (y3 + heightNeeded > pageHeight - margin) {
        pdf.addPage([pageSize.width, pageSize.height]);
        currentPage++;
        y3 = margin;
      }
    };
    const setFont = (family, bold, italic, size) => {
      const pdfFont = mapFontFamily(family);
      pdf.setFontSize(size);
      if (bold && italic) {
        pdf.setFont(pdfFont, "bolditalic");
      } else if (bold) {
        pdf.setFont(pdfFont, "bold");
      } else if (italic) {
        pdf.setFont(pdfFont, "italic");
      } else {
        pdf.setFont(pdfFont, "normal");
      }
    };
    const extractSegments = (nodeContent) => {
      if (!nodeContent || !Array.isArray(nodeContent))
        return [];
      const segments = [];
      for (const item of nodeContent) {
        if (item.type === "text" && item.text) {
          const marks = item.marks || [];
          let fontSize = null;
          let fontFamily = null;
          let color = null;
          let highlight = null;
          for (const mark of marks) {
            if (mark.type === "textStyle") {
              if (mark.attrs?.fontSize) {
                fontSize = parseFontSize(mark.attrs.fontSize);
              }
              if (mark.attrs?.fontFamily) {
                fontFamily = mark.attrs.fontFamily;
              }
              if (mark.attrs?.color) {
                color = mark.attrs.color;
              }
            }
            if (mark.type === "highlight" && mark.attrs?.color) {
              highlight = mark.attrs.color;
            }
          }
          segments.push({
            text: item.text,
            bold: marks.some((m4) => m4.type === "bold"),
            italic: marks.some((m4) => m4.type === "italic"),
            underline: marks.some((m4) => m4.type === "underline"),
            strike: marks.some((m4) => m4.type === "strike"),
            superscript: marks.some((m4) => m4.type === "superscript"),
            subscript: marks.some((m4) => m4.type === "subscript"),
            fontSize,
            fontFamily,
            color,
            highlight
          });
        }
      }
      return segments;
    };
    const getAlignedX = (align, textWidth, indent) => {
      const effectiveWidth = maxWidth - indent;
      switch (align) {
        case "center":
          return margin + indent + effectiveWidth / 2;
        case "right":
          return margin + indent + effectiveWidth;
        default:
          return margin + indent;
      }
    };
    const getJsPdfAlign = (align) => {
      if (align === "center")
        return "center";
      if (align === "right")
        return "right";
      return "left";
    };
    const renderSegments = (segments, align, indent = 0, defaultSize = baseFontSize, forceBold = false, prefix = "") => {
      if (segments.length === 0 && !prefix) {
        y3 += baseLineHeight * 0.5;
        return;
      }
      const effectiveWidth = maxWidth - indent;
      const alignment = getJsPdfAlign(align);
      const fullText = prefix + segments.map((s3) => s3.text).join("");
      setFont(null, forceBold, false, defaultSize);
      const lines = pdf.splitTextToSize(fullText, effectiveWidth);
      let charIndex = 0;
      const prefixLen = prefix.length;
      for (const line of lines) {
        checkPageBreak(baseLineHeight + 2);
        let maxFontSize = defaultSize;
        let lineCharStart = charIndex;
        let lineCharEnd = charIndex + line.length;
        if (charIndex === 0 && prefix) {
          setFont(null, false, false, defaultSize);
          pdf.setTextColor(0, 0, 0);
          const prefixX = getAlignedX(align, pdf.getTextWidth(line), indent);
          pdf.text(prefix, prefixX, y3, { align: alignment });
        }
        let currentX = getAlignedX(align, pdf.getTextWidth(line), indent);
        if (alignment === "left" && charIndex === 0 && prefix) {
          currentX += pdf.getTextWidth(prefix);
        }
        let segmentPos = 0;
        for (const segment of segments) {
          const segStart = prefixLen + segmentPos;
          const segEnd = segStart + segment.text.length;
          segmentPos += segment.text.length;
          if (segEnd <= lineCharStart || segStart >= lineCharEnd) {
            continue;
          }
          const overlapStart = Math.max(segStart, lineCharStart);
          const overlapEnd = Math.min(segEnd, lineCharEnd);
          const textInLine = fullText.substring(overlapStart, overlapEnd);
          if (!textInLine)
            continue;
          const fontSize = segment.fontSize || defaultSize;
          const fontFamily = segment.fontFamily;
          const isBold = forceBold || segment.bold;
          const isItalic = segment.italic;
          setFont(fontFamily, isBold, isItalic, fontSize);
          if (segment.color) {
            const rgb = parseColor(segment.color);
            if (rgb) {
              pdf.setTextColor(rgb.r, rgb.g, rgb.b);
            } else {
              pdf.setTextColor(0, 0, 0);
            }
          } else {
            pdf.setTextColor(0, 0, 0);
          }
          const textWidth = pdf.getTextWidth(textInLine);
          if (segment.highlight) {
            const rgb = parseColor(segment.highlight);
            if (rgb) {
              pdf.setFillColor(rgb.r, rgb.g, rgb.b);
              const rectHeight = fontSize * 0.4;
              pdf.rect(currentX, y3 - rectHeight + 0.5, textWidth, rectHeight, "F");
            }
          }
          let renderY = y3;
          let renderSize = fontSize;
          if (segment.subscript) {
            renderY = y3 + fontSize * 0.15;
            renderSize = fontSize * 0.7;
            pdf.setFontSize(renderSize);
          } else if (segment.superscript) {
            renderY = y3 - fontSize * 0.2;
            renderSize = fontSize * 0.7;
            pdf.setFontSize(renderSize);
          }
          if (alignment === "left") {
            pdf.text(textInLine, currentX, renderY);
            currentX += textWidth;
          }
          if (segment.underline) {
            const underlineY = renderY + 0.5;
            pdf.setDrawColor(segment.color ? parseColor(segment.color)?.r || 0 : 0, segment.color ? parseColor(segment.color)?.g || 0 : 0, segment.color ? parseColor(segment.color)?.b || 0 : 0);
            pdf.setLineWidth(0.2);
            pdf.line(currentX - textWidth, underlineY, currentX, underlineY);
          }
          if (segment.strike) {
            const strikeY = renderY - fontSize * 0.1;
            pdf.setDrawColor(segment.color ? parseColor(segment.color)?.r || 0 : 0, segment.color ? parseColor(segment.color)?.g || 0 : 0, segment.color ? parseColor(segment.color)?.b || 0 : 0);
            pdf.setLineWidth(0.2);
            pdf.line(currentX - textWidth, strikeY, currentX, strikeY);
          }
          maxFontSize = Math.max(maxFontSize, fontSize);
        }
        if (alignment !== "left") {
          const hasAnyBold = segments.some((s3) => s3.bold) || forceBold;
          const hasAnyItalic = segments.some((s3) => s3.italic);
          setFont(null, hasAnyBold, hasAnyItalic, defaultSize);
          pdf.setTextColor(0, 0, 0);
          const lineX = getAlignedX(align, pdf.getTextWidth(line), indent);
          pdf.text(line, lineX, y3, { align: alignment });
        }
        y3 += maxFontSize * 0.38 * lineSpacing;
        charIndex += line.length;
        while (charIndex < fullText.length && fullText[charIndex] === " ") {
          charIndex++;
        }
      }
      y3 += baseLineHeight * 0.2;
    };
    const renderNode = (node2, listType, listIdx, indent = 0) => {
      if (!node2)
        return;
      const textAlign = node2.attrs?.textAlign;
      switch (node2.type) {
        case "heading": {
          const level = node2.attrs?.level || 1;
          const fontSize = level === 1 ? 24 : level === 2 ? 18 : 14;
          const segments = extractSegments(node2.content);
          if (segments.length > 0 || node2.content?.length) {
            y3 += baseLineHeight * 0.6;
            renderSegments(segments, textAlign, indent, fontSize, true);
            y3 += baseLineHeight * 0.3;
          }
          break;
        }
        case "paragraph": {
          const segments = extractSegments(node2.content);
          let prefix = "";
          if (listType === "bullet") {
            prefix = "   ";
          } else if (listType === "ordered" && listIdx !== undefined) {
            prefix = `  ${listIdx}. `;
          }
          renderSegments(segments, textAlign, indent, baseFontSize, false, prefix);
          break;
        }
        case "bulletList": {
          (node2.content || []).forEach((item) => {
            renderNode(item, "bullet", undefined, indent);
          });
          break;
        }
        case "orderedList": {
          (node2.content || []).forEach((item, idx) => {
            renderNode(item, "ordered", idx + 1, indent);
          });
          break;
        }
        case "listItem": {
          (node2.content || []).forEach((child) => {
            renderNode(child, listType, listIdx, indent + 6);
          });
          break;
        }
        case "blockquote": {
          y3 += baseLineHeight * 0.3;
          const startY = y3;
          (node2.content || []).forEach((child) => {
            const segments = extractSegments(child.content);
            const italicSegments = segments.map((s3) => ({
              ...s3,
              italic: true
            }));
            renderSegments(italicSegments, child.attrs?.textAlign, indent + 8, baseFontSize);
          });
          pdf.setDrawColor(180, 180, 180);
          pdf.setLineWidth(0.5);
          pdf.line(margin + indent + 3, startY - 2, margin + indent + 3, y3 - 2);
          y3 += baseLineHeight * 0.3;
          break;
        }
        case "horizontalRule": {
          checkPageBreak(10);
          y3 += baseLineHeight * 0.5;
          pdf.setDrawColor(200, 200, 200);
          pdf.setLineWidth(0.3);
          pdf.line(margin, y3, pageWidth - margin, y3);
          y3 += baseLineHeight * 0.5;
          break;
        }
        case "codeBlock": {
          const segments = extractSegments(node2.content);
          const codeText = segments.map((s3) => s3.text).join("");
          if (codeText) {
            y3 += baseLineHeight * 0.3;
            const codeLines = codeText.split(`
`);
            const bgHeight = codeLines.length * 3.5 + 4;
            checkPageBreak(bgHeight);
            pdf.setFillColor(245, 245, 245);
            pdf.rect(margin + indent, y3 - 3, maxWidth - indent, bgHeight, "F");
            pdf.setFont("courier", "normal");
            pdf.setFontSize(9);
            pdf.setTextColor(50, 50, 50);
            for (const codeLine of codeLines) {
              const wrapped = pdf.splitTextToSize(codeLine || " ", maxWidth - indent - 10);
              for (const wl of wrapped) {
                checkPageBreak(4);
                pdf.text(wl, margin + indent + 3, y3);
                y3 += 3.5;
              }
            }
            y3 += baseLineHeight * 0.3;
            pdf.setTextColor(0, 0, 0);
            setFont(null, false, false, baseFontSize);
          }
          break;
        }
        default:
          if (node2.content && Array.isArray(node2.content)) {
            node2.content.forEach((child) => {
              renderNode(child, listType, listIdx, indent);
            });
          }
      }
    };
    const docContent = content.content || [];
    for (const node2 of docContent) {
      renderNode(node2);
    }
    const safeFilename = title.replace(/[^a-zA-Z0-9\s-]/g, "_").replace(/\s+/g, "_").replace(/_+/g, "_").replace(/^_|_$/g, "") || "document";
    pdf.save(`${safeFilename}.pdf`);
    updateStatus("PDF exported", "saved");
  } catch (error) {
    console.error("PDF export error:", error);
    updateStatus("PDF export failed", "error");
    alert(`PDF export failed: ${error instanceof Error ? error.message : String(error)}`);
  } finally {
    setLoading(false);
  }
}
function setupToolbar() {
  elements2.toolbar.addEventListener("wheel", (e2) => {
    if (elements2.toolbar.scrollWidth > elements2.toolbar.clientWidth) {
      e2.preventDefault();
      elements2.toolbar.scrollLeft += e2.deltaY;
    }
  }, { passive: false });
  elements2.toolbar.addEventListener("click", (e2) => {
    const btn = e2.target.closest(".toolbar-btn");
    if (!btn || !state.editor)
      return;
    const command2 = btn.dataset.command;
    if (!command2)
      return;
    if (command2 === "voice")
      return;
    switch (command2) {
      case "bold":
        state.editor.toggleBold();
        break;
      case "italic":
        state.editor.toggleItalic();
        break;
      case "underline":
        state.editor.toggleUnderline();
        break;
      case "strike":
        state.editor.toggleStrike();
        break;
      case "alignLeft":
        state.editor.setTextAlign("left");
        break;
      case "alignCenter":
        state.editor.setTextAlign("center");
        break;
      case "alignRight":
        state.editor.setTextAlign("right");
        break;
      case "alignJustify":
        state.editor.setTextAlign("justify");
        break;
      case "heading1":
        state.editor.toggleHeading(1);
        break;
      case "heading2":
        state.editor.toggleHeading(2);
        break;
      case "heading3":
        state.editor.toggleHeading(3);
        break;
      case "bulletList":
        state.editor.toggleBulletList();
        break;
      case "orderedList":
        state.editor.toggleOrderedList();
        break;
      case "undo":
        state.editor.undo();
        break;
      case "redo":
        state.editor.redo();
        break;
      case "highlight":
        state.editor.toggleHighlight("#FFEB3B");
        break;
      case "superscript":
        state.editor.toggleSuperscript();
        break;
      case "subscript":
        state.editor.toggleSubscript();
        break;
      case "clearFormatting":
        state.editor.clearFormatting();
        break;
      case "horizontalRule":
        state.editor.setHorizontalRule();
        break;
    }
    updateToolbarState();
  });
}
function updateToolbarState() {
  if (!state.editor)
    return;
  const buttons = elements2.toolbar.querySelectorAll(".toolbar-btn");
  buttons.forEach((btn) => {
    const command2 = btn.dataset.command;
    if (!command2)
      return;
    let isActive2 = false;
    switch (command2) {
      case "bold":
        isActive2 = state.editor.isBoldActive();
        break;
      case "italic":
        isActive2 = state.editor.isItalicActive();
        break;
      case "underline":
        isActive2 = state.editor.isUnderlineActive();
        break;
      case "strike":
        isActive2 = state.editor.isStrikeActive();
        break;
      case "heading1":
        isActive2 = state.editor.isHeadingActive(1);
        break;
      case "heading2":
        isActive2 = state.editor.isHeadingActive(2);
        break;
      case "heading3":
        isActive2 = state.editor.isHeadingActive(3);
        break;
      case "bulletList":
        isActive2 = state.editor.isBulletListActive();
        break;
      case "orderedList":
        isActive2 = state.editor.isOrderedListActive();
        break;
      case "alignLeft":
        isActive2 = state.editor.isActive({ textAlign: "left" });
        break;
      case "alignCenter":
        isActive2 = state.editor.isActive({ textAlign: "center" });
        break;
      case "alignRight":
        isActive2 = state.editor.isActive({ textAlign: "right" });
        break;
      case "alignJustify":
        isActive2 = state.editor.isActive({ textAlign: "justify" });
        break;
      case "highlight":
        isActive2 = state.editor.isHighlightActive();
        break;
      case "superscript":
        isActive2 = state.editor.isSuperscriptActive();
        break;
      case "subscript":
        isActive2 = state.editor.isSubscriptActive();
        break;
    }
    btn.classList.toggle("active", isActive2);
  });
}
function setupVoiceInput() {
  state.voiceInput = new VoiceInput({
    onResult: (text, isFinal) => {
      if (isFinal && state.editor) {
        state.editor.insertText(text + " ");
        markDirty();
        updateWordCount();
      }
    },
    onStart: () => {
      elements2.btnVoice.classList.add("recording");
      updateStatus("Listening...");
    },
    onEnd: () => {
      elements2.btnVoice.classList.remove("recording");
      updateStatus(state.isDirty ? "Unsaved changes" : "Ready");
    },
    onError: (error) => {
      elements2.btnVoice.classList.remove("recording");
      updateStatus(`Voice error: ${error}`, "error");
    }
  });
  if (!state.voiceInput.isSupported()) {
    elements2.btnVoice.disabled = true;
    elements2.btnVoice.title = "Voice input not supported in this browser";
    elements2.btnVoice.style.opacity = "0.5";
    elements2.btnVoice.style.cursor = "not-allowed";
  }
}
function toggleVoiceInput() {
  if (state.voiceInput) {
    state.voiceInput.toggle();
  }
}
function setupEventHandlers() {
  elements2.btnSave.addEventListener("click", () => saveDocument(false));
  elements2.btnNew.addEventListener("click", () => {
    createNewDocument();
    if (window.innerWidth <= 768) {
      toggleSidebar(false);
    }
  });
  elements2.btnExport.addEventListener("click", exportPdf);
  elements2.editorEl.addEventListener("click", (e2) => {
    if (e2.target === elements2.editorEl) {
      state.editor?.focus();
    }
  });
  elements2.btnVoice.addEventListener("click", (e2) => {
    e2.stopPropagation();
    toggleVoiceInput();
  });
  if (elements2.btnDelete) {
    elements2.btnDelete.addEventListener("click", deleteCurrentDocument);
  }
  if (elements2.pageSize) {
    elements2.pageSize.addEventListener("change", () => {
      const size = elements2.pageSize.value;
      elements2.editorEl.classList.remove("page-a4", "page-letter", "page-legal", "page-a5");
      elements2.editorEl.classList.add(`page-${size}`);
    });
  }
  if (elements2.lineSpacing) {
    elements2.lineSpacing.addEventListener("change", () => {
      const spacing = elements2.lineSpacing.value;
      const proseMirror = elements2.editorEl.querySelector(".ProseMirror");
      if (proseMirror) {
        proseMirror.style.lineHeight = spacing;
      }
    });
  }
  if (elements2.fontFamily) {
    elements2.fontFamily.addEventListener("change", () => {
      const font = elements2.fontFamily.value;
      if (state.editor) {
        state.editor.setFontFamily(font);
      }
    });
  }
  if (elements2.fontSize) {
    elements2.fontSize.addEventListener("change", () => {
      const size = elements2.fontSize.value;
      if (state.editor) {
        state.editor.setFontSize(size);
      }
    });
  }
  elements2.docTitle.addEventListener("input", markDirty);
  document.addEventListener("keydown", (e2) => {
    if (e2.ctrlKey && e2.key === "s") {
      e2.preventDefault();
      saveDocument();
    }
    if (e2.ctrlKey && e2.key === "n") {
      e2.preventDefault();
      createNewDocument();
    }
    if (e2.ctrlKey && e2.key === "e") {
      e2.preventDefault();
      exportPdf();
    }
    if (e2.key === "Delete" && e2.ctrlKey && state.currentDocId) {
      e2.preventDefault();
      deleteCurrentDocument();
    }
  });
  window.addEventListener("beforeunload", (e2) => {
    if (state.isDirty) {
      e2.preventDefault();
      e2.returnValue = "";
    }
  });
  if (elements2.btnMenu) {
    elements2.btnMenu.addEventListener("click", () => toggleSidebar());
  }
  if (elements2.sidebarOverlay) {
    elements2.sidebarOverlay.addEventListener("click", () => toggleSidebar(false));
  }
}
async function init() {
  console.log("[Smart Office] Initializing...");
  let lastWordCountUpdate = 0;
  state.editor = new DocumentEditor({
    element: elements2.editorEl,
    placeholder: "Start typing or use voice input...",
    onUpdate: () => {
      markDirty();
      const now = Date.now();
      if (now - lastWordCountUpdate > 500) {
        updateWordCount();
        lastWordCountUpdate = now;
      }
      updateToolbarState();
    }
  });
  setupToolbar();
  setupVoiceInput();
  setupEventHandlers();
  updateDeleteButton();
  await Promise.all([loadDocuments(), loadTemplates()]);
  const draft = loadDraft();
  if (draft) {
    const ageMs = Date.now() - draft.timestamp;
    const ageMinutes = Math.floor(ageMs / 60000);
    const ageDisplay = ageMinutes < 1 ? "less than a minute" : ageMinutes === 1 ? "1 minute" : `${ageMinutes} minutes`;
    const restore = window.confirm(`You have an unsaved draft from ${ageDisplay} ago.

Title: "${draft.title}"

Would you like to restore it?`);
    if (restore) {
      elements2.docTitle.value = draft.title;
      if (state.editor && isValidTipTapContent(draft.content)) {
        state.editor.setContent(draft.content);
      }
      state.isDirty = true;
      updateStatus("Draft restored - remember to save!");
      updateWordCount();
      console.log("[Smart Office] Draft restored from localStorage");
    } else {
      clearDraft();
      console.log("[Smart Office] Draft discarded");
    }
  }
  updateStatus("Ready");
  updateWordCount();
  console.log("[Smart Office] Ready!");
  state.editor.focus();
}
init().catch(console.error);
